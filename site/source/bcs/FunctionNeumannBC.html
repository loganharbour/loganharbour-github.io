<!DOCTYPE html><head><meta charset="UTF-8"><title>FunctionNeumannBC.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="045a3bac-94ca-4844-88a4-19d898158281"><i class="material-icons">menu</i></a><ul class="sidenav" id="045a3bac-94ca-4844-88a4-19d898158281"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">bcs</span><a href="#" class="breadcrumb">FunctionNeumannBC</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="0bd04ae0-f9e0-49fc-98b5-9230dec917ce" data-section-level="1" data-section-text="FunctionNeumannBC"><h1 id="functionneumannbc">FunctionNeumannBC</h1><p>Imposes the integrated boundary condition <span tex="\frac{\partial u}{\partial n}=h(t,\vec{x})" bookmark="moose-equation-1207e5cc-ead4-4c39-a8bc-364693afaebf" recursive="True" class="moose-katex-inline-equation" id="moose-equation-1207e5cc-ead4-4c39-a8bc-364693afaebf"><script>var element = document.getElementById("moose-equation-1207e5cc-ead4-4c39-a8bc-364693afaebf");katex.render("\\frac{\\partial u}{\\partial n}=h(t,\\vec{x})", element, {displayMode:false,throwOnError:false});</script></span>, where <span tex="h" bookmark="moose-equation-ddb63840-03f2-4f37-bc3a-f0563fb885b9" recursive="True" class="moose-katex-inline-equation" id="moose-equation-ddb63840-03f2-4f37-bc3a-f0563fb885b9"><script>var element = document.getElementById("moose-equation-ddb63840-03f2-4f37-bc3a-f0563fb885b9");katex.render("h", element, {displayMode:false,throwOnError:false});</script></span> is a (possibly) time and space-dependent MOOSE Function.</p><section class="scrollspy" id="b833cfa9-aaee-43d8-92de-d347f55c35f0" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p><code>FunctionNeumannBC</code> is a generalization of <a href="NeumannBC.html"><code>NeumannBC</code></a> which is used for imposing flux boundary conditions on systems of partial differential equations (PDEs) where the flux is represented by a spatially- and temporally-varying MOOSE <a href="../../syntax/Functions/index.html"><code>Function</code></a>.  That is, for a PDE of the form <span class="moose-katex-block-equation"><span tex="\begin{aligned}   -\nabla^2 u &= f && \quad \in \Omega \\   u &= g(t,\vec{x}) && \quad \in \partial \Omega_D \\   \frac{\partial u}{\partial n} &= h(t,\vec{x}) && \quad \in \partial \Omega_N, \end{aligned}" bookmark="moose-equation-f1277600-af70-44b0-b919-5b607a9aefb6" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-f1277600-af70-44b0-b919-5b607a9aefb6"></span><script>var element = document.getElementById("moose-equation-f1277600-af70-44b0-b919-5b607a9aefb6");katex.render("\\begin{aligned}   -\\nabla^2 u &= f && \\quad \\in \\Omega \\\\   u &= g(t,\\vec{x}) && \\quad \\in \\partial \\Omega_D \\\\   \\frac{\\partial u}{\\partial n} &= h(t,\\vec{x}) && \\quad \\in \\partial \\Omega_N, \\end{aligned}", element, {displayMode:true,throwOnError:false});</script></span> where <span tex="\Omega \subset \mathbb{R}^n" bookmark="moose-equation-dfe957a9-11cf-42e6-aba5-1525e35ac224" recursive="True" class="moose-katex-inline-equation" id="moose-equation-dfe957a9-11cf-42e6-aba5-1525e35ac224"><script>var element = document.getElementById("moose-equation-dfe957a9-11cf-42e6-aba5-1525e35ac224");katex.render("\\Omega \\subset \\mathbb{R}^n", element, {displayMode:false,throwOnError:false});</script></span> is the domain, and <span tex="\partial \Omega = \partial \Omega_D \cup \partial \Omega_N" bookmark="moose-equation-e73e5994-e3b0-4ec3-b266-5da017660cbc" recursive="True" class="moose-katex-inline-equation" id="moose-equation-e73e5994-e3b0-4ec3-b266-5da017660cbc"><script>var element = document.getElementById("moose-equation-e73e5994-e3b0-4ec3-b266-5da017660cbc");katex.render("\\partial \\Omega = \\partial \\Omega_D \\cup \\partial \\Omega_N", element, {displayMode:false,throwOnError:false});</script></span> is its boundary, a <code>FunctionNeumannBC</code> object can be used to impose condition (3) if the function is well-defined for all relevant times and <span tex="\vec{x} \in \partial \Omega_N" bookmark="moose-equation-27ce4b32-639d-4400-9b17-6a3dfbe5afa5" recursive="True" class="moose-katex-inline-equation" id="moose-equation-27ce4b32-639d-4400-9b17-6a3dfbe5afa5"><script>var element = document.getElementById("moose-equation-27ce4b32-639d-4400-9b17-6a3dfbe5afa5");katex.render("\\vec{x} \\in \\partial \\Omega_N", element, {displayMode:false,throwOnError:false});</script></span>. In this case, the <code>function</code> parameter corresponds to a MOOSE <code>Function</code> object which represents the mathematical function <span tex="h(t,\vec{x})" bookmark="moose-equation-83a90c87-99b0-483a-ac4e-3abf984e9e59" recursive="True" class="moose-katex-inline-equation" id="moose-equation-83a90c87-99b0-483a-ac4e-3abf984e9e59"><script>var element = document.getElementById("moose-equation-83a90c87-99b0-483a-ac4e-3abf984e9e59");katex.render("h(t,\\vec{x})", element, {displayMode:false,throwOnError:false});</script></span>, and the user must define one or more sidesets corresponding to the boundary subset <span tex="\partial \Omega_N" bookmark="moose-equation-d96e5555-96d6-40db-8d8f-92a2b1952d11" recursive="True" class="moose-katex-inline-equation" id="moose-equation-d96e5555-96d6-40db-8d8f-92a2b1952d11"><script>var element = document.getElementById("moose-equation-d96e5555-96d6-40db-8d8f-92a2b1952d11");katex.render("\\partial \\Omega_N", element, {displayMode:false,throwOnError:false});</script></span> via the <code>boundary</code> parameter.</p></section><section class="scrollspy" id="e9fe1578-0eff-4ed2-84c8-c27c27bc7233" data-section-level="2" data-section-text="Example Input Syntax"><h2 id="example-input-syntax">Example Input Syntax</h2><pre class="moose-pre"><code class="language-text">  [./right2]
    type = FunctionNeumannBC
    variable = u
    boundary = right
    function = (y*(t-1))+1
  [../]
</code></pre><a href="#632b8f37-258d-407a-ad3e-b200ffc0ef01" class="modal-trigger">(test/tests/controls/time_periods/bcs/bcs_integrated.i)</a><div class="modal moose-modal" id="632b8f37-258d-407a-ad3e-b200ffc0ef01"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/test/tests/controls/time_periods/bcs/bcs_integrated.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = NeumannBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./right2]
    type = FunctionNeumannBC
    variable = u
    boundary = right
    function = (y*(t-1))+1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 20
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[Controls]
  [./period0]
    type = TimePeriod
    disable_objects = &#x27;BCs::right2&#x27;
    start_time = &#x27;0&#x27;
    end_time = &#x27;0.95&#x27;
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]

  [./period2]
    type = TimePeriod
    disable_objects = &#x27;BCs::right&#x27;
    start_time = &#x27;1&#x27;
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="08571cd8-0c0a-4f4d-8e1c-3405a863a6fe" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="8183c2ee-2926-4458-a3dd-7585b491d6a8" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundary IDs from the mesh where this boundary condition applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<BoundaryName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The list of boundary IDs from the mesh where this boundary condition applies</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">function</span><span class="moose-parameter-header-description">The function.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FunctionName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The function.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">The name of the variable that this boundary condition applies to</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>NonlinearVariableName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the variable that this boundary condition applies to</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="de83388e-1304-4d20-b9fa-ba752bffbc1b" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">displacements</span><span class="moose-parameter-header-description">The displacements</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<VariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The displacements</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="56b8f4a0-5637-40f8-9f4b-01dd3264be19" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">diag_save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this BC's diagonal jacobian contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<AuxVariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this BC's diagonal jacobian contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this BC's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<AuxVariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this BC's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="ee33d38e-2cca-483a-87e6-c5859093bacf" data-section-level="3" data-section-text="Tagging Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">extra_matrix_tags</span><span class="moose-parameter-header-description">The extra tags for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<TagName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_vector_tags</span><span class="moose-parameter-header-description">The extra tags for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<TagName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the vectors this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_tags</span><span class="moose-parameter-header-default">system</span><span class="moose-parameter-header-description">The tag for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>system</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime system</p><p class="moose-parameter-description"><span>Description:</span>The tag for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">vector_tags</span><span class="moose-parameter-header-default">nontime</span><span class="moose-parameter-header-description">The tag for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nontime</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime time</p><p class="moose-parameter-description"><span>Description:</span>The tag for the vectors this Kernel should fill</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Tagging Parameters</h3></summary></details></section></section><section class="scrollspy" id="d8d292a6-cc80-4b6c-887b-ba5cd0d6a9d6" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#033e183e-ddc7-434c-aeac-01df84ee1740" class="modal-trigger">test/tests/kernels/anisotropic_diffusion/aniso_diffusion.i</a></li><li><a href="#3383a217-f4ee-41dd-b282-82497163c5ce" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_xy_homog1mat.i</a></li><li><a href="#835ca77d-8424-4021-93f1-58d3d0c14b7d" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/edge_crack_3d.i</a></li><li><a href="#afe3c012-7424-4ef6-b46e-85dd2e9456d9" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/penny_crack.i</a></li><li><a href="#e09aecb0-8571-45bb-8cda-dbee7c534f69" class="modal-trigger">modules/combined/examples/stochastic/graphite_ring_thermomechanics.i</a></li><li><a href="#8ca0fd3d-7c90-44d4-b663-e31815680b88" class="modal-trigger">test/tests/variables/fe_hier/hier-1-2d.i</a></li><li><a href="#2a3426b7-4b66-4c5c-b6dd-0c05d69868ca" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_rz_lsdep1mat.i</a></li><li><a href="#f9d32056-562d-48de-80bd-99e17f80ba01" class="modal-trigger">modules/xfem/test/tests/moment_fitting/solid_mechanics_moment_fitting.i</a></li><li><a href="#91afcb1b-c68d-4f6a-adf8-45c5182aa018" class="modal-trigger">test/tests/variables/fe_hier/hier-1-1d.i</a></li><li><a href="#11365fe5-578b-4101-9149-e32cd43cef9a" class="modal-trigger">test/tests/kernels/scalar_constraint/scalar_constraint_kernel.i</a></li><li><a href="#fb10eac6-e280-4fb6-bf61-4a44e88e2dc4" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/edge_crack_3d_propagation.i</a></li><li><a href="#0c6d075f-38c7-4ee5-a4c1-c52a0d843161" class="modal-trigger">test/tests/postprocessors/side_flux_average/side_flux_average.i</a></li><li><a href="#9601eb40-c35d-4805-b316-1d82d3628fc9" class="modal-trigger">test/tests/variables/fe_monomial_const/monomial-const-3d.i</a></li><li><a href="#2d11fa20-aae0-4647-952d-f1a6d57156df" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_lsdep1mat.i</a></li><li><a href="#76b09feb-587f-4ee6-a7a0-158a41467df0" class="modal-trigger">test/tests/variables/fe_hermite/hermite-3-2d.i</a></li><li><a href="#24f2c630-b5c3-49b9-bd0a-926a934c6187" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_rz_homog1mat.i</a></li><li><a href="#61a37a19-1038-4d7b-93b6-f8c6054ab38e" class="modal-trigger">test/tests/variables/fe_hier/hier-2-1d.i</a></li><li><a href="#fc9f295a-d5ec-4959-ab24-6e6fa05b8a80" class="modal-trigger">test/tests/misc/check_error/coupled_grad_without_declare.i</a></li><li><a href="#9b8ab75d-0d6b-4090-9f58-60dcd4cd1d30" class="modal-trigger">test/tests/variables/fe_hier/hier-3-1d.i</a></li><li><a href="#d21d7557-f658-45fa-a8b2-4dd088b81133" class="modal-trigger">modules/tensor_mechanics/test/tests/static_deformations/beam_cosserat_02_apply_stress.i</a></li><li><a href="#f3110413-effd-4958-b420-b41604dcaee1" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/mesh_grow.i</a></li><li><a href="#7362e77d-6b5b-4c50-bc38-ef47edf96091" class="modal-trigger">test/tests/variables/previous_newton_iteration/test.i</a></li><li><a href="#7c286c7f-8207-4a6c-984f-bdbc7f54a485" class="modal-trigger">test/tests/variables/fe_hermite/hermite-3-3d.i</a></li><li><a href="#d8461157-60c4-4b89-8c5c-42ff7fa3d1c4" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_rz_lsdep1mat.i</a></li><li><a href="#f84c6d5f-7650-4981-92ec-74640dd1e8c0" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_homog1mat.i</a></li><li><a href="#70ac2811-0fd5-485e-a726-aa5270fdc496" class="modal-trigger">modules/porous_flow/examples/tidal/barometric_fully_confined.i</a></li><li><a href="#c16b5ee6-e46d-4488-be6b-f9b2f314936a" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_discrete2mat.i</a></li><li><a href="#32f196f0-de28-4fa1-97dd-90d8944a958b" class="modal-trigger">test/tests/kernels/scalar_constraint/scalar_constraint_kernel_disp.i</a></li><li><a href="#87c3891d-b2bf-4235-9906-46e869e56f2d" class="modal-trigger">test/tests/variables/fe_monomial_const/monomial-const-2d.i</a></li><li><a href="#0730f5a1-4534-4619-ac4e-fd9c126a27d0" class="modal-trigger">test/tests/bcs/function_neumann_bc/test.i</a></li><li><a href="#7a6b4a03-4c2b-439f-817d-8ee73aa1c772" class="modal-trigger">test/tests/controls/time_periods/bcs/bcs_integrated.i</a></li><li><a href="#16c8dd97-7157-4132-a1cc-e391b568275e" class="modal-trigger">test/tests/variables/fe_hier/hier-2-3d.i</a></li><li><a href="#4cde10c4-93d7-48d0-bb88-478221968ead" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_rz_homog1mat.i</a></li><li><a href="#cdfde1a2-780f-4aa1-b328-520f4e15a88a" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_xy_lsdep1mat.i</a></li><li><a href="#9c4e2378-f637-4591-ab5c-8a93c1fff2e6" class="modal-trigger">test/tests/bcs/ad_function_neumann_bc/test.i</a></li><li><a href="#38378ed5-a2d5-4691-9e9a-c83d6c8907cd" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/elliptical_crack.i</a></li><li><a href="#eff9aae2-8ef5-465d-8620-fa3eb7b1a15e" class="modal-trigger">test/tests/outputs/debug/show_var_residual_norms_debug.i</a></li><li><a href="#eb910a76-5925-4f6f-bf3e-3e19843297ab" class="modal-trigger">modules/porous_flow/examples/tidal/atm_tides.i</a></li><li><a href="#e67d7717-4ae3-4ce2-9220-96a58080a565" class="modal-trigger">test/tests/variables/fe_hermite_convergence/hermite_converge_periodic.i</a></li><li><a href="#be539fa7-26e2-47fd-8e64-9332d170e893" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/penny_crack_cfp.i</a></li><li><a href="#1e86e2e6-4462-4193-91f8-beb96e6bde20" class="modal-trigger">test/tests/variables/fe_hier/hier-1-3d.i</a></li><li><a href="#6c24671d-cb94-4b9b-a148-9431eee6b9ca" class="modal-trigger">modules/porous_flow/examples/tidal/atm_tides_open_hole.i</a></li><li><a href="#597a7754-3a2d-440d-be01-1c83b5f9047e" class="modal-trigger">test/tests/time_integrators/actually_explicit_euler_verification/ee-1d-quadratic-neumann.i</a></li><li><a href="#82605f70-aeae-451e-bab6-d2ab9e3795a9" class="modal-trigger">test/tests/variables/fe_hermite/hermite-3-1d.i</a></li><li><a href="#1abf6f12-27b6-458d-80f1-b7edeab35ac1" class="modal-trigger">test/tests/outputs/debug/show_var_residual_norms.i</a></li><li><a href="#94e3a435-a1c4-4810-9263-a7f7dbd8194b" class="modal-trigger">modules/combined/test/tests/poro_mechanics/unconsolidated_undrained.i</a></li><li><a href="#f012eb30-fffd-444b-94d1-dae2628ba132" class="modal-trigger">test/tests/variables/fe_hier/hier-3-3d.i</a></li><li><a href="#97071600-73a9-4fc4-962c-89cb3318a15e" class="modal-trigger">test/tests/variables/fe_hier/hier-2-2d.i</a></li><li><a href="#374bd681-d694-48b6-a613-abc0d2d32037" class="modal-trigger">test/tests/functions/parsed/mms_transient_coupled.i</a></li><li><a href="#755b54c4-c290-4246-a1df-db95ead73579" class="modal-trigger">test/tests/variables/fe_hier/hier-3-2d.i</a></li><li><a href="#77c57794-eeba-4c20-8c0a-b41f9ad3be5c" class="modal-trigger">test/tests/time_integrators/explicit-euler/ee-1d-quadratic-neumann.i</a></li></ul><div class="modal moose-modal" id="033e183e-ddc7-434c-aeac-01df84ee1740"><div class="modal-content"><h4>test/tests/kernels/anisotropic_diffusion/aniso_diffusion.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = mixed_block.e
  uniform_refine=3
[]

[Functions]
  [./top_bc]
    type = ParsedFunction
    value = &#x27;x&#x27;
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = AnisotropicDiffusion
    variable = u
    tensor_coeff = &#x27;2 0 0
                    0 4 0
        0 0 0&#x27;
  [../]
[]

[BCs]
  active = &#x27;lower_left top&#x27;

  [./lower_left]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 4&#x27;
    value = 1
  [../]

  [./top]
    type = FunctionNeumannBC
    variable = u
    boundary = 3
    function = top_bc
  [../]

  [./right]
    type = NeumannBC
    variable = u
    boundary = 2
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3383a217-f4ee-41dd-b282-82497163c5ce"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_xy_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      xy
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with homogeneous material
#   properties. This problem can be exactly evaluated by FEM/Moose without the
#   moving interface. Both the temperature and level set function are designed
#   to be linear to attempt to minimize error between the Moose/exact solution
#   and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=0, y=0) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9998791
#      0.6                  520         519.9995307
#      0.8                  560         559.9989724
#      1.0                  600         599.9984541
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+200)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+100)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+100)*t+400&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 1.04 - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="835ca77d-8424-4021-93f1-58d3d0c14b7d"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/edge_crack_3d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 5
  ny = 5
  nz = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.2
  elem_type = HEX8
[]

[UserObjects]
  [./square_cut_uo]
    type = RectangleCutUserObject
    cut_data = &#x27; -0.001 0.5 -0.001
                  0.401 0.5 -0.001
                  0.401 0.5  0.201
                 -0.001 0.5  0.201&#x27;
  [../]
[]

[AuxVariables]
  [./SED]
   order = CONSTANT
    family = MONOMIAL
  [../]
[]

[DomainIntegral]
  integrals = &#x27;Jintegral InteractionIntegralKI&#x27;
  crack_front_points = &#x27;0.4 0.5 0.0
                        0.4 0.5 0.1
                        0.4 0.5 0.2&#x27;
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  radius_inner = &#x27;0.2&#x27;
  radius_outer = &#x27;0.4&#x27;
  poissons_ratio = 0.3
  youngs_modulus = 207000
  block = 0
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
    block = 0
  [../]
[]

[Functions]
  [./top_trac_y]
    type = ConstantFunction
    value = 10
  [../]
[]


[BCs]
  [./top_y]
    type = FunctionNeumannBC
    boundary = top
    variable = disp_y
    function = top_trac_y
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = bottom
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    boundary = bottom
    variable = disp_z
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
    block = 0
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  file_base = edge_crack_3d_out
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="afe3c012-7424-4ef6-b46e-85dd2e9456d9"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/penny_crack.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  file = quarter_sym.e
[]

[UserObjects]
  [./circle_cut_uo]
    type = CircleCutUserObject
    cut_data = &#x27;-0.5 -0.5 0
                0.0 -0.5 0
                -0.5 0 0&#x27;
  [../]
[]

[AuxVariables]
  [./SED]
   order = CONSTANT
    family = MONOMIAL
  [../]
[]

[DomainIntegral]
  integrals = &#x27;Jintegral&#x27;
  disp_x = disp_x
  disp_y = disp_y
  disp_z = disp_z
  crack_front_points = &#x27;-0.5 0.0 0.0
                        -0.25 -0.07 0
                        -0.15 -0.15 0
                        -0.07 -0.25 0
                         0 -0.5 0&#x27;
  crack_end_direction_method = CrackDirectionVector
  crack_direction_vector_end_1 = &#x27;0 1 0&#x27;
  crack_direction_vector_end_2 = &#x27;1 0 0&#x27;
  crack_direction_method = CurvedCrackFront
  intersecting_boundary = &#x27;3 4&#x27; #It would be ideal to use this, but can&#x27;t use with XFEM yet
  radius_inner = &#x27;0.3&#x27;
  radius_outer = &#x27;0.6&#x27;
  poissons_ratio = 0.3
  youngs_modulus = 207000
  block = 1
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
    block = 1
  [../]
[]

[Functions]
  [./top_trac_z]
    type = ConstantFunction
    value = 10
  [../]
[]


[BCs]
  [./top_z]
    type = FunctionNeumannBC
    boundary = 2
    variable = disp_z
    function = top_trac_z
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = 1
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 1
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    boundary = 1
    variable = disp_z
    value = 0.0
  [../]
  [./sym_y]
    type = DirichletBC
    boundary = 3
    variable = disp_y
    value = 0.0
  [../]
  [./sym_x]
    type = DirichletBC
    boundary = 4
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  file_base = penny_crack_out
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e09aecb0-8571-45bb-8cda-dbee7c534f69"><div class="modal-content"><h4>modules/combined/examples/stochastic/graphite_ring_thermomechanics.i</h4><pre class="moose-pre"><code class="language-text"># Generate 1/4 of a 2-ring disk and extrude it by half to obtain
# 1/8 of a 3D tube.  Mirror boundary conditions will exist on the
# cut portions.

[Mesh]
  [disk]
    type = ConcentricCircleMeshGenerator
    num_sectors = 10
    radii = &#x27;1.0 1.1 1.2&#x27;
    rings = &#x27;1 1 1&#x27;
    has_outer_square = false
    preserve_volumes = false
    portion = top_right
  []
  [ring]
    type = BlockDeletionGenerator
    input = disk
    block_id = 1
    new_boundary = &#x27;inner&#x27;
  []
  [cylinder]
    type = MeshExtruderGenerator
    input = ring
    extrusion_vector = &#x27;0 0 1.5&#x27;
    num_layers = 15
    bottom_sideset = &#x27;back&#x27;
    top_sideset = &#x27;front&#x27;
  []
[]

[Variables]
  [T]
    initial_condition = 300
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
[]

[Kernels]
  [hc]
    type = HeatConduction
    variable = T
  []
  [TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  []
[]

[BCs]
  [temp_inner]
    type = FunctionNeumannBC
    variable = T
    boundary = &#x27;inner&#x27;
    function = surface_source
  []
  [temp_front]
    type = ConvectiveHeatFluxBC
    variable = T
    boundary = &#x27;front&#x27;
    T_infinity = 300
    heat_transfer_coefficient = 10
  []
  [temp_outer]
    type = ConvectiveHeatFluxBC
    variable = T
    boundary = &#x27;outer&#x27;
    T_infinity = 300
    heat_transfer_coefficient = 10
  []
  # mirror boundary conditions.
  [disp_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left&#x27;
    value = 0.0
  []
  [disp_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  []
  [disp_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;back&#x27;
    value = 0.0
  []
[]

[Materials]
  [cond_inner]
    type = GenericConstantMaterial
    block = 2
    prop_names = thermal_conductivity
    prop_values = 25
  []
  [cond_outer]
    type = GenericConstantMaterial
    block = 3
    prop_names = thermal_conductivity
    prop_values = 100
  []
  [elasticity_tensor_inner]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
    block = 2
  []
  [elasticity_tensor_outer]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3.1e5
    poissons_ratio = 0.2
    block = 3
  []
  [thermal_strain_inner]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 2e-6
    temperature = T
    stress_free_temperature = 300
    eigenstrain_name = eigenstrain_inner
    block = 2
  []
  [thermal_strain_outer]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-6
    temperature = T
    stress_free_temperature = 300
    eigenstrain_name = eigenstrain_outer
    block = 3
  []
  [strain_inner] #We use small deformation mechanics
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    eigenstrain_names = &#x27;eigenstrain_inner&#x27;
    block = 2
  []
  [strain_outer] #We use small deformation mechanics
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    eigenstrain_names = &#x27;eigenstrain_outer&#x27;
    block = 3
  []
  [stress] #We use linear elasticity
    type = ComputeLinearElasticStress
  []
[]

[Functions]
  [surface_source]
    type = ParsedFunction
    value = &#x27;Q_t*pi/2.0/3.0 * cos(pi/3.0*z)&#x27;
    vars = &#x27;Q_t&#x27;
    vals = heat_source
  []
[]

[Executioner]
  type = Steady

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre boomeramg 101&#x27;

  l_max_its = 30
  nl_max_its = 100
  nl_abs_tol = 1e-9
  l_tol = 1e-04
[]

[Preconditioning]
  [SMP]
    type = SMP
    full = true
  []
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[VectorPostprocessors]
  [temp_center]
    type = LineValueSampler
    variable = T
    start_point = &#x27;1 0 0&#x27;
    end_point = &#x27;1.2 0 0&#x27;
    num_points = 11
    sort_by = &#x27;x&#x27;
  []
  [temp_end]
    type = LineValueSampler
    variable = T
    start_point = &#x27;1 0 1.5&#x27;
    end_point = &#x27;1.2 0 1.5&#x27;
    num_points = 11
    sort_by = &#x27;x&#x27;
  []
  [dispx_center]
    type = LineValueSampler
    variable = disp_x
    start_point = &#x27;1 0 0&#x27;
    end_point = &#x27;1.2 0 0&#x27;
    num_points = 11
    sort_by = &#x27;x&#x27;
  []
  [dispx_end]
    type = LineValueSampler
    variable = disp_x
    start_point = &#x27;1 0 1.5&#x27;
    end_point = &#x27;1.2 0 1.5&#x27;
    num_points = 11
    sort_by = &#x27;x&#x27;
  []
  [dispz_end]
    type = LineValueSampler
    variable = disp_z
    start_point = &#x27;1 0 1.5&#x27;
    end_point = &#x27;1.2 0 1.5&#x27;
    num_points = 11
    sort_by = &#x27;x&#x27;
  []
[]

[Postprocessors]
  [heat_source]
    type = FunctionValuePostprocessor
    function = 1
    scale_factor = 10000
    execute_on = linear
  []
  [temp_center_inner]
    type = PointValue
    variable = T
    point = &#x27;1 0 0&#x27;
  []
  [temp_center_outer]
    type = PointValue
    variable = T
    point = &#x27;1.2 0 0&#x27;
  []
  [temp_end_inner]
    type = PointValue
    variable = T
    point = &#x27;1 0 1.5&#x27;
  []
  [temp_end_outer]
    type = PointValue
    variable = T
    point = &#x27;1.2 0 1.5&#x27;
  []
  [dispx_center_inner]
    type = PointValue
    variable = disp_x
    point = &#x27;1 0 0&#x27;
  []
  [dispx_center_outer]
    type = PointValue
    variable = disp_x
    point = &#x27;1.2 0 0&#x27;
  []
  [dispx_end_inner]
    type = PointValue
    variable = disp_x
    point = &#x27;1 0 1.5&#x27;
  []
  [dispx_end_outer]
    type = PointValue
    variable = disp_x
    point = &#x27;1.2 0 1.5&#x27;
  []
  [dispz_inner]
    type = PointValue
    variable = disp_z
    point = &#x27;1 0 1.5&#x27;
  []
  [dispz_outer]
    type = PointValue
    variable = disp_z
    point = &#x27;1.2 0 1.5&#x27;
  []
[]

[Outputs]
  exodus = false
  csv = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8ca0fd3d-7c90-44d4-b663-e31815680b88"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-1-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 1
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 1
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x+y
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x+y
    grad_x = 1
    grad_y = 1
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2a3426b7-4b66-4c5c-b6dd-0c05d69868ca"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_rz_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      rz
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in cylindrical coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is dependent upon the value of the level set function
#   at each timestep.
# Results:
#   The temperature at the left boundary (x=1) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM
#   results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0008131
#      0.6                  520         520.0038333
#      0.8                  560         560.0088286
#      1.0                  600         600.0131612
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 1.0
  xmax = 2.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+400) + (1/x)*(310*t - (10/1.02)*x*t - (1/1.02)*t^2)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.05/2.04)*(2.04-x-0.2*t) + 1.5)*200*t&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.05/2.04)*(2.04-x-0.2*t) + 1.5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;2.04 - x -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f9d32056-562d-48de-80bd-99e17f80ba01"><div class="modal-content"><h4>modules/xfem/test/tests/moment_fitting/solid_mechanics_moment_fitting.i</h4><pre class="moose-pre"><code class="language-text"># Test for a mechanics problem which uses four points moment_fitting approach.
# See this paper (https://doi.org/10.1007/s00466-018-1544-2) for more details about moment_fitting approach.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_uo0]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.0000e+00   6.3330e-01   3.9000e-01   6.3330e-01&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
  [./line_seg_cut_uo1]
    type = LineSegmentCutUserObject
    cut_data = &#x27;3.9000e-01   6.3330e-01   6.8000e-01   6.3330e-01&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
  [../]
[]

[Functions]
  [./right_trac_x]
    type = ParsedFunction
    value = &#x27;-(t*M*y)/I&#x27;
    vars = &#x27;M E I&#x27;
    vals = &#x27;2e4 1e6 0.666666667&#x27;
  [../]
  [./bottom_disp_y]
    type = ParsedFunction
    value = &#x27;((t*M)/(2*E*I))*(1-nu*nu)*(x*x-0.25*l*l)&#x27;
    vars = &#x27;M E I l nu&#x27;
    vals = &#x27;2e4 1e6 0.666666667 2.0 0.3&#x27;
  [../]
  [./soln_x]
    type = ParsedFunction
    value = &#x27;-(M/(E*I))*(1-nu*nu)*x*y&#x27;
    vars = &#x27;M E I nu&#x27;
    vals = &#x27;2e4 1e6 0.666666667 0.3&#x27;
  [../]
  [./soln_y]
    type = ParsedFunction
    value = &#x27;(M/(2*E*I))*(1-nu*nu)*(x*x-0.25*l*l+(nu/(1-nu))*y*y)&#x27;
    vars = &#x27;M E I l nu&#x27;
    vals = &#x27;2e4 1e6 0.666666667 2.0 0.3&#x27;
  [../]
[]

[BCs]
  [./right_x]
    type = FunctionNeumannBC
    boundary = 1
    variable = disp_x
    function = right_trac_x
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    boundary = 0
    variable = disp_y
    function = bottom_disp_y
  [../]
  [./left_x]
    type = DirichletBC
    boundary = 3
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

#  [./Quadrature]
#    order = FOURTH
#    type = MONOMIAL
#  [../]

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-16
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 0.5
  end_time = 1.0
  num_steps = 5000
[]

[Postprocessors]
  [./numel]
    type = NumElems
    execute_on = timestep_end
  [../]
  [./integral]
    type = ElementVectorL2Error
    var_x = disp_x
    var_y = disp_y
    function_x = soln_x
    function_y = soln_y
    execute_on = timestep_end
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="91afcb1b-c68d-4f6a-adf8-45c5182aa018"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-1-1d.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test demonstrating the use of the
# Hierarchic variable type.
#
# @Requirement F3.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
  elem_type = EDGE3
[]

[Functions]
  [./bc_fnl]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 1
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x
    grad_x = 1
  [../]
[]

# Hierarchic Variable type
[Variables]
  [./u]
    order = FIRST
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-11

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="11365fe5-578b-4101-9149-e32cd43cef9a"><div class="modal-content"><h4>test/tests/kernels/scalar_constraint/scalar_constraint_kernel.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]

  [./bottom_bc_fn]
    type = ParsedFunction
    value = -2*y
  [../]

  [./right_bc_fn]
    type = ParsedFunction
    value =  2*x
  [../]

  [./top_bc_fn]
    type = ParsedFunction
    value =  2*y
  [../]

  [./left_bc_fn]
    type = ParsedFunction
    value = -2*x
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]

  [./lambda]
    family = SCALAR
    order = FIRST
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffnk]
    type = BodyForce
    variable = u
    function = ffn
  [../]

  [./sk_lm]
    type = ScalarLagrangeMultiplier
    variable = u
    lambda = lambda
  [../]
[]

[ScalarKernels]
  [./constraint]
    type = AverageValueConstraint
    variable = lambda
    pp_name = pp
    value = 2.666666666666666
  [../]
[]

[BCs]
  [./bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bottom_bc_fn
  [../]
  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_bc_fn
  [../]
  [./top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = top_bc_fn
  [../]
  [./left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = left_bc_fn
  [../]
[]

[Postprocessors]
  [./pp]
    type = ElementIntegralVariablePostprocessor
    variable = u
    execute_on = linear
  [../]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./pc]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-9
  l_tol = 1.e-10
  nl_max_its = 10
  # This example builds an indefinite matrix, so &quot;-pc_type hypre -pc_hypre_type boomeramg&quot; cannot
  # be used reliably on this problem. ILU(0) seems to do OK in both serial and parallel in my testing,
  # I have not seen any zero pivot issues.
  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;bjacobi  ilu&#x27;
  # This is a linear problem, so we don&#x27;t need to recompute the
  # Jacobian. This isn&#x27;t a big deal for a Steady problems, however, as
  # there is only one solve.
  solve_type = &#x27;LINEAR&#x27;
[]

[Outputs]
  exodus = true
  hide = lambda
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fb10eac6-e280-4fb6-bf61-4a44e88e2dc4"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/edge_crack_3d_propagation.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  geometric_cut_userobjects = &#x27;cut_mesh&#x27;
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 5
  ny = 5
  nz = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.2
  elem_type = HEX8
[]

[UserObjects]
  [./cut_mesh]
    type = MeshCut3DUserObject
    mesh_file = mesh_edge_crack.xda
    size_control = 0.1
    n_step_growth = 1
    function_x = growth_func_x
    function_y = growth_func_y
    function_z = growth_func_z
  [../]
[]

[Functions]
  [./growth_func_x]
    type = ParsedFunction
    value = 1
  [../]
  [./growth_func_y]
    type = ParsedFunction
    value = 0
  [../]
  [./growth_func_z]
    type = ParsedFunction
    value = 0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[Functions]
  [./top_trac_y]
    type = ConstantFunction
    value = 10
  [../]
[]


[BCs]
  [./top_y]
    type = FunctionNeumannBC
    boundary = top
    variable = disp_y
    function = top_trac_y
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = bottom
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    boundary = bottom
    variable = disp_z
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
    block = 0
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 5.0
  max_xfem_update = 1
[]

[Outputs]
  file_base = edge_crack_3d_propagation_out
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0c6d075f-38c7-4ee5-a4c1-c52a0d843161"><div class="modal-content"><h4>test/tests/postprocessors/side_flux_average/side_flux_average.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./right_bc]
    # Flux BC for computing the analytical solution in the postprocessor
    type = ParsedFunction
    value = exp(y)+1
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = right
    function = right_bc
  [../]
[]

[Materials]
  [./mat_props]
    type = GenericConstantMaterial
    block = 0
    prop_names = diffusivity
    prop_values = 2
  [../]

  [./mat_props_bnd]
    type = GenericConstantMaterial
    boundary = right
    prop_names = diffusivity
    prop_values = 1
  [../]
[]

[Postprocessors]
  [./avg_flux_right]
    # Computes -\int(exp(y)+1) from 0 to 1 which is -2.718281828
    type = SideFluxAverage
    variable = u
    boundary = right
    diffusivity = diffusivity
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9601eb40-c35d-4805-b316-1d82d3628fc9"><div class="modal-content"><h4>test/tests/variables/fe_monomial_const/monomial-const-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 21
  ny = 21
  nz = 21
  elem_type = HEX8
[]

[Functions]
  [./bc_fn]
    type=ParsedFunction
    value=0
  [../]
  [./bc_fnt]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
#    type = ParsedFunction
#    value = 0
    type = MTPiecewiseConst3D
  [../]

  [./solution]
    type = MTPiecewiseConst3D
  [../]
[]

[Variables]
  [./u]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  # Note: MOOSE&#x27;s DirichletBCs do not work properly with shape functions that do not
  #       have DOFs at the element edges.  This test works because the solution
  #       has been designed to be zero at the boundary which is satisfied by the IC
  #       Ticket #1352
  active = &#x27;&#x27;
  [./bc_all]
    type=FunctionDirichletBC
    variable = u
    boundary = &#x27;top bottom left right&#x27;
    function = bc_fn
  [../]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1.e-9
  [./Adaptivity]

  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  csv = true
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2d11fa20-aae0-4647-952d-f1a6d57156df"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in Cartesian coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is dependent upon the value of the level set function
#   at each timestep.
# Results:
#   The temperature at the left boundary (x=0) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM
#   results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9999722
#      0.6                  520         519.9998726
#      0.8                  560         559.9997314
#      1.0                  600         599.9996885
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;rhoCp*(-200*x+200)-(0.05*200*t/1.04)&#x27;
    vars = &#x27;rhoCp&#x27;
    vals = 10
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.05/1.04)*(1-(x-0.04)-0.2*t) + 1.5)*200*t&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.05/1.04)*(1-(x-0.04)-0.2*t) + 1.5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;1.04 - x - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="76b09feb-587f-4ee6-a7a0-158a41467df0"><div class="modal-content"><h4>test/tests/variables/fe_hermite/hermite-3-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 3*y*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -3*y*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x-6*y+(x*x*x)+(y*y*y)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (x*x*x)+(y*y*y)
    grad_x = 3*x*x
    grad_y = 3*y*y
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;NEWTON&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="24f2c630-b5c3-49b9-bd0a-926a934c6187"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_rz_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      rz
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in cylindrical coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with homogeneous material
#   properties. This problem can be exactly evaluated by FEM/Moose without the
#   moving interface. Both the temperature and level set function are designed
#   to be linear to attempt to minimize error between the Moose/exact solution
#   and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=1, y=1) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9998745
#      0.6                  520         519.9995067
#      0.8                  560         559.9989409
#      1.0                  600         599.9987054
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 1.0
  xmax = 2.0
  ymin = 1.0
  ymax = 2.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+400) + 100*1.5*t/x&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+200)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+200)*t+400&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 2.04 - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="61a37a19-1038-4d7b-93b6-f8c6054ab38e"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-2-1d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
  elem_type = EDGE3
[]

[Functions]
  [./bc_fnl]
    type = ParsedFunction
    value = -2*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 2*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -2+x*x
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x
    grad_x = 2*x
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fc9f295a-d5ec-4959-ab24-6e6fa05b8a80"><div class="modal-content"><h4>test/tests/misc/check_error/coupled_grad_without_declare.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fnu]
    type = ParsedFunction
    value = -5.8*(x+y)+x*x*x-x+y*y*y-y
  [../]
  [./forcing_fnv]
    type = ParsedFunction
    value = -4
  [../]

  [./slnu]
    type = ParsedGradFunction
    value = x*x*x-x+y*y*y-y
    grad_x = 3*x*x-1
    grad_y = 3*y*y-1
  [../]
  [./slnv]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]

  #NeumannBC functions
  [./bc_fnut]
    type = ParsedFunction
    value = 3*y*y-1
  [../]
  [./bc_fnub]
    type = ParsedFunction
    value = -3*y*y+1
  [../]
  [./bc_fnul]
    type = ParsedFunction
    value = -3*x*x+1
  [../]
  [./bc_fnur]
    type = ParsedFunction
    value = 3*x*x-1
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff1 diff2 test1 forceu forcev react&#x27;
  [./diff1]
    type = Diffusion
    variable = u
  [../]
  [./test1]
    type = CoupledConvection
    variable = u
    velocity_vector = v

    # Trigger the error in this class
    test_coupling_declaration_error = true
  [../]
  [./diff2]
    type = Diffusion
    variable = v
  [../]
  [./react]
    type = Reaction
    variable = u
  [../]

  [./forceu]
    type = BodyForce
    variable = u
    function = forcing_fnu
  [../]
  [./forcev]
    type = BodyForce
    variable = v
    function = forcing_fnv
  [../]

[]

[BCs]
  active = &#x27;bc_u_tb bc_v bc_ul bc_ur bc_ut bc_ub&#x27;
  [./bc_u]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_v]
    type = FunctionDirichletBC
    variable = v
    function = slnv
    boundary = &#x27;left right top bottom&#x27;
  [../]

  [./bc_u_lr]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_u_tb]
    type = CoupledKernelGradBC
    variable = u
    var2 = v
    vel = &#x27;0.1 0.1&#x27;
    boundary = &#x27;top bottom left right&#x27;
  [../]

  [./bc_ul]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnul
    boundary = &#x27;left&#x27;
  [../]
  [./bc_ur]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnur
    boundary = &#x27;right&#x27;
  [../]
  [./bc_ut]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnut
    boundary = &#x27;top&#x27;
  [../]
  [./bc_ub]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnub
    boundary = &#x27;bottom&#x27;
  [../]
[]

[Preconditioning]
  active = &#x27; &#x27;
  [./prec]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active=&#x27;L2u L2v&#x27;
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2u]
    type = ElementL2Error
    variable = u
    function = slnu
  [../]
  [./L2v]
    type = ElementL2Error
    variable = v
    function = slnv
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes&#x27;
  nl_rel_tol = 1e-15
  nl_abs_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9b8ab75d-0d6b-4090-9f58-60dcd4cd1d30"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-3-1d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
  elem_type = EDGE3
[]

[Functions]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x+(x*x*x)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x*x
    grad_x = 3*x*x
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d21d7557-f658-45fa-a8b2-4dd088b81133"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/static_deformations/beam_cosserat_02_apply_stress.i</h4><pre class="moose-pre"><code class="language-text"># Beam bending.
# One end is clamped and the other end is subjected to a stress
# and micromechanical moment that will induce bending.
# The stress that will induce bending around the y axis is
# stress_xx = EAz
# This implies a micromechanical moment-stress of
# m_yx = (1/12)EAh^2 for joint_shear_stiffness=0.
# For joint_shear_stiffness!=0, the micromechanical moment-stress
# is
# m_yx = (1/12)EAa^2 G/(ak_s + G)
# All other stresses and moment stresses are assumed to be zero.
# With joint_shear_stiffness=0, and introducing D=-poisson*A, the
# nonzero strains are
# ep_xx = Az
# ep_yy = Dz
# ep_zz = Dz
# kappa_xy = -D
# kappa_yx = A
# This means the displacements are:
# u_x = Axz
# u_y = Dzy
# u_z = -(A/2)x^2 + (D/2)(z^2-y^2)
# wc_x = -Dy
# wc_y = Ax
# wc_z = 0
# This is bending of a bar around the y axis, in plane stress
# (stress_yy=0).  Displacements at the left-hand (x=0) are applied
# according to the above formulae; wc_x and wc_y are applied throughout
# the bar; and stress_xx is applied at the right-hand end (x=10).
# The displacements are measured and
# compared with the above formulae.
# The test uses: E=1.2, poisson=0.3, A=1.11E-2, h=2, ks=0.1, so
# stress_xx = 1.332E-2*z
# m_yx = 0.2379E-2
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
  ny = 1
  nz = 10
  xmin = 0
  xmax = 10
  ymin = -1
  ymax = 1
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  #use_displaced_mesh = false
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  Cosserat_rotations = &#x27;wc_x wc_y wc_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./wc_x]
  [../]
  [./wc_y]
  [../]
[]

[Kernels]
  [./cx_elastic]
    type = CosseratStressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./cy_elastic]
    type = CosseratStressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./cz_elastic]
    type = CosseratStressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./x_couple]
    type = StressDivergenceTensors
    variable = wc_x
    displacements = &#x27;wc_x wc_y wc_z&#x27;
    component = 0
    base_name = couple
  [../]
  [./y_couple]
    type = StressDivergenceTensors
    variable = wc_y
    displacements = &#x27;wc_x wc_y wc_z&#x27;
    component = 1
    base_name = couple
  [../]
  [./x_moment]
    type = MomentBalancing
    variable = wc_x
    component = 0
  [../]
  [./y_moment]
    type = MomentBalancing
    variable = wc_y
    component = 1
  [../]
[]

[BCs]
  # zmin is called back
  # zmax is called front
  # ymin is called bottom
  # ymax is called top
  # xmin is called left
  # xmax is called right
  [./clamp_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = left
    function = &#x27;-0.3*(z*z-y*y)/2.0*1.11E-2&#x27;
  [../]
  [./clamp_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = left
    function = &#x27;-0.3*z*y*1.11E-2&#x27;
  [../]
  [./clamp_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./end_stress]
    type = FunctionNeumannBC
    boundary = right
    function = z*1.2*1.11E-2
    variable = disp_x
  [../]
  [./fix_wc_x]
    type = FunctionDirichletBC
    variable = wc_x
    boundary = &#x27;left&#x27; # right top bottom front back&#x27;
    function = &#x27;0.3*y*1.11E-2&#x27;
  [../]
  [./fix_wc_y]
    type = FunctionDirichletBC
    variable = wc_y
    boundary = &#x27;left&#x27; # right top bottom front back&#x27;
    function = &#x27;1.11E-2*x&#x27;
  [../]
  [./end_moment]
    type = VectorNeumannBC
    boundary = right
    variable = wc_y
    vector_value = &#x27;2.3785714286E-3 0 0&#x27;
  [../]
[]


[AuxVariables]
  [./wc_z]
  [../]
  [./strain_xx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_xy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_xz]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_yx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_yz]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_zx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_zy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./strain_zz]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_xx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_xy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_xz]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_yx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_yz]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_zx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_zy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./stress_zz]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_xx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_xy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_xz]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_yx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_yz]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_zx]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_zy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./couple_stress_zz]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_xy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xy
    index_i = 0
    index_j = 1
  [../]
  [./strain_xz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xz
    index_i = 0
    index_j = 2
  [../]
  [./strain_yx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yx
    index_i = 1
    index_j = 0
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_yz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yz
    index_i = 1
    index_j = 2
  [../]
  [./strain_zx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zx
    index_i = 2
    index_j = 0
  [../]
  [./strain_zy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zy
    index_i = 2
    index_j = 1
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yx
    index_i = 1
    index_j = 0
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zx
    index_i = 2
    index_j = 0
  [../]
  [./stress_zy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zy
    index_i = 2
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./couple_stress_xx]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./couple_stress_xy]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./couple_stress_xz]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./couple_stress_yx]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_yx
    index_i = 1
    index_j = 0
  [../]
  [./couple_stress_yy]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./couple_stress_yz]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./couple_stress_zx]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_zx
    index_i = 2
    index_j = 0
  [../]
  [./couple_stress_zy]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_zy
    index_i = 2
    index_j = 1
  [../]
  [./couple_stress_zz]
    type = RankTwoAux
    rank_two_tensor = couple_stress
    variable = couple_stress_zz
    index_i = 2
    index_j = 2
  [../]
[]

[VectorPostprocessors]
  [./soln]
    type = LineValueSampler
    sort_by = x
    variable = &#x27;disp_x disp_y disp_z stress_xx stress_xy stress_xz stress_yx stress_yy stress_yz stress_zx stress_zy stress_zz wc_x wc_y wc_z couple_stress_xx couple_stress_xy couple_stress_xz couple_stress_yx couple_stress_yy couple_stress_yz couple_stress_zx couple_stress_zy couple_stress_zz&#x27;
    start_point = &#x27;0 0 0.5&#x27;
    end_point = &#x27;10 0 0.5&#x27;
    num_points = 11
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeLayeredCosseratElasticityTensor
    young = 1.2
    poisson = 0.3
    layer_thickness = 2.0
    joint_normal_stiffness = 1E16
    joint_shear_stiffness = 0.1
  [../]
  [./strain]
    type = ComputeCosseratSmallStrain
  [../]
  [./stress]
    type = ComputeCosseratLinearElasticStress
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -snes_atol -snes_rtol -snes_max_it -ksp_atol -ksp_rtol -ksp_max_it -sub_pc_factor_shift_type -pc_asm_overlap -ksp_gmres_restart&#x27;
    petsc_options_value = &#x27;gmres asm lu 1E-11 1E-11 10 1E-15 1E-10 100 NONZERO 2 100&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  num_steps = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = beam_cosserat_02_apply_stress
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f3110413-effd-4958-b420-b41604dcaee1"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/mesh_grow.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  geometric_cut_userobjects = &#x27;cut_mesh&#x27;
  output_cut_plane = true
  qrule = volfrac
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 5
  ny = 5
  nz = 5
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  zmin = -0.4
  zmax = 0.6
  elem_type = HEX8
[]

[UserObjects]
  [./cut_mesh]
    type = MeshCut3DUserObject
    mesh_file = mesh_grow.xda
    function_x = growth_func_x
    function_y = growth_func_y
    function_z = growth_func_z
# The current gold file does not grow the cutting mesh, but this is something
# that needs to be tested more in the future.
#    size_control = 0.05
#    n_step_growth = 50
  [../]
[]

[Functions]
  [./growth_func_x]
    type = ParsedFunction
    value = 5*(x-0.3)+z
  [../]
  [./growth_func_y]
    type = ParsedFunction
    value = 5*(y-0.5)+(z+x)/2
  [../]
  [./growth_func_z]
    type = ParsedFunction
    value = 5*(z-0.1)+x
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[Functions]
  [./top_trac_y]
    type = ConstantFunction
    value = 10
  [../]
[]


[BCs]
  [./top_y]
    type = FunctionNeumannBC
    boundary = top
    variable = disp_y
    function = top_trac_y
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = bottom
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    boundary = bottom
    variable = disp_z
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  file_base = mesh_grow
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7362e77d-6b5b-4c50-bc38-ef47edf96091"><div class="modal-content"><h4>test/tests/variables/previous_newton_iteration/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)+1
  [../]

  [./left_u_bc_fn]
    type = ParsedFunction
    value = -2*x
  [../]
  [./top_u_bc_fn]
    type = ParsedFunction
    value = 2*y
  [../]
  [./right_u_bc_fn]
    type = ParsedFunction
    value = 2*x
  [../]
  [./bottom_u_bc_fn]
    type = ParsedFunction
    value = -2*y
  [../]
[]

[AuxVariables]
  [./a]
    order = SECOND
  [../]
  [./v]
    order = SECOND
  [../]
[]

[AuxKernels]
  [./ak_a]
    type = QuotientAux
    variable = a
    numerator = v
    denominator = u
  [../]

  [./ak_v]
    type = FunctionAux
    variable = v
    function = v_fn
  [../]
[]

[Variables]
  [./u]
    order = SECOND
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    variable = u
    value = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = Diffusion
    variable = u
  [../]
  [./react]
    type = Reaction
    variable = u
  [../]
  [./cv_u]
    type = CoupledForceLagged
    variable = u
    v = v
  [../]
[]

[BCs]
  [./u_bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = left_u_bc_fn
  [../]

  [./u_bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = top_u_bc_fn
  [../]

  [./u_bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_u_bc_fn
  [../]

  [./u_bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bottom_u_bc_fn
  [../]
[]

[Preconditioning]
  [./pc]
    type = SMP
    full = true
    solve_type = PJFNK
  [../]
[]

[Executioner]
  type = Steady

  # to get multiple NL iterations
  l_tol = 1e-3
  nl_rel_tol = 1e-10
[]

[Outputs]
  [./out]
    type = Exodus
    execute_on = &#x27;nonlinear&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7c286c7f-8207-4a6c-984f-bdbc7f54a485"><div class="modal-content"><h4>test/tests/variables/fe_hermite/hermite-3-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX27
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 3*y*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -3*y*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]
  [./bc_fnk]
    type = ParsedFunction
    value = -3*z*z
  [../]
  [./bc_fnf]
    type = ParsedFunction
    value = 3*z*z
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x-6*y-6*z+(x*x*x)+(y*y*y)+(z*z*z)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (x*x*x)+(y*y*y)+(z*z*z)
    grad_x = 3*x*x
    grad_y = 3*y*y
    grad_z = 3*z*z
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
  [./bc_front]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;front&#x27;
    function = bc_fnf
  [../]
  [./bc_back]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;back&#x27;
    function = bc_fnk
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = NEWTON
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d8461157-60c4-4b89-8c5c-42ff7fa3d1c4"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_rz_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      rz
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in cylindrical coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with thermal conductivity
#   dependent upon the transient level set function. This problem can be
#   exactly evaluated by FEM/Moose without the moving interface. Both the
#   temperature and level set function are designed to be linear to attempt to
#   minimize the error between the Moose/exact solution and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=1, y=1) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time   Expected Temperature   XFEM Calculated Temperature
#      0.2                 440        440
#      0.4                 480        479.9998717
#      0.6                 520        519.9994963
#      0.8                 560        559.9989217
#      1.0                 600        599.9986735
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 1.0
  xmax = 2.0
  ymin = 1.0
  ymax = 2.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
    [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+400) + t*(-2.5*y/(2.04*x) + 155/x - t/(2.04*x)
            - 7.5/2.04)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.01/2.04)*(-2.5*x-2.5*y-t)+1.55)*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+200)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+200)*t+400&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.01/2.04)*(-2.5*x-2.5*y-t) + 1.55&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 2.04 -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f84c6d5f-7650-4981-92ec-74640dd1e8c0"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed linear level set function
# Description:
#   A simple transient heat transfer problem in Cartesian coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is a single, constant value at all points in the system.
# Results:
#   The temperature at the left boundary (x=0) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM results
#   at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0000064
#      0.6                  520         520.0000323
#      0.8                  560         560.0000896
#      1.0                  600         600.0001870
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+200)&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;1-(x-0.04)-0.2*t&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*200*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="70ac2811-0fd5-485e-a726-aa5270fdc496"><div class="modal-content"><h4>modules/porous_flow/examples/tidal/barometric_fully_confined.i</h4><pre class="moose-pre"><code class="language-text"># A fully-confined aquifer is fully saturated with water
# Barometric loading is applied to the aquifer.
# Because the aquifer is assumed to be sandwiched between
# impermeable aquitards, the barometric pressure is not felt
# directly by the porepressure.  Instead, the porepressure changes
# only because the barometric loading applies a total stress to
# the top surface of the aquifer.
#
# To replicate standard poroelasticity exactly:
# (1) the PorousFlowBasicTHM Action is used;
# (2) multiply_by_density = false;
# (3) PorousFlowConstantBiotModulus is used
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  zmin = 0
  zmax = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
  biot_coefficient = 0.6
  multiply_by_density = false
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0.0
    boundary = &#x27;left right&#x27;
  [../]
  [./fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0.0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./fix_z_bottom]
    type = DirichletBC
    variable = disp_z
    value = 0.0
    boundary = back
  [../]
  [./barometric_loading]
    type = FunctionNeumannBC
    variable = disp_z
    function = -1000.0 # atmospheric pressure increase of 1kPa
    boundary = front
  [../]
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2E9
    [../]
  [../]
[]

[PorousFlowBasicTHM]
  coupling_type = HydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    bulk_modulus = 10.0E9 # drained bulk modulus
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # only the initial value of this is ever used
    porosity = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    solid_bulk_compliance = 1E-10
    fluid_bulk_modulus = 2E9
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-12 0 0   0 1E-12 0   0 0 1E-12&#x27;
  [../]
[]

[Postprocessors]
  [./pp]
    type = PointValue
    point = &#x27;0.5 0.5 0.5&#x27;
    variable = porepressure
  [../]
[]


[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1
  end_time = 1
[]

[Outputs]
  console = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c16b5ee6-e46d-4488-be6b-f9b2f314936a"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_discrete2mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types:discrete homog 2 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description
#   A transient heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance in the presence of a moving interface separating two
#   discrete material regions for linear element models. Both the temperature
#   solution and level set function are designed to be linear to attempt to
#   minimize error between the exact solution and XFEM results. Thermal
#   conductivity, density, and heat capacity are homogeneous in each material
#   region with a discontinuous jump in thermal flux between the two material
#   regions.
# Results:
#   The temperature at the left boundary is determined by the analytical
#   solution, so temperature at the right boundary (x=1) should exhibit the
#   largest difference between the analytical solution and XFEM results. We
#   present the analytical and XFEM results at the material interface position
#   and right side boundary at various times.
#  Interface:
#     Time    Expected Temperature    XFEM Calculated Temperature
#       20       746.75                  746.7235521
#       40       893.05                  893.0379081
#       60      1040.15                 1040.1527530
#
#  Right Boundary (x=1):
#     Time    Expected Temperature    XFEM Calculated Temperature
#       20       720                     719.9708681
#       40       840                     839.9913293
#       60       960                     960.0100886
#
# IMPORTANT NOTE:
#   When running this input file, add the --allow-test-objects tag!!!
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = phi
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./phi]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = &#x27;diffusion_coefficient&#x27;
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = phi
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    jump_flux = jump_flux_func
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;phi:=(0.75-x-0.001*t);
        i:=(0.75-0.001*t);
        if (phi&gt;=0,
            10*(8-x),
            (7/(1-i))*((i-2)*x + (8-7*i)) )&#x27;
  [../]
  [./right_du_func]
    type = ParsedFunction
    value = &#x27;i:=(0.75-0.001*t);
        (2.0/(1-i))*(-5+5*i+i*t-2*t)&#x27;
  [../]
  [./exact_u_func]
    type = ParsedFunction
    value = &#x27;phi:=(0.75-x-0.001*t);
        i:=(0.75-0.001*t);
        if (phi&gt;=0,
            605 - 5*x + t*(8-x),
            (1/(1-i))*((-5+5*i+i*t-2*t)*x + (605-605*i+8*t-7*t*i)) )&#x27;
  [../]
  [./jump_flux_func]
    type = ParsedFunction
    value = &#x27;i:=(0.75-0.001*t);
        k_1:=(20.0);
        k_2:=(2.0);
        k_1*(5+t) + (k_2/(1-i))*(-5+5*i+i*t-2*t)&#x27;
  [../]

  [./ls_func]
    type = ParsedFunction
    value = &#x27;0.75 - x - 0.001*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;A_rhoCp B_rhoCp&#x27;
    prop_values = &#x27;10 7&#x27;
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;A_diffusion_coefficient B_diffusion_coefficient&#x27;
    prop_values = &#x27;20.0 2.0&#x27;
  [../]

  [./combined_rhoCp]
    type = LevelSetBiMaterialReal
    levelset_positive_base = &#x27;A&#x27;
    levelset_negative_base = &#x27;B&#x27;
    level_set_var = phi
    prop_name = rhoCp
  [../]
  [./combined_diffusion_coefficient]
    type = LevelSetBiMaterialReal
    levelset_positive_base = &#x27;A&#x27;
    levelset_negative_base = &#x27;B&#x27;
    level_set_var = phi
    prop_name = diffusion_coefficient
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    function = exact_u_func
  [../]
  [./right_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_du_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 600
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  # petsc_options_value = &#x27;hypre boomeramg&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 20
  end_time = 60.0
  max_xfem_update = 2
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="32f196f0-de28-4fa1-97dd-90d8944a958b"><div class="modal-content"><h4>test/tests/kernels/scalar_constraint/scalar_constraint_kernel_disp.i</h4><pre class="moose-pre"><code class="language-text">#
# This test is identical to scalar_constraint_kernel.i, but it everything is evaluated on the displaced mesh
#

[GlobalParams]
  use_displaced_mesh = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]

  [./bottom_bc_fn]
    type = ParsedFunction
    value = -2*y
  [../]

  [./right_bc_fn]
    type = ParsedFunction
    value =  2*x
  [../]

  [./top_bc_fn]
    type = ParsedFunction
    value =  2*y
  [../]

  [./left_bc_fn]
    type = ParsedFunction
    value = -2*x
  [../]
[]

[AuxVariables]
  [./disp_x]
    family = LAGRANGE
    order = SECOND
  [../]
  [./disp_y]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[AuxKernels]
  [./disp_x_ak]
    type = ConstantAux
    variable = disp_x
    value = 0
  [../]
  [./disp_y_ak]
    type = ConstantAux
    variable = disp_y
    value = 0
  [../]
[]

# NL

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]

  [./lambda]
    family = SCALAR
    order = FIRST
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffnk]
    type = BodyForce
    variable = u
    function = ffn
  [../]

  [./sk_lm]
    type = ScalarLagrangeMultiplier
    variable = u
    lambda = lambda
  [../]
[]

[ScalarKernels]
  [./constraint]
    type = AverageValueConstraint
    variable = lambda
    pp_name = pp
    value = 2.666666666666666
    # overrride the global setting, scalar kernels do not live on a mesh
    use_displaced_mesh = false
  [../]
[]

[BCs]
  [./bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;0&#x27;
    function = bottom_bc_fn
  [../]
  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;1&#x27;
    function = right_bc_fn
  [../]
  [./top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;2&#x27;
    function = top_bc_fn
  [../]
  [./left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;3&#x27;
    function = left_bc_fn
  [../]
[]

[Postprocessors]
  [./pp]
    type = ElementIntegralVariablePostprocessor
    variable = u
    execute_on = linear
  [../]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./pc]
    type = SMP
    full = true
    solve_type = &#x27;PJFNK&#x27;
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-14
  l_tol = 1e-7
[]

[Outputs]
  exodus = true
  hide = lambda
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="87c3891d-b2bf-4235-9906-46e869e56f2d"><div class="modal-content"><h4>test/tests/variables/fe_monomial_const/monomial-const-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 100
  ny = 100
  elem_type = QUAD4
[]

[Functions]
  [./bc_fn]
    type=ParsedFunction
    value=0
  [../]
  [./bc_fnt]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
#    type = ParsedFunction
#    value = 0
    type = MTPiecewiseConst2D
  [../]

  [./solution]
    type = MTPiecewiseConst2D
  [../]
[]

[Variables]
  [./u]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  # Note: MOOSE&#x27;s DirichletBCs do not work properly with shape functions that do not
  #       have DOFs at the element edges.  This test works because the solution
  #       has been designed to be zero at the boundary which is satisfied by the IC
  #       Ticket #1352
  active = &#x27;&#x27;
  [./bc_all]
    type=FunctionDirichletBC
    variable = u
    boundary = &#x27;top bottom left right&#x27;
    function = bc_fn
  [../]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1.e-10
  [./Adaptivity]

  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  csv = true
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0730f5a1-4534-4619-ac4e-fd9c126a27d0"><div class="modal-content"><h4>test/tests/bcs/function_neumann_bc/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 32
    ny = 32
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./exact_func]
    type = ParsedFunction
    value = x*x
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    value = 2
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionNeumannBC
    function = exact_func
    variable = u
    boundary = right
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = neumannbc_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7a6b4a03-4c2b-439f-817d-8ee73aa1c772"><div class="modal-content"><h4>test/tests/controls/time_periods/bcs/bcs_integrated.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = NeumannBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./right2]
    type = FunctionNeumannBC
    variable = u
    boundary = right
    function = (y*(t-1))+1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 20
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[Controls]
  [./period0]
    type = TimePeriod
    disable_objects = &#x27;BCs::right2&#x27;
    start_time = &#x27;0&#x27;
    end_time = &#x27;0.95&#x27;
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]

  [./period2]
    type = TimePeriod
    disable_objects = &#x27;BCs::right&#x27;
    start_time = &#x27;1&#x27;
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="16c8dd97-7157-4132-a1cc-e391b568275e"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-2-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX27
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 2*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -2*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -2*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 2*x
  [../]
  [./bc_fnf]
    type = ParsedFunction
    value = 2*z
  [../]
  [./bc_fnk]
    type = ParsedFunction
    value = -2*z
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6+x*x+y*y+z*z
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x+y*y+z*z
    grad_x = 2*x
    grad_y = 2*y
    grad_z = 2*z
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
  [./bc_front]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;front&#x27;
    function = bc_fnf
  [../]
  [./bc_back]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;back&#x27;
    function = bc_fnk
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-11

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4cde10c4-93d7-48d0-bb88-478221968ead"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_rz_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      rz
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in cylindrical coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is a single, constant value at all points in the system.
# Results:
#   The temperature at the left boundary (x=1) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM results
#   at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0008118
#      0.6                  520         520.0038529
#      0.8                  560         560.0089177
#      1.0                  600         600.0133344
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 1.0
  xmax = 2.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+400) + 200*1.5*t/x&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*200*t&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;2.04 - x - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cdfde1a2-780f-4aa1-b328-520f4e15a88a"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_xy_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      xy
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with thermal conductivity
#   dependent upon the transient level set function. This problem can be
#   exactly evaluated by FEM/Moose without the moving interface. Both the
#   temperature and level set function are designed to be linear to attempt to
#   minimize the error between the Moose/exact solution and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=0, y=0) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time   Expected Temperature   XFEM Calculated Temperature
#      0.2                 440        440
#      0.4                 480        479.9998738
#      0.6                 520        519.9995114
#      0.8                 560        559.9989360
#      1.0                 600        599.9983833
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+200)-(5*t/1.04)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.01/1.04)*(-2.5*x-2.5*y-t)+1.55)*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+100)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+100)*t+400&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.01/1.04)*(-2.5*x-2.5*y-t)+1.55&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 1.04 -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9c4e2378-f637-4591-ab5c-8a93c1fff2e6"><div class="modal-content"><h4>test/tests/bcs/ad_function_neumann_bc/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 32
    ny = 32
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./exact_func]
    type = ParsedFunction
    value = x*x
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = 2
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionNeumannBC
    function = x
    variable = u
    boundary = right
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = neumannbc_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="38378ed5-a2d5-4691-9e9a-c83d6c8907cd"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/elliptical_crack.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  file = quarter_sym.e
[]

[UserObjects]
  [./ellip_cut_uo]
    type = EllipseCutUserObject
    cut_data = &#x27;-0.5 -0.5 0
                -0.5 -0.1 0
                 0.1 -0.5 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[Functions]
  [./top_trac_z]
    type = ConstantFunction
    value = 10
  [../]
[]


[BCs]
  [./top_z]
    type = FunctionNeumannBC
    boundary = 2
    variable = disp_z
    function = top_trac_z
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = 1
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 1
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    boundary = 1
    variable = disp_z
    value = 0.0
  [../]
  [./sym_y]
    type = DirichletBC
    boundary = 3
    variable = disp_y
    value = 0.0
  [../]
  [./sym_x]
    type = DirichletBC
    boundary = 4
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  file_base = elliptical_crack_out
  exodus = true
  execute_on = timestep_end
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="eff9aae2-8ef5-465d-8620-fa3eb7b1a15e"><div class="modal-content"><h4>test/tests/outputs/debug/show_var_residual_norms_debug.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fnu]
    type = ParsedFunction
    value = -5.8*(x+y)+x*x*x-x+y*y*y-y
  [../]
  [./forcing_fnv]
    type = ParsedFunction
    value = -4
  [../]

  [./slnu]
    type = ParsedGradFunction
    value = x*x*x-x+y*y*y-y
    grad_x = 3*x*x-1
    grad_y = 3*y*y-1
  [../]
  [./slnv]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]

  #NeumannBC functions
  [./bc_fnut]
    type = ParsedFunction
    value = 3*y*y-1
  [../]
  [./bc_fnub]
    type = ParsedFunction
    value = -3*y*y+1
  [../]
  [./bc_fnul]
    type = ParsedFunction
    value = -3*x*x+1
  [../]
  [./bc_fnur]
    type = ParsedFunction
    value = 3*x*x-1
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff1 diff2 test1 forceu forcev react&#x27;
  [./diff1]
    type = Diffusion
    variable = u
  [../]
  [./test1]
    type = CoupledConvection
    variable = u
    velocity_vector = v
  [../]
  [./diff2]
    type = Diffusion
    variable = v
  [../]
  [./react]
    type = Reaction
    variable = u
  [../]

  [./forceu]
    type = BodyForce
    variable = u
    function = forcing_fnu
  [../]
  [./forcev]
    type = BodyForce
    variable = v
    function = forcing_fnv
  [../]

[]

[BCs]
  active = &#x27;bc_u_tb bc_v bc_ul bc_ur bc_ut bc_ub&#x27;
  [./bc_u]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_v]
    type = FunctionDirichletBC
    variable = v
    function = slnv
    boundary = &#x27;left right top bottom&#x27;
  [../]

  [./bc_u_lr]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_u_tb]
    type = CoupledKernelGradBC
    variable = u
    var2 = v
    vel = &#x27;0.1 0.1&#x27;
    boundary = &#x27;top bottom left right&#x27;
  [../]

  [./bc_ul]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnul
    boundary = &#x27;left&#x27;
  [../]
  [./bc_ur]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnur
    boundary = &#x27;right&#x27;
  [../]
  [./bc_ut]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnut
    boundary = &#x27;top&#x27;
  [../]
  [./bc_ub]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnub
    boundary = &#x27;bottom&#x27;
  [../]
[]

[Preconditioning]
  active = &#x27; &#x27;
  [./prec]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active=&#x27;L2u L2v&#x27;
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2u]
    type = ElementL2Error
    variable = u
    function = slnu
  [../]
  [./L2v]
    type = ElementL2Error
    variable = v
    function = slnv
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes&#x27;
  nl_rel_tol = 1e-15
  nl_abs_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="eb910a76-5925-4f6f-bf3e-3e19843297ab"><div class="modal-content"><h4>modules/porous_flow/examples/tidal/atm_tides.i</h4><pre class="moose-pre"><code class="language-text"># A 10m x 10m &quot;column&quot; of height 100m is subjected to cyclic pressure at its top
# Assumptions:
# the boundaries are impermeable, except the top boundary
# only vertical displacement is allowed
# the atmospheric pressure sets the total stress at the top of the model
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 10
  xmin = 0
  xmax = 10
  ymin = 0
  ymax = 10
  zmin = -100
  zmax = 0
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
  biot_coefficient = 0.6
  multiply_by_density = false
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
    scaling = 1E11
  [../]
[]

[ICs]
  [./porepressure]
    type = FunctionIC
    variable = porepressure
    function = &#x27;-10000*z&#x27;  # approximately correct
  [../]
[]

[Functions]
  [./ini_stress_zz]
    type = ParsedFunction
    value = &#x27;(25000 - 0.6*10000)*z&#x27; # remember this is effective stress
  [../]
  [./cyclic_porepressure]
    type = ParsedFunction
    value = &#x27;if(t&gt;0,5000 * sin(2 * pi * t / 3600.0 / 24.0),0)&#x27;
  [../]
  [./neg_cyclic_porepressure]
    type = ParsedFunction
    value = &#x27;-if(t&gt;0,5000 * sin(2 * pi * t / 3600.0 / 24.0),0)&#x27;
  [../]
[]

[BCs]
  # zmin is called &#x27;back&#x27;
  # zmax is called &#x27;front&#x27;
  # ymin is called &#x27;bottom&#x27;
  # ymax is called &#x27;top&#x27;
  # xmin is called &#x27;left&#x27;
  # xmax is called &#x27;right&#x27;
  [./no_x_disp]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;bottom top&#x27; # because of 1-element meshing, this fixes u_x=0 everywhere
  [../]
  [./no_y_disp]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27; # because of 1-element meshing, this fixes u_y=0 everywhere
  [../]
  [./no_z_disp_at_bottom]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = back
  [../]
  [./pp]
    type = FunctionDirichletBC
    variable = porepressure
    function = cyclic_porepressure
    boundary = front
  [../]
  [./total_stress_at_top]
    type = FunctionNeumannBC
    variable = disp_z
    function = neg_cyclic_porepressure
    boundary = front
  [../]
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.0
      bulk_modulus = 2E9
      viscosity = 1E-3
      density0 = 1000.0
    [../]
  [../]
[]

[PorousFlowBasicTHM]
  coupling_type = HydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  gravity = &#x27;0 0 -10&#x27;
  fp = the_simple_fluid
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    bulk_modulus = 10.0E9 # drained bulk modulus
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputeSmallStrain
    eigenstrain_names = ini_stress
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./ini_stress]
    type = ComputeEigenstrainFromInitialStress
    initial_stress = &#x27;0 0 0  0 0 0  0 0 ini_stress_zz&#x27;
    eigenstrain_name = ini_stress
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # only the initial value of this is ever used
    porosity = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    solid_bulk_compliance = 1E-10
    fluid_bulk_modulus = 2E9
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-12 0 0   0 1E-12 0   0 0 1E-14&#x27;
  [../]
  [./density]
    type = GenericConstantMaterial
    prop_names = density
    prop_values = 2500.0
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./uz0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = disp_z
  [../]
  [./p100]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 -100&#x27;
    variable = porepressure
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = -3600 # so postprocessors get recorded correctly at t=0
  dt = 3600
  end_time = 360000
  nl_abs_tol = 5E-7
  nl_rel_tol = 1E-10
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e67d7717-4ae3-4ce2-9220-96a58080a565"><div class="modal-content"><h4>test/tests/variables/fe_hermite_convergence/hermite_converge_periodic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 4
  ny = 4
  elem_type = QUAD4
  # This test will not work in parallel with DistributedMesh enabled
  # due to a bug in PeriodicBCs.
  parallel_type = replicated
[]

[Functions]
  [./bc_fn]
    type = ParsedGradFunction
    value = -sin(pi*x)*sin(pi*y)
    grad_x = -pi*cos(pi*x)*sin(pi*y)
    grad_y = -pi*sin(pi*x)*cos(pi*y)
  [../]
  [./bc_fnt]
    type = ParsedFunction
    value = -pi*sin(pi*x)*cos(pi*y)
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = pi*sin(pi*x)*cos(pi*y)
  [../]
  [./forcing_fn]
    type = ParsedFunction
    value = -2*pi*pi*sin(pi*x)*sin(pi*y)-sin(pi*x)*sin(pi*y)
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./reaction]
    type = Reaction
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      variable = u
      auto_direction= &#x27;x y&#x27;
    [../]
  [../]
  [./bc_top]
    type=FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type=FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]
  [./h]
    type = AverageElementSize
  [../]
  [./L2error]
    type = ElementL2Error
    variable = u
    function = bc_fn
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = bc_fn
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = bc_fn
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;

  # We use higher-order quadrature to ensure that the forcing function
  # is integrated accurately.
  [./Quadrature]
    order=ELEVENTH
  [../]
[]

[Adaptivity]
  steps = 2
  marker = uniform
  [./Markers]
    [./uniform]
      type = UniformMarker
      mark = refine
    [../]
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
  print_mesh_changed_info = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="be539fa7-26e2-47fd-8e64-9332d170e893"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/penny_crack_cfp.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 3
  ny = 3
  nz = 3
  xmin = -1.1
  xmax = 1.1
  ymin = -1.1
  ymax = 1.1
  zmin = -1.1
  zmax = 1.1
  elem_type = HEX8
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[UserObjects]
  [./circle_cut_uo]
    type = CircleCutUserObject
    cut_data = &#x27;0  0 0
                0 -0.5 0
                -0.5 0 0&#x27;
  [../]
[]

[AuxVariables]
  [./SED]
   order = CONSTANT
    family = MONOMIAL
  [../]
[]

[DomainIntegral]
  integrals = &#x27;KfromJIntegral&#x27;
  disp_x = disp_x
  disp_y = disp_y
  disp_z = disp_z
  crack_direction_method = CurvedCrackFront
  radius_inner = &#x27;0.3&#x27;
  radius_outer = &#x27;0.6&#x27;
  poissons_ratio = 0.3
  youngs_modulus = 207000
  block = 0
  crack_front_points_provider = circle_cut_uo
  number_points_from_provider = 10
  closed_loop = true
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
    block = 0
  [../]
[]

[Functions]
  [./top_trac_z]
    type = ConstantFunction
    value = 10
  [../]
[]


[BCs]
  [./top_z]
    type = FunctionNeumannBC
    boundary = front
    variable = disp_z
    function = top_trac_z
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = back
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = back
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    boundary = back
    variable = disp_z
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1e86e2e6-4462-4193-91f8-beb96e6bde20"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-1-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 5
  ny = 5

  elem_type = HEX8
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 1
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 1
  [../]
  [./bc_fnf]
    type = ParsedFunction
    value = 1
  [../]
  [./bc_fnk]
    type = ParsedFunction
    value = -1
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x+y+z
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x+y+z
    grad_x = 1
    grad_y = 1
    grad_z = 1
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
  [./bc_front]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;front&#x27;
    function = bc_fnf
  [../]
  [./bc_back]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;back&#x27;
    function = bc_fnk
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6c24671d-cb94-4b9b-a148-9431eee6b9ca"><div class="modal-content"><h4>modules/porous_flow/examples/tidal/atm_tides_open_hole.i</h4><pre class="moose-pre"><code class="language-text"># A 100m x 10m &quot;slab&quot; of height 100m is subjected to cyclic pressure at its top
# Assumptions:
# the boundaries are impermeable, except the top boundary
# only vertical displacement is allowed
# the atmospheric pressure sets the total stress at the top of the model
# at the slab left-hand side there is a borehole that taps into the base of the slab.
[Mesh]
  [./the_mesh]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 10
    ny = 1
    nz = 10
    xmin = 0
    xmax = 100
    ymin = -5
    ymax = 5
    zmin = -100
    zmax = 0
  [../]
  [./bh_back]
    type = ExtraNodesetGenerator
    coord = &#x27;0 -5 -100&#x27;
    input = the_mesh
    new_boundary = 11
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
  biot_coefficient = 0.6
  multiply_by_density = false
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
    scaling = 1E11
  [../]
[]

[ICs]
  [./porepressure]
    type = FunctionIC
    variable = porepressure
    function = &#x27;-10000*z&#x27;  # this is only approximately correct
  [../]
[]

[Functions]
  [./ini_stress_zz]
    type = ParsedFunction
    value = &#x27;(25000 - 0.6*10000)*z&#x27; # remember this is effective stress
  [../]
  [./cyclic_porepressure]
    type = ParsedFunction
    value = &#x27;if(t&gt;0,5000 * sin(2 * pi * t / 3600.0 / 24.0),0)&#x27;
  [../]
  [./cyclic_porepressure_at_depth]
    type = ParsedFunction
    value = &#x27;-10000*z + if(t&gt;0,5000 * sin(2 * pi * t / 3600.0 / 24.0),0)&#x27;
  [../]
  [./neg_cyclic_porepressure]
    type = ParsedFunction
    value = &#x27;-if(t&gt;0,5000 * sin(2 * pi * t / 3600.0 / 24.0),0)&#x27;
  [../]
[]

[BCs]
  # zmin is called &#x27;back&#x27;
  # zmax is called &#x27;front&#x27;
  # ymin is called &#x27;bottom&#x27;
  # ymax is called &#x27;top&#x27;
  # xmin is called &#x27;left&#x27;
  # xmax is called &#x27;right&#x27;
  [./no_x_disp]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;bottom top&#x27; # because of 1-element meshing, this fixes u_x=0 everywhere
  [../]
  [./no_y_disp]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27; # because of 1-element meshing, this fixes u_y=0 everywhere
  [../]
  [./no_z_disp_at_bottom]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = back
  [../]
  [./pp]
    type = FunctionDirichletBC
    variable = porepressure
    function = cyclic_porepressure
    boundary = front
  [../]
  [./pp_downhole]
    type = FunctionDirichletBC
    variable = porepressure
    function = cyclic_porepressure_at_depth
    boundary = 11
  [../]
  [./total_stress_at_top]
    type = FunctionNeumannBC
    variable = disp_z
    function = neg_cyclic_porepressure
    boundary = front
  [../]
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.0
      bulk_modulus = 2E9
      viscosity = 1E-3
      density0 = 1000.0
    [../]
  [../]
[]

[PorousFlowBasicTHM]
  coupling_type = HydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  gravity = &#x27;0 0 -10&#x27;
  fp = the_simple_fluid
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    bulk_modulus = 10.0E9 # drained bulk modulus
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputeSmallStrain
    eigenstrain_names = ini_stress
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./ini_stress]
    type = ComputeEigenstrainFromInitialStress
    initial_stress = &#x27;0 0 0  0 0 0  0 0 ini_stress_zz&#x27;
    eigenstrain_name = ini_stress
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # only the initial value of this is ever used
    porosity = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    solid_bulk_compliance = 1E-10
    fluid_bulk_modulus = 2E9
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-14 0 0   0 1E-14 0   0 0 1E-14&#x27;
  [../]
  [./density]
    type = GenericConstantMaterial
    prop_names = density
    prop_values = 2500.0
  [../]
[]

[Postprocessors]
  [./p0_0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./p100_0]
    type = PointValue
    outputs = csv
    point = &#x27;100 0 0&#x27;
    variable = porepressure
  [../]
  [./p0_100]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 -100&#x27;
    variable = porepressure
  [../]
  [./p100_100]
    type = PointValue
    outputs = csv
    point = &#x27;100 0 -100&#x27;
    variable = porepressure
  [../]
  [./uz0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = disp_z
  [../]
  [./uz100]
    type = PointValue
    outputs = csv
    point = &#x27;100 0 0&#x27;
    variable = disp_z
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = -3600
  dt = 3600
  end_time = 172800
  nl_rel_tol = 1E-10
  nl_abs_tol = 1E-5
[]

[Outputs]
  print_linear_residuals = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="597a7754-3a2d-440d-be01-1c83b5f9047e"><div class="modal-content"><h4>test/tests/time_integrators/actually_explicit_euler_verification/ee-1d-quadratic-neumann.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 10
  elem_type = EDGE3
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x*x-2*t+t*x*x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x*x
  [../]

  [./left_bc_fn]
    type = ParsedFunction
    value = -t*2*x
  [../]
  [./right_bc_fn]
    type = ParsedFunction
    value = t*2*x
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]
    type = Reaction
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;0&#x27;
    function = left_bc_fn
  [../]

  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;1&#x27;
    function = right_bc_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  l_tol = 1e-12
  start_time = 0.0
  num_steps = 10
  dt = 0.001

  [./TimeIntegrator]
    type = ActuallyExplicitEuler
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="82605f70-aeae-451e-bab6-d2ab9e3795a9"><div class="modal-content"><h4>test/tests/variables/fe_hermite/hermite-3-1d.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test demonstrating the use of the
# Hermite variable type.
#
# @Requirement F3.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
  elem_type = EDGE3
[]

[Functions]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x+(x*x*x)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x*x
    grad_x = 3*x*x
  [../]
[]

# Hermite Variable type
[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;NEWTON&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1abf6f12-27b6-458d-80f1-b7edeab35ac1"><div class="modal-content"><h4>test/tests/outputs/debug/show_var_residual_norms.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fnu]
    type = ParsedFunction
    value = -5.8*(x+y)+x*x*x-x+y*y*y-y
  [../]
  [./forcing_fnv]
    type = ParsedFunction
    value = -4
  [../]

  [./slnu]
    type = ParsedGradFunction
    value = x*x*x-x+y*y*y-y
    grad_x = 3*x*x-1
    grad_y = 3*y*y-1
  [../]
  [./slnv]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]

  #NeumannBC functions
  [./bc_fnut]
    type = ParsedFunction
    value = 3*y*y-1
  [../]
  [./bc_fnub]
    type = ParsedFunction
    value = -3*y*y+1
  [../]
  [./bc_fnul]
    type = ParsedFunction
    value = -3*x*x+1
  [../]
  [./bc_fnur]
    type = ParsedFunction
    value = 3*x*x-1
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff1 diff2 test1 forceu forcev react&#x27;
  [./diff1]
    type = Diffusion
    variable = u
  [../]
  [./test1]
    type = CoupledConvection
    variable = u
    velocity_vector = v
  [../]
  [./diff2]
    type = Diffusion
    variable = v
  [../]
  [./react]
    type = Reaction
    variable = u
  [../]

  [./forceu]
    type = BodyForce
    variable = u
    function = forcing_fnu
  [../]
  [./forcev]
    type = BodyForce
    variable = v
    function = forcing_fnv
  [../]

[]

[BCs]
  active = &#x27;bc_u_tb bc_v bc_ul bc_ur bc_ut bc_ub&#x27;
  [./bc_u]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_v]
    type = FunctionDirichletBC
    variable = v
    function = slnv
    boundary = &#x27;left right top bottom&#x27;
  [../]

  [./bc_u_lr]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_u_tb]
    type = CoupledKernelGradBC
    variable = u
    var2 = v
    vel = &#x27;0.1 0.1&#x27;
    boundary = &#x27;top bottom left right&#x27;
  [../]

  [./bc_ul]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnul
    boundary = &#x27;left&#x27;
  [../]
  [./bc_ur]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnur
    boundary = &#x27;right&#x27;
  [../]
  [./bc_ut]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnut
    boundary = &#x27;top&#x27;
  [../]
  [./bc_ub]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnub
    boundary = &#x27;bottom&#x27;
  [../]
[]

[Preconditioning]
  active = &#x27; &#x27;
  [./prec]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active=&#x27;L2u L2v&#x27;
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2u]
    type = ElementL2Error
    variable = u
    function = slnu
  [../]
  [./L2v]
    type = ElementL2Error
    variable = v
    function = slnv
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes&#x27;
  nl_rel_tol = 1e-15
  nl_abs_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  [./debug] # This is a test, use the [Debug] block to enable this
    type = VariableResidualNormsDebugOutput
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="94e3a435-a1c4-4810-9263-a7f7dbd8194b"><div class="modal-content"><h4>modules/combined/test/tests/poro_mechanics/unconsolidated_undrained.i</h4><pre class="moose-pre"><code class="language-text"># An unconsolidated-undrained test is performed.
# A sample&#x27;s boundaries are impermeable.  The sample is
# squeezed by a uniform mechanical pressure, and the
# rise in porepressure is observed.
#
# Expect:
# volumetricstrain = -MechanicalPressure/UndrainedBulk
# porepressure = SkemptonCoefficient*MechanicalPressure
# stress_zz = -MechanicalPresure + BiotCoefficient*porepressure
#
# Parameters:
# Biot coefficient = 0.3
# Porosity = 0.1
# Bulk modulus = 2
# Shear modulus = 1.5
# fluid bulk modulus = 1/0.3 = 3.333333
# 1/Biot modulus = (1 - 0.3)*(0.3 - 0.1)/2 + 0.1*0.3 = 0.1. BiotModulus = 10
# Undrained Bulk modulus = 2 + 0.3^2*10 = 2.9
# Skempton coefficient = 0.3*10/2.9 = 1.034483
#
# The mechanical pressure is applied using Neumann BCs,
# since the Neumann BCs are setting stressTOTAL.
#
# MechanicalPressure = 0.1*t  (ie, totalstress_zz = total_stress_xx = totalstress_yy = -0.1*t)
#
# Expect:
# disp_z = volumetricstrain/3 = -MechanicalPressure/3/2.9 = -0.1149*0.1*t
# prorepressure = 1.034483*0.1*t
# stress_zz = -0.1*t + 0.3*1.034483*0.1*t = -0.68966*0.1*t


[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./pressure_x]
    type = FunctionNeumannBC
    variable = disp_x
    function = -0.1*t
    boundary = &#x27;right&#x27;
  [../]
  [./pressure_y]
    type = FunctionNeumannBC
    variable = disp_y
    function = -0.1*t
    boundary = &#x27;top&#x27;
  [../]
  [./pressure_z]
    type = FunctionNeumannBC
    variable = disp_z
    function = -0.1*t
    boundary = &#x27;front&#x27;
  [../]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  [../]
[]


[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PoroMechanicsCoupling
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PoroMechanicsCoupling
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PoroMechanicsCoupling
    variable = disp_z
    component = 2
  [../]
  [./poro_timederiv]
    type = PoroFullSatTimeDerivative
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]



[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./poro_material]
    type = PoroFullSatMaterial
    porosity0 = 0.1
    biot_coefficient = 0.3
    solid_bulk_compliance = 0.5
    fluid_bulk_compliance = 0.3
    constant_porosity = true
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]

[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = unconsolidated_undrained
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f012eb30-fffd-444b-94d1-dae2628ba132"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-3-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX27
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 3*y*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -3*y*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]
  [./bc_fnk]
    type = ParsedFunction
    value = -3*z*z
  [../]
  [./bc_fnf]
    type = ParsedFunction
    value = 3*z*z
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x-6*y-6*z+(x*x*x)+(y*y*y)+(z*z*z)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (x*x*x)+(y*y*y)+(z*z*z)
    grad_x = 3*x*x
    grad_y = 3*y*y
    grad_z = 3*z*z
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
  [./bc_front]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;front&#x27;
    function = bc_fnf
  [../]
  [./bc_back]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;back&#x27;
    function = bc_fnk
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="97071600-73a9-4fc4-962c-89cb3318a15e"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-2-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 2*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -2*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -2*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 2*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+x*x+y*y
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="374bd681-d694-48b6-a613-abc0d2d32037"><div class="modal-content"><h4>test/tests/functions/parsed/mms_transient_coupled.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test of the Function System. This
# test uses forcing terms produced from analytical
# functions of space and time to verify a solution
# using MMS.
#
# @Requirement F6.20
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 1.0
  nx = 10
  ymin = 0.0
  ymax = 1.0
  ny = 10
  uniform_refine = 2
  elem_type = QUAD4
[]

[Variables]
  [./u]
  [../]
  [./v]
  [../]
[]

[Functions]
  [./v_left_bc]
    # Left-side boundary condition for v equation, v(0,y,t) = u(0.5,y,t). This is accomplished using a PointValue postprocessor, which is what this input file was designed to test.
    type = ParsedFunction
    value = a
    vals = u_midpoint
    vars = a
  [../]
  [./u_mms_func]
    # MMS Forcing function for the u equation.
    type = ParsedFunction
    value = &#x27; 20*exp(20*t)*x*x*x-6*exp(20*t)*x-(2-0.125*exp(20*t))*sin(5/2*x*pi)-0.125*exp(20*t)-1
&#x27;
  [../]
  [./v_mms_func]
    # MMS forcing function for the v equation.
    type = ParsedFunction
    value = -2.5*exp(20*t)*sin(5/2*x*pi)+2.5*exp(20*t)+25/4*(2-0.125*exp(20*t))*sin(5/2*x*pi)*pi*pi
  [../]
  [./u_right_bc]
    type = ParsedFunction
    value = 3*exp(20*t) # \nabla{u}|_{x=1} = 3\exp(20*t)
  [../]
  [./u_exact]
    # Exact solution for the MMS function for the u variable.
    type = ParsedFunction
    value = exp(20*t)*pow(x,3)+1
  [../]
  [./v_exact]
    # Exact MMS solution for v.
    type = ParsedFunction
    value = (2-0.125*exp(20*t))*sin(5/2*pi*x)+0.125*exp(20*t)+1
  [../]
[]

[Kernels]
  # Strong Form:
  # \frac{\partial u}{\partial t} - \nabla \cdot 0.5 \nabla u - v = 0
  # \frac{\partial u}{\partial t} - \nabla \cdot \nabla v = 0
  #
  # BCs:
  # u(0,y,t) = 1
  # \nabla u |_{x=1} = 3\exp(20*t)
  # v(0,y,t) = u(0.5,y,t)
  # v(1,y,t) = 3
  # \nabla u |_{y=0,1} = 0
  # \nabla v |_{y=0,1} = 0
  #
  [./u_time]
    type = TimeDerivative
    variable = u
  [../]
  [./u_diff]
    type = Diffusion
    variable = u
  [../]
  [./u_source]
    type = CoupledForce
    variable = u
    v = v
  [../]
  [./v_diff]
    type = Diffusion
    variable = v
  [../]
  [./u_mms]
    type = BodyForce
    variable = u
    function = u_mms_func
  [../]
  [./v_mms]
    type = BodyForce
    variable = v
    function = v_mms_func
  [../]
  [./v_time]
    type = TimeDerivative
    variable = v
  [../]
[]

[BCs]
  [./u_left]
    type = DirichletBC
    variable = u
    boundary = left # x=0
    value = 1 # u(0,y,t)=1
  [../]
  [./u_right]
    type = FunctionNeumannBC
    variable = u
    boundary = right # x=1
    function = u_right_bc # \nabla{u}|_{x=1}=3\exp(20t)
  [../]
  [./v_left]
    type = FunctionDirichletBC
    variable = v
    boundary = left # x=0
    function = v_left_bc # v(0,y,t) = u(0.5,y,t)
  [../]
  [./v_right]
    type = DirichletBC
    variable = v
    boundary = right # x=1
    value = 3 # v(1,y,t) = 3
  [../]
[]

[Postprocessors]
  [./u_midpoint]
    type = PointValue
    variable = u
    point = &#x27;0.5 0.5 0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./u_midpoint_exact]
    type = FunctionValuePostprocessor
    function = u_exact
    point = &#x27;0.5 0.5 0.0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./u_error]
    type = ElementL2Error
    variable = u
    function = u_exact
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./v_error]
    type = ElementL2Error
    variable = v
    function = v_exact
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.01

  solve_type = NEWTON

  end_time = 0.1
  scheme = crank-nicolson
[]

[Outputs]
  exodus = true
[]

[ICs]
  [./u_initial]
    # Use the MMS exact solution to compute the initial conditions.
    function = u_exact
    variable = u
    type = FunctionIC
  [../]
  [./v_exact]
    # Use the MMS exact solution to compute the initial condition.
    function = v_exact
    variable = v
    type = FunctionIC
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="755b54c4-c290-4246-a1df-db95ead73579"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-3-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 3*y*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -3*y*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x-6*y+(x*x*x)+(y*y*y)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (x*x*x)+(y*y*y)
    grad_x = 3*x*x
    grad_y = 3*y*y
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="77c57794-eeba-4c20-8c0a-b41f9ad3be5c"><div class="modal-content"><h4>test/tests/time_integrators/explicit-euler/ee-1d-quadratic-neumann.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  implicit = false
[]

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 10
  elem_type = EDGE3
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x*x-2*t+t*x*x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x*x
  [../]

  [./left_bc_fn]
    type = ParsedFunction
    value = -t*2*x
  [../]
  [./right_bc_fn]
    type = ParsedFunction
    value = t*2*x
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]
    type = Reaction
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;0&#x27;
    function = left_bc_fn
  [../]

  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;1&#x27;
    function = right_bc_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;explicit-euler&#x27;
  solve_type = &#x27;LINEAR&#x27;

  l_tol = 1e-12
  start_time = 0.0
  num_steps = 10
  dt = 0.001
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#b833cfa9-aaee-43d8-92de-d347f55c35f0" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#e9fe1578-0eff-4ed2-84c8-c27c27bc7233" class="tooltipped" data-position="left" data-tooltip="Example Input Syntax">Example Input Syntax</a></li><li><a href="#08571cd8-0c0a-4f4d-8e1c-3405a863a6fe" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#d8d292a6-cc80-4b6c-887b-ba5cd0d6a9d6" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>