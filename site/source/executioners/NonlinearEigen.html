<!DOCTYPE html><head><meta charset="UTF-8"><title>NonlinearEigen.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="081d3718-d5fa-4b6d-b9c3-6096e0e5928e"><i class="material-icons">menu</i></a><ul class="sidenav" id="081d3718-d5fa-4b6d-b9c3-6096e0e5928e"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">executioners</span><a href="#" class="breadcrumb">NonlinearEigen</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="97f7f08e-b419-4fa3-96d2-8e76781f3516" data-section-level="1" data-section-text="NonlinearEigen"><h1 id="nonlineareigen">NonlinearEigen</h1><p>Executioner for Eigen value problems.</p><section class="scrollspy" id="258c7394-c4ac-42f9-ad65-2f19fc67fc8f" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>Eigenvalue executioners such as this one intend on solving the eigenvalue problem described by:</p><span class="moose-katex-block-equation"><span tex="Ax = \frac{1}{k}Bx," bookmark="moose-equation-1e9b8eaf-f391-4e77-af14-e7d1943214da" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-1e9b8eaf-f391-4e77-af14-e7d1943214da"></span><script>var element = document.getElementById("moose-equation-1e9b8eaf-f391-4e77-af14-e7d1943214da");katex.render("Ax = \\frac{1}{k}Bx,", element, {displayMode:true,throwOnError:false});</script></span><p>where <span tex="A" bookmark="moose-equation-ee03b05f-5a9d-46fe-8acf-e0963cdbf39d" recursive="True" class="moose-katex-inline-equation" id="moose-equation-ee03b05f-5a9d-46fe-8acf-e0963cdbf39d"><script>var element = document.getElementById("moose-equation-ee03b05f-5a9d-46fe-8acf-e0963cdbf39d");katex.render("A", element, {displayMode:false,throwOnError:false});</script></span> and <span tex="B" bookmark="moose-equation-eedd338d-afde-4725-93a2-3e06d274078f" recursive="True" class="moose-katex-inline-equation" id="moose-equation-eedd338d-afde-4725-93a2-3e06d274078f"><script>var element = document.getElementById("moose-equation-eedd338d-afde-4725-93a2-3e06d274078f");katex.render("B", element, {displayMode:false,throwOnError:false});</script></span> are linear or nonlinear operators represented by kernels. To differentiate the <span tex="B" bookmark="moose-equation-46c156ef-5a54-4d1e-b3b8-ae8d2d42a7a9" recursive="True" class="moose-katex-inline-equation" id="moose-equation-46c156ef-5a54-4d1e-b3b8-ae8d2d42a7a9"><script>var element = document.getElementById("moose-equation-46c156ef-5a54-4d1e-b3b8-ae8d2d42a7a9");katex.render("B", element, {displayMode:false,throwOnError:false});</script></span> kernels from the <span tex="A" bookmark="moose-equation-70c8d096-715c-4718-b162-126952679f8d" recursive="True" class="moose-katex-inline-equation" id="moose-equation-70c8d096-715c-4718-b162-126952679f8d"><script>var element = document.getElementById("moose-equation-70c8d096-715c-4718-b162-126952679f8d");katex.render("A", element, {displayMode:false,throwOnError:false});</script></span> kernels, we must derive all <span tex="B" bookmark="moose-equation-6bfe0477-800d-425c-b4d5-0a96ccb3f705" recursive="True" class="moose-katex-inline-equation" id="moose-equation-6bfe0477-800d-425c-b4d5-0a96ccb3f705"><script>var element = document.getElementById("moose-equation-6bfe0477-800d-425c-b4d5-0a96ccb3f705");katex.render("B", element, {displayMode:false,throwOnError:false});</script></span> kernels from <code>EigenKernel</code>. Currently we are only interested in the absolute minimum eigenvalue  <span tex="\frac{1}{k}" bookmark="moose-equation-b8545895-e9a0-489c-915e-2413e455892b" recursive="True" class="moose-katex-inline-equation" id="moose-equation-b8545895-e9a0-489c-915e-2413e455892b"><script>var element = document.getElementById("moose-equation-b8545895-e9a0-489c-915e-2413e455892b");katex.render("\\frac{1}{k}", element, {displayMode:false,throwOnError:false});</script></span> and the corresponding eigenvector <span tex="x" bookmark="moose-equation-32d2916b-2699-4a27-87a6-23a5a4cde563" recursive="True" class="moose-katex-inline-equation" id="moose-equation-32d2916b-2699-4a27-87a6-23a5a4cde563"><script>var element = document.getElementById("moose-equation-32d2916b-2699-4a27-87a6-23a5a4cde563");katex.render("x", element, {displayMode:false,throwOnError:false});</script></span> of the system. We are also not seeking the solutions of a general nonlinear eigenvalue problem, where the operators have nonlinear dependency on the eigenvalue.</p></section><section class="scrollspy" id="20fe295c-1d18-4e0b-b0f2-b4add0a74971" data-section-level="2" data-section-text="The nonlinear Newton method"><h2 id="the-nonlinear-newton-method">The nonlinear Newton method</h2><p>From the above section, we can see the eigenvalue problem can be viewed as a nonlinear problem</p><span class="moose-katex-block-equation"><span tex="\begin{aligned} &Ax = \frac{1}{k}Bx, \\ &k = |Bx|, \end{aligned}" bookmark="moose-equation-d7b8b376-e7d7-4f42-8c7d-02d7694e5d92" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-d7b8b376-e7d7-4f42-8c7d-02d7694e5d92"></span><script>var element = document.getElementById("moose-equation-d7b8b376-e7d7-4f42-8c7d-02d7694e5d92");katex.render("\\begin{aligned} &Ax = \\frac{1}{k}Bx, \\\\ &k = |Bx|, \\end{aligned}", element, {displayMode:true,throwOnError:false});</script></span><p>so we can use the Newton method to solve it. However, to make the solving converge, we need to have a fairly close initial guess to the fundamental mode. This can be achieved with several free power iterations before the Newton iteration. We do not have to have <span tex="k" bookmark="moose-equation-266b1397-9fc9-4969-a97b-74f18ea8677d" recursive="True" class="moose-katex-inline-equation" id="moose-equation-266b1397-9fc9-4969-a97b-74f18ea8677d"><script>var element = document.getElementById("moose-equation-266b1397-9fc9-4969-a97b-74f18ea8677d");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span> as part of the solution vector. Instead we can apply the elimination technique and view the equation as</p><span class="moose-katex-block-equation"><span tex="Ax = \frac{Bx}{|Bx|}." bookmark="moose-equation-16dc3c02-8a0d-4b87-af82-b283198415c4" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-16dc3c02-8a0d-4b87-af82-b283198415c4"></span><script>var element = document.getElementById("moose-equation-16dc3c02-8a0d-4b87-af82-b283198415c4");katex.render("Ax = \\frac{Bx}{|Bx|}.", element, {displayMode:true,throwOnError:false});</script></span><p>Again we can use PJFNK (preconditioned Jacobian-free Newton Krylov) method to solve this nonlinear problem. The preconditioning matrix can affect the linear convergence in each Newton iteration. If there is a convergence issue, it is suggested to use <span tex="A-\frac{B}{|Bx|}" bookmark="moose-equation-1e76a85d-d094-4e14-9a56-6d62e4a22afa" recursive="True" class="moose-katex-inline-equation" id="moose-equation-1e76a85d-d094-4e14-9a56-6d62e4a22afa"><script>var element = document.getElementById("moose-equation-1e76a85d-d094-4e14-9a56-6d62e4a22afa");katex.render("A-\\frac{B}{|Bx|}", element, {displayMode:false,throwOnError:false});</script></span> and gradually reduce its complexity as the preconditioning matrix.</p></section><section class="scrollspy" id="fe886b3a-2ee0-4b10-9b9a-32db624d9c00" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="f549b22f-a255-448c-895a-35baf4024be5" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">bx_norm</span><span class="moose-parameter-header-description">To evaluate |Bx| for the eigenvalue</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>PostprocessorName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>To evaluate |Bx| for the eigenvalue</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="bf8ef19c-84bc-4ae9-b8bf-c015bba1da88" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">auto_advance</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether to automatically advance sub-applications regardless of whether their solve converges.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether to automatically advance sub-applications regardless of whether their solve converges.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">contact_line_search_allowed_lambda_cuts</span><span class="moose-parameter-header-default">2</span><span class="moose-parameter-header-description">The number of times lambda is allowed to be cut in half in the contact line search. We recommend this number be roughly bounded by 0 <= allowed_lambda_cuts <= 3</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>2</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The number of times lambda is allowed to be cut in half in the contact line search. We recommend this number be roughly bounded by 0 <= allowed_lambda_cuts <= 3</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">contact_line_search_ltol</span><span class="moose-parameter-header-description">The linear relative tolerance to be used while the contact state is changing between non-linear iterations. We recommend that this tolerance be looser than the standard linear tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The linear relative tolerance to be used while the contact state is changing between non-linear iterations. We recommend that this tolerance be looser than the standard linear tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">custom_abs_tol</span><span class="moose-parameter-header-default">1e-50</span><span class="moose-parameter-header-description">The absolute nonlinear residual to shoot for during Picard iterations.  This check is performed based on postprocessor defined by picard_custom_pp residual.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-50</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The absolute nonlinear residual to shoot for during Picard iterations.  This check is performed based on postprocessor defined by picard_custom_pp residual.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">custom_rel_tol</span><span class="moose-parameter-header-default">1e-08</span><span class="moose-parameter-header-description">The relative nonlinear residual drop to shoot for during Picard iterations.  This check is performed based on postprocessor defined by picard_custom_pp residual.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-08</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The relative nonlinear residual drop to shoot for during Picard iterations.  This check is performed based on postprocessor defined by picard_custom_pp residual.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">direct_pp_value</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">True to use direct postprocessor value (scaled by value on first iteration). False (default) to use difference in postprocessor value between picard iterations.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>True to use direct postprocessor value (scaled by value on first iteration). False (default) to use difference in postprocessor value between picard iterations.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">free_l_tol</span><span class="moose-parameter-header-default">0.01</span><span class="moose-parameter-header-description">Relative linear tolerance in free power iteration</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0.01</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Relative linear tolerance in free power iteration</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">free_power_iterations</span><span class="moose-parameter-header-default">4</span><span class="moose-parameter-header-description">The number of free power iterations</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>4</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The number of free power iterations</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">k0</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Initial guess of the eigenvalue</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Initial guess of the eigenvalue</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">line_search</span><span class="moose-parameter-header-default">default</span><span class="moose-parameter-header-description">Specifies the line search type (Note: none = basic)</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>default</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>basic bt contact cp default l2 none project shell</p><p class="moose-parameter-description"><span>Description:</span>Specifies the line search type (Note: none = basic)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">line_search_package</span><span class="moose-parameter-header-default">petsc</span><span class="moose-parameter-header-description">The solver package to use to conduct the line-search</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>petsc</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>petsc moose</p><p class="moose-parameter-description"><span>Description:</span>The solver package to use to conduct the line-search</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_xfem_update</span><span class="moose-parameter-header-default">4294967295</span><span class="moose-parameter-header-description">Maximum number of times to update XFEM crack topology in a step due to evolving cracks</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>4294967295</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Maximum number of times to update XFEM crack topology in a step due to evolving cracks</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">mffd_type</span><span class="moose-parameter-header-default">wp</span><span class="moose-parameter-header-description">Specifies the finite differencing type for Jacobian-free solve types. Note that the default is wp (for Walker and Pernice).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>wp</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>wp ds</p><p class="moose-parameter-description"><span>Description:</span>Specifies the finite differencing type for Jacobian-free solve types. Note that the default is wp (for Walker and Pernice).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nl_div_tol</span><span class="moose-parameter-header-default">1e+10</span><span class="moose-parameter-header-description">Nonlinear Divergence Tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e+10</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Nonlinear Divergence Tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">output_after_power_iterations</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">True to output solution after free power iterations</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>True to output solution after free power iterations</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">petsc_options</span><span class="moose-parameter-header-description">Singleton PETSc options</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>-dm_moose_print_embedding -dm_view -ksp_converged_reason -ksp_gmres_modifiedgramschmidt -ksp_monitor -ksp_monitor_snes_lg-snes_ksp_ew -ksp_snes_ew -snes_converged_reason -snes_ksp -snes_ksp_ew -snes_linesearch_monitor -snes_mf -snes_mf_operator -snes_monitor -snes_test_display -snes_view</p><p class="moose-parameter-description"><span>Description:</span>Singleton PETSc options</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">petsc_options_iname</span><span class="moose-parameter-header-description">Names of PETSc name/value pairs</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>-ksp_atol -ksp_gmres_restart -ksp_max_it -ksp_pc_side -ksp_rtol -ksp_type -mat_fd_coloring_err -mat_fd_type -mat_mffd_type -pc_asm_overlap -pc_factor_levels -pc_factor_mat_ordering_type -pc_hypre_boomeramg_grid_sweeps_all -pc_hypre_boomeramg_max_iter -pc_hypre_boomeramg_strong_threshold -pc_hypre_type -pc_type -snes_atol -snes_linesearch_type -snes_ls -snes_max_it -snes_rtol -snes_divergence_tolerance -snes_type -sub_ksp_type -sub_pc_type</p><p class="moose-parameter-description"><span>Description:</span>Names of PETSc name/value pairs</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">petsc_options_value</span><span class="moose-parameter-header-description">Values of PETSc name/value pairs (must correspond with "petsc_options_iname"</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Values of PETSc name/value pairs (must correspond with "petsc_options_iname"</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">resid_vs_jac_scaling_param</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">A parameter that indicates the weighting of the residual vs the Jacobian in determining variable scaling parameters. A value of 1 indicates pure residual-based scaling. A value of 0 indicates pure Jacobian-based scaling</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>A parameter that indicates the weighting of the residual vs the Jacobian in determining variable scaling parameters. A value of 1 indicates pure residual-based scaling. A value of 0 indicates pure Jacobian-based scaling</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">scaling_group_variables</span><span class="moose-parameter-header-description">Name of variables that are grouped together to for determing scale factors. (Multiple groups can be provided, separated by semicolon)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::vector<std::string>></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Name of variables that are grouped together to for determing scale factors. (Multiple groups can be provided, separated by semicolon)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">skip_exception_check</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Specifies whether or not to skip exception check</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Specifies whether or not to skip exception check</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">solve_type</span><span class="moose-parameter-header-description">PJFNK: Preconditioned Jacobian-Free Newton Krylov JFNK: Jacobian-Free Newton Krylov NEWTON: Full Newton Solve FD: Use finite differences to compute Jacobian LINEAR: Solving a linear problem</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>PJFNK JFNK NEWTON FD LINEAR</p><p class="moose-parameter-description"><span>Description:</span>PJFNK: Preconditioned Jacobian-Free Newton Krylov JFNK: Jacobian-Free Newton Krylov NEWTON: Full Newton Solve FD: Use finite differences to compute Jacobian LINEAR: Solving a linear problem</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">splitting</span><span class="moose-parameter-header-description">Top-level splitting defining a hierarchical decomposition into subsystems to help the solver.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Top-level splitting defining a hierarchical decomposition into subsystems to help the solver.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">update_xfem_at_timestep_begin</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Should XFEM update the mesh at the beginning of the timestep</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Should XFEM update the mesh at the beginning of the timestep</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">verbose</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Set to true to print additional information</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set to true to print additional information</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="6fda5c80-7be3-4f0e-8a53-1aaeb5f829fc" data-section-level="3" data-section-text="Picard Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">accept_on_max_picard_iteration</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">True to treat reaching the maximum number of Picard iterations as converged.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>True to treat reaching the maximum number of Picard iterations as converged.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">disable_picard_residual_norm_check</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Disable the Picard residual norm evaluation thus the three parameters picard_rel_tol, picard_abs_tol and picard_force_norms.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Disable the Picard residual norm evaluation thus the three parameters picard_rel_tol, picard_abs_tol and picard_force_norms.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">picard_abs_tol</span><span class="moose-parameter-header-default">1e-50</span><span class="moose-parameter-header-description">The absolute nonlinear residual to shoot for during Picard iterations.  This check is performed based on the Master app's nonlinear residual.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-50</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The absolute nonlinear residual to shoot for during Picard iterations.  This check is performed based on the Master app's nonlinear residual.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">picard_custom_pp</span><span class="moose-parameter-header-description">Postprocessor for custom picard convergence check.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>PostprocessorName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Postprocessor for custom picard convergence check.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">picard_force_norms</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Force the evaluation of both the TIMESTEP_BEGIN and TIMESTEP_END norms regardless of the existance of active MultiApps with those execute_on flags, default: false.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Force the evaluation of both the TIMESTEP_BEGIN and TIMESTEP_END norms regardless of the existance of active MultiApps with those execute_on flags, default: false.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">picard_max_its</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Specifies the maximum number of Picard iterations.  Mainly used when wanting to do Picard iterations with MultiApps that are set to execute_on timestep_end or timestep_begin. Setting this parameter to 1 turns off the Picard iterations.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Specifies the maximum number of Picard iterations.  Mainly used when wanting to do Picard iterations with MultiApps that are set to execute_on timestep_end or timestep_begin. Setting this parameter to 1 turns off the Picard iterations.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">picard_rel_tol</span><span class="moose-parameter-header-default">1e-08</span><span class="moose-parameter-header-description">The relative nonlinear residual drop to shoot for during Picard iterations.  This check is performed based on the Master app's nonlinear residual.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-08</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The relative nonlinear residual drop to shoot for during Picard iterations.  This check is performed based on the Master app's nonlinear residual.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">relaxation_factor</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Fraction of newly computed value to keep.Set between 0 and 2.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Fraction of newly computed value to keep.Set between 0 and 2.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">relaxed_variables</span><span class="moose-parameter-header-description">List of variables to relax during Picard Iteration</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>List of variables to relax during Picard Iteration</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Picard Parameters</h3></summary></details></section><section id="eedad2be-81bf-4899-a866-412f199b9686" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">auto_initialization</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">True to ask the solver to set initial</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>True to ask the solver to set initial</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">time</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">System time</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>System time</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="96b4cb78-5af2-4a27-a729-9e08f04101ab" data-section-level="3" data-section-text="Solver Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">automatic_scaling</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether to use automatic scaling for the variables.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether to use automatic scaling for the variables.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute_initial_residual_before_preset_bcs</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Use the residual norm computed *before* preset BCs are imposed in relative convergence check</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Use the residual norm computed *before* preset BCs are imposed in relative convergence check</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute_scaling_once</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether the scaling factors should only be computed once at the beginning of the simulation through an extra Jacobian evaluation. If this is set to false, then the scaling factors will be computed during an extra Jacobian evaluation at the beginning of every time step.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether the scaling factors should only be computed once at the beginning of the simulation through an extra Jacobian evaluation. If this is set to false, then the scaling factors will be computed during an extra Jacobian evaluation at the beginning of every time step.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">l_abs_tol</span><span class="moose-parameter-header-default">1e-50</span><span class="moose-parameter-header-description">Linear Absolute Tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-50</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Linear Absolute Tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">l_max_its</span><span class="moose-parameter-header-default">10000</span><span class="moose-parameter-header-description">Max Linear Iterations</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>10000</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Max Linear Iterations</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">l_tol</span><span class="moose-parameter-header-default">0.01</span><span class="moose-parameter-header-description">Linear Tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0.01</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Linear Tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nl_abs_step_tol</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Nonlinear Absolute step Tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Nonlinear Absolute step Tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nl_abs_tol</span><span class="moose-parameter-header-default">1e-06</span><span class="moose-parameter-header-description">Nonlinear Absolute Tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-06</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Nonlinear Absolute Tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nl_max_funcs</span><span class="moose-parameter-header-default">10000</span><span class="moose-parameter-header-description">Max Nonlinear solver function evaluations</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>10000</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Max Nonlinear solver function evaluations</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nl_max_its</span><span class="moose-parameter-header-default">50</span><span class="moose-parameter-header-description">Max Nonlinear Iterations</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>50</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Max Nonlinear Iterations</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nl_rel_step_tol</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Nonlinear Relative step Tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Nonlinear Relative step Tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">nl_rel_tol</span><span class="moose-parameter-header-default">1e-50</span><span class="moose-parameter-header-description">Nonlinear Relative Tolerance</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1e-50</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Nonlinear Relative Tolerance</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">num_grids</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">The number of grids to use for a grid sequencing algorithm. This includes the final grid, so num_grids = 1 indicates just one solve in a time-step</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The number of grids to use for a grid sequencing algorithm. This includes the final grid, so num_grids = 1 indicates just one solve in a time-step</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">snesmf_reuse_base</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Specifies whether or not to reuse the base vector for matrix-free calculation</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Specifies whether or not to reuse the base vector for matrix-free calculation</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Solver Parameters</h3></summary></details></section><section id="14b03a9f-609c-4115-a28f-62a7c9cd4230" data-section-level="3" data-section-text="Normalization Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">normal_factor</span><span class="moose-parameter-header-description">Normalize x to make |x| equal to this factor</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Normalize x to make |x| equal to this factor</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">normalization</span><span class="moose-parameter-header-description">To evaluate |x| for normalization</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>PostprocessorName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>To evaluate |x| for normalization</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">output_before_normalization</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">True to output a step before normalization</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>True to output a step before normalization</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Normalization Parameters</h3></summary></details></section><section id="3fb018c4-bb68-4b47-8da0-91dd9d09d446" data-section-level="3" data-section-text="Restart Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Restart Parameters</h3></summary></details></section></section><section class="scrollspy" id="5924a396-4a23-4db1-90e1-01c8b8c12ac6" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#3f0e35b4-87fd-4799-a5e9-2f374e280eea" class="modal-trigger">test/tests/executioners/eigen_executioners/ane.i</a></li><li><a href="#934b0e1e-f07c-4c31-9452-0dd00f36960a" class="modal-trigger">test/tests/executioners/eigen_executioners/ne_coupled.i</a></li><li><a href="#aa7d6582-1661-4d70-b4d2-1e6ed32b39e1" class="modal-trigger">test/tests/executioners/eigen_executioners/ne.i</a></li><li><a href="#ca640a8b-5ddf-42e0-b41e-99ef6c84e9a9" class="modal-trigger">test/tests/executioners/eigen_executioners/ne_deficient_b.i</a></li><li><a href="#461956fd-0ba7-4bf4-ae60-002b74013f98" class="modal-trigger">test/tests/multiapps/full_solve_multiapp/master_eigen.i</a></li><li><a href="#2463ee95-c8ba-43fb-9caf-484351ebe0ea" class="modal-trigger">test/tests/executioners/eigen_executioners/ne_mat.i</a></li></ul><div class="modal moose-modal" id="3f0e35b4-87fd-4799-a5e9-2f374e280eea"><div class="modal-content"><h4>test/tests/executioners/eigen_executioners/ane.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
 type = GeneratedMesh
 dim = 2
 xmin = 0
 xmax = 10
 ymin = 0
 ymax = 10
 elem_type = QUAD4
 nx = 8
 ny = 8

 uniform_refine = 0
[]

# the minimum eigenvalue is (2*PI*(p-1)^(1/p)/a/p/sin(PI/p))^p;
# Its inverse is 35.349726539758187. Here a is equal to 10.

[Variables]
  active = &#x27;u&#x27;

  [./u]
    # second order is way better than first order
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./uic]
    type = RandomIC
    variable = u
  [../]
[]

[Kernels]
  active = &#x27;diff rhs&#x27;

  [./diff]
    type = PHarmonic
    variable = u
    p = 3
  [../]

  [./rhs]
    type = PMassEigenKernel
    variable = u
    p = 3
  [../]
[]

[BCs]
  active = &#x27;homogeneous&#x27;

  [./homogeneous]
    type = DirichletBC
    variable = u
    boundary = &#x27;0 2&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = NonlinearEigen

  bx_norm = &#x27;unorm&#x27;

  free_power_iterations = 10
  nl_abs_tol = 1e-12
  nl_rel_tol = 1e-50
  k0 = 1.0
# important: constant initial value set by auto_initilization does not
# converge to the fundamental mode
  auto_initialization = false
  output_after_power_iterations = false

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;
  l_max_its = 100
[]

[Postprocessors]
  active = &#x27;unorm udiff&#x27;

  [./unorm]
    type = ElementIntegralVariablePostprocessor
    variable = u
    # execute on residual is important for nonlinear eigen solver!
    execute_on = linear
  [../]

  [./udiff]
    type = ElementL2Diff
    variable = u
    outputs = console
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = ane
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="934b0e1e-f07c-4c31-9452-0dd00f36960a"><div class="modal-content"><h4>test/tests/executioners/eigen_executioners/ne_coupled.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
 type = GeneratedMesh
 dim = 2
 xmin = 0
 xmax = 10
 ymin = 0
 ymax = 10
 elem_type = QUAD4
 nx = 8
 ny = 8

 uniform_refine = 0
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./T]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./power]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = DiffMKernel
    variable = u
    mat_prop = diffusion
    offset = 0.0
  [../]

  [./rhs]
    type = MassEigenKernel
    variable = u
  [../]

  [./diff_T]
    type = Diffusion
    variable = T
  [../]
  [./src_T]
    type = CoupledForce
    variable = T
    v = power
  [../]
[]

[AuxKernels]
  [./power_ak]
    type = NormalizationAux
    variable = power
    source_variable = u
    normalization = unorm

# this coefficient will affect the eigenvalue.
    normal_factor = 10


    execute_on = linear
  [../]
[]

[BCs]
  [./homogeneous]
    type = DirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    value = 0
  [../]

  [./homogeneousT]
    type = DirichletBC
    variable = T
    boundary = &#x27;0 1 2 3&#x27;
    value = 0
  [../]
[]

[Materials]
  [./dc]
    type = VarCouplingMaterial
    var = T
    block = 0
    base = 1.0
    coef = 1.0
  [../]
[]

[Executioner]
  type = NonlinearEigen

  bx_norm = &#x27;unorm&#x27;

  free_power_iterations = 2
  nl_abs_tol = 1e-12
  nl_rel_tol = 1e-50
  k0 = 1.0
  output_after_power_iterations = false

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;
[]

[Postprocessors]
  active = &#x27;unorm udiff&#x27;

  [./unorm]
    type = ElementIntegralVariablePostprocessor
    variable = u
    # execute on residual is important for nonlinear eigen solver!
    execute_on = linear
  [../]

  [./udiff]
    type = ElementL2Diff
    variable = u
    outputs = console
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = ne_coupled
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aa7d6582-1661-4d70-b4d2-1e6ed32b39e1"><div class="modal-content"><h4>test/tests/executioners/eigen_executioners/ne.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
 type = GeneratedMesh
 dim = 2
 xmin = 0
 xmax = 10
 ymin = 0
 ymax = 10
 elem_type = QUAD4
 nx = 8
 ny = 8

 uniform_refine = 0
[]

# the minimum eigenvalue of this problem is 2*(PI/a)^2;
# Its inverse is 0.5*(a/PI)^2 = 5.0660591821169. Here a is equal to 10.

[Variables]
  active = &#x27;u&#x27;

  [./u]
    # second order is way better than first order
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff rhs&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./rhs]
    type = MassEigenKernel
    variable = u
  [../]
[]

[BCs]
  active = &#x27;homogeneous&#x27;

  [./homogeneous]
    type = DirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1 2 3&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = NonlinearEigen

  bx_norm = &#x27;unorm&#x27;
  normalization = &#x27;unorm&#x27;
  normal_factor = 9.990012561844

  free_power_iterations = 2
  nl_abs_tol = 1e-12
  nl_rel_tol = 1e-50
  k0 = 1.0

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active = &#x27;unorm udiff&#x27;

  [./unorm]
    type = ElementIntegralVariablePostprocessor
    variable = u
    # execute on residual is important for nonlinear eigen solver!
    execute_on = linear
  [../]

  [./udiff]
    type = ElementL2Diff
    variable = u
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = ne
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ca640a8b-5ddf-42e0-b41e-99ef6c84e9a9"><div class="modal-content"><h4>test/tests/executioners/eigen_executioners/ne_deficient_b.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
 type = GeneratedMesh
 dim = 2
 xmin = 0
 xmax = 10
 ymin = 0
 ymax = 10
 elem_type = QUAD4
 nx = 8
 ny = 8

 uniform_refine = 0
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
  [./v]
    order = FIRST
    family = LAGRANGE
    eigen = true
  [../]
[]

[Kernels]
  [./diff_u]
    type = Diffusion
    variable = u
  [../]
  [./diff_v]
    type = Diffusion
    variable = v
  [../]

  [./rhs]
    type = CoupledEigenKernel
    variable = u
    v = v
  [../]
  [./src_v]
    type = CoupledForce
    variable = v
    v = u
  [../]
[]

[BCs]
  [./homogeneous_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    value = 0
  [../]
  [./homogeneous_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;0 1 2 3&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = NonlinearEigen

  bx_norm = &#x27;vnorm&#x27;

  free_power_iterations = 2
  nl_abs_tol = 1e-12
  nl_rel_tol = 1e-50
  k0 = 1.0
  output_after_power_iterations = false

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;
[]

[Postprocessors]
  [./vnorm]
    type = ElementIntegralVariablePostprocessor
    variable = v
    # execute on residual is important for nonlinear eigen solver!
    execute_on = linear
  [../]

  [./udiff]
    type = ElementL2Diff
    variable = u
    outputs = console
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = ne_deficient_b
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="461956fd-0ba7-4bf4-ae60-002b74013f98"><div class="modal-content"><h4>test/tests/multiapps/full_solve_multiapp/master_eigen.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []
  [rhs]
    type = MassEigenKernel
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Executioner]
  type = NonlinearEigen

  bx_norm = &#x27;unorm&#x27;

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [unorm]
    type = ElementIntegralVariablePostprocessor
    variable = u
    # execute on residual is important for nonlinear eigen solver!
    execute_on = linear
  []
[]

[Outputs]
  exodus = true
  perf_graph = true
[]

[MultiApps]
  [full_solve]
    type = FullSolveMultiApp
    # not setting app_type to use the same app type of master, i.e. MooseTestApp
    execute_on = initial
    positions = &#x27;0 0 0&#x27;
    input_files = sub.i
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2463ee95-c8ba-43fb-9caf-484351ebe0ea"><div class="modal-content"><h4>test/tests/executioners/eigen_executioners/ne_mat.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
 type = GeneratedMesh
 dim = 2
 xmin = 0
 xmax = 10
 ymin = 0
 ymax = 10
 elem_type = QUAD4
 nx = 8
 ny = 8

 uniform_refine = 0
[]

# the minimum eigenvalue of this problem is 2*(PI/a)^2;
# Its inverse is 0.5*(a/PI)^2 = 5.0660591821169. Here a is equal to 10.

[Variables]
  active = &#x27;u&#x27;

  [./u]
    # second order is way better than first order
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff rhs&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./rhs]
    type = MaterialEigenKernel
    variable = u
    mat = varmat
  [../]
[]

[Materials]
  [./var_mat]
    type = VarCouplingMaterialEigen
    block = 0
    var = u
    material_prop_name = varmat
  [../]
[]

[BCs]
  active = &#x27;homogeneous&#x27;

  [./homogeneous]
    type = DirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1 2 3&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = NonlinearEigen

  bx_norm = &#x27;unorm&#x27;
  normalization = &#x27;unorm&#x27;
  normal_factor = 9.990012561844

  free_power_iterations = 2
  nl_abs_tol = 1e-12
  nl_rel_tol = 1e-50
  k0 = 1.0

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;
[]

[Postprocessors]
  active = &#x27;unorm udiff&#x27;

  [./unorm]
    type = ElementIntegralVariablePostprocessor
    variable = u
    # execute on residual is important for nonlinear eigen solver!
    execute_on = linear
  [../]

  [./udiff]
    type = ElementL2Diff
    variable = u
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = ne_mat
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#258c7394-c4ac-42f9-ad65-2f19fc67fc8f" class="tooltipped" data-position="left" data-tooltip="Overview">Overview</a></li><li><a href="#20fe295c-1d18-4e0b-b0f2-b4add0a74971" class="tooltipped" data-position="left" data-tooltip="The nonlinear Newton method">The nonlinear Newton method</a></li><li><a href="#fe886b3a-2ee0-4b10-9b9a-32db624d9c00" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#5924a396-4a23-4db1-90e1-01c8b8c12ac6" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>