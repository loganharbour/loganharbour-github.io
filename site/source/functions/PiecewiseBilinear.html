<!DOCTYPE html><head><meta charset="UTF-8"><title>PiecewiseBilinear.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="5697c452-6ad9-44ec-a6af-546079f3d051"><i class="material-icons">menu</i></a><ul class="sidenav" id="5697c452-6ad9-44ec-a6af-546079f3d051"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">functions</span><a href="#" class="breadcrumb">PiecewiseBilinear</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="2ff84a22-c461-434c-ba3f-14ca786ea13a" data-section-level="1" data-section-text="PiecewiseBilinear"><h1 id="piecewisebilinear">PiecewiseBilinear</h1><p>Interpolates values from a csv file</p><section class="scrollspy" id="bc8bf16c-2f68-44c2-b890-28671e650a00" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p>The <code>PiecewiseBilinear</code> function reads a csv file and interpolates values based on the data in the file.  The interpolation is based on x-y pairs.  If <code>axis</code> is given, time is used as the y index.  Either <code>xaxis</code> or <code>yaxis</code> or both may be given.  Time is used as the other index if one of them is not given.  If <code>radius</code> is given, <code>xaxis</code> and <code>yaxis</code> are used to orient a cylindrical coordinate system, and the x-y pair used in the query will be the radial coordinate and time.</p></section><section class="scrollspy" id="37fe733a-cedf-4332-a1ad-2d7bb6344da5" data-section-level="2" data-section-text="Example Input Syntax"><h2 id="example-input-syntax">Example Input Syntax</h2><pre class="moose-pre"><code class="language-text">[Functions]

  [./u]
    type = PiecewiseBilinear
    #x = &#x27;0 1 3&#x27; # Testing this error
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    axis = 0
  [../] # End Functions
[]
</code></pre><a href="#01558fca-6f24-4ed3-87a8-c8b65a96a795" class="modal-trigger">(test/tests/utils/2d_linear_interpolation/xyz_error.i)</a><div class="modal moose-modal" id="01558fca-6f24-4ed3-87a8-c8b65a96a795"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/test/tests/utils/2d_linear_interpolation/xyz_error.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cube.e
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Variables]

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]

  [./u]
    type = PiecewiseBilinear
    #x = &#x27;0 1 3&#x27; # Testing this error
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    axis = 0
  [../]
[] # End Functions

[Kernels]

  [./diffu]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]

  [./u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = u
  [../]
[]

[Executioner]
  type = Transient
  dt = 1
  end_time = 2
  nl_rel_tol = 1e-12
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="1aa2ddc5-2a52-4e5c-92d1-83245e35cf4b" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="59741deb-2481-4685-ba54-f93d2aff8f8d" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">axis</span><span class="moose-parameter-header-default">-1</span><span class="moose-parameter-header-description">The axis used (0, 1, or 2 for x, y, or z).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>-1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The axis used (0, 1, or 2 for x, y, or z).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">data_file</span><span class="moose-parameter-header-description">File holding csv data for use with PiecewiseBilinear</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FileName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>File holding csv data for use with PiecewiseBilinear</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">radial</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Set to true if you want to interpolate along a radius rather that along a specific axis, and note that you have to define xaxis and yaxis in the input file</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set to true if you want to interpolate along a radius rather that along a specific axis, and note that you have to define xaxis and yaxis in the input file</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">scale_factor</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Scale factor to be applied to the axis, yaxis, or xaxis values</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Scale factor to be applied to the axis, yaxis, or xaxis values</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">x</span><span class="moose-parameter-header-description">The x abscissa values</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The x abscissa values</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">xaxis</span><span class="moose-parameter-header-default">-1</span><span class="moose-parameter-header-description">The coordinate used for x-axis data (0, 1, or 2 for x, y, or z).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>-1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The coordinate used for x-axis data (0, 1, or 2 for x, y, or z).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">y</span><span class="moose-parameter-header-description">The y abscissa values</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The y abscissa values</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">yaxis</span><span class="moose-parameter-header-default">-1</span><span class="moose-parameter-header-description">The coordinate used for y-axis data (0, 1, or 2 for x, y, or z).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>-1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The coordinate used for y-axis data (0, 1, or 2 for x, y, or z).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">z</span><span class="moose-parameter-header-description">The ordinate values</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The ordinate values</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="69c39e5d-53a1-49ab-9bb0-7af754b75572" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section class="scrollspy" id="4f4ffa6d-548f-47f8-904e-e349bd57edf0" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#3725a5b5-56fb-4fcf-b4db-78f95d8853b3" class="modal-trigger">test/tests/utils/2d_linear_interpolation/2d_linear_interpolation_test_internal.i</a></li><li><a href="#a8a7b94f-df30-44fc-9a95-f9af70531696" class="modal-trigger">test/tests/utils/2d_linear_interpolation/xyz_error.i</a></li><li><a href="#5bc95056-4ab3-484b-b90e-f6a7938d0c8f" class="modal-trigger">test/tests/utils/2d_linear_interpolation/2d_linear_interpolation_test.i</a></li></ul><div class="modal moose-modal" id="3725a5b5-56fb-4fcf-b4db-78f95d8853b3"><div class="modal-content"><h4>test/tests/utils/2d_linear_interpolation/2d_linear_interpolation_test_internal.i</h4><pre class="moose-pre"><code class="language-text"># Test description - view this file in emacs and adjust the window size to view the file as it was created.
#
# This problem tests the MOOSE function PiecewiseBilinear and the MOOSE utility BilinearInterpolation, which are
# used to solve 2D linear interpolation problems.
#
# The problem is one element with node coordinate locations in x,y,z space as indicated in the ASCII art:
#
#
#                    ^
#                    |
#                    z
#                    |
#
#                    (1,1,2)        (1,2,2)
#                    *--------------*
#                  / |            / |
#                /   |  (2,2,2) /   |
#       (2,1,2) *--------------*    |
#               |    |         |    |
#               |    *---------|----* (1,2,1)  --y--&gt;
#               |  / (1,1,1)   |  /
#               |/             |/
#               *--------------*
#              / (2,1,1)       (2,2,1)
#            /
#          x
#        /
#      |_
#
#  problem time ...0...1...2
#
#
# There are four variables and four functions of the same name, u,v,w, and A.  The diffusion equation is solved
# for each of these variables with a boundary condition of type FunctionDirchletBC applied to a boundary
# (i.e. node set) that includes every node in the element.  Each boundary condition uses a function of type
# PiecewiseBilinear that gets its value from the specified x, y, and z values.
#
# fred is a matrix of data whose first row and first column are vectors that can refer to either spacial positions
# corresponding to an axis or values of time.  The remaining data are values of fred for a given row and column pair.
#
#
# Visualize fred like this:
#
#                          0 1 3  where fred is a csv file that actually looks like this    0,1,3
#                        0 0 0 0                                                            0,0,0,0
#                        1 0 1 3                                                            1,0,1,3
#                        3 0 5 7                                                            3,0,5,7
#
#  Another way to think of fred is:
#
#                                   |0 1 3| - These values can be spacial positions corresponding to
#                                             axis= 0,1, or 2, or time
#
#
#                           |0|     |0 0 0|
#     These values can be - |1|     |0 1 3| - values of fred corresponding to row-column pairs
#     time or spacial       |3|     |0 5 7|
#     positions corresponding
#     to axis= 0,1, or 2
#
#
# The parameters and possible values for the function PiecewiseBilinear are:
#
# x = &#x27;0 1 3&#x27;
# y = &#x27;0 1 3&#x27;
# z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
# axis = 0, 1, or 2
# xaxis = 0, 1, or 2
# yaxis = 0, 1, or 2
# radial = true or false (false is default)
#
# where 0, 1, or 2 refer to the x, y, or z axis.
#
# If the parameter axis is defined, then the first row of fred are spacial position and the first column
# of fred are the values of time.
#
# If the parameter xaxis is defined, then the first row of fred are spacial positions and the first column
# of fred are the values of time ... just like defining the parameter axis.
#
# If the parameter yaxis is defined, then the first row of fred are time values and the first column of fred
# are spacial positions.
#
# If parameters axis AND EITHER xaxis or yaxis are defined together you&#x27;ll get a moose error.
# i.e.
# axis = 0
# xaxis = 1
# results in an error.  So, if you use the parameter axis, don&#x27;t use xaxis or yaxis.
#
# If parameters xaxis and yaxis are defined (and radial is false), then the first row of fred are spacial positions corresponding to xaxis value,
# and the first column are spacial positions corresponding to the yaxis value.
#
# If xaxis and yaxis are defined and radial is true, the first row of fred contains values
# corresponding to the radius calculated from the coordinates of each point.  Note that
# the definition of xaxis and yaxis define the &quot;plane&quot; of the radius.  For example,
# xaxis = 0 and yaxis = 1 means that x and y components of the point are use to
# calculate the radius.  xaxis = 1 and yaxis = 2 means that x and z components are used.
# The first column is for time in this case.  xaxis and yaxis have to be specified and
# radial = true for this to work, otherwise a MOOSE error will result.
# This was developed so that an axisymmetric function could be defined for a 3D mesh.
#
[Mesh]
  file = cube.e
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Variables]

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
  [./w]
    order = FIRST
    family = LAGRANGE
  [../]
  [./A]
    order = FIRST
    family = LAGRANGE
  [../]
  [./scaled_u]
    order = FIRST
    family = LAGRANGE
  [../]
  [./R]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]


  [./u]
    type = PiecewiseBilinear
    x = &#x27;0 1 3&#x27;
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    axis = 0
  [../]
#
# Example 1 - variable u
#
# In this example, the first variable is u and the parameter axis is given the value 0.  For such a case, the first
# row of fred refers to nodal x-coordinate values and the first column of fred (after the first row) refers to the
# times 0, 1, and 3.
#
# So, at time = 0, the value of u at each node is 0, because that&#x27;s the value of fred for all x-coordinate values at time=0.
#
# At time = 1, the value of u at nodes with x-coordinate = 1 is 1.
#            , the value of u at nodes with x-coordinate = 2 is 2.
#
# You can check this value with your own 2D linear interpolation calculation.  Go ahead and check all the examples!
#
# At time = 2, the value of u at nodes with x-coordinate = 1 is 3.
#            , the value of u at nodes with x-coordinate = 2 is 4.
#
  [./v]
    type = PiecewiseBilinear
    x = &#x27;0 1 3&#x27;
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    xaxis = 1
  [../]
#
# Example 2 - variable v
#
# In this example, the variable is v and the parameter xaxis is given the value 1.  For such a case, the first
# row of fred refers to nodal y-coordinate values and the first column of fred (after the first row) refers to the
# times 0, 1, and 3.
#
# At time = 0, the value of v at each node is 0, because that&#x27;s the value of fred for all y-coordinate values at time=0.
#
# At time = 1, the value of v at nodes with y-coordinate = 1 is 1.
#            , the value of v at nodes with y-coordinate = 2 is 2.
#
# At time = 2, the value of v at nodes with y-coordinate = 1 is 3.
#            , the value of v at nodes with y-coordinate = 2 is 4.
#
  [./w]
    type = PiecewiseBilinear
    x = &#x27;0 1 3&#x27;
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    yaxis = 2
  [../]
#
# Example 3 - variable w
#
# In this example, the variable is w and the parameter yaxis is given the value 2.  For such a case, the first
# row of fred refers to times 0, 1, and 3.  The first column of fred (after the first row) refers to the nodal
# z-coordinate values.
#
# At time = 0, the value of w at each node is 0, because that&#x27;s the value of fred for all z-coordinate values at time=0.
#
# At time = 1, the value of w at nodes with z-coordinate = 1 is 1.
#            , the value of w at nodes with z-coordinate = 2 is 3.
#
# At time = 2, the value of w at nodes with z-coordinate = 1 is 2.
#            , the value of w at nodes with z-coordinate = 2 is 4.
#
  [./A]
    type = PiecewiseBilinear
    x = &#x27;0 1 3&#x27;
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    xaxis = 0
    yaxis = 1
  [../]
#
# Example 4 - variable A
#
# In this example, the variable is A and the parameters xaxis AND yaxis BOTH defined and given the values 0 and 1 respectivley.
# For such a case, the first row of fred refers to nodal x-coordinate values.
# The first column refers to nodal y-coordinate values.
#
# In this example the values are the same for every time (except time=0 where the values are undefined)
#
# For nodal coordinates with x=1, y=1 A = 1
#                            x=2, y=1 A = 2
#                            x=1, y=2 A = 3
#                            x=2, y=2 A = 4
#
# You can use this 2D linear interpolation function for anything (BC, Kernel, AuxKernel, Material) that has
# a function as one of its parameters.  For example, this can be used to describe the fission peaking factors
# that vary in time and along the length of a fuel rod, or a fission rate distribution in metal fuel that varies
# as a function of x and y postion, but is constant in time.
#
#
  [./scaled_u]
    type = PiecewiseBilinear
    x = &#x27;0 1 3&#x27;
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    axis = 0
    scale_factor = 2
  [../]
#
# Example 5 - variable scaled_u.  This is just a scaled version of Example 1 to see if the scale_factor works
#
#
#
  [./R]
    type = PiecewiseBilinear
    x = &#x27;0 1 3&#x27;
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    xaxis = 0
    yaxis = 1
    radial = true
  [../]
#
# Example 6 - variable R
#
# In this example, the variable is R and the parameters xaxis and yaxis are defined and
# given the values 0 and 1 respectivley.  The parameter radial is also defined and given
# the value true.  In this case, the x and y components of each point are used to
# calculate a radius.  This radius is used in the call to BilinearInterpolation.
# In fred.csv, the first row are the radius values.  The first column is time.
#
# At time = 1, the value of R at nodes with coordinates (x = 1, y = 1, or r = 1.414) is 1.414.
#            , the value of R at nodes with coordinates (x = 1, y = 2, or r = 2.236) is 2.236.
#            , the value of R at nodes with coordinates (x = 2, y = 2, or r = 2.828) is 2.828.
#
# At time = 2, the value of R at nodes with coordinates (x = 1, y = 1, or r = 1.414) is 3.414.
#            , the value of R at nodes with coordinates (x = 1, y = 2, or r = 2.236) is 4.236.
#            , the value of R at nodes with coordinates (x = 2, y = 2, or r = 2.828) is 4.828.
#
# Note that the case of x = 2, y = 1 gives the same result as x = 1, y=2.
#
#
[] # End Functions

[Kernels]

  [./diffu]
    type = Diffusion
    variable = u
  [../]
  [./diffv]
    type = Diffusion
    variable = v
  [../]
  [./diffw]
    type = Diffusion
    variable = w
  [../]
  [./diffA]
    type = Diffusion
    variable = A
  [../]
  [./diff_scaled_u]
    type = Diffusion
    variable = scaled_u
  [../]
  [./diffR]
    type = Diffusion
    variable = R
  [../]
[]

[BCs]

  [./u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = u
  [../]
  [./v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;1&#x27;
    function = v
  [../]
  [./w]
    type = FunctionDirichletBC
    variable = w
    boundary = &#x27;1&#x27;
    function = w
  [../]
  [./A]
    type = FunctionDirichletBC
    variable = A
    boundary = &#x27;1&#x27;
    function = A
  [../]
  [./scaled_u]
    type = FunctionDirichletBC
    variable = scaled_u
    boundary = &#x27;1&#x27;
    function = scaled_u
  [../]
  [./R]
    type = FunctionDirichletBC
    variable = R
    boundary = &#x27;1&#x27;
    function = R
  [../]
[]

[Executioner]
  type = Transient
  dt = 1
  end_time = 2
  nl_rel_tol = 1e-12
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a8a7b94f-df30-44fc-9a95-f9af70531696"><div class="modal-content"><h4>test/tests/utils/2d_linear_interpolation/xyz_error.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cube.e
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Variables]

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]


  [./u]
    type = PiecewiseBilinear
    #x = &#x27;0 1 3&#x27; # Testing this error
    y = &#x27;0 1 3&#x27;
    z = &#x27;0 0 0 0 1 3 0 5 7&#x27;
    axis = 0
  [../]
[] # End Functions

[Kernels]

  [./diffu]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]

  [./u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = u
  [../]
[]

[Executioner]
  type = Transient
  dt = 1
  end_time = 2
  nl_rel_tol = 1e-12
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5bc95056-4ab3-484b-b90e-f6a7938d0c8f"><div class="modal-content"><h4>test/tests/utils/2d_linear_interpolation/2d_linear_interpolation_test.i</h4><pre class="moose-pre"><code class="language-text"># Test description - view this file in emacs and adjust the window size to view the file as it was created.
#
# This problem tests the MOOSE function PiecewiseBilinear and the MOOSE utility BilinearInterpolation, which are
# used to solve 2D linear interpolation problems.
#
# The problem is one element with node coordinate locations in x,y,z space as indicated in the ASCII art:
#
#
#                    ^
#                    |
#                    z
#                    |
#
#                    (1,1,2)        (1,2,2)
#                    *--------------*
#                  / |            / |
#                /   |  (2,2,2) /   |
#       (2,1,2) *--------------*    |
#               |    |         |    |
#               |    *---------|----* (1,2,1)  --y--&gt;
#               |  / (1,1,1)   |  /
#               |/             |/
#               *--------------*
#              / (2,1,1)       (2,2,1)
#            /
#          x
#        /
#      |_
#
#  problem time ...0...1...2
#
#
# There are four variables and four functions of the same name, u,v,w, and A.  The diffusion equation is solved
# for each of these variables with a boundary condition of type FunctionDirchletBC applied to a boundary
# (i.e. node set) that includes every node in the element.  Each boundary condition uses a function of type
# PiecewiseBilinear that gets its value from a file named fred.csv.
#
# fred is a matrix of data whose first row and first column are vectors that can refer to either spacial positions
# corresponding to an axis or values of time.  The remaining data are values of fred for a given row and column pair.
#
#
# Visualize fred like this:
#
#                          0 1 3  where fred is a csv file that actually looks like this    0,1,3
#                        0 0 0 0                                                            0,0,0,0
#                        1 0 1 3                                                            1,0,1,3
#                        3 0 5 7                                                            3,0,5,7
#
#  Another way to think of fred is:
#
#                                   |0 1 3| - These values can be spacial positions corresponding to
#                                             axis= 0,1, or 2, or time
#
#
#                           |0|     |0 0 0|
#     These values can be - |1|     |0 1 3| - values of fred corresponding to row-column pairs
#     time or spacial       |3|     |0 5 7|
#     positions corresponding
#     to axis= 0,1, or 2
#
#
# The parameters and possible values for the function PiecewiseBilinear are:
#
# data_file = fred.csv
# axis = 0, 1, or 2
# xaxis = 0, 1, or 2
# yaxis = 0, 1, or 2
# radial = true or false (false is default)
#
# where 0, 1, or 2 refer to the x, y, or z axis.
#
# If the parameter axis is defined, then the first row of fred are spacial position and the first column
# of fred are the values of time.
#
# If the parameter xaxis is defined, then the first row of fred are spacial positions and the first column
# of fred are the values of time ... just like defining the parameter axis.
#
# If the parameter yaxis is defined, then the first row of fred are time values and the first column of fred
# are spacial positions.
#
# If parameters axis AND EITHER xaxis or yaxis are defined together you&#x27;ll get a moose error.
# i.e.
# axis = 0
# xaxis = 1
# results in an error.  So, if you use the parameter axis, don&#x27;t use xaxis or yaxis.
#
# If parameters xaxis and yaxis are defined (and radial is false), then the first row of fred are spacial positions corresponding to xaxis value,
# and the first column are spacial positions corresponding to the yaxis value.
#
# If xaxis and yaxis are defined and radial is true, the first row of fred contains values
# corresponding to the radius calculated from the coordinates of each point.  Note that
# the definition of xaxis and yaxis define the &quot;plane&quot; of the radius.  For example,
# xaxis = 0 and yaxis = 1 means that x and y components of the point are use to
# calculate the radius.  xaxis = 1 and yaxis = 2 means that x and z components are used.
# The first column is for time in this case.  xaxis and yaxis have to be specified and
# radial = true for this to work, otherwise a MOOSE error will result.
# This was developed so that an axisymmetric function could be defined for a 3D mesh.
#
[Mesh]
  file = cube.e
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Variables]

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
  [./w]
    order = FIRST
    family = LAGRANGE
  [../]
  [./A]
    order = FIRST
    family = LAGRANGE
  [../]
  [./scaled_u]
    order = FIRST
    family = LAGRANGE
  [../]
  [./R]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]


  [./u]
    type = PiecewiseBilinear
    data_file = fred.csv
    axis = 0
  [../]
#
# Example 1 - variable u
#
# In this example, the first variable is u and the parameter axis is given the value 0.  For such a case, the first
# row of fred refers to nodal x-coordinate values and the first column of fred (after the first row) refers to the
# times 0, 1, and 3.
#
# So, at time = 0, the value of u at each node is 0, because that&#x27;s the value of fred for all x-coordinate values at time=0.
#
# At time = 1, the value of u at nodes with x-coordinate = 1 is 1.
#            , the value of u at nodes with x-coordinate = 2 is 2.
#
# You can check this value with your own 2D linear interpolation calculation.  Go ahead and check all the examples!
#
# At time = 2, the value of u at nodes with x-coordinate = 1 is 3.
#            , the value of u at nodes with x-coordinate = 2 is 4.
#
  [./v]
    type = PiecewiseBilinear
    data_file = fred.csv
    xaxis = 1
  [../]
#
# Example 2 - variable v
#
# In this example, the variable is v and the parameter xaxis is given the value 1.  For such a case, the first
# row of fred refers to nodal y-coordinate values and the first column of fred (after the first row) refers to the
# times 0, 1, and 3.
#
# At time = 0, the value of v at each node is 0, because that&#x27;s the value of fred for all y-coordinate values at time=0.
#
# At time = 1, the value of v at nodes with y-coordinate = 1 is 1.
#            , the value of v at nodes with y-coordinate = 2 is 2.
#
# At time = 2, the value of v at nodes with y-coordinate = 1 is 3.
#            , the value of v at nodes with y-coordinate = 2 is 4.
#
  [./w]
    type = PiecewiseBilinear
    data_file = fred.csv
    yaxis = 2
  [../]
#
# Example 3 - variable w
#
# In this example, the variable is w and the parameter yaxis is given the value 2.  For such a case, the first
# row of fred refers to times 0, 1, and 3.  The first column of fred (after the first row) refers to the nodal
# z-coordinate values.
#
# At time = 0, the value of w at each node is 0, because that&#x27;s the value of fred for all z-coordinate values at time=0.
#
# At time = 1, the value of w at nodes with z-coordinate = 1 is 1.
#            , the value of w at nodes with z-coordinate = 2 is 3.
#
# At time = 2, the value of w at nodes with z-coordinate = 1 is 2.
#            , the value of w at nodes with z-coordinate = 2 is 4.
#
  [./A]
    type = PiecewiseBilinear
    data_file = fred.csv
    xaxis = 0
    yaxis = 1
  [../]
#
# Example 4 - variable A
#
# In this example, the variable is A and the parameters xaxis AND yaxis BOTH defined and given the values 0 and 1 respectivley.
# For such a case, the first row of fred refers to nodal x-coordinate values.
# The first column refers to nodal y-coordinate values.
#
# In this example the values are the same for every time (except time=0 where the values are undefined)
#
# For nodal coordinates with x=1, y=1 A = 1
#                            x=2, y=1 A = 2
#                            x=1, y=2 A = 3
#                            x=2, y=2 A = 4
#
# You can use this 2D linear interpolation function for anything (BC, Kernel, AuxKernel, Material) that has
# a function as one of its parameters.  For example, this can be used to describe the fission peaking factors
# that vary in time and along the length of a fuel rod, or a fission rate distribution in metal fuel that varies
# as a function of x and y postion, but is constant in time.
#
#
  [./scaled_u]
    type = PiecewiseBilinear
    data_file = fred.csv
    axis = 0
    scale_factor = 2
  [../]
#
# Example 5 - variable scaled_u.  This is just a scaled version of Example 1 to see if the scale_factor works
#
#
#
  [./R]
    type = PiecewiseBilinear
    data_file = fred.csv
    xaxis = 0
    yaxis = 1
    radial = true
  [../]
#
# Example 6 - variable R
#
# In this example, the variable is R and the parameters xaxis and yaxis are defined and
# given the values 0 and 1 respectivley.  The parameter radial is also defined and given
# the value true.  In this case, the x and y components of each point are used to
# calculate a radius.  This radius is used in the call to BilinearInterpolation.
# In fred.csv, the first row are the radius values.  The first column is time.
#
# At time = 1, the value of R at nodes with coordinates (x = 1, y = 1, or r = 1.414) is 1.414.
#            , the value of R at nodes with coordinates (x = 1, y = 2, or r = 2.236) is 2.236.
#            , the value of R at nodes with coordinates (x = 2, y = 2, or r = 2.828) is 2.828.
#
# At time = 2, the value of R at nodes with coordinates (x = 1, y = 1, or r = 1.414) is 3.414.
#            , the value of R at nodes with coordinates (x = 1, y = 2, or r = 2.236) is 4.236.
#            , the value of R at nodes with coordinates (x = 2, y = 2, or r = 2.828) is 4.828.
#
# Note that the case of x = 2, y = 1 gives the same result as x = 1, y=2.
#
#
[] # End Functions

[Kernels]

  [./diffu]
    type = Diffusion
    variable = u
  [../]
  [./diffv]
    type = Diffusion
    variable = v
  [../]
  [./diffw]
    type = Diffusion
    variable = w
  [../]
  [./diffA]
    type = Diffusion
    variable = A
  [../]
  [./diff_scaled_u]
    type = Diffusion
    variable = scaled_u
  [../]
  [./diffR]
    type = Diffusion
    variable = R
  [../]
[]

[BCs]

  [./u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = u
  [../]
  [./v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;1&#x27;
    function = v
  [../]
  [./w]
    type = FunctionDirichletBC
    variable = w
    boundary = &#x27;1&#x27;
    function = w
  [../]
  [./A]
    type = FunctionDirichletBC
    variable = A
    boundary = &#x27;1&#x27;
    function = A
  [../]
  [./scaled_u]
    type = FunctionDirichletBC
    variable = scaled_u
    boundary = &#x27;1&#x27;
    function = scaled_u
  [../]
  [./R]
    type = FunctionDirichletBC
    variable = R
    boundary = &#x27;1&#x27;
    function = R
  [../]
[]

[Executioner]
  type = Transient
  dt = 1
  end_time = 2
  nl_rel_tol = 1e-12
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#bc8bf16c-2f68-44c2-b890-28671e650a00" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#37fe733a-cedf-4332-a1ad-2d7bb6344da5" class="tooltipped" data-position="left" data-tooltip="Example Input Syntax">Example Input Syntax</a></li><li><a href="#1aa2ddc5-2a52-4e5c-92d1-83245e35cf4b" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#4f4ffa6d-548f-47f8-904e-e349bd57edf0" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>