<!DOCTYPE html><head><meta charset="UTF-8"><title>PiecewiseLinear.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="a8e7d4ba-11f6-48cd-8bf9-1fc15c7d92db"><i class="material-icons">menu</i></a><ul class="sidenav" id="a8e7d4ba-11f6-48cd-8bf9-1fc15c7d92db"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">functions</span><a href="#" class="breadcrumb">PiecewiseLinear</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="3a161570-0776-472c-adc4-3b139fbeaf58" data-section-level="1" data-section-text="PiecewiseLinear"><h1 id="piecewiselinear">PiecewiseLinear</h1><p>Linearly interpolates between pairs of x-y data</p><section class="scrollspy" id="a8ee1579-0398-4b94-987d-63f2c0783b51" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p>The <code>PiecewiseLinear</code> function performs linear interpolations between user-provided pairs of x-y data.  The x-y data can be provided in three ways. The first way is through a combination of the <code>x</code> and <code>y</code> paramaters, which are lists of the x and y coordinates of the data points that make up the function.  The second way is in the <code>xy_data</code> parameter, which is a list of pairs of x-y data that make up the points of the function.  This allows for the function data to be specified in columns by inserting line breaks after each x-y data point.  Finally, the x-y data can be provided in an external file containing comma-separated values.  The file name is provided in <code>data_file</code>, and the data can be provided in either rows (default) or columns, as specified in the <code>format</code> parameter.</p><p>By default, the x-data corresponds to time, but this can be changed to correspond to x, y, or z coordinate with the <code>axis</code> line.  If the function is queried outside of its range of x data, it returns the y value associated with the closest x data point.</p></section><section class="scrollspy" id="fce241fb-29f0-43f8-bd18-67e5f95b41ab" data-section-level="2" data-section-text="Example Input Syntax"><h2 id="example-input-syntax">Example Input Syntax</h2><pre class="moose-pre"><code class="language-text">[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_columns.csv #Will generate error because data is expected in rows
    scale_factor = 1.0
  [../]
[]
</code></pre><a href="#c36d8dfd-eec3-45ce-a524-fa2399f997a5" class="modal-trigger">(test/tests/misc/check_error/function_file_test1.i)</a><div class="modal moose-modal" id="c36d8dfd-eec3-45ce-a524-fa2399f997a5"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/test/tests/misc/check_error/function_file_test1.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_columns.csv #Will generate error because data is expected in rows
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="8bb355cc-675b-4341-82e6-7d20b0562295" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="0a841233-e04e-4262-97c9-caf6d510ab8b" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">axis</span><span class="moose-parameter-header-description">The axis used (x, y, or z) if this is to be a function of position</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>x y z</p><p class="moose-parameter-description"><span>Description:</span>The axis used (x, y, or z) if this is to be a function of position</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">data_file</span><span class="moose-parameter-header-description">File holding CSV data</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FileName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>File holding CSV data</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">format</span><span class="moose-parameter-header-default">rows</span><span class="moose-parameter-header-description">Format of csv data file that is in either in columns or rows</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>rows</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>columns rows</p><p class="moose-parameter-description"><span>Description:</span>Format of csv data file that is in either in columns or rows</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">scale_factor</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Scale factor to be applied to the ordinate values</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Scale factor to be applied to the ordinate values</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">x</span><span class="moose-parameter-header-description">The abscissa values</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The abscissa values</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">x_index_in_file</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The abscissa index in the data file</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The abscissa index in the data file</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">xy_data</span><span class="moose-parameter-header-description">All function data, supplied in abscissa, ordinate pairs</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>All function data, supplied in abscissa, ordinate pairs</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">xy_in_file_only</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">If the data file only contains abscissa and ordinate data</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>If the data file only contains abscissa and ordinate data</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">y</span><span class="moose-parameter-header-description">The ordinate values</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The ordinate values</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">y_index_in_file</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">The ordinate index in the data file</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The ordinate index in the data file</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="0d9047d0-767c-4765-b633-d982c929e0ca" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section class="scrollspy" id="8ab9018f-04b2-4b3b-a9b9-2908a3ca1459" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#d557d01a-e6de-4927-9125-b5de1a7091d3" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3ns.i</a></li><li><a href="#4468774a-099a-4786-af5c-b63963581438" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test3nns.i</a></li><li><a href="#61a2c5c9-e37c-4a55-b0eb-5c651fa25c71" class="modal-trigger">modules/richards/test/tests/theis/th22.i</a></li><li><a href="#a61b7d03-d1f3-4b4f-97df-555e4a26e1ea" class="modal-trigger">modules/combined/test/tests/poro_mechanics/mandel.i</a></li><li><a href="#ba5abe26-dd01-4a76-a011-29a812afab28" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_3d.i</a></li><li><a href="#a2c266f5-3ef4-4eda-a383-e166718a1f4c" class="modal-trigger">modules/tensor_mechanics/test/tests/volumetric_eigenstrain/volumetric_mechanical.i</a></li><li><a href="#9b6d115a-6016-4e2a-8bd8-fbff8e589fc4" class="modal-trigger">modules/combined/test/tests/thermo_mech/youngs_modulus_function_temp.i</a></li><li><a href="#f148e614-057a-4e74-8a39-6c21660a967d" class="modal-trigger">modules/contact/test/tests/simple_contact/simple_contact_rz_test.i</a></li><li><a href="#86f9285e-04a9-49a6-8bb1-47cb5ddfc053" class="modal-trigger">modules/tensor_mechanics/test/tests/scalar_material_damage/scalar_material_damage.i</a></li><li><a href="#4eb82cfb-f765-494e-bb82-e6338ecaedc3" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D_yz.i</a></li><li><a href="#b8980312-b5a4-4928-a653-3d1cbd7c678e" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/negative_volume.i</a></li><li><a href="#afe9bbfd-06ac-4a0c-80d7-e6786b55658d" class="modal-trigger">modules/combined/test/tests/inelastic_strain/elas_plas/elas_plas_nl1.i</a></li><li><a href="#aa2d989d-f22b-4628-b4a8-b2d276d5c3c6" class="modal-trigger">modules/richards/test/tests/theis/th02.i</a></li><li><a href="#56ac28d0-1358-42fb-898e-678d633cf918" class="modal-trigger">modules/xfem/test/tests/second_order_elements/square_branch_tri6_2d.i</a></li><li><a href="#ea6538e3-4667-4c7c-b07e-36289d9b7d91" class="modal-trigger">modules/contact/test/tests/verification/hertz_cyl/half_symm_q8/hertz_cyl_half_1deg_template3.i</a></li><li><a href="#c71cd972-afce-4657-b431-ec7e04665939" class="modal-trigger">modules/combined/test/tests/power_law_creep/power_law_creep_smallstrain.i</a></li><li><a href="#0f278c6f-23d0-453d-9702-cc7937d5c10b" class="modal-trigger">modules/combined/test/tests/evolving_mass_density/rz_tensors.i</a></li><li><a href="#3c7e6d46-06e9-4ef2-b8d6-f6a020867941" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_power.i</a></li><li><a href="#31a80b90-7ea4-47bd-9e30-0b61b693204a" class="modal-trigger">modules/tensor_mechanics/test/tests/strain_energy_density/nonAD_rate_model_weak_plane.i</a></li><li><a href="#99d94614-4c46-4256-abad-cb8efa04fb4c" class="modal-trigger">modules/tensor_mechanics/test/tests/strain_energy_density/rate_model_small.i</a></li><li><a href="#90b70aa0-6b93-4560-a691-796e4a308a2b" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_plane_stress.i</a></li><li><a href="#d3e429dd-2fc0-4aec-812c-aad6f61e6b3b" class="modal-trigger">modules/contact/test/tests/hertz_spherical/hertz_contact_rz.i</a></li><li><a href="#9da893ad-8314-4cd4-83d1-14bd16886fc3" class="modal-trigger">modules/peridynamics/test/tests/generalized_plane_strain/out_of_plane_pressure_OSPD.i</a></li><li><a href="#787570a2-ed35-450d-acc9-75303cc237a0" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/restart2.i</a></li><li><a href="#625b8de2-8d0d-4a57-b10f-13bb1b583eef" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/additional_volume.i</a></li><li><a href="#8d2d088c-d0ff-4248-b711-d1dbfc791ad0" class="modal-trigger">test/tests/misc/check_error/missing_function_file_test.i</a></li><li><a href="#76eaa8ce-0f79-4ded-9bd6-09cd41ea19d1" class="modal-trigger">modules/xfem/test/tests/diffusion_xfem/diffusion.i</a></li><li><a href="#49630299-b6ab-41e1-8b62-0514ffec3828" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/fric_constraint/2_block_common_cross_stick.i</a></li><li><a href="#ee8c6b49-8af9-4400-b3de-aebeae0e7d61" class="modal-trigger">modules/contact/test/tests/tension_release/8ElemTensionRelease.i</a></li><li><a href="#75f723ce-bc9a-45f1-94c7-fd3e801b803c" class="modal-trigger">modules/richards/test/tests/theis/th21.i</a></li><li><a href="#b811f94e-cc58-4180-ae22-ac2bb5061bde" class="modal-trigger">modules/tensor_mechanics/test/tests/czm/czm_patch_test.i</a></li><li><a href="#2b726810-c9c3-41ac-a189-f67290759f1d" class="modal-trigger">modules/tensor_mechanics/test/tests/combined_creep_plasticity/combined_creep_plasticity_start_time.i</a></li><li><a href="#49901e77-2046-428f-8a76-a5cfea69ce81" class="modal-trigger">modules/contact/test/tests/nodal_area/nodal_area_Hex20_3.i</a></li><li><a href="#8546124f-f914-454e-a835-98f8c1a6577e" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test4tt.i</a></li><li><a href="#864b4c88-7151-45c0-a580-0e116f83701a" class="modal-trigger">modules/richards/test/tests/buckley_leverett/bl22_lumped.i</a></li><li><a href="#e37e88b4-7dc0-4e46-b12b-0935f64ad3c7" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test3qns.i</a></li><li><a href="#2ba8fc72-25c8-4ce6-9e7a-4e11d5977700" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral_vtest/j_int_surfbreak_ellip_crack_sym_mm.i</a></li><li><a href="#681b2cab-3c28-44a3-b409-a41daff66a36" class="modal-trigger">modules/tensor_mechanics/test/tests/truss/truss_3d_action.i</a></li><li><a href="#6c54f1bd-5cdc-4f8a-a8c6-6d0de2399b7c" class="modal-trigger">modules/tensor_mechanics/test/tests/recompute_radial_return/isotropic_plasticity_finite_strain.i</a></li><li><a href="#faaddb9e-c2af-43c8-a856-d52c482862e4" class="modal-trigger">modules/tensor_mechanics/test/tests/combined_creep_plasticity/combined_creep_plasticity.i</a></li><li><a href="#3b64a4f5-dc6a-4aff-932c-f5500dcbc93e" class="modal-trigger">test/tests/misc/check_error/function_file_test4.i</a></li><li><a href="#724ee8bc-7e65-4df4-9831-e2b12c9628e4" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymmetric_gps_small.i</a></li><li><a href="#e5980d28-4d5e-40a6-8668-2360d99161d9" class="modal-trigger">modules/richards/test/tests/rogers_stallybrass_clements/rsc01.i</a></li><li><a href="#a44e3eec-bf36-44cc-81e8-c21d4c88d291" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_newmark.i</a></li><li><a href="#9ed71a79-10da-4aae-b9fa-ba9b4c92615c" class="modal-trigger">modules/tensor_mechanics/test/tests/strain_energy_density/ad_rate_model_weak_plane.i</a></li><li><a href="#5ed62b78-ddd1-49bf-b97b-dd8462996ff3" class="modal-trigger">modules/porous_flow/test/tests/infiltration_and_drainage/rd03.i</a></li><li><a href="#8b720aea-942e-443e-a605-2bee998c0ce2" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass.i</a></li><li><a href="#63bfb5a5-4bf3-47b4-975c-8479b3f24f7a" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test4qtt.i</a></li><li><a href="#8db5c77b-f1ec-4082-b90d-cad2416c3d33" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_plane_strain_small.i</a></li><li><a href="#02c185ee-faef-4cb5-9526-18940cd0d44f" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/static/large_strain_m_40_AD.i</a></li><li><a href="#0b5a357f-903b-432d-9fdc-0234d2d097b5" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_2d_small_strain.i</a></li><li><a href="#4c3decec-32f8-4489-9ec0-ddb8378b6666" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_as_2d.i</a></li><li><a href="#c20ac123-5c3b-41ce-9204-ff5f6b09f0b2" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral_vtest/j_int_surfbreak_ellip_crack_sym_mm_cm.i</a></li><li><a href="#da8dd9f8-c5ac-4180-b12c-63d1525a9261" class="modal-trigger">modules/richards/test/tests/buckley_leverett/bl22_lumped_fu.i</a></li><li><a href="#270ddb4c-a79d-43f9-beec-5f3bb9db1202" class="modal-trigger">modules/xfem/test/tests/pressure_bc/edge_2d_pressure.i</a></li><li><a href="#7e75d6c6-0345-4dcd-9eb5-6d336cb11703" class="modal-trigger">test/tests/functions/function_file_format/function_file_format_test.i</a></li><li><a href="#bed51eb3-3c74-4c1d-9fc4-7564a23a4ec7" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_function.i</a></li><li><a href="#46225f90-2200-4fdf-b357-007e5c667727" class="modal-trigger">modules/tensor_mechanics/test/tests/combined_creep_plasticity/combined_stress_relaxation.i</a></li><li><a href="#e9974658-7f63-407c-99fc-8f128d57b7d2" class="modal-trigger">modules/richards/test/tests/gravity_head_1/gh20.i</a></li><li><a href="#feba7da0-9522-469c-93ae-d842232fa2b6" class="modal-trigger">test/tests/multiapps/multilevel/time_dt_from_master_master.i</a></li><li><a href="#f739afe9-caaf-47a8-ac4a-d6b802edfa13" class="modal-trigger">modules/contact/test/tests/verification/hertz_cyl/half_symm_q4/hertz_cyl_half_1deg_template1.i</a></li><li><a href="#f03cb640-411e-48fb-924e-3b0a015061d7" class="modal-trigger">test/tests/misc/check_error/function_file_test2.i</a></li><li><a href="#7812a6f0-acdc-4c92-8977-61044fe7133b" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/prescribed_displacement/3D_QStatic_1_Ramped_Displacement_with_gravity.i</a></li><li><a href="#ef48ac1d-46b7-4122-9afa-b88c8849d9e5" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/finite_const.i</a></li><li><a href="#5794295c-6c07-4e97-854e-63bd042b080a" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/dilatation.i</a></li><li><a href="#5200cf9a-34af-4e68-a1fb-9b0ca885dc3e" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh18.i</a></li><li><a href="#ab31411e-c44c-4769-956d-658eec2c71b0" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/static/euler_finite_rot_y.i</a></li><li><a href="#809f515f-fac8-48a1-9b51-4b2b845bc36c" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test3.i</a></li><li><a href="#e82aea97-aa8b-4a4b-8469-fcd8e5d31420" class="modal-trigger">modules/contact/test/tests/incremental_slip/incremental_slip.i</a></li><li><a href="#52776d99-8a8b-4954-b149-af52d5f39626" class="modal-trigger">test/tests/misc/check_error/function_file_test16.i</a></li><li><a href="#69b2f471-ec21-4492-bac3-2bb99cd6456e" class="modal-trigger">modules/richards/test/tests/dirac/bh27.i</a></li><li><a href="#0aaa2fc7-1305-4a6a-8c42-d96b0fa7ec8c" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/constraints/glued_constraint.i</a></li><li><a href="#536327af-2a4c-4200-b16f-c2e33c3a9657" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/mandel_fully_saturated_volume.i</a></li><li><a href="#300b55f4-7420-4f16-a7ac-d6d1bc15fef4" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3qnstt.i</a></li><li><a href="#30e95957-01d2-4ef4-a9b8-b0fa8c9f6318" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass2.i</a></li><li><a href="#5a107d88-ecd7-4c23-97ae-9e50d08bd3fe" class="modal-trigger">framework/contrib/hit/test/output.i</a></li><li><a href="#ce5e3c0d-3cf8-4ae4-a963-58f62ad381da" class="modal-trigger">modules/contact/test/tests/hertz_spherical/hertz_contact_rz_quad8.i</a></li><li><a href="#c62d017a-a5fd-4227-82f8-2ad828d91ea3" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/2D/2d_nodalmass_explicit.i</a></li><li><a href="#dce9ad80-83cc-4710-aadf-c3d32cab34d6" class="modal-trigger">modules/combined/test/tests/phase_field_fracture/crack2d_computeCrackedStress_finitestrain_plastic.i</a></li><li><a href="#6917522b-fa39-48e4-b9a9-badd665fe85a" class="modal-trigger">modules/porous_flow/test/tests/infiltration_and_drainage/rd01.i</a></li><li><a href="#c9fd8d76-8502-4431-a6b6-86dc89a05173" class="modal-trigger">modules/richards/test/tests/theis/th_lumped_01.i</a></li><li><a href="#528be7be-e864-4aca-8d02-9ac43f9be4c5" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_plane_stress.i</a></li><li><a href="#ba0aed19-5129-48aa-922e-4b97ef73a3a8" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh_fu_18.i</a></li><li><a href="#1e51d3a6-9720-4628-b1ad-9ab070085d88" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_points.i</a></li><li><a href="#ed704cc3-9d99-41e2-8b09-f28b674b4884" class="modal-trigger">modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_3d_points.i</a></li><li><a href="#3265bc10-4fbc-4d20-a446-9607e1b1216f" class="modal-trigger">modules/tensor_mechanics/test/tests/finite_strain_tensor_mechanics_tests/finite_strain_patch.i</a></li><li><a href="#3968c358-f22e-46c5-aee3-3622eff0b787" class="modal-trigger">modules/tensor_mechanics/test/tests/thermal_expansion_function/small_linear.i</a></li><li><a href="#001e7347-a837-413d-adeb-9ad1995d8b28" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking.i</a></li><li><a href="#6eb748cd-bc3e-4600-abf7-884b1cd5cb0d" class="modal-trigger">test/tests/time_steppers/cutback_factor_at_failure/function_dt_cutback.i</a></li><li><a href="#8b408234-abd5-46d6-81ce-e5ca38b10153" class="modal-trigger">test/tests/misc/check_error/function_file_test14.i</a></li><li><a href="#e5b00a5e-e185-4b51-b6b1-135b50f66191" class="modal-trigger">modules/tensor_mechanics/test/tests/temperature_dependent_hardening/temp_dep_hardening.i</a></li><li><a href="#f4bfbabe-dbc2-4c8c-8fab-f23015626647" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/creep.i</a></li><li><a href="#6afab823-234f-49a8-abaf-7565af845a67" class="modal-trigger">test/tests/multiapps/picard/function_dt_master.i</a></li><li><a href="#c09b0a08-37f1-4e4e-acbe-288dd2d68b9c" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/rz.i</a></li><li><a href="#54ac402d-dc2d-4bcd-a24f-e69dca56ea8f" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_hht.i</a></li><li><a href="#f04b332b-3267-4ca1-ac91-d7b4cefc5b06" class="modal-trigger">test/tests/misc/check_error/function_file_test10.i</a></li><li><a href="#13a5f998-5b7f-4009-b586-5a79c58d1fbd" class="modal-trigger">modules/tensor_mechanics/test/tests/plane_stress/weak_plane_stress_small.i</a></li><li><a href="#db8a9ce1-af18-43b3-ac34-200e2b6472b0" class="modal-trigger">modules/xfem/test/tests/second_order_elements/diffusion_2d_quad9.i</a></li><li><a href="#d7f2c638-6e1a-4b84-882b-553344f6986e" class="modal-trigger">modules/richards/test/tests/broadbridge_white/bw02.i</a></li><li><a href="#5c289ba7-efe5-416a-8f0b-8da3af9dad67" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test1tt.i</a></li><li><a href="#f62ff17e-5f93-45a2-af22-8d42967432e8" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/planar_xy.i</a></li><li><a href="#d4e43159-a6a6-44ed-a531-decfb322c1f5" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_rz_exponential.i</a></li><li><a href="#d739d369-ca81-4e42-a2da-d6115e931fd9" class="modal-trigger">modules/tensor_mechanics/test/tests/thermal_expansion_function/small_const.i</a></li><li><a href="#2a07b42d-b0d4-496b-b331-4663193c9b4c" class="modal-trigger">modules/combined/test/tests/thermal_elastic/ad-thermal_elastic.i</a></li><li><a href="#26206ce9-3d2d-4f69-ace7-908bd05b8f3b" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/acceleration_bc/AccelerationBC_test_ti.i</a></li><li><a href="#0c93d114-ec0f-44e6-92a2-8e6cf0c0b5df" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_power.i</a></li><li><a href="#b56a6566-920c-4ea3-b7f9-e99a8c6aee16" class="modal-trigger">test/tests/misc/check_error/function_file_test6.i</a></li><li><a href="#6ee68e8b-def9-4568-9b2c-94073fe56a5d" class="modal-trigger">modules/contact/test/tests/verification/patch_tests/single_pnt_2d/single_point_2d_contact_line_search.i</a></li><li><a href="#35be9f0c-c7c6-4528-b693-57691193c468" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/static/euler_finite_rot_z.i</a></li><li><a href="#a347473b-3b6e-491f-849d-d00c548ca715" class="modal-trigger">modules/richards/test/tests/gravity_head_1/gh21.i</a></li><li><a href="#cab4e02b-12b3-42c3-b09f-3f7db1644247" class="modal-trigger">modules/contact/test/tests/verification/patch_tests/single_pnt_2d/single_point_2d_frictional.i</a></li><li><a href="#0d37ffe2-cf38-46ed-9114-1a8d8ca70af6" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_gps_small.i</a></li><li><a href="#33fee500-7fec-420f-bbae-dc8664e95dd8" class="modal-trigger">modules/tensor_mechanics/test/tests/interaction_integral_benchmark/input.i</a></li><li><a href="#0e4600b2-0acb-4caa-b97f-d10a91f792dd" class="modal-trigger">modules/combined/test/tests/power_law_creep/power_law_creep_restart1.i</a></li><li><a href="#72bf0acd-71cc-44c9-9650-b3b36a589d84" class="modal-trigger">modules/richards/test/tests/buckley_leverett/bl20_lumped.i</a></li><li><a href="#a7182977-482c-44f2-a4e2-67ab34a3abb3" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_single.i</a></li><li><a href="#0da60e36-5f7d-418a-91df-6d078b41000b" class="modal-trigger">modules/porous_flow/test/tests/dirackernels/bh04.i</a></li><li><a href="#b9ad119e-0037-4d7a-b869-c67605760cdf" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/planar_yz.i</a></li><li><a href="#1b2e9934-dba4-416e-99cc-055916020629" class="modal-trigger">modules/tensor_mechanics/test/tests/pressure/pressure_test.i</a></li><li><a href="#7c74d126-2144-4f56-8c46-de0d8b265ee9" class="modal-trigger">modules/combined/test/tests/adaptive_timestepping/adapt_tstep_function_force_step.i</a></li><li><a href="#33f704f8-f5cc-43bc-b7f6-211c2f55af47" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_gps_incremental.i</a></li><li><a href="#ecaa8c67-cf55-4d35-8d39-5b1c5f0da29d" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/1D/1d_consistent_explicit.i</a></li><li><a href="#63d8402d-edef-472a-a215-0c2c0e5d3e08" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_rz_test.i</a></li><li><a href="#a577f975-2c8c-4449-9c20-a50819c4b3a4" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_rayleigh_hht_action.i</a></li><li><a href="#8bc4c36e-87ee-4da1-83b6-6aaa2d7b6352" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D.i</a></li><li><a href="#2ffec56a-fdac-4698-b974-36dbe691812e" class="modal-trigger">modules/tensor_mechanics/test/tests/strain_energy_density/tot_model.i</a></li><li><a href="#0e66896e-4b07-4654-95e0-bbf2d608765d" class="modal-trigger">modules/contact/test/tests/hertz_spherical/hertz_contact_hex27.i</a></li><li><a href="#d1cb70f4-1c8d-4cc4-9002-ae7cfc3f6c3d" class="modal-trigger">modules/xfem/test/tests/second_order_elements/diffusion_2d_tri6.i</a></li><li><a href="#e5bb58c7-2842-4b19-a121-3567b97ad450" class="modal-trigger">modules/combined/test/tests/cavity_pressure/3d.i</a></li><li><a href="#91fa075f-a34f-4134-a9d1-b5aa19d0081a" class="modal-trigger">modules/combined/test/tests/internal_volume/rz_displaced_quad8.i</a></li><li><a href="#62a04ddf-d5d5-4684-8ab2-bcc0ea30b238" class="modal-trigger">modules/richards/test/tests/gravity_head_1/gh_fu_22.i</a></li><li><a href="#9d4c1d99-f16b-4a74-aa07-d15bce879f07" class="modal-trigger">modules/combined/test/tests/cavity_pressure/initial_temperature.i</a></li><li><a href="#aecb2d11-03a5-4b07-abd7-2a85d792a0ac" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/3D/3d_lumped_explicit.i</a></li><li><a href="#18058189-da2d-454e-9d9f-e9dadeec4e7b" class="modal-trigger">test/tests/postprocessors/function_element_integral/function_element_integral.i</a></li><li><a href="#5874182a-ac01-47b7-a3fa-6a2789bb8cea" class="modal-trigger">modules/porous_flow/test/tests/infiltration_and_drainage/bw02.i</a></li><li><a href="#b6384c9b-8831-4781-96cb-53afdfb572e2" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test1.i</a></li><li><a href="#71d857f6-fc2b-4a57-90de-d03dff8e0dfd" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_plane_strain_incremental.i</a></li><li><a href="#761df66b-2897-4b0e-9c56-3d1f2e2f0b28" class="modal-trigger">modules/contact/test/tests/nodal_area/nodal_area_Hex20.i</a></li><li><a href="#ae3488d3-e0a4-48e0-86c5-3a05ffad6a15" class="modal-trigger">modules/tensor_mechanics/test/tests/generalized_plane_strain/plane_strain_prescribed.i</a></li><li><a href="#b7bbe695-2630-465c-84a5-00e35fcaf651" class="modal-trigger">modules/richards/test/tests/buckley_leverett/bl21.i</a></li><li><a href="#c75fbb43-53c8-4c98-b584-b677870eb5aa" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_timoshenko_small.i</a></li><li><a href="#551897e5-0590-40aa-be35-07014a9a49d1" class="modal-trigger">modules/richards/test/tests/theis/th_lumped_22.i</a></li><li><a href="#25f6e0c4-5202-4902-b57f-69b98bb65f25" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test2qtt.i</a></li><li><a href="#46ef241a-9f0a-4526-8fdb-267b6fd97b60" class="modal-trigger">modules/richards/test/tests/recharge_discharge/rd02.i</a></li><li><a href="#fa58b152-e37a-4e2d-81b8-59b335021eb1" class="modal-trigger">modules/porous_flow/test/tests/infiltration_and_drainage/rsc01.i</a></li><li><a href="#e3730d70-e614-4c9f-b11e-56a2864596a3" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/mandel_fully_saturated.i</a></li><li><a href="#1dc8f002-3f4e-48f1-b832-8a1840752d48" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test2.i</a></li><li><a href="#4b34ab4c-0f3d-4c35-ade0-51471789dbbf" class="modal-trigger">modules/richards/test/tests/dirac/bh_fu_08.i</a></li><li><a href="#cc71cb65-64f7-422b-89c8-199c776637d0" class="modal-trigger">modules/xfem/test/tests/second_order_elements/diffusion_2d_quad8.i</a></li><li><a href="#51b59bb1-ba62-45ca-a43b-a171e7e8d727" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test4qtt.i</a></li><li><a href="#5ba28bf2-e4a5-4da8-9cf2-2cee58340698" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/2D/2d_nodalmass_implicit.i</a></li><li><a href="#46bcb29a-0cd5-4865-b599-be0ced9ef00e" class="modal-trigger">modules/tensor_mechanics/test/tests/plane_stress/weak_plane_stress_finite.i</a></li><li><a href="#07641752-c40b-4598-a885-6bccd5e442db" class="modal-trigger">modules/richards/test/tests/dirac/bh_fu_05.i</a></li><li><a href="#8966fb70-3051-4ad6-8e38-526876a72a63" class="modal-trigger">modules/xfem/test/tests/init_solution_propagation/init_solution_propagation.i</a></li><li><a href="#ab8c20f2-6c94-4b1c-b85e-8f2e322f4fbc" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/sphere3D.i</a></li><li><a href="#7d64c7c9-0fe3-4f97-b24c-dbaeaf13de90" class="modal-trigger">modules/richards/test/tests/buckley_leverett/bl22.i</a></li><li><a href="#bca4fa82-64a4-426d-ad83-28eb06165f64" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/time_integration/newmark_test.i</a></li><li><a href="#5f91786d-ce4b-4a9d-bff2-e4cccab26fd0" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_exponential_deprecated.i</a></li><li><a href="#36d272b7-1c6f-44f1-9cfe-6644fba4ec8c" class="modal-trigger">framework/contrib/hit/test/input.i</a></li><li><a href="#ce42d44e-2287-436e-827c-4ac7507ae430" class="modal-trigger">test/tests/time_steppers/iteration_adaptive/hit_function_knot.i</a></li><li><a href="#a12e0a60-e782-4936-8220-c03a61db1ae4" class="modal-trigger">test/tests/misc/check_error/function_file_test9.i</a></li><li><a href="#8fffbe2a-8f3f-4825-adce-257bb2b8f5d3" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test1qtt.i</a></li><li><a href="#03796172-c3a1-4ee5-89e4-0c181d41ea14" class="modal-trigger">modules/tensor_mechanics/test/tests/domain_integral_thermal/j_integral_2d_ctefunc.i</a></li><li><a href="#10a5e9f4-46e9-4393-b136-7064147822df" class="modal-trigger">modules/xfem/test/tests/diffusion_xfem/levelsetcut3d.i</a></li><li><a href="#69ad1d82-945a-4533-9e88-960aed61b814" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test3ns.i</a></li><li><a href="#2124c247-78f7-4103-b34d-f42d2b3ce4c8" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test2q.i</a></li><li><a href="#0ce5c9bf-2fde-4297-8a24-f1b3be025071" class="modal-trigger">modules/contact/test/tests/normalized_penalty/normalized_penalty.i</a></li><li><a href="#1a52a2dd-4f2d-46b3-968a-c34b284a8e0d" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh_fu_05.i</a></li><li><a href="#866ba055-eee6-442c-b4d4-59f02ae74fe0" class="modal-trigger">modules/combined/test/tests/adaptive_timestepping/adapt_tstep_function_change_restart1.i</a></li><li><a href="#c0316427-6854-4000-ac85-824bd79b1bfd" class="modal-trigger">modules/tensor_mechanics/test/tests/combined_creep_plasticity/combined_stress_prescribed.i</a></li><li><a href="#8614ce41-1b17-4ff8-bed9-d3558a8a7a70" class="modal-trigger">modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_3d_as_2d.i</a></li><li><a href="#5a136da3-34c1-4b7d-b05b-3db1998742f7" class="modal-trigger">modules/combined/test/tests/ad_power_law_creep/power_law_creep_restart1.i</a></li><li><a href="#db25cd60-fde8-40f6-b165-07a0832b470f" class="modal-trigger">modules/contact/test/tests/normalized_penalty/normalized_penalty_kin.i</a></li><li><a href="#26b29524-9e3e-4755-beff-cd04b5f145ed" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/3D/3d_nodalmass_implicit.i</a></li><li><a href="#60d918b2-3a4d-4581-9d5e-aa55c90d37fc" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4qnstt.i</a></li><li><a href="#f7ed441e-1ed0-4e15-88e5-4b1f75dd2a49" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/1D/1d_consistent_implicit.i</a></li><li><a href="#a0e405fa-352a-4f87-ba09-4d905806d5b4" class="modal-trigger">modules/richards/test/tests/gravity_head_1/gh23.i</a></li><li><a href="#add13e2c-e44c-4e46-8464-6df885f0b8a4" class="modal-trigger">modules/combined/test/tests/combined_plasticity_temperature/plasticity_temperature_dep_yield.i</a></li><li><a href="#2637c936-27ad-4fd2-9bd6-fff681ed2276" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test4qnns.i</a></li><li><a href="#02d1c7ae-0df8-48e7-83ad-589e0a574a69" class="modal-trigger">modules/combined/test/tests/thermal_strain/thermal_strain.i</a></li><li><a href="#0db5fb81-dc64-4505-b64b-072e04bcfa86" class="modal-trigger">modules/tensor_mechanics/test/tests/truss/truss_2d_action.i</a></li><li><a href="#d9f1ebb3-38d1-45aa-8aff-8838b0e112ec" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/finite_linear.i</a></li><li><a href="#842ff250-1e92-4e5a-9d8b-aa8a7a887f7f" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral_vtest/c_int_surfbreak_ellip_crack_sym_mm.i</a></li><li><a href="#614a298a-8813-493a-bbbf-3f9ee9ed857b" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free_orientation_inclined_hht.i</a></li><li><a href="#656bca78-7c7b-4342-85b0-dc7a68d4e0ee" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_multiple_softening.i</a></li><li><a href="#38f5a8e3-a48f-491f-9b87-e7ca4469d3be" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test1tt.i</a></li><li><a href="#42442cfd-08c2-4279-adf9-4be7e39ef822" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_hht_ti.i</a></li><li><a href="#b8041719-87c3-4848-bf79-959537bbc7bd" class="modal-trigger">modules/geochemistry/test/tests/time_dependent_reactions/seawater_evaporation_flow_through.i</a></li><li><a href="#c5c1f45d-f2fc-4cf2-bad9-3ab5f553f467" class="modal-trigger">modules/xfem/test/tests/pressure_bc/edge_3d_pressure.i</a></li><li><a href="#e9b0f56f-cf9d-434a-965b-205e019fc013" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_test.i</a></li><li><a href="#878d9601-327b-4a17-ac44-1acced0ea6e6" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/3D/3d_consistent_implicit.i</a></li><li><a href="#47ec753e-4b04-44c8-8585-f328c2c3ef51" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/mandel_basicthm.i</a></li><li><a href="#29eac931-7d7b-41a9-9808-d5eeca92ec7c" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/constraints/frictionless_constraint.i</a></li><li><a href="#0b145dfe-0d9d-4b46-a00d-fe309008102f" class="modal-trigger">modules/richards/test/tests/rogers_stallybrass_clements/rsc02.i</a></li><li><a href="#99855d40-af89-46b0-9872-c95da71183a8" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free.i</a></li><li><a href="#5d2dd839-db74-4cf7-b300-3c7d65231bc8" class="modal-trigger">modules/xfem/test/tests/second_order_elements/diffusion_3d_hex27.i</a></li><li><a href="#18aaeebe-6a4f-4553-a14e-501256afdb80" class="modal-trigger">modules/tensor_mechanics/test/tests/generalized_plane_strain/out_of_plane_pressure.i</a></li><li><a href="#cce58486-248b-423e-be43-48d7102e4c03" class="modal-trigger">modules/navier_stokes/test/tests/ins/jeffery_hamel/wedge_dirichlet.i</a></li><li><a href="#6dc2e1b9-edf6-48b0-8da8-84929b37200b" class="modal-trigger">test/tests/misc/check_error/function_file_test15.i</a></li><li><a href="#6b601c43-bbbc-47f9-b1f2-394fa2b534ff" class="modal-trigger">modules/tensor_mechanics/test/tests/scalar_material_damage/scalar_material_damage_creep.i</a></li><li><a href="#8b460a21-bd60-47d4-9e43-32f0d3bd9613" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test2q.i</a></li><li><a href="#57055127-330e-4e49-89af-ee3d30c0269b" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_gravity.i</a></li><li><a href="#c949d621-e698-41f2-a72e-72d07641486a" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh08.i</a></li><li><a href="#68bc077e-9ac3-4723-b7a3-fb1c49105323" class="modal-trigger">modules/tensor_mechanics/test/tests/elastic_patch/elastic_patch.i</a></li><li><a href="#055eaebe-2d31-4676-b518-8731fc65c1ea" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh_fu_17.i</a></li><li><a href="#7972801f-21ab-4c58-a9c1-19de4d11eb99" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/1D/1d_lumped_explicit.i</a></li><li><a href="#830dd845-95d4-4fca-849b-c86f59db194d" class="modal-trigger">test/tests/functions/vector_postprocessor_function/vector_postprocessor_function.i</a></li><li><a href="#d77fce90-3eee-4dd0-9bc3-9bc47a2c3c2d" class="modal-trigger">modules/contact/test/tests/ring_contact/ring_contact.i</a></li><li><a href="#424c52a3-2bd4-4eb3-86a2-d95045eeff0d" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_convex/gap_heat_transfer_convex_gap_offsets.i</a></li><li><a href="#d6dfa47a-3b2a-431e-98d7-252caab66286" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh_lumped_17.i</a></li><li><a href="#c3feffd1-c180-480b-98f8-30340a87fda2" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/time_integration/hht_test_ti.i</a></li><li><a href="#de5bff04-fd51-4393-b9d8-6369f40b7f0e" class="modal-trigger">modules/combined/test/tests/elastic_thermal_patch/elastic_thermal_patch.i</a></li><li><a href="#dff24c6c-d5d6-4208-b432-b30455409248" class="modal-trigger">modules/combined/test/tests/evolving_mass_density/uniform_expand_compress_test_tensors.i</a></li><li><a href="#29ea5cd9-e45e-4697-abfa-5e51337a452f" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3qns.i</a></li><li><a href="#37b41898-ee0f-4434-aae0-e8d39eacab5c" class="modal-trigger">modules/combined/test/tests/generalized_plane_strain_tm_contact/out_of_plane_pressure.i</a></li><li><a href="#8dee9511-faf5-4256-9878-bf5cf6b54b79" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_rz.i</a></li><li><a href="#6fb13707-1b68-4634-89bf-006759523c3a" class="modal-trigger">modules/contact/test/tests/normal-nodal-lm-tan-tolerance/normal-nodal-lm-tan-tolerance.i</a></li><li><a href="#22954ce8-78ef-479e-ad27-ded889912783" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test1qtt.i</a></li><li><a href="#0209061b-8378-42a6-ac28-c5ec416767c4" class="modal-trigger">modules/contact/test/tests/verification/hertz_cyl/quart_symm_q8/hertz_cyl_qsym_1deg_template1.i</a></li><li><a href="#e15eead2-6b7e-4b2a-82fd-7cf5903ff093" class="modal-trigger">modules/richards/test/tests/buckley_leverett/bl20.i</a></li><li><a href="#65fe7852-6750-49b5-94ee-f6d15ba6c6dc" class="modal-trigger">modules/contact/test/tests/tension_release/4ElemTensionRelease.i</a></li><li><a href="#210b62bb-5aa8-450c-84c5-6e18fc85f1e5" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_2d_points.i</a></li><li><a href="#bfa48199-38d5-4e19-a832-39b967e68461" class="modal-trigger">modules/tensor_mechanics/test/tests/thermal_expansion_function/finite_const.i</a></li><li><a href="#da3ca1e6-cadb-4078-b199-94b54dd5c7ee" class="modal-trigger">modules/richards/test/tests/dirac/bh04.i</a></li><li><a href="#a78ba1b0-a69e-4382-837e-94a0259024e4" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test3qnns.i</a></li><li><a href="#8a9abb76-60d2-4c9a-844c-4e165d840737" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/test_crack_counter.i</a></li><li><a href="#c17b4629-197e-4e29-8341-b44709caf44d" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test4tt.i</a></li><li><a href="#f38442da-6e97-4d0d-95a0-b815d3136297" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh05.i</a></li><li><a href="#fb0ee7c0-cdce-470e-b437-cde6c875dc5b" class="modal-trigger">modules/richards/test/tests/dirac/bh_fu_07.i</a></li><li><a href="#7afeaea7-631a-4258-8652-804107088c3f" class="modal-trigger">test/tests/misc/check_error/function_file_test11.i</a></li><li><a href="#0ee4d248-6af6-49ef-be9b-c4c1f87c082f" class="modal-trigger">modules/tensor_mechanics/test/tests/domain_integral_thermal/interaction_integral_2d_c.i</a></li><li><a href="#e3b5c267-4e0d-4eb4-a3e3-91a4323143b1" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_gps_finite.i</a></li><li><a href="#d15a5f49-833a-464e-876c-d36d30190431" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/prescribed_displacement/3D_QStatic_1_Ramped_Displacement.i</a></li><li><a href="#5476a6bb-1c7b-469a-90d4-5ab93ce1b836" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_it_plot_test.i</a></li><li><a href="#98d5c579-8574-4e2d-9d17-bec1ce7d8816" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_exponential_deprecated.i</a></li><li><a href="#b06411e1-18b8-4d95-a4ba-f315382d2be8" class="modal-trigger">modules/contact/test/tests/verification/hertz_cyl/quart_symm_q4/hertz_cyl_qsym_1deg_template1.i</a></li><li><a href="#fcdc9b25-f2f5-4014-bd22-4da721c1a025" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_exponential.i</a></li><li><a href="#860f63bd-9944-4fff-b96c-f1a5b4fd016c" class="modal-trigger">test/tests/time_steppers/iteration_adaptive/piecewise_linear.i</a></li><li><a href="#7c92e63d-cddc-4422-8e6a-0e6909d06ee7" class="modal-trigger">test/tests/controls/control_piecewise/controlled_piecewise.i</a></li><li><a href="#dfdab61a-4091-4849-b15e-cf44828166d7" class="modal-trigger">modules/tensor_mechanics/test/tests/line_material_rank_two_sampler/rank_two_sampler.i</a></li><li><a href="#95289863-5c47-4e49-9dc2-df7d2ac20ebf" class="modal-trigger">test/tests/misc/check_error/function_file_test3.i</a></li><li><a href="#d386856c-59d7-4058-bc3a-a2c6dd489f13" class="modal-trigger">modules/tensor_mechanics/test/tests/recompute_radial_return/isotropic_plasticity_errors.i</a></li><li><a href="#d78049b8-4aeb-4c05-adc2-8f5d96e5e8f7" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test4q.i</a></li><li><a href="#876a9b81-7f11-483d-81ab-c0cb5a9a8a1f" class="modal-trigger">modules/richards/test/tests/theis/th01.i</a></li><li><a href="#bdcda029-92b9-4526-8b9c-7878c5556cce" class="modal-trigger">modules/xfem/test/tests/diffusion_xfem/levelsetcut2d.i</a></li><li><a href="#ef6190b8-c54a-4fa5-89d9-95c1673544f3" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh_lumped_08.i</a></li><li><a href="#ae8798dd-aeb7-4b42-a054-c1f43cde9758" class="modal-trigger">modules/geochemistry/test/tests/time_dependent_reactions/seawater_evaporation_no_flow_through.i</a></li><li><a href="#d5857590-4323-49e7-b8e0-995c9d52b2f1" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test3q.i</a></li><li><a href="#e08b1cff-6080-4cf8-bb1d-299b8f626e0d" class="modal-trigger">modules/tensor_mechanics/test/tests/strain_energy_density/rate_model.i</a></li><li><a href="#b37fc298-cbea-44c4-88e6-0f6ec247b943" class="modal-trigger">modules/combined/test/tests/internal_volume/rz_cone.i</a></li><li><a href="#d9781cb1-960b-4d4b-a9a6-bcae05a76d23" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_deprecated.i</a></li><li><a href="#ec14dd8d-5489-4065-8b13-c14da55c93d5" class="modal-trigger">modules/combined/test/tests/axisymmetric_2d3d_solution_function/2d.i</a></li><li><a href="#653d09fc-d9a6-4a1a-8874-a92872a50697" class="modal-trigger">modules/richards/test/tests/dirac/bh_lumped_07.i</a></li><li><a href="#bd0c9e7a-6988-472d-bbcf-493e1c9e76f6" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_as_2d_topo_q_func.i</a></li><li><a href="#211e2382-d9ae-46f8-8041-82b959fe0784" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test4ns.i</a></li><li><a href="#fc74181e-d540-469a-bc4f-ef39965e2eb6" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_2d.i</a></li><li><a href="#f36d6477-18bf-4cb0-abe0-77b7ba193445" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_mouth_dir.i</a></li><li><a href="#fd3f0b6d-24f3-45df-b74d-76eca803a6be" class="modal-trigger">modules/xfem/test/tests/pressure_bc/2d_pressure_displaced_mesh.i</a></li><li><a href="#4868102e-f59e-45bd-b610-e01429ab1039" class="modal-trigger">modules/xfem/test/tests/second_order_elements/diffusion_quad9_levelsetcut.i</a></li><li><a href="#ee8c46f7-ed6e-4ef3-b548-a3ac7c4faff9" class="modal-trigger">modules/richards/test/tests/theis/th_lumped_02.i</a></li><li><a href="#7d1ddf0d-d21e-4ddf-a703-670613a01543" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test4nns.i</a></li><li><a href="#79179453-f2ba-412d-a288-3350afbc52da" class="modal-trigger">test/tests/misc/check_error/function_file_test7.i</a></li><li><a href="#08139623-52c0-4616-a548-0febfbe16ccd" class="modal-trigger">modules/contact/test/tests/verification/patch_tests/single_pnt_2d/single_point_2d.i</a></li><li><a href="#08d4f434-20cf-481b-93d9-9ad300bf72c6" class="modal-trigger">modules/xfem/test/tests/second_order_elements/diffusion_3d_tet10.i</a></li><li><a href="#e86608ef-4c61-45c9-a0be-f1ee8b7ae79c" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3nnstt.i</a></li><li><a href="#42956e9a-58a2-46cf-b8f8-85fa3f8299f2" class="modal-trigger">modules/tensor_mechanics/test/tests/strain_energy_density/incr_model_elas_plas.i</a></li><li><a href="#372792c7-8919-4db9-8138-e68c8ab0032a" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test2qtt.i</a></li><li><a href="#c639f428-0768-4cd4-ae50-e637f943103e" class="modal-trigger">modules/tensor_mechanics/test/tests/scalar_material_damage/combined_scalar_damage.i</a></li><li><a href="#7fa4f3a8-302f-43f5-9394-ff2b923a4d3a" class="modal-trigger">modules/tensor_mechanics/test/tests/recompute_radial_return/affine_plasticity.i</a></li><li><a href="#33d863eb-1023-42cc-9a40-d110868fe82a" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_radiation/gap_heat_transfer_radiation_test.i</a></li><li><a href="#60df40e7-a667-4e8b-8787-bb467cfd8005" class="modal-trigger">test/tests/misc/check_error/function_file_test17.i</a></li><li><a href="#b12fc0e6-7f5d-4d34-910f-7bc679ff0b04" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test4.i</a></li><li><a href="#a6ec3497-3e06-4d70-b120-b5379ac9a592" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_newmark_material_dependent.i</a></li><li><a href="#e155e1c2-c5b0-4fff-93f8-e5e067339ce9" class="modal-trigger">test/tests/auxkernels/time_integration/time_integration.i</a></li><li><a href="#17dc52a2-5c77-48d8-b6b8-df7ee8d5ba2a" class="modal-trigger">modules/xfem/test/tests/second_order_elements/diffusion_2d_quad9_test.i</a></li><li><a href="#87bb2cc9-a403-410f-9e26-015e939cda4d" class="modal-trigger">modules/contact/test/tests/verification/hertz_cyl/half_symm_q8/hertz_cyl_half_1deg_template1.i</a></li><li><a href="#2eaaa47f-12bb-419e-a071-c31e82ff0e30" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_function.i</a></li><li><a href="#8b1f2c8f-3a49-49e0-af28-84aebb3ce60e" class="modal-trigger">modules/combined/test/tests/internal_volume/hex20.i</a></li><li><a href="#2920bc09-7f06-47df-9bab-3b275c89dad8" class="modal-trigger">test/tests/misc/check_error/function_file_test1.i</a></li><li><a href="#87c80e3b-0d68-4215-9fed-931beb42d449" class="modal-trigger">modules/richards/test/tests/gravity_head_1/gh22.i</a></li><li><a href="#79e0744d-bf25-4463-abd4-aac3a85bab2b" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_rayleigh_hht_ti.i</a></li><li><a href="#be548480-b6af-4812-8ad7-7167368b703e" class="modal-trigger">modules/xfem/test/tests/second_order_elements/diffusion_3d_hex20.i</a></li><li><a href="#ed9f8075-80ce-4c38-9a25-f9f1d8de2690" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment.i</a></li><li><a href="#cbfc96f6-29e4-4496-bf29-873c2e7b7f12" class="modal-trigger">modules/porous_flow/test/tests/buckley_leverett/bl01.i</a></li><li><a href="#32eff997-b02b-4d77-9f90-9602d17ca112" class="modal-trigger">modules/combined/test/tests/fdp_geometric_coupling/fdp_geometric_coupling.i</a></li><li><a href="#35f6f244-007b-4599-8324-3fd90ae74d84" class="modal-trigger">modules/combined/test/tests/internal_volume/rspherical.i</a></li><li><a href="#910790e9-d992-4db5-9e2d-1341cee8e40f" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test1.i</a></li><li><a href="#f3556b79-4da0-4899-95ac-660fd5c4862d" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/1D/1d_nodalmass_implicit.i</a></li><li><a href="#1c37af33-cad1-4a1f-852d-b27b49037d41" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test2tt.i</a></li><li><a href="#bcee3f25-1138-4850-b2e1-abe579dba16a" class="modal-trigger">modules/combined/test/tests/thermal_conductivity_temperature_function_test/thermal_conductivity_temperature_function_test.i</a></li><li><a href="#afbe06d1-184d-47ca-aaaf-9521797b4de9" class="modal-trigger">test/tests/test_harness/csv_validation_tester_01.i</a></li><li><a href="#03b9d3a1-eb88-4e8c-9ebb-5903d23a7300" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_xyz.i</a></li><li><a href="#acacfa24-12c6-4877-9a9e-be159701c061" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_hht.i</a></li><li><a href="#7894f2a4-2661-435c-86c4-197464cfbed6" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh06.i</a></li><li><a href="#dcc93163-22a6-41fd-b764-9b7f88a1309c" class="modal-trigger">modules/contact/test/tests/hertz_spherical/hertz_contact.i</a></li><li><a href="#46beff83-824c-45fd-9b1c-7059b6dfa039" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_dual.i</a></li><li><a href="#7d75cb4b-d511-45c8-b0b6-3a5bf3d9b01d" class="modal-trigger">modules/combined/test/tests/internal_volume/rz_quad8.i</a></li><li><a href="#f6fb6c27-0a3a-436e-95cf-1375b3d5a114" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/3d.i</a></li><li><a href="#cf970470-2d72-4479-a48f-34a86d978783" class="modal-trigger">modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_2d_rot.i</a></li><li><a href="#1fe79850-7458-444e-998d-944e79f27292" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3nstt.i</a></li><li><a href="#332fada5-de34-4032-bfbd-18fcfbeffb4a" class="modal-trigger">modules/xfem/test/tests/mechanical_constraint/glued_penalty.i</a></li><li><a href="#b6ad4b8f-f81b-4c82-9779-60ee38966466" class="modal-trigger">modules/combined/test/tests/adaptive_timestepping/adapt_tstep_function_change.i</a></li><li><a href="#d67477e3-c01f-4251-9f00-43498e4c0e83" class="modal-trigger">modules/porous_flow/test/tests/infiltration_and_drainage/bw01.i</a></li><li><a href="#eefb81f5-dc8c-499c-8d40-60042c684fb0" class="modal-trigger">modules/geochemistry/test/tests/solubilities_and_activities/gypsum_solubility.i</a></li><li><a href="#2f2f9f3a-1d60-401c-82a2-1cec0849077d" class="modal-trigger">test/tests/misc/check_error/function_file_test5.i</a></li><li><a href="#2468baf0-7d5a-4ab0-a9dc-d9436587272c" class="modal-trigger">modules/xfem/test/tests/second_order_elements/square_branch_quad8_2d.i</a></li><li><a href="#78a21757-1a09-4490-8987-ea1a94ca2180" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D_xz.i</a></li><li><a href="#9b995ed6-0a66-4110-96ee-f63d097996da" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_multiple_softening.i</a></li><li><a href="#de7c50e4-2173-4e0a-bccb-2e539e147025" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/planar_xz.i</a></li><li><a href="#e06694f7-54ed-4671-acfa-7601e35e491c" class="modal-trigger">modules/xfem/test/tests/second_order_elements/square_branch_quad9_2d.i</a></li><li><a href="#ce25f89a-a51e-4b9d-acc6-dab42728d037" class="modal-trigger">modules/combined/test/tests/internal_volume/rz_displaced.i</a></li><li><a href="#76d0a1bc-ab47-4761-a69d-e05a84545d96" class="modal-trigger">modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_3d.i</a></li><li><a href="#3987b606-4ab1-42e9-9f85-8f648c7f0cdb" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4nnstt.i</a></li><li><a href="#69acd70d-da84-4c2b-bf4c-c4cb0fbcb40a" class="modal-trigger">modules/combined/test/tests/internal_volume/hex8.i</a></li><li><a href="#5a580c75-4499-4045-abcd-8f6d0566340d" class="modal-trigger">test/tests/multiapps/sub_cycling_failure/master_gold.i</a></li><li><a href="#4e51f044-561b-44c8-8abb-edf172f4af93" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral_vtest/j_int_surfbreak_ellip_crack_sym_mm_cfp_cm.i</a></li><li><a href="#5e0688fe-d126-48ee-842a-de82c1bfc6d0" class="modal-trigger">test/tests/time_steppers/iteration_adaptive/adapt_tstep_pps_lim.i</a></li><li><a href="#5543b679-1356-405c-90e7-6ceb5aa6a2f6" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_xyz.i</a></li><li><a href="#85046aa6-3a7b-4fb6-9552-caa42d8bef1a" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test3.i</a></li><li><a href="#0238a1f6-b2ad-4b06-ac7b-871ecf4371a1" class="modal-trigger">modules/tensor_mechanics/test/tests/thermal_expansion_function/finite_linear.i</a></li><li><a href="#d8a905f0-9466-40ef-ac05-bfe707fda4d0" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_rspherical.i</a></li><li><a href="#7a5174fa-a955-4d8f-a31c-2d3ffcad6919" class="modal-trigger">modules/tensor_mechanics/test/tests/thermal_expansion_function/dilatation.i</a></li><li><a href="#926523b5-6974-43f1-8b3b-4dcacb286992" class="modal-trigger">test/tests/misc/check_error/function_file_test12.i</a></li><li><a href="#e96275b1-d46e-4086-a6fa-23513f4f119f" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/1D/1d_nodalmass_explicit.i</a></li><li><a href="#4c6d60b4-324b-42f1-a5bc-aa55d3c7e8df" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_single_split.i</a></li><li><a href="#e3b0bb92-ecfa-4487-aa2f-fadde683fef7" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_newmark.i</a></li><li><a href="#aaafa7b3-e7bb-4389-ae4d-af039e866b56" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_rayleigh_hht.i</a></li><li><a href="#61b7f2f3-e6ba-4649-8101-acc85eb38ee6" class="modal-trigger">modules/xfem/test/tests/moment_fitting/diffusion_moment_fitting_four_points.i</a></li><li><a href="#0d54d2d0-9d69-4c68-b73e-2ce802f8fdbc" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/square_branch_tri_2d.i</a></li><li><a href="#af840b96-b6da-4c00-ad3c-f1e2dbc48f0d" class="modal-trigger">modules/combined/test/tests/power_law_creep/power_law_creep_restart2.i</a></li><li><a href="#c0660e9c-af97-4e2b-becc-6d00e6496857" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test4q.i</a></li><li><a href="#3f0eac92-6fcc-4f73-8591-583244308f88" class="modal-trigger">modules/xfem/test/tests/moment_fitting/diffusion_moment_fitting_six_points.i</a></li><li><a href="#c4344f83-65b9-4c10-bed4-d1e7e6f1dde9" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh17.i</a></li><li><a href="#01e4c9e1-797f-4480-8f6b-bc609bb7c5c9" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_mouth_dir_end_dir_vec.i</a></li><li><a href="#73f8755d-a8c5-401e-a99b-ce5769b7c09c" class="modal-trigger">modules/combined/test/tests/cavity_pressure/additional_volume.i</a></li><li><a href="#515a4a7d-9f3c-4064-9096-19e3aaccd2a7" class="modal-trigger">modules/tensor_mechanics/test/tests/line_material_rank_two_sampler/rank_two_scalar_sampler.i</a></li><li><a href="#8a51396d-38c8-48e9-9dc3-94dc9b8fe59a" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/gtn_single.i</a></li><li><a href="#033e80b1-9e10-473c-bacb-b32385ddfc48" class="modal-trigger">modules/tensor_mechanics/test/tests/material_limit_time_step/elas_plas/nafems_nl1_lim.i</a></li><li><a href="#45fcadcb-39c3-4c78-bc21-e9e4a65ecf52" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/2D/2d_consistent_explicit.i</a></li><li><a href="#207a33b0-bdf2-4959-ad4c-3faebec93a94" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/mandel_constM.i</a></li><li><a href="#ffe05a53-eab8-4c69-84a9-f549998ae6b1" class="modal-trigger">modules/tensor_mechanics/test/tests/creep_tangent_operator/creep.i</a></li><li><a href="#85f9d575-26bc-442d-972e-953751bb660e" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/square_branch_quad_2d.i</a></li><li><a href="#dcdd9a46-6699-43cf-8d37-616c3d914eb8" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/initial_temperature.i</a></li><li><a href="#acad31d1-426a-4725-95ef-21a8df147a2a" class="modal-trigger">modules/porous_flow/test/tests/gravity/grav02d.i</a></li><li><a href="#bfbeebfb-fa75-4d80-b171-28e4d2b2a1d2" class="modal-trigger">modules/tensor_mechanics/test/tests/t_stress/t_stress_crack_infinite_plate_2d.i</a></li><li><a href="#6f5d1bfe-0609-4617-9cbd-9deb381743c5" class="modal-trigger">modules/contact/test/tests/tension_release/4ElemTensionRelease_mechanical_constraint.i</a></li><li><a href="#de812cd3-d443-4b48-a7b3-6764d034aba2" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_inertia_damping_action.i</a></li><li><a href="#8433c1e9-a011-47a5-b9bb-88dfe9d6bbf3" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test3tt.i</a></li><li><a href="#d41a8268-1037-4306-8b2a-d73cb6a2ed6d" class="modal-trigger">modules/richards/test/tests/buckley_leverett/bl20_lumped_fu.i</a></li><li><a href="#dae9bb67-5dbb-41e5-a331-51317b5445d2" class="modal-trigger">modules/combined/test/tests/inelastic_strain/elas_plas/elas_plas_nl1_cycle.i</a></li><li><a href="#64ac14dc-e49a-48cc-a620-69fd909da5c2" class="modal-trigger">test/tests/time_steppers/function_dt/function_dt_min.i</a></li><li><a href="#c89762a8-9202-4fb4-b0b4-b1d34f36a22e" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral_vtest/j_int_surfbreak_ellip_crack_sym_mm_cfp.i</a></li><li><a href="#fe9c7703-193b-4800-bddd-91f0c627a7ff" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/small_const.i</a></li><li><a href="#b45ca734-b1a4-4d02-af35-7d6a08cc65d6" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/fric_constraint/2_block_common_cross.i</a></li><li><a href="#68cf78b8-6ae0-4179-be05-628e3498b3cf" class="modal-trigger">modules/contact/test/tests/normalized_penalty/normalized_penalty_kin_Q8.i</a></li><li><a href="#5443fec4-471f-4fff-b9a9-db877277e27f" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_convex/gap_heat_transfer_convex.i</a></li><li><a href="#d6985f84-dd53-424a-be12-e110548c7d5e" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_hht_AD.i</a></li><li><a href="#87a358a1-fbcc-41c6-8041-5ffb133c12de" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymmetric_gps_finite.i</a></li><li><a href="#ecbf7065-3920-4094-b6c6-912163a951e4" class="modal-trigger">modules/combined/test/tests/reference_residual/reference_residual.i</a></li><li><a href="#286d27ba-fbb5-4d42-bef1-f3a94b1db0cc" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/mandel.i</a></li><li><a href="#441803d4-b6d1-4a64-b4bd-a302cc2653ff" class="modal-trigger">modules/combined/test/tests/heat_conduction_xfem/heat.i</a></li><li><a href="#e55b2b27-86c7-4de8-bd1a-31bf285dd60a" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test1q.i</a></li><li><a href="#175b3ecc-26f0-45a8-bd63-a9f933c9c399" class="modal-trigger">modules/tensor_mechanics/test/tests/jacobian_damper/cube_load.i</a></li><li><a href="#a31e2802-204d-45be-b857-fcdf71ef15d2" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/sphere2DRZ.i</a></li><li><a href="#762125c7-a1bd-4140-bb7a-1c56c3e06204" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_rz_exponential.i</a></li><li><a href="#201fd15b-23b2-4871-b463-5c0c3c7efaa5" class="modal-trigger">modules/richards/test/tests/dirac/bh05.i</a></li><li><a href="#43aceb2c-49d5-4fa8-a9c0-7df0771db7ce" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_file.i</a></li><li><a href="#9aea7b1c-9fc2-4c30-aee1-056e2752d55a" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymmetric_gps_incremental.i</a></li><li><a href="#0e340aa7-b673-433a-a107-7b7808d42f1d" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_topo_q_func.i</a></li><li><a href="#a8ed3cb2-9171-48b0-925b-ccc8a8b1a7bd" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test3qtt.i</a></li><li><a href="#b4fbca17-9a9b-461a-a991-8546ad194c82" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/cyl3D.i</a></li><li><a href="#72813bce-926f-454c-83d5-1e8f71b450c6" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_inertia_damping_ti.i</a></li><li><a href="#044fe992-d884-4f10-a333-f1d16ce637bd" class="modal-trigger">modules/richards/test/tests/gravity_head_2/ghQ2P_pgas.i</a></li><li><a href="#3c0e4168-0584-48c4-af84-0f500928d951" class="modal-trigger">modules/combined/test/tests/evolving_mass_density/expand_compress_test_tensors.i</a></li><li><a href="#49bfa2e7-b20e-408b-9132-c95788319aca" class="modal-trigger">modules/tensor_mechanics/test/tests/truss/truss_3d.i</a></li><li><a href="#256bc751-dcc2-4fe8-9728-647ad70d1581" class="modal-trigger">modules/combined/test/tests/reference_residual/reference_residual_perfgraph.i</a></li><li><a href="#72267406-fae1-44f4-8f26-3eb3d7314816" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small.i</a></li><li><a href="#ef9a2936-d006-48d2-b832-c95d6341bee6" class="modal-trigger">modules/tensor_mechanics/test/tests/domain_integral_thermal/j_integral_2d_inst_ctefunc.i</a></li><li><a href="#47d23d97-6fec-4f53-beac-3fa4da88fd3c" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/multiple_postprocessors.i</a></li><li><a href="#f95e669c-039f-481c-8d02-b688a8617d24" class="modal-trigger">modules/richards/test/tests/broadbridge_white/bw01.i</a></li><li><a href="#1b188290-bcac-469e-b227-a0d1ec9b72ac" class="modal-trigger">modules/contact/test/tests/normalized_penalty/normalized_penalty_Q8.i</a></li><li><a href="#0cc318a8-9e21-4e44-b2d1-289ed300af48" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/restart.i</a></li><li><a href="#3880fda2-eecd-4836-93b9-0edbcf251bd1" class="modal-trigger">modules/geochemistry/test/tests/kinetics/quartz_dissolution.i</a></li><li><a href="#ef572e7a-8443-458a-8d4a-2059162b7122" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_hht.i</a></li><li><a href="#244c486f-0853-4318-9466-9ce6529c1320" class="modal-trigger">test/tests/time_integrators/newmark-beta/newmark_beta_prescribed_parameters.i</a></li><li><a href="#f150f570-7f9b-49c1-b5ab-24f4fbd547af" class="modal-trigger">modules/combined/test/tests/cavity_pressure/multiple_postprocessors.i</a></li><li><a href="#4e3ba5f5-1f11-4b94-9a5b-b690a5d45fa0" class="modal-trigger">modules/tensor_mechanics/test/tests/recompute_radial_return/isotropic_plasticity_incremental_strain.i</a></li><li><a href="#a70e5387-03b2-41cd-bb90-6023dd057212" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4nstt.i</a></li><li><a href="#8ee48e1c-e9df-48ff-a5ee-18da6fb28bd7" class="modal-trigger">modules/combined/test/tests/cavity_pressure/negative_volume.i</a></li><li><a href="#38e0b552-1bb1-4a71-9176-975cb80e827a" class="modal-trigger">modules/tensor_mechanics/test/tests/plane_stress/ad_weak_plane_stress_finite.i</a></li><li><a href="#5247eb70-4805-4441-a901-fd6b36d156fe" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4ns.i</a></li><li><a href="#9688ab36-4d31-4ded-86c0-0f05207302a3" class="modal-trigger">modules/richards/test/tests/recharge_discharge/rd01.i</a></li><li><a href="#74feaaeb-e58f-4360-bdd6-2a492fb74609" class="modal-trigger">modules/tensor_mechanics/test/tests/strain_energy_density/rate_incr_model_elas_plas.i</a></li><li><a href="#7662ccb4-47c4-441e-9dd2-f39458ecbf9b" class="modal-trigger">modules/combined/test/tests/internal_volume/rz.i</a></li><li><a href="#5d413680-2980-447e-aec4-7b944e7614df" class="modal-trigger">modules/porous_flow/test/tests/infiltration_and_drainage/rsc02.i</a></li><li><a href="#230732f5-c0c8-4ee7-a8f1-7a9bc3cc3197" class="modal-trigger">modules/xfem/test/tests/pressure_bc/inclined_edge_2d_pressure.i</a></li><li><a href="#c5b1e981-1af7-4d7e-a82e-96e1a9a51ac9" class="modal-trigger">modules/porous_flow/test/tests/infiltration_and_drainage/rd02.i</a></li><li><a href="#61841c84-2edc-4c13-9fbf-f7971980e1cc" class="modal-trigger">modules/tensor_mechanics/test/tests/anisotropic_patch/anisotropic_patch_test.i</a></li><li><a href="#59554c2d-da1c-478f-84a9-589d18e7fc91" class="modal-trigger">modules/tensor_mechanics/test/tests/domain_integral_thermal/c_integral_2d.i</a></li><li><a href="#080bbdef-9a16-4976-9ff6-cd535f52b389" class="modal-trigger">modules/contact/test/tests/glued/glued_contact_mechanical_constraint_test.i</a></li><li><a href="#b36fee62-2eb1-46f0-9c24-8f9eebcf0e3d" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_hht_ti.i</a></li><li><a href="#2226f0b2-7db4-4401-8f3e-01b85159ef92" class="modal-trigger">modules/combined/test/tests/adaptive_timestepping/adapt_tstep_function_change_restart2.i</a></li><li><a href="#56ebda8c-274b-4127-906e-d8778119f879" class="modal-trigger">modules/navier_stokes/test/tests/ins/jeffery_hamel/wedge_natural.i</a></li><li><a href="#dfc51758-d4ee-472e-a194-2369816d8f6a" class="modal-trigger">modules/combined/test/tests/ad_power_law_creep/power_law_creep_smallstrain.i</a></li><li><a href="#e99e86b9-97b6-4a62-95c3-66ddd6104978" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh16.i</a></li><li><a href="#5350903c-0f23-4ad8-b35d-7295869e4fba" class="modal-trigger">modules/xfem/test/tests/solid_mechanics_basic/crack_propagation_2d.i</a></li><li><a href="#6717f7b7-2ede-4152-b184-b270148ebfd2" class="modal-trigger">modules/richards/test/tests/recharge_discharge/rd03.i</a></li><li><a href="#297aff57-9810-43c1-8885-df82a65ac48b" class="modal-trigger">modules/tensor_mechanics/test/tests/material_limit_time_step/damage/scalar_material_damage_timestep_limit.i</a></li><li><a href="#790a2c23-4760-4e2d-a4c3-b7e44a30205c" class="modal-trigger">modules/contact/test/tests/nodal_area/nodal_area_Hex27.i</a></li><li><a href="#7dac3a9e-1371-4443-a8c4-b9954ad7062c" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test4qns.i</a></li><li><a href="#da7866b4-ce39-4520-bf3e-52d1c0851dd8" class="modal-trigger">modules/contact/test/tests/hertz_spherical/hertz_contact_hex20.i</a></li><li><a href="#8c661e97-1a14-456c-bd45-bbb1265ccf37" class="modal-trigger">test/tests/time_integrators/newmark-beta/newmark_beta_default_parameters.i</a></li><li><a href="#aec4a637-a381-4ec7-bc70-fc02e5837a63" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh_lumped_07.i</a></li><li><a href="#fdc6cd2f-f4c5-45e1-94fb-73f8b071482e" class="modal-trigger">modules/richards/test/tests/broadbridge_white/bw_lumped_02.i</a></li><li><a href="#5b929a99-d298-4263-a3ac-313567bb28fc" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/time_integration/hht_test.i</a></li><li><a href="#7b337c88-13b4-44c1-a89a-f065baf08b6b" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_deprecated.i</a></li><li><a href="#bd3b5d7b-2dcd-479f-a60c-8e4193caddaf" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test2tt.i</a></li><li><a href="#e096a369-cd9e-46cb-937c-868f1aab73e8" class="modal-trigger">modules/richards/test/tests/dirac/bh_fu_04.i</a></li><li><a href="#499f7b40-0d99-4ec8-8a3c-868a406b4862" class="modal-trigger">modules/tensor_mechanics/test/tests/smeared_cracking/cracking_rz.i</a></li><li><a href="#b3ee2585-0198-4581-b4d3-eb7d27ae7421" class="modal-trigger">modules/combined/test/tests/thermo_mech/ad-youngs_modulus_function_temp.i</a></li><li><a href="#fddaab35-3097-4c07-9f87-58eaf388fc10" class="modal-trigger">test/tests/time_integrators/central-difference/central_difference.i</a></li><li><a href="#a1ff818c-f176-4fb8-8d8b-d5bbdf0cfa05" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_plastic/power_law_creep.i</a></li><li><a href="#db72e7a0-1727-4656-9310-ec0fc813e574" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh_fu_06.i</a></li><li><a href="#06ac3d78-036e-4682-967a-9d3888e761a5" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4nns.i</a></li><li><a href="#3f2c160d-7244-4eb3-b24a-33ea31c29871" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/static_vm/ansys_vm2.i</a></li><li><a href="#49cfea83-795a-4818-b75a-8e61d605a9d3" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_2d_mouth_dir.i</a></li><li><a href="#158c58d6-f2db-43a7-9cb4-1d4f5212dc61" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/prescribed_displacement/3D_QStatic_1_Ramped_Displacement_ti.i</a></li><li><a href="#c925ab1f-b6b2-4fa8-8803-334d439b310c" class="modal-trigger">modules/porous_flow/test/tests/dirackernels/bh07.i</a></li><li><a href="#80115afa-0150-48b8-9af7-27d2a0f979d3" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test4.i</a></li><li><a href="#eafbb0e3-3091-4988-acb2-bba6a5c3f9bc" class="modal-trigger">modules/porous_flow/test/tests/functions/mpf1.i</a></li><li><a href="#1391cce4-2bcc-4cd2-8a65-5e6de270437b" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/3D/3d_nodalmass_explicit.i</a></li><li><a href="#75c04fff-0399-46b1-991e-6e466eae49c3" class="modal-trigger">modules/tensor_mechanics/test/tests/truss/truss_hex.i</a></li><li><a href="#2ac4b22d-3310-4cf2-988f-48a3fc0c7b94" class="modal-trigger">modules/tensor_mechanics/test/tests/strain_energy_density/incr_model.i</a></li><li><a href="#5c342816-084a-48fd-a5c7-454cc08f5d80" class="modal-trigger">modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_3d_rot.i</a></li><li><a href="#65d8b779-bde1-4d18-829e-c50632c73492" class="modal-trigger">modules/xfem/test/tests/diffusion_xfem/levelsetcut2d_aux.i</a></li><li><a href="#84e4bf84-db80-44da-b43f-69b369c79af2" class="modal-trigger">modules/xfem/test/tests/moving_interface/moving_level_set.i</a></li><li><a href="#21ff8b29-6759-4d33-b084-3d50bd186380" class="modal-trigger">modules/combined/test/tests/power_law_creep/power_law_creep.i</a></li><li><a href="#44ab44fa-f7aa-4ce5-93d3-edf56cde2d4d" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh07.i</a></li><li><a href="#ef8218d3-18ed-4d10-9a2c-16a0bc9441a3" class="modal-trigger">modules/porous_flow/test/tests/dirackernels/bh05.i</a></li><li><a href="#cefb3243-efff-4f15-84a8-875dc53820ff" class="modal-trigger">modules/richards/test/tests/rogers_stallybrass_clements/rsc_fu_01.i</a></li><li><a href="#30ff01e7-7714-4552-ba79-29f8b9bed6c5" class="modal-trigger">modules/combined/test/tests/ad_power_law_creep/power_law_creep_restart2.i</a></li><li><a href="#1541eab3-16ca-4c2e-8c88-09e0e7e149fa" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/3D/3d_consistent_explicit.i</a></li><li><a href="#4963c3d5-d0b7-40fb-aaea-27ca603b6d01" class="modal-trigger">modules/contact/test/tests/catch_release/catch_release.i</a></li><li><a href="#e662aabe-289b-41b5-913e-82d7892298da" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4qns.i</a></li><li><a href="#8e22278b-fae7-4aa5-8b48-32403775feb3" class="modal-trigger">modules/tensor_mechanics/test/tests/plane_stress/ad_weak_plane_stress_incremental.i</a></li><li><a href="#158b6e2d-cd0d-4cce-a8d7-4d42de428edd" class="modal-trigger">modules/richards/test/tests/rogers_stallybrass_clements/rsc_lumped_01.i</a></li><li><a href="#dc11c838-141c-4834-9a43-2b9cca0ef47a" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3nns.i</a></li><li><a href="#1dec4166-17ca-4f24-98ef-f20141769a26" class="modal-trigger">modules/tensor_mechanics/test/tests/plane_stress/weak_plane_stress_incremental.i</a></li><li><a href="#73328e76-9748-4ef9-8bef-5a37032e6614" class="modal-trigger">test/tests/misc/check_error/function_file_test13.i</a></li><li><a href="#3d48afc3-9d42-4068-9344-2fd8d21ca18d" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test3qtt.i</a></li><li><a href="#58e042e1-00d0-4359-b3a4-5be16fba5964" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_dyn_variable_action.i</a></li><li><a href="#702c4531-877a-4ba2-93ba-30da14a04373" class="modal-trigger">modules/combined/test/tests/evolving_mass_density/shear_test_tensors.i</a></li><li><a href="#4320a252-6ead-44e1-a944-f5a13c0358fe" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_inertia_damping.i</a></li><li><a href="#1ae839eb-17d9-4b20-a049-5c3a875d85f2" class="modal-trigger">modules/tensor_mechanics/test/tests/torque_reaction/disp_about_axis_errors.i</a></li><li><a href="#75be278c-e939-42ec-aa94-3ccd5b6ce29b" class="modal-trigger">modules/tensor_mechanics/test/tests/t_stress/t_stress_ellip_crack_3d.i</a></li><li><a href="#98222419-93a5-4e2e-a4d6-e61188292a23" class="modal-trigger">modules/combined/test/tests/cavity_pressure/rz.i</a></li><li><a href="#0c3bc44c-6677-41dd-83e3-8306f58c7a82" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/acceleration_bc/AccelerationBC_test.i</a></li><li><a href="#0d624219-2a35-4b55-96b3-d82ed806a767" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/constraints/frictional_constraint.i</a></li><li><a href="#40d72645-b381-453d-a137-3eb5c65e85e4" class="modal-trigger">modules/porous_flow/test/tests/gravity/grav02c.i</a></li><li><a href="#f0d94607-3df7-4045-bf27-9194e6ffb569" class="modal-trigger">modules/tensor_mechanics/test/tests/truss/truss_hex_action.i</a></li><li><a href="#f3b90773-81d7-429c-98b4-d032a8362622" class="modal-trigger">modules/combined/examples/xfem/xfem_mechanics_prescribed_growth.i</a></li><li><a href="#1634cf7f-c8f4-45c1-a300-b0d29ff761a7" class="modal-trigger">modules/tensor_mechanics/test/tests/j_integral/j_integral_2d_topo_q_func.i</a></li><li><a href="#5dcad217-4f5e-4dae-80ab-55897e74195c" class="modal-trigger">modules/tensor_mechanics/test/tests/plane_stress/ad_weak_plane_stress_small.i</a></li><li><a href="#5c9cf51f-4f16-46c3-891c-4904fa4bad86" class="modal-trigger">test/tests/utils/mathutils/clamp.i</a></li><li><a href="#7940c67b-fdde-42b8-bced-baae6ec558ee" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/2D/2d_lumped_explicit.i</a></li><li><a href="#64db5113-4382-45ba-90b6-bf6091c39ae2" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test2.i</a></li><li><a href="#d1865a05-e6e4-4358-b858-875cb87b890c" class="modal-trigger">modules/peridynamics/test/tests/simple_tests/2D_regularD_constH_BPD.i</a></li><li><a href="#4b4ec11e-f433-4b2a-9e8b-161e13a6a545" class="modal-trigger">test/tests/geomsearch/3d_moving_penetration/pl_test3tt.i</a></li><li><a href="#dc1c875f-762e-48c9-a629-5f2b4b244b12" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/static/euler_finite_rot_y_action.i</a></li><li><a href="#40292187-b24e-4120-bb11-ec66239a56e4" class="modal-trigger">modules/richards/test/tests/rogers_stallybrass_clements/rsc_fu_02.i</a></li><li><a href="#39a14ce8-e3dc-49ea-8e2c-e4d491277b48" class="modal-trigger">modules/tensor_mechanics/test/tests/truss/truss_2d.i</a></li><li><a href="#d7ff43dd-a75d-464c-9d7d-37160ee8f00e" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_exponential.i</a></li><li><a href="#0ae6bc22-9838-4231-9e2f-19c1ab4bc1a2" class="modal-trigger">modules/combined/test/tests/thermal_elastic/thermal_elastic.i</a></li><li><a href="#e39a44a4-4be9-4761-ae7b-d23cee2c1996" class="modal-trigger">modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_2d.i</a></li><li><a href="#4e981835-3f9a-4e26-8074-d8d4fe606867" class="modal-trigger">modules/contact/test/tests/verification/hertz_cyl/half_symm_q4/hertz_cyl_half_1deg_template3.i</a></li><li><a href="#435cd628-80e1-4bd4-80c9-c5abba422e27" class="modal-trigger">modules/richards/test/tests/gravity_head_1/gh_fu_20.i</a></li><li><a href="#c30ae724-c401-493f-868f-7ce5cb208207" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free_orientation_inclined.i</a></li><li><a href="#bc010d63-9286-4f2a-9ae8-f22124f5e681" class="modal-trigger">modules/tensor_mechanics/test/tests/coupled_pressure/coupled_pressure_test.i</a></li><li><a href="#820cc8b4-0990-4987-a404-bf359d196dd4" class="modal-trigger">modules/richards/test/tests/gravity_head_2/gh_lumped_18.i</a></li><li><a href="#5e0709a3-1418-45fb-97e9-e4e8d37f815d" class="modal-trigger">modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_plane_strain_finite.i</a></li><li><a href="#186ab161-8a9f-4881-9796-5b73550c8d65" class="modal-trigger">modules/geochemistry/test/tests/time_dependent_reactions/mixing.i</a></li><li><a href="#a52ded63-bdde-40b3-b7d6-08bfb7a8f7aa" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_pressure/pressure_test.i</a></li><li><a href="#e23a1b6d-4229-4078-ba05-f309b563caf8" class="modal-trigger">modules/peridynamics/test/tests/generalized_plane_strain/planestrain_prescribed_OSPD.i</a></li><li><a href="#a1a4d425-cbc2-4127-a3d6-84f70e78e4f5" class="modal-trigger">modules/combined/test/tests/inelastic_strain/creep/creep_nl1.i</a></li><li><a href="#84286a1a-8e32-474a-8fb4-8e8d6b759f56" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test3q.i</a></li><li><a href="#0d286563-798b-4996-a9a8-b2f0c547bb42" class="modal-trigger">test/tests/misc/check_error/function_file_test8.i</a></li><li><a href="#a84c8d2e-8677-4347-8701-6f285b3ef78a" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/2D/2d_consistent_implicit.i</a></li><li><a href="#9c5c6658-119d-4d5f-97e6-a32318413b53" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/small_linear.i</a></li><li><a href="#5ff6185b-271d-4599-807a-8b0333e319fe" class="modal-trigger">modules/richards/test/tests/dirac/bh07.i</a></li><li><a href="#6591a1af-8879-44d0-8bf5-9ae187b8c6bc" class="modal-trigger">test/tests/multiapps/picard/function_dt_sub.i</a></li><li><a href="#d539d47e-88d0-4ed5-af7c-7e60356e2d70" class="modal-trigger">modules/combined/test/tests/combined_plasticity_temperature/ad_plasticity_temperature_dep_yield.i</a></li><li><a href="#1205ff51-8ade-4a29-b550-3c0c5bda8448" class="modal-trigger">modules/tensor_mechanics/test/tests/truss/truss_plastic.i</a></li><li><a href="#9b4d52f9-efd5-4b11-ae1a-1ed0bcc4b44c" class="modal-trigger">modules/richards/test/tests/dirac/q2p01.i</a></li><li><a href="#c48b0aba-dabb-43a7-846c-c15b0befd76b" class="modal-trigger">test/tests/geomsearch/2d_moving_penetration/pl_test1q.i</a></li><li><a href="#3d398e3f-510d-40d7-8188-4609326ab58d" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking.i</a></li><li><a href="#1ae9de4a-3a12-45dd-91b0-48490e65454a" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_newmark.i</a></li><li><a href="#6baf2a47-d04b-443c-912c-47df544b4184" class="modal-trigger">modules/richards/test/tests/user_objects/uo3.i</a></li></ul><div class="modal moose-modal" id="d557d01a-e6de-4927-9125-b5de1a7091d3"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3ns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3ns_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4468774a-099a-4786-af5c-b63963581438"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test3nns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_method = nodal_normal_based
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3nns_out
  exodus = true
[]

[NodalNormals]
  boundary = 11
  corner_boundary = 20
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="61a2c5c9-e37c-4a55-b0eb-5c651fa25c71"><div class="modal-content"><h4>modules/richards/test/tests/theis/th22.i</h4><pre class="moose-pre"><code class="language-text"># two-phase, fully-saturated
# production
[Mesh]
  type = FileMesh
  file = th02_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 2 4 20&#x27;
    x = &#x27;0 1 10 100&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-5
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]

  [./total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]


[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_pressure
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsPolyLineSink
    pressures = &#x27;-1E9 1E9&#x27;
    fluxes = &#x27;200 200&#x27;
    point_file = th01.points
    SumQuantityUO = total_outflow_mass
    variable = pwater
  [../]
[]


[Postprocessors]
  [./flow_report]
    type = RichardsPlotQuantity
    uo = total_outflow_mass
  [../]
  [./p50]
    type = PointValue
    variable = pwater
    point = &#x27;50 0 0&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E5
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 1E-5&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-7 1E-10 20 1E-10 1E-100&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 100
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = th22
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a61b7d03-d1f3-4b4f-97df-555e4a26e1ea"><div class="modal-content"><h4>modules/combined/test/tests/poro_mechanics/mandel.i</h4><pre class="moose-pre"><code class="language-text"># Mandel&#x27;s problem of consolodation of a drained medium
#
# A sample is in plane strain.
# -a &lt;= x &lt;= a
# -b &lt;= y &lt;= b
# It is squashed with constant force by impermeable, frictionless plattens on its top and bottom surfaces (at y=+/-b)
# Fluid is allowed to leak out from its sides (at x=+/-a)
# The porepressure within the sample is monitored.
#
# As is common in the literature, this is simulated by
# considering the quarter-sample, 0&lt;=x&lt;=a and 0&lt;=y&lt;=b, with
# impermeable, roller BCs at x=0 and y=0 and y=b.
# Porepressure is fixed at zero on x=a.
# Porepressure and displacement are initialised to zero.
# Then the top (y=b) is moved downwards with prescribed velocity,
# so that the total force that is inducing this downwards velocity
# is fixed.  The velocity is worked out by solving Mandel&#x27;s problem
# analytically, and the total force is monitored in the simulation
# to check that it indeed remains constant.
#
# Here are the problem&#x27;s parameters, and their values:
# Soil width.  a = 1
# Soil height.  b = 0.1
# Soil&#x27;s Lame lambda.  la = 0.5
# Soil&#x27;s Lame mu, which is also the Soil&#x27;s shear modulus.  mu = G = 0.75
# Soil bulk modulus.  K = la + 2*mu/3 = 1
# Drained Poisson ratio.  nu = (3K - 2G)/(6K + 2G) = 0.2
# Soil bulk compliance.  1/K = 1
# Fluid bulk modulus.  Kf = 8
# Fluid bulk compliance.  1/Kf = 0.125
# Soil initial porosity.  phi0 = 0.1
# Biot coefficient.  alpha = 0.6
# Biot modulus.  M = 1/(phi0/Kf + (alpha - phi0)(1 - alpha)/K) = 4.705882
# Undrained bulk modulus. Ku = K + alpha^2*M = 2.694118
# Undrained Poisson ratio.  nuu = (3Ku - 2G)/(6Ku + 2G) = 0.372627
# Skempton coefficient.  B = alpha*M/Ku = 1.048035
# Fluid mobility (soil permeability/fluid viscosity).  k = 1.5
# Consolidation coefficient.  c = 2*k*B^2*G*(1-nu)*(1+nuu)^2/9/(1-nuu)/(nuu-nu) = 3.821656
# Normal stress on top.  F = 1
#
# The solution for porepressure and displacements is given in
# AHD Cheng and E Detournay &quot;A direct boundary element method for plane strain poroelasticity&quot; International Journal of Numerical and Analytical Methods in Geomechanics 12 (1988) 551-572.
# The solution involves complicated infinite series, so I shall not write it here

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
  ny = 1
  nz = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 0.1
  zmin = 0
  zmax = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./roller_xmin]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left&#x27;
  [../]
  [./roller_ymin]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  [../]
  [./plane_strain]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
  [./xmax_drained]
    type = DirichletBC
    variable = porepressure
    value = 0
    boundary = right
  [../]
  [./top_velocity]
    type = FunctionDirichletBC
    variable = disp_y
    function = top_velocity
    boundary = top
  [../]
[]

[Functions]
  [./top_velocity]
    type = PiecewiseLinear
    x = &#x27;0 0.002 0.006   0.014   0.03    0.046   0.062   0.078   0.094   0.11    0.126   0.142   0.158   0.174   0.19 0.206 0.222 0.238 0.254 0.27 0.286 0.302 0.318 0.334 0.35 0.366 0.382 0.398 0.414 0.43 0.446 0.462 0.478 0.494 0.51 0.526 0.542 0.558 0.574 0.59 0.606 0.622 0.638 0.654 0.67 0.686 0.702&#x27;
    y = &#x27;-0.041824842    -0.042730269    -0.043412712    -0.04428867     -0.045509181    -0.04645965     -0.047268246 -0.047974749      -0.048597109     -0.0491467  -0.049632388     -0.050061697      -0.050441198     -0.050776675     -0.051073238      -0.0513354 -0.051567152      -0.051772022     -0.051953128 -0.052113227 -0.052254754 -0.052379865 -0.052490464 -0.052588233 -0.052674662 -0.052751065 -0.052818606 -0.052878312 -0.052931093 -0.052977751 -0.053018997 -0.053055459 -0.053087691 -0.053116185 -0.053141373 -0.05316364 -0.053183324 -0.053200724 -0.053216106 -0.053229704 -0.053241725 -0.053252351 -0.053261745 -0.053270049 -0.053277389 -0.053283879 -0.053289615&#x27;
  [../]
[]


[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_force]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./tot_force]
    type = ParsedAux
    args = &#x27;stress_yy porepressure&#x27;
    execute_on = timestep_end
    variable = tot_force
    function = &#x27;-stress_yy+0.6*porepressure&#x27;
  [../]
[]



[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
    [./poro_x]
    type = PoroMechanicsCoupling
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PoroMechanicsCoupling
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PoroMechanicsCoupling
    variable = disp_z
    component = 2
  [../]
  [./poro_timederiv]
    type = PoroFullSatTimeDerivative
    variable = porepressure
  [../]
  [./darcy_flow]
    type = CoefDiffusion
    variable = porepressure
    coef = 1.5
  [../]
[]


[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0.5 0.75&#x27;
    # bulk modulus is lambda + 2*mu/3 = 0.5 + 2*0.75/3 = 1
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./poro_material]
    type = PoroFullSatMaterial
    porosity0 = 0.1
    biot_coefficient = 0.6
    solid_bulk_compliance = 1
    fluid_bulk_compliance = 0.125
    constant_porosity = true
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0.0 0 0&#x27;
    variable = porepressure
  [../]
  [./p1]
    type = PointValue
    outputs = csv
    point = &#x27;0.1 0 0&#x27;
    variable = porepressure
  [../]
  [./p2]
    type = PointValue
    outputs = csv
    point = &#x27;0.2 0 0&#x27;
    variable = porepressure
  [../]
  [./p3]
    type = PointValue
    outputs = csv
    point = &#x27;0.3 0 0&#x27;
    variable = porepressure
  [../]
  [./p4]
    type = PointValue
    outputs = csv
    point = &#x27;0.4 0 0&#x27;
    variable = porepressure
  [../]
  [./p5]
    type = PointValue
    outputs = csv
    point = &#x27;0.5 0 0&#x27;
    variable = porepressure
  [../]
  [./p6]
    type = PointValue
    outputs = csv
    point = &#x27;0.6 0 0&#x27;
    variable = porepressure
  [../]
  [./p7]
    type = PointValue
    outputs = csv
    point = &#x27;0.7 0 0&#x27;
    variable = porepressure
  [../]
  [./p8]
    type = PointValue
    outputs = csv
    point = &#x27;0.8 0 0&#x27;
    variable = porepressure
  [../]
  [./p9]
    type = PointValue
    outputs = csv
    point = &#x27;0.9 0 0&#x27;
    variable = porepressure
  [../]
  [./p99]
    type = PointValue
    outputs = csv
    point = &#x27;1 0 0&#x27;
    variable = porepressure
  [../]
  [./xdisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_x
  [../]
  [./ydisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_y
  [../]
  [./total_downwards_force]
     type = ElementAverageValue
     outputs = csv
     variable = tot_force
  [../]
  [./dt]
    type = FunctionValuePostprocessor
    outputs = console
    function = if(0.15*t&lt;0.01,0.15*t,0.01)
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 0.7
  [./TimeStepper]
    type = PostprocessorDT
    postprocessor = dt
    dt = 0.001
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = mandel
  [./csv]
    interval = 3
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ba5abe26-dd01-4a76-a011-29a812afab28"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_3d.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with 2 elements
#through the thickness, and calculates the J-Integrals using options
#to treat it as 3d.
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack3d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  radius_inner = &#x27;4.0 5.5&#x27;
  radius_outer = &#x27;5.5 7.0&#x27;
  output_variable = &#x27;disp_x&#x27;
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_z2]
    type = DirichletBC
    variable = disp_z
    boundary = 510
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]

[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]


[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Postprocessors]
  [./disp_x_centercrack]
    type = CrackFrontData
    crack_front_definition = crackFrontDefinition
    variable = disp_x
    crack_front_point_index = 1
  [../]
[]

[Outputs]
  file_base = j_integral_3d_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a2c266f5-3ef4-4eda-a383-e166718a1f4c"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/volumetric_eigenstrain/volumetric_mechanical.i</h4><pre class="moose-pre"><code class="language-text"># This test ensures that the reported volumetric strain for a cube with
# mechanically imposed displacements (through Dirichlet BCs) exactly
# matches that from a version of this test that experiences the same
# defomation, but due to imposed eigenstrains.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./volumetric_strain]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    decomposition_method = EigenSolution #Necessary for exact solution
  [../]
[]

[AuxKernels]
  [./volumetric_strain]
    type = RankTwoScalarAux
    scalar_type = VolumetricStrain
    rank_two_tensor = total_strain
    variable = volumetric_strain
  [../]
[]

[Functions]
  [pres_disp]
    type = PiecewiseLinear
    # These values are taken from the displacements in the eigenstrain
    # version of this test. The volume of the cube (which starts out as
    # a 1x1x1 cube) is (1 + disp)^3. At time 2, this is
    # (1.44224957030741)^3, which is 3.0.
    xy_data = &#x27;0 0
               1 0.25992104989487
               2 0.44224957030741&#x27;
  []
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = right
    function = pres_disp
  [../]
  [./top]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pres_disp
  [../]
  [./front]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = front
    function = pres_disp
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./finite_strain_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./volumetric_change]
    type = GenericFunctionMaterial
    prop_names = volumetric_change
    prop_values = t
  [../]
[]

[Postprocessors]
  [./vol]
    type = VolumePostprocessor
    use_displaced_mesh = true
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./volumetric_strain]
    type = ElementalVariableValue
    variable = volumetric_strain
    elementid = 0
  [../]
  [./disp_right]
    type = NodalMaxValue
    variable = disp_x
    boundary = right
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 2.0
  dt = 1.0
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9b6d115a-6016-4e2a-8bd8-fbff8e589fc4"><div class="modal-content"><h4>modules/combined/test/tests/thermo_mech/youngs_modulus_function_temp.i</h4><pre class="moose-pre"><code class="language-text"># ---------------------------------------------------------------------------
# This test is designed to verify the variable elasticity tensor functionality in the
# ComputeFiniteStrainElasticStress class with the elasticity_tensor_has_changed flag
# by varying the young&#x27;s modulus with temperature. A constant strain is applied
# to the mesh in this case, and the stress varies with the changing elastic constants.
#
# Geometry: A single element cube in symmetry boundary conditions and pulled
#           at a constant displacement to create a constant strain in the x-direction.
#
# Temperature:  The temperature varies from 400K to 700K in this simulation by
#           100K each time step. The temperature is held constant in the last
#           timestep to ensure that the elasticity tensor components are constant
#           under constant temperature.
#
# Results: Because Poisson&#x27;s ratio is set to zero, only the stress along the x
#          axis is non-zero.  The stress changes with temperature.
#
#    Temperature(K)   strain_{xx}(m/m)     Young&#x27;s Modulus(Pa)   stress_{xx}(Pa)
#          400              0.001             10.0e6               1.0e4
#          500              0.001             10.0e6               1.0e4
#          600              0.001              9.94e6              9.94e3
#          700              0.001              9.93e6              9.93e3
#
#    The tensor mechanics results align exactly with the analytical results above
#    when this test is run with ComputeIncrementalSmallStrain.  When the test is
#    run with ComputeFiniteStrain, a 0.05% discrepancy between the analytical
#    strains and the simulation strain results is observed, and this discrepancy
#    is carried over into the calculation of the elastic stress.
#-------------------------------------------------------------------------

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 400
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./temperature_function]
    type = PiecewiseLinear
    x = &#x27;1       4&#x27;
    y = &#x27;400   700&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = Diffusion
    variable = temp
  [../]

  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]


[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]

 [./elastic_strain_xx]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./u_left_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_back_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./u_pull_right]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0.001
  [../]

  [./temp_bc_1]
    type = FunctionDirichletBC
    variable = temp
    preset = false
    boundary = &#x27;1 2 3 4&#x27;
    function = temperature_function
  [../]
[]

[Materials]
  [./youngs_modulus]
    type = PiecewiseLinearInterpolationMaterial
    xy_data = &#x27;0          10e+6
               599.9999   10e+6
               600        9.94e+6
               99900      10e3&#x27;
    property = youngs_modulus
    variable = temp
  [../]
  [./elasticity_tensor]
    type = ComputeVariableIsotropicElasticityTensor
    args = temp
    youngs_modulus = youngs_modulus
    poissons_ratio = 0.0
  [../]
  [./strain]
    type = ComputeIncrementalSmallStrain
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  end_time = 5
[]

[Postprocessors]
  [./elastic_strain_xx]
    type = ElementAverageValue
    variable = elastic_strain_xx
  [../]
  [./elastic_stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  [../]

  [./temp]
    type = AverageNodalVariableValue
    variable = temp
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f148e614-057a-4e74-8a39-6c21660a967d"><div class="modal-content"><h4>modules/contact/test/tests/simple_contact/simple_contact_rz_test.i</h4><pre class="moose-pre"><code class="language-text">#
# The analytic solution is:
#   disp_x = -7e-5 * x
#   disp_y =  6e-5 * y
#   stress_xx = stress_zz = -100
#   stress_yy = stress_xy = 0
#
# Note: Run merged_rz.i to generate a solution to compare to that doesn&#x27;t use contact.

[Mesh]
  file = contact_rz.e
  # PETSc &lt; 3.5.0 requires the iteration patch_update_strategy to
  # avoid PenetrationLocator warnings, which are currently treated as
  # errors by the TestHarness.
  patch_update_strategy = &#x27;iteration&#x27;
[]

[GlobalParams]
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 1&#x27;
    scale_factor = 100
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    incremental = true
    strain = FINITE
    generate_output = &#x27;stress_xx stress_xy stress_zx stress_yy stress_zz stress_yz&#x27;
  [../]
[]

[Contact]
  [./dummy_name]
    primary = 3
    secondary = 2
    penalty = 1e5
  [../]
[]

[BCs]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]

  [./bottom_y]
    type = DirichletBC
    variable = disp_y
    boundary = 10
    value = 0.0
  [../]

  [./Pressure]
    [./right_pressure]
      boundary = 4
      function = pressure
    [../]
  [../]
[]

[Materials]
  [./stiffStuff]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stiffStuff_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type &#x27;
  petsc_options_value = &#x27;lu       &#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-9
  nl_rel_tol = 1e-9

  l_max_its = 20
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="86f9285e-04a9-49a6-8bb1-47cb5ddfc053"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/scalar_material_damage/scalar_material_damage.i</h4><pre class="moose-pre"><code class="language-text"># This is a basic test of the system for continuum damage mechanics
# materials. It uses ScalarMaterialDamage for the damage model,
# which simply gets its damage index from another material. In this
# case, we prescribe the evolution of the damage index using a
# function. A single element has a fixed prescribed displacement
# on one side that puts the element in tension, and then the
# damage index evolves from 0 to 1 over time, and this verifies
# that the stress correspondingly drops to 0.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX8
[]

[AuxVariables]
  [damage_index]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Modules/TensorMechanics/Master]
  [all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_xx strain_xx&#x27;
  []
[]

[AuxKernels]
  [damage_index]
    type = MaterialRealAux
    variable = damage_index
    property = damage_index_prop
    execute_on = timestep_end
  []
[]

[BCs]
  [symmy]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0
  []
  [symmx]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0
  []
  [symmz]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0
  []
  [axial_load]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0.01
  []
[]

[Functions]
  [damage_evolution]
    type = PiecewiseLinear
    xy_data = &#x27;0.0   0.0
               0.1   0.0
               2.1   2.0&#x27;
  []
[]

[Materials]
  [damage_index]
    type = GenericFunctionMaterial
    prop_names = damage_index_prop
    prop_values = damage_evolution
  []
  [damage]
    type = ScalarMaterialDamage
    damage_index = damage_index_prop
  []
  [stress]
    type = ComputeDamageStress
    damage_model = damage
  []
  [elasticity]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.2
    youngs_modulus = 10e9
  []
[]

[Postprocessors]
  [stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  []
  [strain_xx]
    type = ElementAverageValue
    variable = strain_xx
  []
  [damage_index]
    type = ElementAverageValue
    variable = damage_index
  []
[]

[Executioner]
  type = Transient

  l_max_its  = 50
  l_tol      = 1e-8
  nl_max_its = 20
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-8

  dt = 0.1
  dtmin = 0.1
  end_time = 1.1
[]

[Outputs]
  csv=true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4eb82cfb-f765-494e-bb82-e6338ecaedc3"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D_yz.i</h4><pre class="moose-pre"><code class="language-text">#
# 2D Cylindrical Gap Heat Transfer Test.
#
# This test exercises 2D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid cylinder of radius = 1 unit, and outer
# hollow cylinder with an inner radius of 2 in the y-z plane. In other words,
# the gap between them is 1 radial unit in length.
#
# The calculated results are the same as for the cyl2D.i case in the x-y plane.

[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  [file]
    type = FileMeshGenerator
    file = cyl2D.e
  []
  [./rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;0 90 90&#x27;
    input = file
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]

[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]

[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = CYLINDER
    cylinder_axis_point_1 = &#x27;0 0 0&#x27;
    cylinder_axis_point_2 = &#x27;1 0 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b8980312-b5a4-4928-a653-3d1cbd7c678e"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/negative_volume.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute a negative number of moles
# to trigger an error check in the CavityPressureUserObject.
# The negative number of moles is achieved by supplying an
# open volume to the InternalVolume postprocessor, which
# calculates a negative volume.

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 2
[]

[Functions]
  [./temperature]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 2&#x27;
    scale_factor = 100
  [../]
[]

[Variables]
  [./temperature]
    initial_condition = 100
  [../]
[]

[Modules/TensorMechanics/Master]
  [./block]
    strain = FINITE
    add_variables = true
    use_automatic_differentiation = true
  [../]
[]

[Kernels]
  [./heat]
    type = Diffusion
    variable = temperature
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./no_x]
    type = ADDirichletBC
    variable = disp_r
    boundary = left
    value = 0.0
  [../]
  [./no_y]
    type = ADDirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 2
    function = temperature
    variable = temperature
  [../]
  [./CavityPressure]
    [./pressure]
      boundary = &#x27;top bottom right&#x27;
      initial_pressure = 10e5
      R = 8.3143
      output_initial_moles = initial_moles
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elastic_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_abs_tol = 1e-10
  l_max_its = 20
  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = &#x27;top bottom right&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = AxisymmetricCenterlineAverageValue
    boundary = left
    variable = temperature
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="afe9bbfd-06ac-4a0c-80d7-e6786b55658d"><div class="modal-content"><h4>modules/combined/test/tests/inelastic_strain/elas_plas/elas_plas_nl1.i</h4><pre class="moose-pre"><code class="language-text">#
# Test for effective strain calculation.
# Boundary conditions from NAFEMS test NL1
#
# This is not a verification test. The boundary conditions are applied such
# that the first step generates only elastic stresses. The second and third
# steps generate plastic deformation and the effective strain should be
# increasing throughout the run.
#
[GlobalParams]
  order = FIRST
  family = LAGRANGE
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = one_elem2.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./pressure]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./eff_plastic_strain]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./vonmises]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = vonmises
    scalar_type = VonMisesStress
    execute_on = timestep_end
  [../]
  [./pressure]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = pressure
    scalar_type = Hydrostatic
    execute_on = timestep_end
  [../]
  [./elastic_strain_xx]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./elastic_strain_yy]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./elastic_strain_zz]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./plastic_strain_xx]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./plastic_strain_yy]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./plastic_strain_zz]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./tot_strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./tot_strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./tot_strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./eff_plastic_strain]
    type = MaterialRealAux
    property = effective_plastic_strain
    variable = eff_plastic_strain
  [../]
[]

[Functions]
  [./appl_dispy]
    type = PiecewiseLinear
    x = &#x27;0     1.0     2.0     3.0&#x27;
    y = &#x27;0.0 0.208e-4 0.50e-4 1.00e-4&#x27;
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_x
    boundary = 101
    value = 0.0
  [../]
  [./origin_x]
    type = DirichletBC
    variable = disp_x
    boundary = 103
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_y
    boundary = 102
    value = 0.0
  [../]
  [./origin_y]
    type = DirichletBC
    variable = disp_y
    boundary = 103
    value = 0.0
  [../]
  [./top_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = appl_dispy
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 1
    youngs_modulus = 250e9
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputePlaneFiniteStrain
    block = 1
  [../]
  [./stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;isoplas&#x27;
    block = 1
  [../]
  [./isoplas]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 5e6
    hardening_constant = 0.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 20

  dt = 1.0
  start_time = 0.0
  num_steps = 100
  end_time = 3.0
[] # Executioner

[Postprocessors]
  [./stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ElementAverageValue
    variable = stress_xy
  [../]
  [./vonmises]
    type = ElementAverageValue
    variable = vonmises
  [../]
  [./pressure]
    type = ElementAverageValue
    variable = pressure
  [../]
  [./el_strain_xx]
    type = ElementAverageValue
    variable = elastic_strain_xx
  [../]
  [./el_strain_yy]
    type = ElementAverageValue
    variable = elastic_strain_yy
  [../]
  [./el_strain_zz]
    type = ElementAverageValue
    variable = elastic_strain_zz
  [../]
  [./pl_strain_xx]
    type = ElementAverageValue
    variable = plastic_strain_xx
  [../]
  [./pl_strain_yy]
    type = ElementAverageValue
    variable = plastic_strain_yy
  [../]
  [./pl_strain_zz]
    type = ElementAverageValue
    variable = plastic_strain_zz
  [../]
  [./eff_plastic_strain]
    type = ElementAverageValue
    variable = eff_plastic_strain
  [../]
  [./tot_strain_xx]
    type = ElementAverageValue
    variable = tot_strain_xx
  [../]
  [./tot_strain_yy]
    type = ElementAverageValue
    variable = tot_strain_yy
  [../]
  [./tot_strain_zz]
    type = ElementAverageValue
    variable = tot_strain_zz
  [../]
  [./disp_x1]
    type = NodalVariableValue
    nodeid = 0
    variable = disp_x
  [../]
  [./disp_x4]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_x
  [../]
  [./disp_y1]
    type = NodalVariableValue
    nodeid = 0
    variable = disp_y
  [../]
  [./disp_y4]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./_dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  [./console]
    type = Console
    output_linear = true
  [../]
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aa2d989d-f22b-4628-b4a8-b2d276d5c3c6"><div class="modal-content"><h4>modules/richards/test/tests/theis/th02.i</h4><pre class="moose-pre"><code class="language-text"># fully-saturated
# production
[Mesh]
  type = FileMesh
  file = th02_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 2 4 20&#x27;
    x = &#x27;0 1 10 100&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]

  [./total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsPolyLineSink
    pressures = &#x27;-1E9 1E9&#x27;
    fluxes = &#x27;200 200&#x27;
    point_file = th01.points
    SumQuantityUO = total_outflow_mass
    variable = pressure
  [../]
[]


[Postprocessors]
  [./flow_report]
    type = RichardsPlotQuantity
    uo = total_outflow_mass
  [../]
  [./p50]
    type = PointValue
    variable = pressure
    point = &#x27;50 0 0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E5
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    sat_UO = Saturation
    seff_UO = Seff1VG
    SUPG_UO = SUPGstandard
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-6 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 100
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  file_base = th02
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="56ac28d0-1358-42fb-898e-678d633cf918"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/square_branch_tri6_2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = false
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = TRI6
[]

[UserObjects]
  [./line_seg_cut_set_uo]
    type = LineSegmentCutSetUserObject
    cut_data = &#x27;-1.0000e-10   6.6340e-01   6.6340e-01  -1.0000e-10  0.0  1.0
                 3.3120e-01   3.3200e-01   1.0001e+00   3.3200e-01  1.0  2.0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
  [../]
[]

[Functions]
  [./right_disp_x]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
  [./top_disp_y]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
[]

[BCs]
  [./right_x]
    type = FunctionDirichletBC
    boundary = 1
    variable = disp_x
    function = right_disp_x
  [../]
  [./top_y]
    type = FunctionDirichletBC
    boundary = 2
    variable = disp_y
    function = top_disp_y
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
  [./left_x]
    type = DirichletBC
    boundary = 3
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-16
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 2.2
  num_steps = 5000
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ea6538e3-4667-4c7c-b07e-36289d9b7d91"><div class="modal-content"><h4>modules/contact/test/tests/verification/hertz_cyl/half_symm_q8/hertz_cyl_half_1deg_template3.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = hertz_cyl_half_1deg.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
  [./tang_force_x]
  [../]
  [./tang_force_y]
  [../]
[]

[Functions]
  [./disp_ramp_vert]
    type = PiecewiseLinear
    x = &#x27;0. 1. 11.&#x27;
    y = &#x27;0. -0.0020 -0.0020&#x27;
  [../]
  [./disp_ramp_horz]
    type = PiecewiseLinear
    x = &#x27;0. 1. 11.&#x27;
    y = &#x27;0. 0.0 0.0014&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./inc_slip_x]
    type = PenetrationAux
    variable = inc_slip_x
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./inc_slip_y]
    type = PenetrationAux
    variable = inc_slip_y
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_x]
    type = PenetrationAux
    variable = accum_slip_x
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_y]
    type = PenetrationAux
    variable = accum_slip_y
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./tang_force_x]
    type = PenetrationAux
    variable = tang_force_x
    quantity = tangential_force_x
    boundary = 3
    paired_boundary = 2
  [../]
  [./tang_force_y]
    type = PenetrationAux
    variable = tang_force_y
    quantity = tangential_force_y
    boundary = 3
    paired_boundary = 2
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 3
    paired_boundary = 2
  [../]
[]

[Postprocessors]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 1
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 1
  [../]
  [./top_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 4
  [../]
  [./top_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 4
  [../]
  [./disp_x639]
    type = NodalVariableValue
    nodeid = 638
    variable = disp_x
  [../]
  [./disp_y639]
    type = NodalVariableValue
    nodeid = 638
    variable = disp_y
  [../]
  [./_dt]
    type = TimestepSize
  [../]
  [./num_lin_it]
    type = NumLinearIterations
  [../]
  [./num_nonlin_it]
    type = NumNonlinearIterations
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./top_y_disp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = disp_ramp_vert
  [../]
  [./top_x_disp]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = disp_ramp_horz
  [../]
[]

[Materials]
  [./stuff1_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e10
    poissons_ratio = 0.0
  [../]
  [./stuff1_strain]
    type = ComputeFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./stuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./stuff2_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff2_strain]
    type = ComputeFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./stuff2_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
  [./stuff3_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;3&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff3_strain]
    type = ComputeFiniteStrain
    block = &#x27;3&#x27;
  [../]
  [./stuff3_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;3&#x27;
  [../]
  [./stuff4_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;4&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff4_strain]
    type = ComputeFiniteStrain
    block = &#x27;4&#x27;
  [../]
  [./stuff4_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;4&#x27;
  [../]
  [./stuff5_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;5&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff5_strain]
    type = ComputeFiniteStrain
    block = &#x27;5&#x27;
  [../]
  [./stuff5_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;5&#x27;
  [../]
  [./stuff6_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;6&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff6_strain]
    type = ComputeFiniteStrain
    block = &#x27;6&#x27;
  [../]
  [./stuff6_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;6&#x27;
  [../]
  [./stuff7_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;7&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff7_strain]
    type = ComputeFiniteStrain
    block = &#x27;7&#x27;
  [../]
  [./stuff7_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;7&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-7
  nl_rel_tol = 1e-6
  l_max_its = 100
  nl_max_its = 200

  start_time = 0.0
  end_time = 2.0
  l_tol = 5e-4
  dt = 0.1
  dtmin = 0.1
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[VectorPostprocessors]
  [./x_disp]
    type = NodalValueSampler
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    sort_by = id
  [../]
  [./y_disp]
    type = NodalValueSampler
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    sort_by = id
  [../]
  [./cont_press]
    type = NodalValueSampler
    variable = contact_pressure
    boundary = &#x27;3&#x27;
    sort_by = id
  [../]
[]

[Outputs]
  print_linear_residuals = true
  perf_graph = true
  [./exodus]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 5
  [../]
  [./chkfile]
    type = CSV
    show = &#x27;x_disp y_disp cont_press&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./chkfile2]
    type = CSV
    show = &#x27;bot_react_x bot_react_y disp_x639 disp_y639 top_react_x top_react_y&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./outfile]
    type = CSV
    delimiter = &#x27; &#x27;
    execute_vector_postprocessors_on = none
  [../]
[]

[Contact]
  [./interface]
    primary = 2
    secondary = 3
    model = coulomb
    friction_coefficient = 0.0
    formulation = penalty
    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+9
  [../]
[]

[Dampers]
  [./contact_slip]
    type = ContactSlipDamper
    primary = &#x27;2&#x27;
    secondary = &#x27;3&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c71cd972-afce-4657-b431-ec7e04665939"><div class="modal-content"><h4>modules/combined/test/tests/power_law_creep/power_law_creep_smallstrain.i</h4><pre class="moose-pre"><code class="language-text"># 1x1x1 unit cube with uniform pressure on top face for the case of small strain.
#  This test does not have a solid mechanics analog because there is not an equvialent
#  small strain with rotations strain calculator material in solid mechanics

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1000.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy&#x27;
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./u_top_pull]
    type = Pressure
    variable = disp_y
    component = 1
    boundary = top
    factor = -10.0e6
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp_fix]
    type = DirichletBC
    variable = temp
    boundary = &#x27;bottom top&#x27;
    value = 1000.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2e11
    poissons_ratio = 0.3
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;power_law_creep&#x27;
    tangent_operator = elastic
  [../]
  [./power_law_creep]
    type = PowerLawCreepStressUpdate
    coefficient = 1.0e-15
    n_exponent = 4
    activation_energy = 3.0e5
    temperature = temp
  [../]

  [./thermal]
    type = HeatConductionMaterial
    specific_heat = 1.0
    thermal_conductivity = 100.
  [../]
  [./density]
    type = Density
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.0
  end_time = 1.0
  num_steps = 10
  dt = 0.1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0f278c6f-23d0-453d-9702-cc7937d5c10b"><div class="modal-content"><h4>modules/combined/test/tests/evolving_mass_density/rz_tensors.i</h4><pre class="moose-pre"><code class="language-text">#  Constant mass in RZ using Tensor Mechanics
#
# This test forces an RZ mesh to move through a series of displacements
#   in order to test whether the mass is constant.  The density is chosen
#   such that the mass is 2.5.
# This test is a duplicate of the rz.i test for solid mechanics, and the
#   output of this tensor mechanics test is compared to the original
#   solid mechanics output.  The duplication is necessary to test the
#   migrated tensor mechanics version while maintaining tests for solid mechanics.

[Mesh]
  file = elastic_patch_rz.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Functions]
  [./x101]
    type = PiecewiseLinear
    x = &#x27;0 5 6&#x27;
    y = &#x27;0 0 0.24&#x27;
  [../]
  [./y101]
    type = PiecewiseLinear
    x = &#x27;0 6&#x27;
    y = &#x27;0 0&#x27;
  [../]
  [./x102]
    type = PiecewiseLinear
    x = &#x27;0 4 5&#x27;
    y = &#x27;0 0 0.24&#x27;
  [../]
  [./y102]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3&#x27;
    y = &#x27;0 0 0.12 0&#x27;
  [../]
  [./x103]
    type = PiecewiseLinear
    x = &#x27;0 4 5&#x27;
    y = &#x27;0 0 0.24&#x27;
  [../]
  [./y103]
    type = PiecewiseLinear
    x = &#x27;0 1    3    4&#x27;
    y = &#x27;0 0.12 0.12 0&#x27;
  [../]
  [./x104]
    type = PiecewiseLinear
    x = &#x27;0 5 6&#x27;
    y = &#x27;0 0 0.24&#x27;
  [../]
  [./y104]
    type = PiecewiseLinear
    x = &#x27;0 2 3    4&#x27;
    y = &#x27;0 0 0.12 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[BCs]

  [./101x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 101
    function = x101
  [../]
  [./101y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 101
    function = y101
  [../]

  [./102x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 102
    function = x102
  [../]
  [./102y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 102
    function = y102
  [../]

  [./103x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 103
    function = x103
  [../]
  [./103y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 103
    function = y103
  [../]

  [./104x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 104
    function = x104
  [../]
  [./104y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 104
    function = y104
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = PATCH
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./small_strain_rz]
    type = ComputeAxisymmetricRZSmallStrain
    block = PATCH
  [../]

  [./elastic_stress]
    type = ComputeLinearElasticStress
    block = PATCH
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  # Two sets of linesearch options are for petsc 3.1 and 3.3 respectively
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       101&#x27;

  line_search = &#x27;none&#x27;
  nl_abs_tol = 1e-10
  l_max_its = 20

  start_time = 0.0
  dt = 1
  num_steps = 6
  end_time = 6.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
    file_base = rz_out
  [../]
[]

[Postprocessors]
  [./mass]
    type = Mass
    variable = disp_x
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3c7e6d46-06e9-4ef2-b8d6-f6a020867941"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_power.i</h4><pre class="moose-pre"><code class="language-text">#
# Simple test of power law softening law for smeared cracking.
# Upon reaching the failure stress in the x direction, the
# softening model abruptly reduces the stress to a fraction
# of its original value, and re-loading occurs at a reduced
# stiffness. This is repeated multiple times.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3  4&#x27;
    y = &#x27;0 1 0 -1 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pull]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = right
    function = displ
  [../]
  [./left]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./bottom]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./back]
    type = ADDirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 1.68e6
    softening_models = power_law_softening
  [../]
  [./power_law_softening]
    type = ADPowerLawSoftening
    stiffness_reduction = 0.3333
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 1.0
  dt = 0.01
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="31a80b90-7ea4-47bd-9e30-0b61b693204a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/strain_energy_density/nonAD_rate_model_weak_plane.i</h4><pre class="moose-pre"><code class="language-text"># Single element test to check the strain energy density calculation

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
  out_of_plane_strain = strain_zz
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 2
[]

[Variables]
  [./strain_zz]
  []
[]

[AuxVariables]
  [./SERD]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress strain_xx strain_yy&#x27;
    planar_formulation = WEAK_PLANE_STRESS
  [../]
[]

[AuxKernels]
  [./SERD]
    type = MaterialRealAux
    variable = SERD
    property = strain_energy_rate_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./Pressure]
    [./top]
      boundary = &#x27;top&#x27;
      function = rampConstantUp
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.0
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
  [./powerlawcrp]
    type = PowerLawCreepStressUpdate
    coefficient = 3.125e-21 # 7.04e-17 #
    n_exponent = 4.0
    m_exponent = 0.0
    activation_energy = 0.0
    # max_inelastic_increment = 0.01
  [../]
  [./strain_energy_rate_density]
    type = StrainEnergyRateDensity
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
[]

[Executioner]
   type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./SERD]
    type = ElementAverageValue
    variable = SERD
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="99d94614-4c46-4256-abad-cb8efa04fb4c"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/strain_energy_density/rate_model_small.i</h4><pre class="moose-pre"><code class="language-text"># Single element test to check the strain energy density calculation

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 2
[]

[AuxVariables]
  [./SERD]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
  [./ramp_disp_y]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 6.8e-6 1.36e-5&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = SMALL
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress elastic_strain_xx elastic_strain_yy elastic_strain_zz strain_xx strain_yy strain_zz&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SERD]
    type = MaterialRealAux
    variable = SERD
    property = strain_energy_rate_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./top_disp]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = &#x27;top&#x27;
    function = ramp_disp_y
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.0
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
  [./powerlawcrp]
    type = PowerLawCreepStressUpdate
    coefficient = 3.125e-21 # 7.04e-17 #
    n_exponent = 4.0
    m_exponent = 0.0
    activation_energy = 0.0
    # max_inelastic_increment = 0.01
  [../]
  [./strain_energy_rate_density]
    type = StrainEnergyRateDensity
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
[]

[Executioner]
   type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 2
   num_steps = 2
[]

[Postprocessors]
  [./etxx]
    type = ElementalVariableValue
    variable = strain_xx
    elementid = 0
  [../]
  [./etyy]
    type = ElementalVariableValue
    variable = strain_yy
    elementid = 0
  [../]
  [./etzz]
    type = ElementalVariableValue
    variable = strain_zz
    elementid = 0
  [../]
  [./sigxx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./sigyy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./sigzz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./SERD]
    type = ElementAverageValue
    variable = SERD
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="90b70aa0-6b93-4560-a691-796e4a308a2b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_plane_stress.i</h4><pre class="moose-pre"><code class="language-text">################################################################################
#
# 1x1x1 cube, single element
# simulate plane stress
# pull in +y direction on right surface to produce shear strain
#
#
#
#          ____________
#         /|          /|
#        / |  5      / |                       -X  Left   1
#       /__________ /  |                       +X  Right  4
#      |   |    3  |   |                       +Y  Top    5
#      | 1 |       | 4 |                       -Y  Bottom 2
#      |   |_6_____|___|           y           +Z  Front  6
#      |  /        |  /            ^           -Z  Back   3
#      | /    2    | /             |
#      |/__________|/              |
#                                  ----&gt; x
#                                 /
#                                /
#                               z
#
#
#
#################################################################################

[Mesh]
  file = cube.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 0.1 0.2 0.3 0.4&#x27;
    y = &#x27;0 0.0026 0 -0.0026 0&#x27;
  [../]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0 0.1 0.2 0.3 0.4&#x27;
    y = &#x27;0 0   0    0   0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pull_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = displ
  [../]
  [./pin_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1  4&#x27;
    value = 0.0
  [../]
  [./pin_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;3&#x27;
    value = 0.0
  [../]
  [./front]
    type = Pressure
    variable = disp_z
    component = 2
    boundary = 6
    function = pressure
    factor   = 1.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 200.0e3
    poissons_ratio = .3
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 120
    shear_retention_factor = 0.1
    softening_models = exponential_softening
  [../]
  [./exponential_softening]
    type = ExponentialSoftening
    residual_stress = 0.1
    beta = 0.1
  [../]
[]

[Executioner]
  type = Transient
  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.4
  dt = 0.04
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d3e429dd-2fc0-4aec-812c-aad6f61e6b3b"><div class="modal-content"><h4>modules/contact/test/tests/hertz_spherical/hertz_contact_rz.i</h4><pre class="moose-pre"><code class="language-text"># Hertz Contact: Sphere on sphere

# Spheres have the same radius, Young&#x27;s modulus, and Poisson&#x27;s ratio.

# Define E:
# 1/E = (1-nu1^2)/E1 + (1-nu2^2)/E2
#
# Effective radius R:
# 1/R = 1/R1 + 1/R2
#
# F is the applied compressive load.
#
# Area of contact a::
# a^3 = 3FR/4E
#
# Depth of indentation d:
# d = a^2/R
#
#
# Let R1 = R2 = 2.  Then R = 1.
#
# Let nu1 = nu2 = 0.25, E1 = E2 = 1.40625e7.  Then E = 7.5e6.
#
# Let F = 10000.  Then a = 0.1, d = 0.01.
#

## Note: There is not a good way to check the result.  The standard approach is
## to map contact pressure as a function of radius, but we don&#x27;t have the
## contact pressure available.  See the description on Wikipedia for details of
## analytic equations, and the Abaqus Benchmarks Manual, 1.1.11, for a plot of
## contact pressure vs. radius.
[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]#Comment
  file = hertz_contact_rz.e
  displacements = &#x27;disp_x disp_y&#x27;
[] # Mesh

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 795.77471545947674 # 10000/pi/2^2
  [../]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.  1.    2.&#x27;
    y = &#x27;0. -0.01 -0.01&#x27;
  [../]
[] # Functions

[Variables]

  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

[] # Variables

[AuxVariables]

  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./hydrostatic]
    order = CONSTANT
    family = MONOMIAL
  [../]

[] # AuxVariables

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = SMALL
  [../]
[]
[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]

[] # AuxKernels

[BCs]

  [./base_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1000
    value = 0.0
  [../]

  [./symm_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./disp_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

[] # BCs


[Contact]
  [./dummy_name]
    primary = 1000
    secondary = 100
    model = coulomb
    formulation = penalty
    normalize_penalty = true
    friction_coefficient = 0.4
    penalty = 8e7
    tangential_tolerance = 0.005
  [../]
[]

[Materials]

  [./tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1.40625e7
    poissons_ratio = 0.25
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = &#x27;1&#x27;
  [../]

  [./tensor_1000]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1000&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]
  [./stress_1000]
    type = ComputeLinearElasticStress
    block = &#x27;1000&#x27;
  [../]

[] # Materials

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  []
[]

[Executioner]

  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      101&#x27;


  line_search = &#x27;none&#x27;


  nl_abs_tol = 1e-7

  l_max_its = 200

  start_time = 0.0
  dt = 0.5
  end_time = 2.0
[] # Executioner

[Postprocessors]
  [./maxdisp]
    type = NodalVariableValue
    nodeid = 39 # 40-1 where 40 is the exodus node number of the top-left node
    variable = disp_y
  [../]
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9da893ad-8314-4cd4-83d1-14bd16886fc3"><div class="modal-content"><h4>modules/peridynamics/test/tests/generalized_plane_strain/out_of_plane_pressure_OSPD.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  scalar_out_of_plane_strain = scalar_strain_zz
[]

[Mesh]
  type = PeridynamicsMesh
  horizon_number = 3

  [./gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 4
    ny = 4
  [../]
  [./gpd]
    type = MeshGeneratorPD
    input = gmg
    retain_fe_mesh = false
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]

  [./scalar_strain_zz]
    order = FIRST
    family = SCALAR
  [../]
[]

[AuxVariables]
  [./stress_zz]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules]
  [./Peridynamics/Mechanics]
    [./Master]
      [./all]
        formulation = ORDINARY_STATE
      [../]
    [../]
    [./GeneralizedPlaneStrain]
      [./all]
        formulation = ORDINARY_STATE
        out_of_plane_stress_variable = stress_zz
        out_of_plane_pressure = pressure_function
        factor = 1e5
      [../]
    [../]
  [../]
[]

[AuxKernels]
  [./stress_zz]
    type = NodalRankTwoPD
    variable = stress_zz
    poissons_ratio = 0.3
    youngs_modulus = 1e6
    rank_two_tensor = stress
    output_type = component
    index_i = 2
    index_j = 2
  [../]
[]

[Postprocessors]
  [./react_z]
    type = NodalVariableIntegralPD
    variable = stress_zz
  [../]
[]

[Functions]
  [./pressure_function]
    type = PiecewiseLinear
    x = &#x27;0  1&#x27;
    y = &#x27;0  1&#x27;
  [../]
[]

[BCs]
  [./left_x]
    type = DirichletBC
    boundary = 1003
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 1000
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]

  [./force_density]
    type = ComputeSmallStrainConstantHorizonMaterialOSPD
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  line_search = none

  start_time = 0.0
  end_time = 1.0
[]

[Outputs]
  exodus = true
  file_base = out_of_plane_pressure_OSPD
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="787570a2-ed35-450d-acc9-75303cc237a0"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/restart2.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  exodus = true
[]

[Problem]
  restart_file_base = restart_out_cp/0010
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="625b8de2-8d0d-4a57-b10f-13bb1b583eef"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/additional_volume.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test using using automatic differentiation
#
# This test is designed to compute an internal pressure based on
# p = n * R * / (V_cavity / T_cavity + V_add / T_add)
# where
#  p is the pressure
#  n is the amount of material in the volume (moles)
#  R is the universal gas constant
#  T_cavity is the temperature in the cavity
#  T_add is the temperature of the additional volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7. An additional volume of 2 is added.
#
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V_cavity0 + gamma * t + V_add
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = -(0.003322259...) * V0
#   T0 = 240.54443866068704
#   V_cavity0 = 7
#   V_add = 2
#   T_add = 100
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
#  An additional volume of 2 with a temperature of 100.0 is included.
#
# So, n0 = p0 * (V_cavity / T_cavity + V_add / T_add) / R
#        = 100 * (7 / 240.544439 + 2 / 100) / 8.314472
#        = 0.59054
#
# The parameters combined at t = 1 gives p = 249.647.
#
# This test sets the initial temperature to 500, but the CavityPressure
#   is told that that initial temperature is T0.  Thus, the final solution
#   is unchanged.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3d.e
[]

[GlobalParams]
  volumetric_locking_correction = true
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.59054&#x27;
  [../]
  [./additional_volume]
    type = ConstantFunction
    value = 2
  [../]
  [./temperature_of_additional_volume]
    type = ConstantFunction
    value = 100
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 500
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = ADDiffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = ADFunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      initial_temperature = 240.54443866068704
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      additional_volumes = volume1
      temperature_of_additional_volumes = temperature1
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ADComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 1
  [../]
  [./strain1]
    type = ADComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ADComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 2
  [../]
  [./strain2]
    type = ADComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
  [./volume1]
    type = FunctionValuePostprocessor
    function = additional_volume
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./temperature1]
    type = FunctionValuePostprocessor
    function = temperature_of_additional_volume
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8d2d088c-d0ff-4248-b711-d1dbfc791ad0"><div class="modal-content"><h4>test/tests/misc/check_error/missing_function_file_test.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = nonexistent_file #should generate error
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="76eaa8ce-0f79-4ded-9bd6-09cd41ea19d1"><div class="modal-content"><h4>modules/xfem/test/tests/diffusion_xfem/diffusion.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 6
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.5 1.0 0.5 0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = 3
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="49630299-b6ab-41e1-8b62-0514ffec3828"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/fric_constraint/2_block_common_cross_stick.i</h4><pre class="moose-pre"><code class="language-text"># Test for LineElementAction on multiple blocks by placing parameters
# common to all blocks outside of the individual action blocks

# 2 beams of length 1m are fixed at one end and a force of 1e-4 N
# is applied at the other end of the beams. Beam 1 is in block 1
# and beam 2 is in block 2. All the material properties for the two
# beams are identical. The moment of inertia of beam 2 is twice that
# of beam 1.

# Since the end displacement of a cantilever beam is inversely proportional
# to the moment of inertia, the y displacement at the end of beam 1 should be twice
# that of beam 2.

[Mesh]
  type = FileMesh
  file = test_fric_cross.e
  #displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1 3&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./move_z4]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 2
    function = pull
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0  3.0  4.0  5.0  6.0  7.0   8.0  9.0 10.0 11.0 12.0 13.0&#x27;
    y = &#x27;0.0 0.0 -0.2 -0.4 -0.6 -0.8 -0.6 -0.4 -0.2  0.0 0.2 0.4  0.6 0.8&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 5e-5
  l_max_its = 10

  dt = 1
  dtmin = 1
  end_time = 13
[]

[Modules/TensorMechanics/LineElementMaster]
  # parameters common to all blocks

  add_variables = true
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  rotations = &#x27;rot_x rot_y rot_z&#x27;

  # Geometry parameters
  area = 0.5
  y_orientation = &#x27;0.0 1.0 0.0&#x27;

  [./block_1]
    Iy = 1e-5
    Iz = 1e-5
    block = 1
  [../]
  [./block_2]
    Iy = 8e-4
    Iz = 8e-4
    block = &#x27;2 3&#x27;
  [../]
[]

[Materials]
  [./stress]
    type = ComputeBeamResultants
    block = &#x27;1 2 3&#x27;
  [../]
  [./elasticity_1]
    type = ComputeElasticityBeam
    youngs_modulus = 2.0
    poissons_ratio = 0.3
    shear_coefficient = 1.0
    block = &#x27;1 2 3&#x27;
  [../]
[]

[Constraints]
  [./tie_z]
    type = NodalStickConstraint
    penalty = 1e8
    boundary = 6
    secondary = 4
    variable = disp_z
    formulation = kinematic
  [../]
  [./tie_z2]
    type = NodalStickConstraint
    penalty = 1e8
    boundary = 6
    secondary = 5
    variable = disp_z
    formulation = kinematic
  [../]
[]

[Postprocessors]
  [./disp_x_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_x
  [../]
  [./disp_x_2]
    type = NodalVariableValue
    nodeid = 2
    variable = disp_x
  [../]
  [./disp_z_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_z
  [../]
  [./disp_z_2]
    type = NodalVariableValue
    nodeid = 2
    variable = disp_z
  [../]
[]

[Outputs]
  #file_base = &#x27;2_block_out&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ee8c6b49-8af9-4400-b3de-aebeae0e7d61"><div class="modal-content"><h4>modules/contact/test/tests/tension_release/8ElemTensionRelease.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = 8ElemTensionRelease.e
  partitioner = centroid
  centroid_partitioner_direction = x
[]

[GlobalParams]
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./up]
    type = PiecewiseLinear
    x = &#x27;0 1      2 3&#x27;
    y = &#x27;0 0.0001 0 -.0001&#x27;
  [../]
[]

[AuxVariables]
  [./status]
  [../]
  [./pid]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = FINITE
  []
[]

[Contact]
  [./dummy_name]
    primary = 2
    secondary = 3
    penalty = 1e6
    model = frictionless
    tangential_tolerance = 0.01
  [../]
[]

[AuxKernels]
  [./pid]
    type = ProcessorIDAux
    variable = pid
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./status]
    type = PenetrationAux
    quantity = mechanical_status
    variable = status
    boundary = 3
    paired_boundary = 2
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./lateral]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 4&#x27;
    value = 0
  [../]

  [./bottom_up]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = up
  [../]

  [./top]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1.0e6
    poissons_ratio = 0.3
  [../]
  [./stiffStuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      101&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  l_tol = 1e-4

  l_max_its = 100
  nl_max_its = 10
  dt = 0.1
  num_steps = 30

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="75f723ce-bc9a-45f1-94c7-fd3e801b803c"><div class="modal-content"><h4>modules/richards/test/tests/theis/th21.i</h4><pre class="moose-pre"><code class="language-text"># two-phase, fully-saturated
# production
[Mesh]
  type = FileMesh
  file = th01_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;0.5 1 2 10&#x27;
    x = &#x27;0 1 10 100&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-5
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]

  [./total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]


[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_pressure
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsPolyLineSink
    pressures = &#x27;-1E9 1E9&#x27;
    fluxes = &#x27;200 200&#x27;
    point_file = th01.points
    SumQuantityUO = total_outflow_mass
    variable = pwater
  [../]
[]


[Postprocessors]
  [./flow_report]
    type = RichardsPlotQuantity
    uo = total_outflow_mass
  [../]
  [./p50]
    type = PointValue
    variable = pwater
    point = &#x27;50 0 0&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E5
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 1E-5&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-6 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 100
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  file_base = th21
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b811f94e-cc58-4180-ae22-ac2bb5061bde"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/czm/czm_patch_test.i</h4><pre class="moose-pre"><code class="language-text"># Patch test for cohesive zone modeling to check convergence
[Mesh]
  [./msh]
  type = FileMeshGenerator
  file = patch_mesh.e
  []
  [./transform]
  type = TransformGenerator
  input = msh
  transform = TRANSLATE
  vector_value = &#x27;-0.5 -0.5 -0.5&#x27;
  []
  [./split]
    type = BreakMeshByBlockGenerator
    input = transform
  []
  [./add_surfaces]
    type = SideSetsFromNormalsGenerator
    input = split
    normals = &#x27;0  0  1
               0  1  0
               1  0  0
               0  0 -1
               0 -1  0
              -1  0  0&#x27;
    fixed_normal = true
    new_boundary = &#x27;front top right back bottom left&#x27;
  []
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./all]
        strain = FINITE
        add_variables = true
        use_finite_deform_jacobian = true
        use_automatic_differentiation = true
      [../]
    [../]
  [../]
[]


[Functions]
  [./angles]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0&#x27;
  [../]

  [./stretch]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.01&#x27;
  [../]

  [./move_y]
    type = ParsedFunction
    value = &#x27;y*cos(theta) - z * (1 + a)*sin(theta) - y&#x27;
    vars = &#x27;a theta&#x27;
    vals = &#x27;stretch angles&#x27;
  [../]

  [./move_z]
    type = ParsedFunction
    value = &#x27;y*sin(theta) + z*(1+a)*cos(theta) - z&#x27;
    vars = &#x27;a theta&#x27;
    vals = &#x27;stretch angles&#x27;
  [../]

  [./dt_fun]
    type = PiecewiseConstant
    x = &#x27;0 1&#x27;
    y = &#x27;0.25 0.25&#x27;
  []
[]

[BCs]
  [./fix]
    type = DirichletBC
    preset = true
    value = 0.0
    boundary = left
    variable = disp_x
  [../]

  [./front_y]
    type = FunctionDirichletBC
    boundary = front
    variable = disp_y
    function = move_y
    preset = true
  [../]

  [./back_y]
    type = FunctionDirichletBC
    boundary = back
    variable = disp_y
    function = move_y
    preset = true
  [../]

  [./front_z]
    type = FunctionDirichletBC
    boundary = front
    variable = disp_z
    function = move_z
    preset = true
  [../]

  [./back_z]
    type = FunctionDirichletBC
    boundary = back
    variable = disp_z
    function = move_z
    preset = true
  [../]

[]


[Modules/TensorMechanics/CohesiveZoneMaster]
  [./czm_ik]
    boundary = &#x27;interface&#x27;
  [../]
[]

[Materials]
  [./stress]
    type = ADComputeFiniteStrainElasticStress
  [../]
  [./elasticity_tensor]
    type = ADComputeElasticityTensor
    fill_method = symmetric9
    C_ijkl = &#x27;1.684e5 0.176e5 0.176e5 1.684e5 0.176e5 1.684e5 0.754e5 0.754e5 0.754e5&#x27;
  [../]
  [./czm_mat]
    boundary = &#x27;interface&#x27;
  [../]
[]



[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;newton&#x27;
  line_search = none

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;

  l_max_its = 2
  l_tol = 1e-14
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10
  start_time = 0.0
  dt = 0.25
  end_time = 1
[]

[Postprocessors]
  [./nonlin]
    type = NumNonlinearIterations
  [../]
[]


[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2b726810-c9c3-41ac-a189-f67290759f1d"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/combined_creep_plasticity/combined_creep_plasticity_start_time.i</h4><pre class="moose-pre"><code class="language-text">#
# This test is Example 2 from &quot;A Consistent Formulation for the Integration
#   of Combined Plasticity and Creep&quot; by P. Duxbury, et al., Int J Numerical
#   Methods in Engineering, Vol. 37, pp. 1277-1295, 1994.
#
# The problem is a one-dimensional bar which is loaded from yield to a value of twice
#   the initial yield stress and then unloaded to return to the original stress. The
#   bar must harden to the required yield stress during the load ramp, with no
#   further yielding during unloading. The initial yield stress (sigma_0) is prescribed
#   as 20 with a plastic strain hardening of 100. The mesh is a 1x1x1 cube with symmetry
#   boundary conditions on three planes to provide a uniaxial stress field.
#
#  In the PowerLawCreep model, the creep strain rate is defined by:
#
#   edot = A(sigma)**n * exp(-Q/(RT)) * t**m
#
#   The creep law specified in the paper, however, defines the creep strain rate as:
#
#   edot = Ao * mo * (sigma)**n * t**(mo-1)
#      with the creep parameters given by
#         Ao = 1e-7
#         mo = 0.5
#         n  = 5
#
#   thus, input parameters for the test were specified as:
#         A = Ao * mo = 1e-7 * 0.5 = 0.5e-7
#         m = mo-1 = -0.5
#         n = 5
#         Q = 0
#
#   The variation of load P with time is:
#       P = 20 + 20t      0 &lt; t &lt; 1
#       P = 40 - 40(t-1)  1 &lt; t 1.5
#
#  The analytic solution for total strain during the loading period 0 &lt; t &lt; 1 is:
#
#    e_tot = (sigma_0 + 20*t)/E + 0.2*t + A * t**0.5  * sigma_0**n * [ 1 + (5/3)*t +
#               + 2*t**2 + (10/7)*t**3 + (5/9)**t**4 + (1/11)*t**5 ]
#
#    and during the unloading period 1 &lt; t &lt; 1.5:
#
#    e_tot = (sigma_1 - 40*(t-1))/E + 0.2 + (4672/693) * A * sigma_0**n +
#               A * sigma_0**n * [ t**0.5 * ( 32 - (80/3)*t + 16*t**2 - (40/7)*t**3
#                                  + (10/9)*t**4 - (1/11)*t**5 ) - (11531/693) ]
#
#         where sigma_1 is the stress at time t = 1.
#
#  Assuming a Young&#x27;s modulus (E) of 1000 and using the parameters defined above:
#
#    e_tot(1) = 2.39734
#    e_tot(1.5) = 3.16813
#
#
#   The numerically computed solution is:
#
#    e_tot(1) = 2.39718         (~0.006% error)
#    e_tot(1.5) = 3.15555       (~0.40% error)
#
[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy elastic_strain_yy creep_strain_yy plastic_strain_yy&#x27;
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;  10   11   11.5&#x27;
    y = &#x27;-20 -40   -20&#x27;
  [../]

  [./dts]
    type = PiecewiseLinear
    x = &#x27;10        10.5    11.0    11.5&#x27;
    y = &#x27;0.015  0.015  0.005  0.005&#x27;
  [../]
[]

[BCs]
  [./u_top_pull]
    type = Pressure
    variable = disp_y
    component = 1
    boundary = top
    factor = 1
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 0
    youngs_modulus = 1e3
    poissons_ratio = 0.3
  [../]
  [./creep_plas]
    type = ComputeMultipleInelasticStress
    block = 0
    tangent_operator = elastic
    inelastic_models = &#x27;creep plas&#x27;
    max_iterations = 50
    absolute_tolerance = 1e-05
    combined_inelastic_strain_weights = &#x27;0.0 1.0&#x27;
  [../]
  [./creep]
    type = PowerLawCreepStressUpdate
    block = 0
    coefficient = 0.5e-7
    n_exponent = 5
    m_exponent = -0.5
    activation_energy = 0
    start_time = 10
  [../]
  [./plas]
    type = IsotropicPlasticityStressUpdate
    block = 0
    hardening_constant = 100
    yield_stress = 20
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  l_tol = 1e-5
  start_time = 10.0
  end_time = 11.5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="49901e77-2046-428f-8a76-a5cfea69ce81"><div class="modal-content"><h4>modules/contact/test/tests/nodal_area/nodal_area_Hex20_3.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = nodal_area_Hex20.e
[]

[GlobalParams]
  order = SECOND
  displacements = &#x27;displ_x displ_y displ_z&#x27;
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0     1&#x27;
    y = &#x27;0  20e-6&#x27;
  [../]
[]

[Variables]
  [./displ_x]
  [../]
  [./displ_y]
  [../]
  [./displ_z]
  [../]
[]

[AuxVariables]
  [./react_x]
  [../]
  [./react_y]
  [../]
  [./react_z]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    incremental = true
    save_in = &#x27;react_x react_y react_z&#x27;
    add_variables = true
    strain = FINITE
    generate_output = &#x27;stress_xx&#x27;
  [../]
[]

[BCs]
  [./move_right]
    type = FunctionDirichletBC
    boundary = &#x27;1&#x27;
    variable = displ_x
    function = disp
  [../]

  [./fixed_x]
    type = DirichletBC
    boundary = &#x27;3 4&#x27;
    variable = displ_x
    value = 0
  [../]

  [./fixed_y]
    type = DirichletBC
    boundary = 10
    variable = displ_y
    value = 0
  [../]

  [./fixed_z]
    type = DirichletBC
    boundary = 11
    variable = displ_z
    value = 0
  [../]
[]

[Contact]
  [./dummy_name]
    primary = 3
    secondary = 2
    formulation = penalty
    penalty = 1e9
    tangential_tolerance = 1e-5
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-7
  l_tol = 1e-4
  l_max_its = 40
  nl_max_its = 10

  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 1.0

  [./Quadrature]
    order = THIRD
  [../]
[]

[Postprocessors]
  [./react_x]
    type = NodalSum
    variable = react_x
    boundary = 1
  [../]
  [./total_area]
    type = NodalSum
    variable = nodal_area_dummy_name
    boundary = 2
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8546124f-f914-454e-a835-98f8c1a6577e"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test4tt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4tt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="864b4c88-7151-45c0-a580-0e116f83701a"><div class="modal-content"><h4>modules/richards/test/tests/buckley_leverett/bl22_lumped.i</h4><pre class="moose-pre"><code class="language-text"># two-phase version
# super-sharp front version
[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 150
  xmin = 0
  xmax = 15
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-4 1E-3 1E-2 2E-2 5E-2 6E-2 0.1 0.2&#x27;
    x = &#x27;0    1E-2 1E-1 1    5    20   40  41&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E6
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-4
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-4
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
  [./bounds_dummy]
  [../]
[]

[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
  [./richardsppenalty]
    type = RichardsPPenalty
    variable = pgas
    a = 1E-18
    lower_var = pwater
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_water
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_gas
  [../]
[]

[BCs]
  [./left_w]
    type = DirichletBC
    variable = pwater
    boundary = left
    value = 1E6
  [../]
  [./left_g]
    type = DirichletBC
    variable = pgas
    boundary = left
    value = 1000
  [../]
  [./right_w]
    type = DirichletBC
    variable = pwater
    boundary = right
    value = -100000
  [../]
  [./right_g]
    type = DirichletBC
    variable = pgas
    boundary = right
    value = 0
  [../]
[]


[Functions]
  [./initial_water]
    type = ParsedFunction
    value = 1000000*(1-min(x/5,1))-if(x&lt;5,0,100000)
  [../]
  [./initial_gas]
    type = ParsedFunction
    value = 1000
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.15
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    viscosity = &#x27;1E-3 1E-6&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]

  [./standard]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10 1E-10 20 1E-10 1E-100&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  end_time = 50

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = bl22_lumped
  [./exodus]
    type = Exodus
    interval = 100000
    hide = &#x27;pgas bounds_dummy&#x27;
    execute_on = &#x27;initial final timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e37e88b4-7dc0-4e46-b12b-0935f64ad3c7"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test3qns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test3qns_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2ba8fc72-25c8-4ce6-9e7a-4e11d5977700"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral_vtest/j_int_surfbreak_ellip_crack_sym_mm.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = ellip_crack_4sym_norad_mm.e
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./resid_z]
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1&#x27;
    scale_factor = -68.95 #MPa
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 1001
  crack_direction_method = CurvedCrackFront
  crack_end_direction_method = CrackDirectionVector
  crack_direction_vector_end_1 = &#x27;0.0 1.0 0.0&#x27;
  crack_direction_vector_end_2 = &#x27;1.0 0.0 0.0&#x27;
  radius_inner = &#x27;12.5 25.0 37.5&#x27;
  radius_outer = &#x27;25.0 37.5 50.0&#x27;
  intersecting_boundary = &#x27;1 2&#x27;
  symmetry_plane = 2
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 12
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 5
      function = rampConstantUp
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]

   type = Transient
  # Two sets of linesearch options are for petsc 3.1 and 3.3 respectively
  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

#  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;
  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 1e-5
   nl_rel_tol = 1e-11
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./nl_its]
    type = NumNonlinearIterations
  [../]
  [./lin_its]
    type = NumLinearIterations
  [../]
  [./react_z]
    type = NodalSum
    variable = resid_z
    boundary = 5
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = j_int_surfbreak_ellip_crack_sym_mm_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="681b2cab-3c28-44a3-b409-a41daff66a36"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/truss/truss_3d_action.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = truss_3d.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
 [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./x2]
    type = PiecewiseLinear
    x = &#x27;0  1 2 3&#x27;
    y = &#x27;0 .5 1 1&#x27;
  [../]
  [./y2]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3&#x27;
    y = &#x27;0 0 .5 1&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0.0
  [../]
  [./fixx2]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    function = x2
  [../]
  [./fixx3]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 3
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]
  [./fixy2]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = y2
  [../]
  [./fixy3]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 3
    value = 0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]
  [./fixz2]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
  [./fixz3]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 3
    value = 0
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    block = &#x27;1 2&#x27;
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    block = &#x27;1 2&#x27;
    property = e_over_l
    variable = e_over_l
  [../]
  [./area]
    type = ConstantAux
    block = &#x27;1 2&#x27;
    variable = area
    value = 1.0
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;jacobi   101&#x27;
  line_search = &#x27;none&#x27;

  nl_max_its = 15
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10

  dt = 1
  num_steps = 3
  end_time = 3
[]

[Modules/TensorMechanics/LineElementMaster]
  [./block]
    truss = true
    add_variables = true
    displacements = &#x27;disp_x disp_y disp_z&#x27;

    area = area

    block = &#x27;1 2&#x27;

    save_in = &#x27;react_x react_y react_z&#x27;
  [../]
[]

[Materials]
  [./linelast]
    type = LinearElasticTruss
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[Outputs]
  file_base = &#x27;truss_3d_out&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6c54f1bd-5cdc-4f8a-a8c6-6d0de2399b7c"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/recompute_radial_return/isotropic_plasticity_finite_strain.i</h4><pre class="moose-pre"><code class="language-text"># This simulation uses the piece-wise linear strain hardening model
# with the incremental small strain formulation; incremental small strain
# is required to produce the strain_increment for the DiscreteRadialReturnStressIncrement
# class, which handles the calculation of the stress increment to return
# to the yield surface in a J2 (isotropic) plasticity problem.
#
#  This test assumes a Poissons ratio of 0.3 and applies a displacement loading
# condition on the top in the y direction.
#
# An identical problem was run in Abaqus on a similar 1 element mesh and was used
# to verify the SolidMechanics solution; this TensorMechanics code matches the
# SolidMechanics solution.
#
# Mechanical strain is the sum of the elastic and plastic strains but is different
# from total strain in cases with eigen strains, e.g. thermal strain.

[Mesh]
  file = 1x1x1cube.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./top_pull]
    type = ParsedFunction
    value = t*(0.0625)
  [../]
  [./hf]
    type = PiecewiseLinear
    x = &#x27;0  0.001 0.003 0.023&#x27;
    y = &#x27;50 52    54    56&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_yy plastic_strain_xx plastic_strain_yy plastic_strain_zz&#x27;
  [../]
[]

[BCs]
  [./y_pull_function]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = top_pull
  [../]
  [./x_bot]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
  [./z_bot]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./isotropic_plasticity]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 50.0
    hardening_function = hf
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;isotropic_plasticity&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 50
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10
  l_tol = 1e-9

  start_time = 0.0
  end_time = 0.075
  dt = 0.00125
  dtmin = 0.0001
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="faaddb9e-c2af-43c8-a856-d52c482862e4"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/combined_creep_plasticity/combined_creep_plasticity.i</h4><pre class="moose-pre"><code class="language-text">#
# This test is Example 2 from &quot;A Consistent Formulation for the Integration
#   of Combined Plasticity and Creep&quot; by P. Duxbury, et al., Int J Numerical
#   Methods in Engineering, Vol. 37, pp. 1277-1295, 1994.
#
# The problem is a one-dimensional bar which is loaded from yield to a value of twice
#   the initial yield stress and then unloaded to return to the original stress. The
#   bar must harden to the required yield stress during the load ramp, with no
#   further yielding during unloading. The initial yield stress (sigma_0) is prescribed
#   as 20 with a plastic strain hardening of 100. The mesh is a 1x1x1 cube with symmetry
#   boundary conditions on three planes to provide a uniaxial stress field.
#
#  In the PowerLawCreep model, the creep strain rate is defined by:
#
#   edot = A(sigma)**n * exp(-Q/(RT)) * t**m
#
#   The creep law specified in the paper, however, defines the creep strain rate as:
#
#   edot = Ao * mo * (sigma)**n * t**(mo-1)
#      with the creep parameters given by
#         Ao = 1e-7
#         mo = 0.5
#         n  = 5
#
#   thus, input parameters for the test were specified as:
#         A = Ao * mo = 1e-7 * 0.5 = 0.5e-7
#         m = mo-1 = -0.5
#         n = 5
#         Q = 0
#
#   The variation of load P with time is:
#       P = 20 + 20t      0 &lt; t &lt; 1
#       P = 40 - 40(t-1)  1 &lt; t 1.5
#
#  The analytic solution for total strain during the loading period 0 &lt; t &lt; 1 is:
#
#    e_tot = (sigma_0 + 20*t)/E + 0.2*t + A * t**0.5  * sigma_0**n * [ 1 + (5/3)*t +
#               + 2*t**2 + (10/7)*t**3 + (5/9)**t**4 + (1/11)*t**5 ]
#
#    and during the unloading period 1 &lt; t &lt; 1.5:
#
#    e_tot = (sigma_1 - 40*(t-1))/E + 0.2 + (4672/693) * A * sigma_0**n +
#               A * sigma_0**n * [ t**0.5 * ( 32 - (80/3)*t + 16*t**2 - (40/7)*t**3
#                                  + (10/9)*t**4 - (1/11)*t**5 ) - (11531/693) ]
#
#         where sigma_1 is the stress at time t = 1.
#
#  Assuming a Young&#x27;s modulus (E) of 1000 and using the parameters defined above:
#
#    e_tot(1) = 2.39734
#    e_tot(1.5) = 3.16813
#
#
#   The numerically computed solution is:
#
#    e_tot(1) = 2.39718         (~0.006% error)
#    e_tot(1.5) = 3.15555       (~0.40% error)
#
[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy elastic_strain_yy creep_strain_yy plastic_strain_yy&#x27;
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;  0   1   1.5&#x27;
    y = &#x27;-20 -40   -20&#x27;
  [../]

  [./dts]
    type = PiecewiseLinear
    x = &#x27;0        0.5    1.0    1.5&#x27;
    y = &#x27;0.015  0.015  0.005  0.005&#x27;
  [../]
[]

[BCs]
  [./u_top_pull]
    type = Pressure
    variable = disp_y
    component = 1
    boundary = top
    factor = 1
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 0
    youngs_modulus = 1e3
    poissons_ratio = 0.3
  [../]
  [./creep_plas]
    type = ComputeMultipleInelasticStress
    block = 0
    tangent_operator = elastic
    inelastic_models = &#x27;creep plas&#x27;
    max_iterations = 50
    absolute_tolerance = 1e-05
    combined_inelastic_strain_weights = &#x27;0.0 1.0&#x27;
  [../]
  [./creep]
    type = PowerLawCreepStressUpdate
    block = 0
    coefficient = 0.5e-7
    n_exponent = 5
    m_exponent = -0.5
    activation_energy = 0
  [../]
  [./plas]
    type = IsotropicPlasticityStressUpdate
    block = 0
    hardening_constant = 100
    yield_stress = 20
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  l_tol = 1e-5
  start_time = 0.0
  end_time = 1.5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3b64a4f5-dc6a-4aff-932c-f5500dcbc93e"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test4.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = dummy #we don&#x27;t get that far
    format = rowls
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="724ee8bc-7e65-4df4-9831-e2b12c9628e4"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymmetric_gps_small.i</h4><pre class="moose-pre"><code class="language-text">#
# This test checks the generalized plane strain using small strain formulation.
# The model consists of two sets of line elements. One undergoes a temperature rise of 100 with
# the other seeing a temperature rise of 300.  Young&#x27;s modulus is 3600, and
# Poisson&#x27;s ratio is 0.2.  The thermal expansion coefficient is 1e-8.  All
# nodes are constrained against movement.
#
# For plane strain case, i.e., without constraining the strain_yy to be uniform,
# the stress solution would be [-6e-3, -6e-3, -6e-3] and [-18e-3, -18e-3, -18e-3] (xx, yy, zz).
# The generalized plane strain kernels work to balance the force in y direction.
#
# With out of plane strain of 3e-6, the stress solution becomes
# [-3e-3, 6e-3, -3e-3] and [-15e-3, -6e-3, -15e-3] (xx, yy, zz).  This gives
# a domain integral of out-of-plane stress to be zero.
#

[GlobalParams]
  displacements = disp_x
  scalar_out_of_plane_strain = scalar_strain_yy
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = lines.e
[]

[Variables]
  [./disp_x]
  [../]
  [./temp]
    initial_condition = 580.0
  [../]
  [./scalar_strain_yy]
    order = FIRST
    family = SCALAR
  [../]
[]

[Functions]
  [./temp100]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;580 680&#x27;
  [../]
  [./temp300]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;580 880&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = Diffusion
    variable = temp
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./gps]
        planar_formulation = GENERALIZED_PLANE_STRAIN
        scalar_out_of_plane_strain = scalar_strain_yy
        strain = SMALL
        generate_output = &#x27;strain_xx strain_yy strain_zz stress_xx stress_yy stress_zz&#x27;
        eigenstrain_names = eigenstrain
      [../]
    [../]
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1000
    value = 0
    variable = disp_x
  [../]
  [./temp100]
    type = FunctionDirichletBC
    variable = temp
    function = temp100
    boundary = 2
  [../]
  [./temp300]
    type = FunctionDirichletBC
    variable = temp
    function = temp300
    boundary = 3
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-8
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-08
  nl_max_its = 15
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 1
  num_steps = 1
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e5980d28-4d5e-40a6-8668-2360d99161d9"><div class="modal-content"><h4>modules/richards/test/tests/rogers_stallybrass_clements/rsc01.i</h4><pre class="moose-pre"><code class="language-text"># RSC test with high-res time and spatial resolution
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 600
  ny = 1
  xmin = 0
  xmax = 10 # x is the depth variable, called zeta in RSC
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;3E-3 3E-2 0.05&#x27;
    x = &#x27;0 1 5&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater poil&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 10
    bulk_mod = 2E9
  [../]
  [./DensityOil]
    type = RichardsDensityConstBulk
    dens0 = 20
    bulk_mod = 2E9
  [../]
  [./SeffWater]
    type = RichardsSeff2waterRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./SeffOil]
    type = RichardsSeff2gasRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./RelPerm]
    type = RichardsRelPermMonomial
    simm = 0
    n = 1
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E-2
  [../]
[]


[Variables]
  [./pwater]
  [../]
  [./poil]
  [../]
[]

[ICs]
  [./water_init]
    type = ConstantIC
    variable = pwater
    value = 0
  [../]
  [./oil_init]
    type = ConstantIC
    variable = poil
    value = 15
  [../]
[]

[Kernels]
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstoil]
    type = RichardsMassChange
    variable = poil
  [../]
  [./richardsfoil]
    type = RichardsFlux
    variable = poil
  [../]
[]


[AuxVariables]
  [./SWater]
  [../]
  [./SOil]
  [../]
[]


[AuxKernels]
  [./Seff1VGwater_AuxK]
    type = RichardsSeffAux
    variable = SWater
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
  [./Seff1VGoil_AuxK]
    type = RichardsSeffAux
    variable = SOil
    seff_UO = SeffOil
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
[]


[BCs]
# we are pumping water into a system that has virtually incompressible fluids, hence the pressures rise enormously.  this adversely affects convergence because of almost-overflows and precision-loss problems.  The fixed things help keep pressures low and so prevent these awful behaviours.   the movement of the saturation front is the same regardless of the fixed things.
  active = &#x27;recharge fixedoil fixedwater&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pwater
    boundary = &#x27;left&#x27;
    pressures = &#x27;-1E10 1E10&#x27;
    bare_fluxes = &#x27;-1 -1&#x27;
    use_mobility = false
    use_relperm = false
  [../]
  [./fixedwater]
    type = DirichletBC
    variable = pwater
    boundary = &#x27;right&#x27;
    value = 0
  [../]
  [./fixedoil]
    type = DirichletBC
    variable = poil
    boundary = &#x27;right&#x27;
    value = 15
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.25
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityOil&#x27;
    relperm_UO = &#x27;RelPerm RelPerm&#x27;
    SUPG_UO = &#x27;SUPGstandard SUPGstandard&#x27;
    sat_UO = &#x27;Saturation Saturation&#x27;
    seff_UO = &#x27;SeffWater SeffOil&#x27;
    viscosity = &#x27;1E-3 2E-3&#x27;
    gravity = &#x27;0E-0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = rsc01
  interval = 100000
  execute_on = &#x27;initial final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a44e3eec-bf36-44cc-81e8-c21d4c88d291"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_newmark.i</h4><pre class="moose-pre"><code class="language-text"># Wave propogation in 1D using Newmark time integration
#
# The test is for an 1D bar element of length 4m  fixed on one end
# with a sinusoidal pulse dirichlet boundary condition applied to the other end.
# beta and gamma are Newmark time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel +  K*disp = 0
#
# Here M is the mass matrix, K is the stiffness matrix
#
# This equation is equivalent to:
#
# density*accel + Div Stress= 0
#
# The first term on the left is evaluated using the Inertial force kernel
# The last term on the left is evaluated using StressDivergenceTensors
#
# The displacement at the second, third and fourth node at t = 0.1 are
# -8.021501116638234119e-02, 2.073994362053969628e-02 and  -5.045094181261772920e-03, respectively

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 4
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 4.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.3025
    gamma = 0.6
    eta=0.0
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.3025
    gamma = 0.6
    eta=0.0
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.3025
    gamma = 0.6
    eta = 0.0
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.6
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.6
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.6
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value=0.0
  [../]
  [./right_z]
    type = DirichletBC
    variable = disp_z
    boundary = right
    value=0.0
  [../]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value=0.0
  [../]
  [./left_z]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value=0.0
  [../]
  [./front_x]
    type = DirichletBC
    variable = disp_x
    boundary = front
    value=0.0
  [../]
  [./front_z]
    type = DirichletBC
    variable = disp_z
    boundary = front
    value=0.0
  [../]
  [./back_x]
    type = DirichletBC
    variable = disp_x
    boundary = back
    value=0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = bottom
    function = displacement_bc
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;1 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 6.0
  l_tol = 1e-12
  nl_rel_tol = 1e-12
  dt = 0.1
[]


[Functions]
  [./displacement_bc]
    type = PiecewiseLinear
    data_file = &#x27;sine_wave.csv&#x27;
    format = columns
  [../]

[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_y
  [../]
  [./disp_2]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./disp_3]
    type = NodalVariableValue
    nodeid = 10
    variable = disp_y
  [../]
  [./disp_4]
    type = NodalVariableValue
    nodeid = 14
    variable = disp_y
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9ed71a79-10da-4aae-b9fa-ba9b4c92615c"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/strain_energy_density/ad_rate_model_weak_plane.i</h4><pre class="moose-pre"><code class="language-text"># Single element test to check the strain energy density calculation

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
  out_of_plane_strain = strain_zz
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 2
[]

[AuxVariables]
  [./SERD]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Variables]
  [./strain_zz]
  []
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress strain_xx strain_yy&#x27;
    planar_formulation = WEAK_PLANE_STRESS
    use_automatic_differentiation = true
  [../]
[]

[AuxKernels]
  [./SERD]
    type = ADMaterialRealAux
    variable = SERD
    property = strain_energy_rate_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./Pressure]
    [./top]
      boundary = &#x27;top&#x27;
      function = rampConstantUp
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.0
  [../]
  [./radial_return_stress]
    type = ADComputeMultipleInelasticStress
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
  [./powerlawcrp]
    type = ADPowerLawCreepStressUpdate
    coefficient = 3.125e-21 # 7.04e-17 #
    n_exponent = 4.0
    m_exponent = 0.0
    activation_energy = 0.0
    # max_inelastic_increment = 0.01
  [../]
  [./strain_energy_rate_density]
    type = ADStrainEnergyRateDensity
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
[]

[Executioner]
   type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./SERD]
    type = ElementAverageValue
    variable = SERD
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5ed62b78-ddd1-49bf-b97b-dd8462996ff3"><div class="modal-content"><h4>modules/porous_flow/test/tests/infiltration_and_drainage/rd03.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = gold/rd02.e
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;2E4 1E6&#x27;
    x = &#x27;0 1E6&#x27;
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = pressure
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.336
    alpha = 1.43e-4
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e7
      viscosity = 1.01e-3
      density0 = 1000
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pressure
    capillary_pressure = pc
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityVG
    m = 0.336
    seff_turnover = 0.99
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.33
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;0.295E-12 0 0  0 0.295E-12 0  0 0 0.295E-12&#x27;
  [../]
[]

[Variables]
  [./pressure]
    initial_from_file_timestep = LATEST
    initial_from_file_var = pressure
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pressure
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pressure
    gravity = &#x27;-10 0 0&#x27;
  [../]
[]

[AuxVariables]
  [./SWater]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./SWater]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 0
    variable = SWater
  [../]
[]

[BCs]
  [./base]
    type = DirichletBC
    boundary = left
    value = 0.0
    variable = pressure
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10      1E-10      10&#x27;
  [../]
[]

[VectorPostprocessors]
  [./swater]
    type = LineValueSampler
    variable = SWater
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;6 0 0&#x27;
    sort_by = x
    num_points = 121
    execute_on = timestep_end
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 8.2944E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = rd03
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial final&#x27;
  [../]
  [./along_line]
    type = CSV
    execute_on = final
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8b720aea-942e-443e-a605-2bee998c0ce2"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first frequency of this beam is:
# f1 = 1/(2 pi) * sqrt(3EI/(mL^3)) = 0.25

# This implies that the corresponding time period of this beam is 4s.

# The FEM solution for this beam with 10 element gives time periods of 4s with time step of 0.01s.
# A higher time step of 0.1 s is used in the test to reduce computational time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y                vel_y                accel_y
# 0.0    0.0                   0.0                  0.0
# 0.1    0.0013076435060869    0.026152870121738    0.52305740243477
# 0.2    0.0051984378734383    0.051663017225289   -0.01285446036375
# 0.3    0.010269120909367     0.049750643493289   -0.02539301427625
# 0.4    0.015087433925158     0.046615616822532   -0.037307519138892
# 0.5    0.019534963888307     0.042334982440433   -0.048305168503101

[Mesh]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  nx = 10
  dim = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="63bfb5a5-4bf3-47b4-975c-8479b3f24f7a"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test4qtt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test4qtt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8db5c77b-f1ec-4082-b90d-cad2416c3d33"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_plane_strain_small.i</h4><pre class="moose-pre"><code class="language-text">#
# This test checks elastic stress calculations with mechanical and thermal
# strain using small strain formulation. Young&#x27;s modulus is 3600, and Poisson&#x27;s ratio is 0.2.
# The axisymmetric, plane strain 1D mesh is pulled with 1e-6 strain.  Thus,
# the strain is [1e-6, 0, 1e-6] (xx, yy, zz).  This gives stress of
# [5e-3, 2e-3, 5e-3].  After a temperature increase of 100 with alpha of
# 1e-8, the stress becomes [-1e-3, -4e-3, -1e-3].
#

[GlobalParams]
  displacements = disp_x
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = line.e
[]

[Variables]
  [./disp_x]
  [../]
[]

[AuxVariables]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;580 580 680&#x27;
  [../]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 2e-6&#x27;
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./ps]
        planar_formulation = PLANE_STRAIN
        strain = SMALL
        generate_output = &#x27;strain_xx strain_zz stress_xx stress_yy stress_zz&#x27;
        eigenstrain_names = eigenstrain
      [../]
    [../]
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = temp
    execute_on = &#x27;timestep_begin&#x27;
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1
    value = 0
    variable = disp_x
  [../]
  [./disp_x]
    type = FunctionDirichletBC
    boundary = 2
    function = disp_x
    variable = disp_x
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-8
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-6
  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 2
  num_steps = 2
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="02c185ee-faef-4cb5-9526-18940cd0d44f"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/static/large_strain_m_40_AD.i</h4><pre class="moose-pre"><code class="language-text"># Large strain/rotation test for shell elements

# A cantilever beam that is 40 m long (Y direction) with 1 m x 1 m
# cross-section is modeled using 5 shell elements placed along its
# length. The bottom boundary is fixed in all displacements and
# rotations. A load of 0.140625 N is applied at each node on the top
# boundary, resulting in a total load of 0.28125 N. E = 1800 Pa and
# v = 0.0.

# The reference solution for large deflection of this beam is based on
# K. E. Bisshopp and D.C. Drucker, Quaterly of Applied Mathematics,
# Vol 3, No. # 3, 1945.

# For PL^2/EI = 3, disp_z at tip = 0.6L = 24 m &amp; disp_y at tip = 0.76*L-L = -9.6 m

# The FEM solution at tip of cantilever is:
# disp_z = 24.85069 m; relative error = 3.54 %
# disp_y = -9.125937 m; relative error = 5.19 %

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 5
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 40.0
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = bottom
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = bottom
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = top
    function = force_y
  [../]
[]

[Functions]
  [./force_y]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 3.0&#x27;
    y = &#x27;0.0 1.0 1.0&#x27;
    scale_factor = 0.140625
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  automatic_scaling = true

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-14

  dt = 0.1
  dtmin = 0.1
  end_time = 3.0
[]

[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
    large_strain = true
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
    large_strain = true
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
    large_strain = true
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
    large_strain = true
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
    large_strain = true
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 1800
    poissons_ratio = 0.0
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeFiniteShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 1.0
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
[]

[Postprocessors]
  [./disp_z2]
    type = PointValue
    point = &#x27;1.0 40.0 0.0&#x27;
    variable = disp_z
  [../]
  [./disp_y2]
    type = PointValue
    point = &#x27;1.0 40.0 0.0&#x27;
    variable = disp_y
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0b5a357f-903b-432d-9fdc-0234d2d097b5"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_2d_small_strain.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 2d plane strain model
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;4.0 4.5 5.0 5.5 6.0&#x27;
  radius_outer = &#x27;4.5 5.0 5.5 6.0 6.5&#x27;
  output_q = false
  incremental = false
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = SMALL
    add_variables = true
    incremental = false
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = j_integral_2d_small_strain_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4c3decec-32f8-4489-9ec0-ddb8378b6666"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_as_2d.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with one element
#through the thickness, and calculates the J-Integrals using options
#to treat it as 2d.
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack_3d_as_2d.e
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;4.0 4.5 5.0 5.5 6.0&#x27;
  radius_outer = &#x27;4.5 5.0 5.5 6.0 6.5&#x27;
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]

   type = Transient
  # Two sets of linesearch options are for petsc 3.1 and 3.3 respectively
  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 1e-5
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Outputs]
  file_base = j_integral_3d_as_2d_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c20ac123-5c3b-41ce-9204-ff5f6b09f0b2"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral_vtest/j_int_surfbreak_ellip_crack_sym_mm_cm.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = ellip_crack_4sym_norad_mm.e
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./resid_z]
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 0.1&#x27;
    scale_factor = -689.5 #MPa
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 1001
  crack_direction_method = CrackMouth
  crack_mouth_boundary = 11
  crack_end_direction_method = CrackDirectionVector
  crack_direction_vector_end_1 = &#x27;0.0 1.0 0.0&#x27;
  crack_direction_vector_end_2 = &#x27;1.0 0.0 0.0&#x27;
  radius_inner = &#x27;12.5 25.0 37.5&#x27;
  radius_outer = &#x27;25.0 37.5 50.0&#x27;
  intersecting_boundary = &#x27;1 2&#x27;
  symmetry_plane = 2
  position_type = angle
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 12
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 5
      function = rampConstantUp
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]

   type = Transient
  # Two sets of linesearch options are for petsc 3.1 and 3.3 respectively
  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 1e-5
   nl_rel_tol = 1e-11
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./nl_its]
    type = NumNonlinearIterations
  [../]
  [./lin_its]
    type = NumLinearIterations
  [../]
  [./react_z]
    type = NodalSum
    variable = resid_z
    boundary = 5
  [../]
[]


[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = j_int_surfbreak_ellip_crack_sym_mm_cm_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="da8dd9f8-c5ac-4180-b12c-63d1525a9261"><div class="modal-content"><h4>modules/richards/test/tests/buckley_leverett/bl22_lumped_fu.i</h4><pre class="moose-pre"><code class="language-text"># two-phase version
# super-sharp front version
[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 150
  xmin = 0
  xmax = 15
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-4 1E-3 1E-2 2E-2 5E-2 6E-2 0.1 0.2&#x27;
    x = &#x27;0    1E-2 1E-1 1    5    20   40  41&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E6
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-4
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-4
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
  [./bounds_dummy]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFullyUpwindFlux
    variable = pgas
  [../]
  [./richardsppenalty]
    type = RichardsPPenalty
    variable = pgas
    a = 1E-18
    lower_var = pwater
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_water
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_gas
  [../]
[]

[BCs]
  [./left_w]
    type = DirichletBC
    variable = pwater
    boundary = left
    value = 1E6
  [../]
  [./left_g]
    type = DirichletBC
    variable = pgas
    boundary = left
    value = 1000
  [../]
  [./right_w]
    type = DirichletBC
    variable = pwater
    boundary = right
    value = -100000
  [../]
  [./right_g]
    type = DirichletBC
    variable = pgas
    boundary = right
    value = 0
  [../]
[]


[Functions]
  [./initial_water]
    type = ParsedFunction
    value = 1000000*(1-min(x/5,1))-if(x&lt;5,0,100000)
  [../]
  [./initial_gas]
    type = ParsedFunction
    value = 1000
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.15
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    viscosity = &#x27;1E-3 1E-6&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]

  [./standard]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10 1E-10 20 1E-10 1E-100&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  end_time = 50

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = bl22_lumped_fu
  [./exodus]
    type = Exodus
    interval = 100000
    hide = &#x27;pgas bounds_dummy&#x27;
    execute_on = &#x27;initial final timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="270ddb4c-a79d-43f9-beec-5f3bb9db1202"><div class="modal-content"><h4>modules/xfem/test/tests/pressure_bc/edge_2d_pressure.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = False
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 9
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.0 0.5 0.5 0.5&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    generate_output = &#x27;stress_xx stress_yy&#x27;
  [../]
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0 1.0 2.0&#x27;
    y = &#x27;0 500 1000&#x27;
  [../]
[]

[BCs]
  [./bottom_y]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
  [./top_y]
    type = DirichletBC
    boundary = 2
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
[]

[DiracKernels]
  [./pressure_x]
    type = XFEMPressure
    variable = disp_x
    component = 0
    function = pressure
  [../]

  [./pressure_y]
    type = XFEMPressure
    variable = disp_y
    component = 1
    function = pressure
  [../]
[]


[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12

# time control
  start_time = 0.0
  dt = 1
  end_time = 2
[]

[Outputs]
  file_base = edge_2d_pressure_out
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7e75d6c6-0345-4dcd-9eb5-6d336cb11703"><div class="modal-content"><h4>test/tests/functions/function_file_format/function_file_format_test.i</h4><pre class="moose-pre"><code class="language-text"># This tests the capability of the code to read input files in csv or space separated format.
# There are four variables and four functions of the same name; a,b,c, and d.  The diffusion equation is &quot;solved&quot;
# for each of these variables with a boundary condition of type FunctionDirchletBC applied to a boundary
# (i.e. node set) that includes every node in the element, so the solution is the boundary condition defined by the function.
#  Each boundary condition uses a function of type PiecewiseLinear that gets its value from a file,
# which could be in comma separated or space separated format.  The input file can also contain comments.
#
# The files could have the form
# 0,1,2,3 # time
# 0,4,5,6 # bc value
# for format = row
# or
# 0,0
# 1,4
# 2,5
# 3,6
# for format = column
# Values in files could be separated by white space.  See the .csv and .dat files for format examples.
#
# The value of the variables should correspond to the function.
# At time = 0, the variable = 0, at time = 1, variable = 4 and so on.
[Mesh]
  file = cube.e
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Variables]

  [./a]
  [../]

  [./b]
  [../]

  [./c]
  [../]

  [./d]
  [../]

  [./e]
  [../]

  [./f]
  [../]

[]

[Functions]


  [./a]
    type = PiecewiseLinear
    data_file = rows.csv
    format = rows
  [../]
  [./b]
    type = PiecewiseLinear
    data_file = columns.csv
    format = columns
  [../]
  [./c]
    type = PiecewiseLinear
    data_file = rows_space.dat
    format = rows
  [../]
  [./d]
    type = PiecewiseLinear
    data_file = columns_space.dat
    format = columns
  [../]
  [./e_func]
    type = PiecewiseLinear
    data_file = rows_more_data.csv
    format = rows
    xy_in_file_only = false
    x_index_in_file = 2
    y_index_in_file = 0
  [../]
  [./f]
    type = PiecewiseLinear
    data_file = columns_more_data.csv
    format = columns
    xy_in_file_only = false
    x_index_in_file = 2
    y_index_in_file = 0
  [../]


[]

[Kernels]

  [./diffa]
    type = Diffusion
    variable = a
  [../]
  [./diffb]
    type = Diffusion
    variable = b
  [../]
  [./diffc]
    type = Diffusion
    variable = c
  [../]
  [./diffd]
    type = Diffusion
    variable = d
  [../]
  [./diffe]
    type = Diffusion
    variable = e
  [../]
  [./difff]
    type = Diffusion
    variable = f
  [../]

[]

[BCs]

  [./a]
    type = FunctionDirichletBC
    variable = a
    boundary = &#x27;1&#x27;
    function = a
  [../]
  [./b]
    type = FunctionDirichletBC
    variable = b
    boundary = &#x27;1&#x27;
    function = b
  [../]
  [./c]
    type = FunctionDirichletBC
    variable = c
    boundary = &#x27;1&#x27;
    function = c
  [../]
  [./d]
    type = FunctionDirichletBC
    variable = d
    boundary = &#x27;1&#x27;
    function = d
  [../]
  [./e]
    type = FunctionDirichletBC
    variable = e
    boundary = &#x27;1&#x27;
    function = e_func
  [../]
  [./f]
    type = FunctionDirichletBC
    variable = f
    boundary = &#x27;1&#x27;
    function = f
  [../]

[]

[Executioner]
  type = Transient
  dt = 0.5
  end_time = 3
  nl_rel_tol = 1e-12
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bed51eb3-3c74-4c1d-9fc4-7564a23a4ec7"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_function.i</h4><pre class="moose-pre"><code class="language-text">#
# Simple pull test for cracking. This tests the option to prescribe the
# cracking strength using an AuxVariable. In this case, an elemental
# AuxVariable is used, and a function is used to prescribe its value.
# One of the elements is weaker than the others, so the crack localizes
# in that element.
#
[Mesh]
   file = plate.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[AuxVariables]
  [./cracking_stress_fn]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./crack_flags2]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 0.1 0.2 0.3 0.4&#x27;
    y = &#x27;0 0.001 0 -0.001 0&#x27;
  [../]
  [./fstress]
    type = ParsedFunction
    value = &#x27;if(x &gt; 0.667, 1.1e6, 1.2e6)&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx strain_xx strain_yy strain_xy strain_yz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[AuxKernels]
  [./cracking_stress_fn]
    type = FunctionAux
    variable = cracking_stress_fn
    function = fstress
    execute_on = initial
  [../]
  [./crack_flags2]
    type = ADMaterialRealVectorValueAux
    property = crack_flags
    variable = crack_flags2
   component = 2
  [../]
[]

[BCs]
  [./pull]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    function = displ
  [../]

  [./pin_x]
    type = ADDirichletBC
    variable = disp_x
    boundary =  &#x27;1 2&#x27;
    value = 0
  [../]
  [./pin_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = &#x27;1 4&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 200.0e7
    poissons_ratio = 0.0
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = cracking_stress_fn
    softening_models = abrupt_softening
  [../]
  [./abrupt_softening]
    type = ADAbruptSoftening
    residual_stress = 0.0
  [../]
[]

[Postprocessors]
  [./elem_stress_xx]
    type = ElementalVariableValue
    variable = stress_xx
    elementid = 2
  [../]
  [./elem_strain_xx]
    type = ElementalVariableValue
    variable = strain_xx
    elementid = 2
  [../]
  [./elem_crack_flags_x]
    type = ElementalVariableValue
    variable = crack_flags2
    elementid = 2
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton

  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101               &#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.2
  dt = 0.0025
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="46225f90-2200-4fdf-b357-007e5c667727"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/combined_creep_plasticity/combined_stress_relaxation.i</h4><pre class="moose-pre"><code class="language-text">#
# 1x1x1 unit cube with constant displacement on top face
#
# This problem was taken from &quot;Finite element three-dimensional elastic-plastic
#    creep analysis&quot; by A. Levy, Eng. Struct., 1981, Vol. 3, January, pp. 9-16.
#
# The problem is a one-dimensional creep analysis.  The top face is displaced 0.01
#    units and held there.  The stress relaxes in time according to the creep law.
#
# The analytic solution to this problem is (contrary to what is shown in the paper):
#
#                 /      (E*ef)^3      \^(1/3)
#    stress_yy = |---------------------|
#                \ 3*a*E^4*ef^3*t + 1 /
#
#    where E  = 2.0e11  (Young&#x27;s modulus)
#          a  = 3e-26  (creep coefficient)
#          ef = 0.01   (displacement)
#          t  = 2160.0    (time)
#
#    such that the analytical solution is computed to be 2.9518e3 Pa
#
# Averaged over the single element block, MOOSE calculates the stress in the yy direction to be
#     to be 3.046e3 Pa, which is a 3.2% error from the analytical solution.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1e-2 1e-1 1e0 1e1 1e2&#x27;
    x = &#x27;0    7e-1 7e0 7e1 1e2&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy&#x27;
  [../]
[]

[BCs]
  [./u_top_pull]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value = 0.01
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.0e11
    poissons_ratio = 0.3
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;power_law_creep&#x27;
  [../]
  [./power_law_creep]
    type = PowerLawCreepStressUpdate
    coefficient = 3.0e-26
    n_exponent = 4
    activation_energy = 0.0
    relative_tolerance = 1e-14
    absolute_tolerance = 1e-14
  [../]
[]

[Postprocessors]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-5
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 2160

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e9974658-7f63-407c-99fc-8f128d57b7d2"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_1/gh20.i</h4><pre class="moose-pre"><code class="language-text"># investigating validity of immobile saturation
# 5 elements, no SUPG

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 5
  xmin = -1
  xmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 10 100 1000 10000&#x27;
    x = &#x27;0 10 100 1000 10000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E3
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.1
  [../]
  [./SUPGnone]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -1.0
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    SUPG_UO = SUPGnone
    sat_UO = Saturation
    seff_UO = SeffVG
    viscosity = 1E-3
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1E0
  end_time = 1E5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh20
  execute_on = &#x27;timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="feba7da0-9522-469c-93ae-d842232fa2b6"><div class="modal-content"><h4>test/tests/multiapps/multilevel/time_dt_from_master_master.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmax = 100
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    x = &#x27;0     1&#x27;
    y = &#x27;0.25  1&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  dt = 0.25
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
  [./out]
    type = Console
    output_file = true
  [../]
[]

[MultiApps]
  [./sub]
    type = TransientMultiApp
    app_type = MooseTestApp
    positions = &#x27;0 0 0 0.5 0.5 0&#x27;
    input_files = time_dt_from_master_sub.i
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f739afe9-caaf-47a8-ac4a-d6b802edfa13"><div class="modal-content"><h4>modules/contact/test/tests/verification/hertz_cyl/half_symm_q4/hertz_cyl_half_1deg_template1.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = hertz_cyl_half_1deg.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
  [./tang_force_x]
  [../]
  [./tang_force_y]
  [../]
[]

[Functions]
  [./disp_ramp_vert]
    type = PiecewiseLinear
    x = &#x27;0. 1. 3.5&#x27;
    y = &#x27;0. -0.0020 -0.0020&#x27;
  [../]
  [./disp_ramp_horz]
    type = PiecewiseLinear
    x = &#x27;0. 1. 3.5&#x27;
    y = &#x27;0. 0.0 0.0014&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./inc_slip_x]
    type = PenetrationAux
    variable = inc_slip_x
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./inc_slip_y]
    type = PenetrationAux
    variable = inc_slip_y
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_x]
    type = PenetrationAux
    variable = accum_slip_x
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_y]
    type = PenetrationAux
    variable = accum_slip_y
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./tang_force_x]
    type = PenetrationAux
    variable = tang_force_x
    quantity = tangential_force_x
    boundary = 3
    paired_boundary = 2
  [../]
  [./tang_force_y]
    type = PenetrationAux
    variable = tang_force_y
    quantity = tangential_force_y
    boundary = 3
    paired_boundary = 2
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 3
    paired_boundary = 2
  [../]
[]

[Postprocessors]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 1
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 1
  [../]
  [./top_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 4
  [../]
  [./top_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 4
  [../]
  [./disp_x226]
    type = NodalVariableValue
    nodeid = 225
    variable = disp_x
  [../]
  [./disp_y226]
    type = NodalVariableValue
    nodeid = 225
    variable = disp_y
  [../]
  [./_dt]
    type = TimestepSize
  [../]
  [./num_lin_it]
    type = NumLinearIterations
  [../]
  [./num_nonlin_it]
    type = NumNonlinearIterations
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./top_y_disp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = disp_ramp_vert
  [../]
  [./top_x_disp]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = disp_ramp_horz
  [../]
[]

[Materials]
  [./stuff1_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e10
    poissons_ratio = 0.0
  [../]
  [./stuff1_strain]
    type = ComputeFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./stuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./stuff2_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff2_strain]
    type = ComputeFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./stuff2_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
  [./stuff3_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;3&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff3_strain]
    type = ComputeFiniteStrain
    block = &#x27;3&#x27;
  [../]
  [./stuff3_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;3&#x27;
  [../]
  [./stuff4_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;4&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff4_strain]
    type = ComputeFiniteStrain
    block = &#x27;4&#x27;
  [../]
  [./stuff4_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;4&#x27;
  [../]
  [./stuff5_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;5&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff5_strain]
    type = ComputeFiniteStrain
    block = &#x27;5&#x27;
  [../]
  [./stuff5_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;5&#x27;
  [../]
  [./stuff6_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;6&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff6_strain]
    type = ComputeFiniteStrain
    block = &#x27;6&#x27;
  [../]
  [./stuff6_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;6&#x27;
  [../]
  [./stuff7_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;7&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff7_strain]
    type = ComputeFiniteStrain
    block = &#x27;7&#x27;
  [../]
  [./stuff7_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;7&#x27;
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-6
  nl_rel_tol = 1e-5
  l_max_its = 100
  nl_max_its = 200

  start_time = 0.0
  end_time = 3.5
  l_tol = 1e-3
  dt = 0.1
  dtmin = 0.1
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[VectorPostprocessors]
  [./x_disp]
    type = NodalValueSampler
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    sort_by = id
  [../]
  [./y_disp]
    type = NodalValueSampler
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    sort_by = id
  [../]
  [./cont_press]
    type = NodalValueSampler
    variable = contact_pressure
    boundary = &#x27;3&#x27;
    sort_by = id
  [../]
[]

[Outputs]
  print_linear_residuals = true
  perf_graph = true
  [./exodus]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 5
  [../]
  [./chkfile]
    type = CSV
    show = &#x27;x_disp y_disp cont_press&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./chkfile2]
    type = CSV
    show = &#x27;bot_react_x bot_react_y disp_x226 disp_y226 top_react_x top_react_y&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./outfile]
    type = CSV
    delimiter = &#x27; &#x27;
    execute_vector_postprocessors_on = none
  [../]
[]

[Contact]
  [./interface]
    primary = 2
    secondary = 3
    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f03cb640-411e-48fb-924e-3b0a015061d7"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test2.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_rows.csv #Will generate error because data is expected in columns
    format = columns
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7812a6f0-acdc-4c92-8977-61044fe7133b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/prescribed_displacement/3D_QStatic_1_Ramped_Displacement_with_gravity.i</h4><pre class="moose-pre"><code class="language-text"># One 3D element under ramped displacement loading.
#
# loading in z direction:
# time : 0.0 0.1  0.2  0.3
# disp : 0.0 0.0 -0.01 -0.01

# Gravity is applied in y direction. To equilibrate the system
# under gravity, a static analysis is run in the first time step
# by turning off the inertial terms. (see controls block and
# DynamicTensorMechanics block).

# Result: The displacement at the top node in the z direction should match
# the prescribed displacement. Also, the z acceleration should
# be two triangular pulses, one peaking at 0.1 and another peaking at
# 0.2.

# The y displacement would be offset by the gravity displacement.
# Also the y acceleration and velocity should be zero until the loading in
# the z direction starts (i.e, until 0.1s)

# Note: The time step used in the displacement data file should match
# the simulation time step (dt and dtmin in the Executioner block).

[Mesh]
  type = GeneratedMesh
  dim = 3 # Dimension of the mesh
  nx = 1 # Number of elements in the x direction
  ny = 1 # Number of elements in the y direction
  nz = 1 # Number of elements in the z direction
  xmin = 0.0
  xmax = 1
  ymin = 0.0
  ymax = 1
  zmin = 0.0
  zmax = 1
  allow_renumbering = false # So NodalVariableValue can index by id
[]

[Variables] # variables that are solved
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables] # variables that are calculated for output
  [./accel_x]
  [../]
  [./vel_x]
  [../]
  [./accel_y]
  [../]
  [./vel_y]
  [../]
  [./accel_z]
  [../]
  [./vel_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics] # zeta*K*vel + K * disp
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    zeta = 0.000025
    static_initialization = true #turns off rayliegh damping for the first time step to stabilize system under gravity
  [../]
  [./inertia_x] # M*accel + eta*M*vel
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.25 # Newmark time integration
    gamma = 0.5 # Newmark time integration
    eta = 19.63
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.25
    gamma = 0.5
    eta = 19.63
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    gamma = 0.5
    eta = 19.63
  [../]
  [./gravity]
    type = Gravity
    variable = disp_y
    value = -9.81
  [../]
[]

[AuxKernels]
  [./accel_x] # Calculates and stores acceleration at the end of time step
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x] # Calculates and stores velocity at the end of the time step
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./displacement_front]
    type = PiecewiseLinear
    data_file = &#x27;displacement.csv&#x27;
    format = columns
  [../]
[]

[BCs]
  [./prescribed_displacement]
    type = PresetDisplacement
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    boundary = front
    function = displacement_front
  [../]
  [./anchor_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./anchor_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./anchor_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    youngs_modulus = 325e6 #Pa
    poissons_ratio = 0.3
    type = ComputeIsotropicElasticityTensor
    block = 0
  [../]
  [./strain]
    #Computes the strain, assuming small strains
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    #Computes the stress, using linear elasticity
    type = ComputeLinearElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 2000 #kg/m3
  [../]
[]

[Controls] # turns off inertial terms for the first time step
  [./period0]
    type = TimePeriod
    disable_objects = &#x27;*/vel_x */vel_y */vel_z */accel_x */accel_y */accel_z */inertia_x */inertia_y */inertia_z&#x27;
    start_time = 0.0
    end_time = 0.1 # dt used in the simulation
  [../]
[../]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 3.0
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  dt = 0.1
  timestep_tolerance = 1e-6
[]

[Postprocessors] # These quantites are printed to a csv file at every time step
  [./_dt]
    type = TimestepSize
  [../]
  [./accel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_x
  [../]
  [./accel_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_y
  [../]
  [./accel_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_z
  [../]
  [./vel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_x
  [../]
  [./vel_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_y
  [../]
  [./vel_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_z
  [../]
  [./disp_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_x
  [../]
  [./disp_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_y
  [../]
  [./disp_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_z
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ef48ac1d-46b7-4122-9afa-b88c8849d9e5"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/finite_const.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function has a constant value,
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# This version of the test uses finite deformation theory.
# The two models produce very similar results.  There are slight
# differences due to the large deformation treatment.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 3
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ADComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion_strain1]
    type = ADComputeMeanThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 0.5
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
  [./thermal_expansion_strain2]
    type = ADComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 2
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (t - tsf) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 1.0
               2 1.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = NEWTON
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5794295c-6c07-4e97-854e-63bd042b080a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/dilatation.i</h4><pre class="moose-pre"><code class="language-text"># This test checks the thermal expansion calculated via an dilatation function.
# The coefficient is selected so as to result in a 1e-4 strain in the x-axis, and to cross over
# from positive to negative strain.

[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = &#x27;1 + t&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ADComputeDilatationThermalExpansionFunctionEigenstrain
    dilatation_function = cte_dilatation
    stress_free_temperature = 1.5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_dilatation]
    type = PiecewiseLinear
    x = &#x27;1 2&#x27;
    y = &#x27;-1e-4 1e-4&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x_max]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./temp_avg]
    type = ElementAverageValue
    variable = temp
  [../]
[]

[Executioner]
  type = Transient

  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5200cf9a-34af-4e68-a1fb-9b0ca885dc3e"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh18.i</h4><pre class="moose-pre"><code class="language-text"># with immobile saturation
# unsaturated = true
# gravity = true
# supg = true
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 0.5E1 0.5E2 0.4E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.4
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 2
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh18
  execute_on = &#x27;timestep_end final&#x27;
  interval = 100000
  exodus = true
  [./console]
    type = Console
    interval = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ab31411e-c44c-4769-956d-658eec2c71b0"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/static/euler_finite_rot_y.i</h4><pre class="moose-pre"><code class="language-text"># Large strain/large rotation cantilever beam test

# A 300 N point load is applied at the end of a 4 m long cantilever beam.
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 1e8
# shear coefficient (k) = 1.0
# Poisson&#x27;s ratio (nu) = -0.99995
# Area (A) = 1.0
# Iy = Iz = 0.16

# The dimensionless parameter alpha = kAGL^2/EI = 1e6
# Since the value of alpha is quite high, the beam behaves like
# a thin beam where shear effects are not significant.

# Beam deflection:
# small strain+rot = 3.998 m (exact 4.0)
# large strain + small rotation = -0.05 m in x and 3.74 m in y
# large rotations + small strain = -0.92 m in x and 2.38 m in y
# large rotations + large strain = -0.954 m in x and 2.37 m in y (exact -1.0 m in x and 2.4 m in y)

# References:
# K. E. Bisshopp and D.C. Drucker, Quaterly of Applied Mathematics, Vol 3, No. 3, 1945.

[Mesh]
  type = FileMesh
  file = beam_finite_rot_test_2.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = 1
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = 1
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = 1
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = 2
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 2.0  8.0&#x27;
    y = &#x27;0.0 300.0 300.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre     boomeramg     4&#x27;
  nl_max_its = 50
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-7
  l_max_its = 50
  dt = 0.05
  end_time = 2.1
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1e4
    poissons_ratio = -0.99995
    shear_coefficient = 1.0
    block = 1
  [../]
  [./strain]
    type = ComputeFiniteBeamStrain
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 1.0
    Ay = 0.0
    Az = 0.0
    Iy = 0.16
    Iz = 0.16
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
    large_strain = true
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 1
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./rot_z]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = rot_z
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="809f515f-fac8-48a1-9b51-4b2b845bc36c"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test3.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e82aea97-aa8b-4a4b-8469-fcd8e5d31420"><div class="modal-content"><h4>modules/contact/test/tests/incremental_slip/incremental_slip.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  file = incremental_slip.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
  [../]
[]

[Functions]
  [./secondary_x]
    type = PiecewiseLinear
    x = &#x27;0 1 2   3 4 5  6    7 8   9&#x27;
    y = &#x27;0 0 0.5 0 0 0 -0.25 0 0.5 0&#x27;
  [../]
  [./secondary_y]
    type = PiecewiseLinear
    x = &#x27;0  1     9&#x27;
    y = &#x27;0 -0.15 -0.15&#x27;
  [../]
  [./secondary_z]
    type = PiecewiseLinear
    x = &#x27;0 1  2   3 4 5 6    7  8   9&#x27;
    y = &#x27;0 0 -0.5 0 0 0 0.25 0 -0.5 0&#x27;
  [../]

  [./primary_x]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3 4   5 6    7 8   9&#x27;
    y = &#x27;0 0  0 0 0.5 0 0.25 0 0.5 0&#x27;
  [../]
  [./primary_y]
    type = PiecewiseLinear
    x = &#x27;0 9&#x27;
    y = &#x27;0 0&#x27;
  [../]
  [./primary_z]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3 4   5  6    7  8   9&#x27;
    y = &#x27;0 0  0 0 0.5 0 -0.25 0 -0.5 0&#x27;
  [../]
[]

[AuxVariables]
  [./inc_slip_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./inc_slip_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./inc_slip_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./inc_slip_x]
    type = PenetrationAux
    variable = inc_slip_x
    quantity = incremental_slip_x
    boundary = 3
    paired_boundary = 2
  [../]
  [./inc_slip_y]
    type = PenetrationAux
    variable = inc_slip_y
    quantity = incremental_slip_y
    boundary = 3
    paired_boundary = 2
  [../]
  [./inc_slip_z]
    type = PenetrationAux
    variable = inc_slip_z
    quantity = incremental_slip_z
    boundary = 3
    paired_boundary = 2
  [../]
[]

[Contact]
  [./dummy_name]
    primary = 2
    secondary = 3
    penalty = 1e7
  [../]
[]

[BCs]
  [./secondary_x]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = 4
    function = secondary_x
  [../]
  [./secondary_y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 4
    function = secondary_y
  [../]
  [./secondary_z]
    type = FunctionDirichletBC
    variable = disp_z
    preset = false
    boundary = 4
    function = secondary_z
  [../]

  [./primary_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    function = primary_x
  [../]
  [./primary_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = &#x27;1 2&#x27;
    function = primary_y
  [../]
  [./primary_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = &#x27;1 2&#x27;
    function = primary_z
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor_1]
    type = ComputeIsotropicElasticityTensor
    block = 1
    youngs_modulus = 1.0e6
    poissons_ratio = 0.0
  [../]
  [./stress_1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]

  [./elasticity_tensor_2]
    type = ComputeIsotropicElasticityTensor
    block = 2
    youngs_modulus = 1.0e6
    poissons_ratio = 0.0
  [../]
  [./stress_2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu            superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-8
  l_max_its = 100
  nl_max_its = 10
  dt = 1.0
  num_steps = 9
[] # Executioner

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="52776d99-8a8b-4954-b149-af52d5f39626"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test16.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_rows_more_data.csv
    xy_in_file_only = false
    y_index_in_file = 3 # will generate an error because no forth row of data
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="69b2f471-ec21-4492-bac3-2bb99cd6456e"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh27.i</h4><pre class="moose-pre"><code class="language-text">#2-phase version of bh07 (go to steadystate with borehole)
[Mesh]
  type = FileMesh
  file = bh07_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
  viscosity = &#x27;1E-3 1E-5&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1000 10000&#x27;
    x = &#x27;100 1000&#x27;
  [../]
[]


[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.6
    al = 1E-5
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.6
    al = 1E-5
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGnone
  [../]
  [./SUPGgas]
    type = RichardsSUPGnone
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = 1E7
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = 1E7
  [../]
[]

[BCs]
  [./fix_outer_w]
    type = DirichletBC
    boundary = perimeter
    variable = pwater
    value = 1E7
  [../]
  [./fix_outer_g]
    type = DirichletBC
    boundary = perimeter
    variable = pgas
    value = 1E7
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFullyUpwindFlux
    variable = pgas
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = 0
    point_file = bh07.bh
    SumQuantityUO = borehole_total_outflow_mass
    fully_upwind = true
    variable = pwater
    unit_weight = &#x27;0 0 0&#x27;
    re_constant = 0.1594
    character = 2 # this is to make the length 1m borehole fill the entire 2m height
  [../]
  [./bh_gas_dummy]
    type = RichardsBorehole
    bottom_pressure = 0
    point_file = bh07.bh
    SumQuantityUO = borehole_total_outflow_mass
    fully_upwind = true
    variable = pgas
    unit_weight = &#x27;0 0 0&#x27;
    re_constant = 0.1594
    character = 2 # this is to make the length 1m borehole fill the entire 2m height
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./water_mass]
    type = RichardsMass
    variable = pwater
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./gas_mass]
    type = RichardsMass
    variable = pgas
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]



[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-11 0 0  0 1E-11 0  0 0 1E-11&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10 1E-10 20 1E-10 1E-100&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 1000
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]

[]

[Outputs]
  file_base = bh27
  execute_on = &#x27;initial timestep_end final&#x27;
  interval = 1000000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0aaa2fc7-1305-4a6a-8c42-d96b0fa7ec8c"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/constraints/glued_constraint.i</h4><pre class="moose-pre"><code class="language-text"># Test for glued beam constraint.
#
# Using a simple L-shaped geometry with a glued constraint at the
# corner between the two beams. The longer beam properties and loading is
# taken from an earlier beam regression test for static loading. The maximum
# applied load of 50000 lb should result in a displacement of 3.537e-3. Since
# the constraint is glued, the y-dir displacement of the long beam is
# 3.537e-3 and the short beam y-dir displacement is the same. The stiffness of
# the short beam is much less than the longer beam and thus should not
# significantly influence the displacement solution.

[Mesh]
  file = beam_cons_patch.e
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
[]

[Constraints]
  [./tie_y_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = disp_y
  [../]
  [./tie_x_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = disp_x
  [../]
  [./tie_z_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = disp_z
  [../]
  [./tie_rot_y_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_y
  [../]
  [./tie_rot_x_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_x
  [../]
  [./tie_rot_z_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_z
  [../]
[]

[Functions]
  [./force_loading]
    type = PiecewiseLinear
    x = &#x27;0.0 5.0&#x27;
    y = &#x27;0.0 50000.0&#x27;
  [../]
  [./disp_y_ramp]
    type = PiecewiseLinear
    x = &#x27;0.0 5.0&#x27;
    y = &#x27;0.0 1e-2&#x27;
  [../]
[]

[NodalKernels]
  [./force_x2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = &#x27;1004&#x27;
    function = force_loading
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]
[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-8

  dt = 1
  dtmin = 1
  end_time = 5
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity_pipe]
    type = ComputeElasticityBeam
    shear_coefficient = 1.0
    youngs_modulus = 30e6
    poissons_ratio = 0.3
    block = 1
    outputs = exodus
    output_properties = &#x27;material_stiffness material_flexure&#x27;
  [../]
  [./strain_pipe]
    type = ComputeIncrementalBeamStrain
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 28.274
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 0.0 1.0&#x27;
  [../]
  [./stress_pipe]
    type = ComputeBeamResultants
    block = 1
    outputs = exodus
    output_properties = &#x27;forces moments&#x27;
  [../]
  [./elasticity_cons]
    type = ComputeElasticityBeam
    shear_coefficient = 1.0
    youngs_modulus = 10e2
    poissons_ratio = 0.3
    block = 2
    outputs = exodus
    output_properties = &#x27;material_stiffness material_flexure&#x27;
  [../]
  [./strain_cons]
    type = ComputeIncrementalBeamStrain
    block = &#x27;2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 1.0
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 0.0 1.0&#x27;
  [../]
  [./stress_cons]
    type = ComputeBeamResultants
    block = 2
    outputs = exodus
    output_properties = &#x27;forces moments&#x27;
  [../]
[]

[Postprocessors]
  [./disp_y_n4]
    type = NodalVariableValue
    variable = disp_y
    nodeid = 3
  [../]
  [./disp_y_n2]
    type = NodalVariableValue
    variable = disp_y
    nodeid = 1
  [../]
  [./forces_y]
    type = PointValue
    point = &#x27;10.0 59.9 0.0&#x27;
    variable = forces_y
  [../]
[]

[Outputs]
  csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="536327af-2a4c-4200-b16f-c2e33c3a9657"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/mandel_fully_saturated_volume.i</h4><pre class="moose-pre"><code class="language-text"># Mandel&#x27;s problem of consolodation of a drained medium
# Using the FullySaturatedDarcyBase and FullySaturatedFullySaturatedMassTimeDerivative kernels
# with multiply_by_density = false, so that this problem becomes linear
# Note the use of consistent_with_displaced_mesh = false in the calculation of volumetric strain
#
# A sample is in plane strain.
# -a &lt;= x &lt;= a
# -b &lt;= y &lt;= b
# It is squashed with constant force by impermeable, frictionless plattens on its top and bottom surfaces (at y=+/-b)
# Fluid is allowed to leak out from its sides (at x=+/-a)
# The porepressure within the sample is monitored.
#
# As is common in the literature, this is simulated by
# considering the quarter-sample, 0&lt;=x&lt;=a and 0&lt;=y&lt;=b, with
# impermeable, roller BCs at x=0 and y=0 and y=b.
# Porepressure is fixed at zero on x=a.
# Porepressure and displacement are initialised to zero.
# Then the top (y=b) is moved downwards with prescribed velocity,
# so that the total force that is inducing this downwards velocity
# is fixed.  The velocity is worked out by solving Mandel&#x27;s problem
# analytically, and the total force is monitored in the simulation
# to check that it indeed remains constant.
#
# Here are the problem&#x27;s parameters, and their values:
# Soil width.  a = 1
# Soil height.  b = 0.1
# Soil&#x27;s Lame lambda.  la = 0.5
# Soil&#x27;s Lame mu, which is also the Soil&#x27;s shear modulus.  mu = G = 0.75
# Soil bulk modulus.  K = la + 2*mu/3 = 1
# Drained Poisson ratio.  nu = (3K - 2G)/(6K + 2G) = 0.2
# Soil bulk compliance.  1/K = 1
# Fluid bulk modulus.  Kf = 8
# Fluid bulk compliance.  1/Kf = 0.125
# Soil initial porosity.  phi0 = 0.1
# Biot coefficient.  alpha = 0.6
# Biot modulus.  M = 1/(phi0/Kf + (alpha - phi0)(1 - alpha)/K) = 4.705882
# Undrained bulk modulus. Ku = K + alpha^2*M = 2.694118
# Undrained Poisson ratio.  nuu = (3Ku - 2G)/(6Ku + 2G) = 0.372627
# Skempton coefficient.  B = alpha*M/Ku = 1.048035
# Fluid mobility (soil permeability/fluid viscosity).  k = 1.5
# Consolidation coefficient.  c = 2*k*B^2*G*(1-nu)*(1+nuu)^2/9/(1-nuu)/(nuu-nu) = 3.821656
# Normal stress on top.  F = 1
#
# The solution for porepressure and displacements is given in
# AHD Cheng and E Detournay &quot;A direct boundary element method for plane strain poroelasticity&quot; International Journal of Numerical and Analytical Methods in Geomechanics 12 (1988) 551-572.
# The solution involves complicated infinite series, so I shall not write it here

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
  ny = 1
  nz = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 0.1
  zmin = 0
  zmax = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./roller_xmin]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left&#x27;
  [../]
  [./roller_ymin]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  [../]
  [./plane_strain]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
  [./xmax_drained]
    type = DirichletBC
    variable = porepressure
    value = 0
    boundary = right
  [../]
  [./top_velocity]
    type = FunctionDirichletBC
    variable = disp_y
    function = top_velocity
    boundary = top
  [../]
[]

[Functions]
  [./top_velocity]
    type = PiecewiseLinear
    x = &#x27;0 0.002 0.006   0.014   0.03    0.046   0.062   0.078   0.094   0.11    0.126   0.142   0.158   0.174   0.19 0.206 0.222 0.238 0.254 0.27 0.286 0.302 0.318 0.334 0.35 0.366 0.382 0.398 0.414 0.43 0.446 0.462 0.478 0.494 0.51 0.526 0.542 0.558 0.574 0.59 0.606 0.622 0.638 0.654 0.67 0.686 0.702&#x27;
    y = &#x27;-0.041824842    -0.042730269    -0.043412712    -0.04428867     -0.045509181    -0.04645965     -0.047268246 -0.047974749      -0.048597109     -0.0491467  -0.049632388     -0.050061697      -0.050441198     -0.050776675     -0.051073238      -0.0513354 -0.051567152      -0.051772022     -0.051953128 -0.052113227 -0.052254754 -0.052379865 -0.052490464 -0.052588233 -0.052674662 -0.052751065 -0.052818606 -0.052878312 -0.052931093 -0.052977751 -0.053018997 -0.053055459 -0.053087691 -0.053116185 -0.053141373 -0.05316364 -0.053183324 -0.053200724 -0.053216106 -0.053229704 -0.053241725 -0.053252351 -0.053261745 -0.053270049 -0.053277389 -0.053283879 -0.053289615&#x27;
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_force]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./tot_force]
    type = ParsedAux
    args = &#x27;stress_yy porepressure&#x27;
    execute_on = timestep_end
    variable = tot_force
    function = &#x27;-stress_yy+0.6*porepressure&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    component = 2
    variable = disp_z
  [../]
  [./mass0]
    type = PorousFlowFullySaturatedMassTimeDerivative
    biot_coefficient = 0.6
    multiply_by_density = false
    coupling_type = HydroMechanical
    variable = porepressure
  [../]
  [./flux]
    type = PorousFlowFullySaturatedDarcyBase
    multiply_by_density = false
    variable = porepressure
    gravity = &#x27;0 0 0&#x27;
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 8
      density0 = 1
      thermal_expansion = 0
      viscosity = 1
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0.5 0.75&#x27;
    # bulk modulus is lambda + 2*mu/3 = 0.5 + 2*0.75/3 = 1
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure_qp]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
    consistent_with_displaced_mesh = false
  [../]
  [./ppss]
    type = PorousFlow1PhaseFullySaturated
    porepressure = porepressure
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid_qp]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # only the initial value of this is ever used
    porosity = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    biot_coefficient = 0.6
    solid_bulk_compliance = 1
    fluid_bulk_modulus = 8
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1.5 0 0   0 1.5 0   0 0 1.5&#x27;
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0.0 0 0&#x27;
    variable = porepressure
  [../]
  [./p1]
    type = PointValue
    outputs = csv
    point = &#x27;0.1 0 0&#x27;
    variable = porepressure
  [../]
  [./p2]
    type = PointValue
    outputs = csv
    point = &#x27;0.2 0 0&#x27;
    variable = porepressure
  [../]
  [./p3]
    type = PointValue
    outputs = csv
    point = &#x27;0.3 0 0&#x27;
    variable = porepressure
  [../]
  [./p4]
    type = PointValue
    outputs = csv
    point = &#x27;0.4 0 0&#x27;
    variable = porepressure
  [../]
  [./p5]
    type = PointValue
    outputs = csv
    point = &#x27;0.5 0 0&#x27;
    variable = porepressure
  [../]
  [./p6]
    type = PointValue
    outputs = csv
    point = &#x27;0.6 0 0&#x27;
    variable = porepressure
  [../]
  [./p7]
    type = PointValue
    outputs = csv
    point = &#x27;0.7 0 0&#x27;
    variable = porepressure
  [../]
  [./p8]
    type = PointValue
    outputs = csv
    point = &#x27;0.8 0 0&#x27;
    variable = porepressure
  [../]
  [./p9]
    type = PointValue
    outputs = csv
    point = &#x27;0.9 0 0&#x27;
    variable = porepressure
  [../]
  [./p99]
    type = PointValue
    outputs = csv
    point = &#x27;1 0 0&#x27;
    variable = porepressure
  [../]
  [./xdisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_x
  [../]
  [./ydisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_y
  [../]
  [./total_downwards_force]
     type = ElementAverageValue
     outputs = csv
     variable = tot_force
  [../]
  [./dt]
    type = FunctionValuePostprocessor
    outputs = console
    function = if(0.15*t&lt;0.01,0.15*t,0.01)
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres asm lu 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 0.7
  [./TimeStepper]
    type = PostprocessorDT
    postprocessor = dt
    dt = 0.001
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = mandel_fully_saturated_volume
  [./csv]
    interval = 3
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="300b55f4-7420-4f16-a7ac-d6d1bc15fef4"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3qnstt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3qtt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_abs_tol = 1e-7
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test3qnstt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="30e95957-01d2-4ef4-a9b8-b0fa8c9f6318"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass2.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 5ft (60 in).
# The beam is massless with a lumped mass at the end of the beam of 5000 lb
# The properties of the cantilever beam are as follows:
# E = 1e7 and I = 120 in^4
# Assuming a square cross section A = sqrt(12 * I) = 37.95
# Shear modulus (G) = 3.846e6
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 1.0
# mass (m) = 5000 lb / 386 = 12.95

# The theoretical first frequency of this beam is:
# f1 = 1/(2 pi) * sqrt(3EI/(mL^3)) = 5.71 cps

# This implies that the corresponding time period of this beam is 0.175 s.

# The FEM solution for this beam with 10 elements gives
# a time period of 0.175 s with time step of 0.005 s.

# Reference: Strength of Materials by Marin ans Sauer, 2nd Ed.
# Example Problem 11-50, pg. 375

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 60.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 12.95
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 12.95
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 12.95
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  l_tol = 1e-8
  l_max_its = 50
  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  start_time = 0.0
  dt = 0.005
  end_time = 1.5
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e7
    poissons_ratio = 0.30005200208
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 37.95
    Ay = 0.0
    Az = 0.0
    Iy = 120.0
    Iz = 120.0
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;60.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;60.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;60.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;60.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5a107d88-ecd7-4c23-97ae-9e50d08bd3fe"><div class="modal-content"><h4>framework/contrib/hit/test/output.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function has a constant value,
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# The two models produce very similar results.  There are slight
# differences due to the large deformation treatment.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[SolidMechanics]
  [./solid]
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
  [../]
[]

[BCs]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [left]
    type = FunctionDirichletBC
    variable = disp_x
    function = 0.02*t
    boundary = 3
  []
  [back]
    type = FunctionDirichletBC
    variable = disp_z
    function = 0.01*t
    boundary = 1
  []
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./mean_alpha]
    type = Elastic
    block = 1
    youngs_modulus = 1e6
    poissons_ratio = .3
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
    temp = temp
    thermal_expansion_function = cte_func_mean
    stress_free_temperature = 0.0
    thermal_expansion_reference_temperature = 0.5
    thermal_expansion_function_type = mean
  [../]

  [./inst_alpha]
    type = Elastic
    block = 2
    youngs_modulus = 1e6
    poissons_ratio = .3
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
    temp = temp
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    thermal_expansion_function_type = instantaneous
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (t - tsf) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 1.0
               2 1.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  file_base = const_alpha_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ce5e3c0d-3cf8-4ae4-a963-58f62ad381da"><div class="modal-content"><h4>modules/contact/test/tests/hertz_spherical/hertz_contact_rz_quad8.i</h4><pre class="moose-pre"><code class="language-text"># Hertz Contact: Sphere on sphere

# Spheres have the same radius, Young&#x27;s modulus, and Poisson&#x27;s ratio.

# Define E:
# 1/E = (1-nu1^2)/E1 + (1-nu2^2)/E2
#
# Effective radius R:
# 1/R = 1/R1 + 1/R2
#
# F is the applied compressive load.
#
# Area of contact a::
# a^3 = 3FR/4E
#
# Depth of indentation d:
# d = a^2/R
#
#
# Let R1 = R2 = 2.  Then R = 1.
#
# Let nu1 = nu2 = 0.25, E1 = E2 = 1.40625e7.  Then E = 7.5e6.
#
# Let F = 10000.  Then a = 0.1, d = 0.01.
#

[GlobalParams]
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y&#x27;
  order = SECOND
[]

[Problem]
  coord_type = RZ
[]

[Mesh]#Comment
  file = hertz_contact_rz_quad8.e
  displacements = &#x27;disp_x disp_y&#x27;
[] # Mesh

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 795.77471545947674 # 10000/pi/2^2
  [../]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.  1.    2.&#x27;
    y = &#x27;0. -0.01 -0.01&#x27;
  [../]
[] # Functions

[Variables]

  [./disp_x]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_y]
    order = SECOND
    family = LAGRANGE
  [../]

[] # Variables

[AuxVariables]

  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./hydrostatic]
    order = CONSTANT
    family = MONOMIAL
  [../]

[] # AuxVariables

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = SMALL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[] # AuxKernels

[BCs]

  [./base_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1000
    value = 0.0
  [../]

  [./symm_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./disp_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

[] # BCs

[Contact]
  [./dummy_name]
    primary = 1000
    secondary = 100
    # normal_smoothing_distance = 0.01
    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+10

  [../]
[]


[Materials]
  [./tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1.40625e7
    poissons_ratio = 0.25
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = &#x27;1&#x27;
  [../]

  [./tensor_1000]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1000&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]
  [./stress_1000]
    type = ComputeLinearElasticStress
    block = &#x27;1000&#x27;
  [../]
[] # Materials

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  []
[]

[Executioner]

  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;
  nl_abs_tol = 1e-7
  l_abs_tol = 1e-9
  l_max_its = 200

  start_time = 0.0
  dt = 0.5
  end_time = 2.0

  [./Quadrature]
    order = FIFTH
  [../]

[] # Executioner

[Postprocessors]
  [./maxdisp]
    type = NodalVariableValue
    nodeid = 103 # 104-1 where 104 is the exodus node number of the top-left node
    variable = disp_y
  [../]
[]

[Outputs]
  [./out]
    type = Exodus
  [../]
[] # Output
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c62d017a-a5fd-4227-82f8-2ad828d91ea3"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/2D/2d_nodalmass_explicit.i</h4><pre class="moose-pre"><code class="language-text"># One element test to test the central difference time integrator.

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = 0
    ymax = 2
    nx = 1
    ny = 2
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;1 2 0&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
  [./accel_y]
  [../]
  [./vel_y]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
[]

[BCs]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./x_bot]
    type = FunctionDirichletBC
    boundary = bottom
    variable = disp_x
    function = disp
    preset = false
  [../]
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
[]

[NodalKernels]
  [./nodal_mass_x]
    type = NodalTranslationalInertia
    variable = &#x27;disp_x&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    boundary = &#x27;all&#x27;
  [../]
  [./nodal_mass_y]
    type = NodalTranslationalInertia
    variable = &#x27;disp_y&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    boundary = &#x27;all&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = CentralDifference
  [../]
[]

[Postprocessors]
  [./accel_2x]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dce9ad80-83cc-4710-aadf-c3d32cab34d6"><div class="modal-content"><h4>modules/combined/test/tests/phase_field_fracture/crack2d_computeCrackedStress_finitestrain_plastic.i</h4><pre class="moose-pre"><code class="language-text">#This input uses PhaseField-Nonconserved Action to add phase field fracture bulk rate kernels
[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 40
    ny = 20
    ymax = 0.5
  []
  [./noncrack]
    type = BoundingBoxNodeSetGenerator
    new_boundary = noncrack
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 0 0&#x27;
    input = gen
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[AuxVariables]
  [./strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./elastic_strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./plastic_strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./uncracked_stress_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./All]
        add_variables = true
        strain = FINITE
        planar_formulation = PLANE_STRAIN
        additional_generate_output = &#x27;stress_yy vonmises_stress&#x27;
        strain_base_name = uncracked
      [../]
    [../]
  [../]
  [./PhaseField]
    [./Nonconserved]
      [./c]
        free_energy = E_el
        kappa = kappa_op
        mobility = L
      [../]
    [../]
  [../]
[]

[Kernels]
  [./solid_x]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_x
    component = 0
    c = c
  [../]
  [./solid_y]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_y
    component = 1
    c = c
  [../]
  [./off_disp]
    type = AllenCahnElasticEnergyOffDiag
    variable = c
    displacements = &#x27;disp_x disp_y&#x27;
    mob_name = L
  [../]
[]

[AuxKernels]
  [./strain_yy]
    type = RankTwoAux
    variable = strain_yy
    rank_two_tensor = uncracked_mechanical_strain
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
  [./elastic_strain_yy]
    type = RankTwoAux
    variable = elastic_strain_yy
    rank_two_tensor = uncracked_elastic_strain
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
  [./plastic_strain_yy]
    type = RankTwoAux
    variable = plastic_strain_yy
    rank_two_tensor = uncracked_plastic_strain
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
  [./uncracked_stress_yy]
    type = RankTwoAux
    variable = uncracked_stress_yy
    rank_two_tensor = uncracked_stress
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
[]

[BCs]
  [./ydisp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = &#x27;t&#x27;
  [../]
  [./yfix]
    type = DirichletBC
    variable = disp_y
    boundary = noncrack
    value = 0
  [../]
  [./xfix]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0
  [../]
[]

[Functions]
  [./hf]
    type = PiecewiseLinear
    x = &#x27;0    0.001 0.003 0.023&#x27;
    y = &#x27;0.85 1.0   1.25  1.5&#x27;
  [../]
[]

[Materials]
  [./pfbulkmat]
    type = GenericConstantMaterial
    prop_names = &#x27;gc_prop l visco&#x27;
    prop_values = &#x27;1e-3 0.05 5e-3&#x27;
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;120.0 80.0&#x27;
    fill_method = symmetric_isotropic
    base_name = uncracked
  [../]
  [./isotropic_plasticity]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 0.85
    hardening_function = hf
    base_name = uncracked
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;isotropic_plasticity&#x27;
    base_name = uncracked
  [../]
  [./cracked_stress]
    type = ComputeCrackedStress
    c = c
    F_name = E_el
    use_current_history_variable = true
    uncracked_base_name = uncracked
    finite_strain_model = true
  [../]
[]

[Postprocessors]
  [./av_stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./av_strain_yy]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./av_uncracked_stress_yy]
    type = ElementAverageValue
    variable = uncracked_stress_yy
  [../]
  [./max_c]
    type = ElementExtremeValue
    variable = c
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solving_package&#x27;
  petsc_options_value = &#x27;lu superlu_dist&#x27;

  nl_rel_tol = 1e-8
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 10

  dt = 2.0e-5
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6917522b-fa39-48e4-b9a9-badd665fe85a"><div class="modal-content"><h4>modules/porous_flow/test/tests/infiltration_and_drainage/rd01.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 120
  ny = 1
  xmin = 0
  xmax = 6
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1 10 500 5000 5000&#x27;
    x = &#x27;0 10 100 1000 10000 100000&#x27;
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = pressure
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.336
    alpha = 1.43e-4
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e7
      viscosity = 1.01e-3
      density0 = 1000
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pressure
    capillary_pressure = pc
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityVG
    m = 0.336
    seff_turnover = 0.99
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.33
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;0.295E-12 0 0  0 0.295E-12 0  0 0 0.295E-12&#x27;
  [../]
[]

[Variables]
  [./pressure]
    initial_condition = -72620.4
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pressure
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pressure
    gravity = &#x27;-10 0 0&#x27;
  [../]
[]

[AuxVariables]
  [./SWater]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./SWater]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 0
    variable = SWater
  [../]
[]

[BCs]
  [./base]
    type = PorousFlowSink
    boundary = right
    flux_function = -2.315E-3
    variable = pressure
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10      1E-10      10&#x27;
  [../]
[]

[VectorPostprocessors]
  [./swater]
    type = LineValueSampler
    variable = SWater
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;6 0 0&#x27;
    sort_by = x
    num_points = 121
    execute_on = timestep_end
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 359424

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = rd01
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial final&#x27;
  [../]
  [./along_line]
    type = CSV
    execute_on = final
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c9fd8d76-8502-4431-a6b6-86dc89a05173"><div class="modal-content"><h4>modules/richards/test/tests/theis/th_lumped_01.i</h4><pre class="moose-pre"><code class="language-text"># fully-saturated
# production
# lumped
[Mesh]
  type = FileMesh
  file = th01_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  sat_UO = Saturation
  seff_UO = Seff1VG
  SUPG_UO = SUPGstandard
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;0.5 1 2 10&#x27;
    x = &#x27;0 1 10 100&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]

  [./total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsLumpedMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsPolyLineSink
    pressures = &#x27;-1E9 1E9&#x27;
    fluxes = &#x27;200 200&#x27;
    point_file = th01.points
    SumQuantityUO = total_outflow_mass
    variable = pressure
  [../]
[]


[Postprocessors]
  [./flow_report]
    type = RichardsPlotQuantity
    uo = total_outflow_mass
  [../]
  [./p50]
    type = PointValue
    variable = pressure
    point = &#x27;50 0 0&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E5
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-6 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 100
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = th_lumped_01
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="528be7be-e864-4aca-8d02-9ac43f9be4c5"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_plane_stress.i</h4><pre class="moose-pre"><code class="language-text">################################################################################
#
# 1x1x1 cube, single element
# simulate plane stress
# pull in +y direction on right surface to produce shear strain
#
#
#
#          ____________
#         /|          /|
#        / |  5      / |                       -X  Left   1
#       /__________ /  |                       +X  Right  4
#      |   |    3  |   |                       +Y  Top    5
#      | 1 |       | 4 |                       -Y  Bottom 2
#      |   |_6_____|___|           y           +Z  Front  6
#      |  /        |  /            ^           -Z  Back   3
#      | /    2    | /             |
#      |/__________|/              |
#                                  ----&gt; x
#                                 /
#                                /
#                               z
#
#
#
#################################################################################

[Mesh]
  file = cube.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 0.1 0.2 0.3 0.4&#x27;
    y = &#x27;0 0.0026 0 -0.0026 0&#x27;
  [../]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0 0.1 0.2 0.3 0.4&#x27;
    y = &#x27;0 0   0    0   0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pull_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = displ
  [../]
  [./pin_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = &#x27;1  4&#x27;
    value = 0.0
  [../]
  [./pin_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./back]
    type = ADDirichletBC
    variable = disp_z
    boundary = &#x27;3&#x27;
    value = 0.0
  [../]
  [./front]
    type = ADPressure
    variable = disp_z
    component = 2
    boundary = 6
    function = pressure
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 200.0e3
    poissons_ratio = .3
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 120
    shear_retention_factor = 0.1
    softening_models = exponential_softening
  [../]
  [./exponential_softening]
    type = ADExponentialSoftening
    residual_stress = 0.1
    beta = 0.1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.4
  dt = 0.04
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ba0aed19-5129-48aa-922e-4b97ef73a3a8"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh_fu_18.i</h4><pre class="moose-pre"><code class="language-text"># with immobile saturation - this illustrates a perfect case of fullyupwind working very well
# unsaturated = true
# gravity = true
# full upwinding = true
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 0.5E1 0.5E2 0.4E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.4
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 2
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFullyUpwindFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh_fu_18
  execute_on = &#x27;timestep_end final&#x27;
  interval = 100000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1e51d3a6-9720-4628-b1ad-9ab070085d88"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_points.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with 2 elements
#through the thickness, and calculates the J-Integrals using options
#to treat it as 3d.
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack3d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  crack_front_points = &#x27;0 -10 .5
                        0 -10 0
                        0 -10 -.5&#x27;
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  radius_inner = &#x27;4.0 5.5&#x27;
  radius_outer = &#x27;5.5 7.0&#x27;
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_z2]
    type = DirichletBC
    variable = disp_z
    boundary = 510
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]

[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]


[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = j_integral_3d_points_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ed704cc3-9d99-41e2-8b09-f28b674b4884"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_3d_points.i</h4><pre class="moose-pre"><code class="language-text">#This tests the Interaction-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with 2 elements
#through the thickness, and calculates the Interaction-Integrals using options
#to treat it as 3d.

[GlobalParams]
  order = FIRST
#  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack3d.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = &#x27;InteractionIntegralKI InteractionIntegralKII InteractionIntegralKIII&#x27;
  crack_front_points = &#x27;0 -10 .5
                        0 -10 0
                        0 -10 -.5&#x27;
  closed_loop = false # if user provides &#x27;crack_front_points&#x27; instead of &#x27;boundary&#x27;, &#x27;closed_loop&#x27; should be set by user!
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  radius_inner = &#x27;4.0 5.5&#x27;
  radius_outer = &#x27;5.5 7.0&#x27;
  block = 1
  youngs_modulus = 207000
  poissons_ratio = 0.3
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_z2]
    type = DirichletBC
    variable = disp_z
    boundary = 510
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-7
  l_tol = 1e-3

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = interaction_integral_3d_points_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3265bc10-4fbc-4d20-a446-9607e1b1216f"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/finite_strain_tensor_mechanics_tests/finite_strain_patch.i</h4><pre class="moose-pre"><code class="language-text"># Patch Test
# This test is designed to compute constant xx, yy, zz, xy, yz, and zx
# stress on a set of irregular hexes.  The mesh is composed of one
# block with seven elements.  The elements form a unit cube with one
# internal element.  There is a nodeset for each exterior node.
# The cube is displaced by 1e-6 units in x, 2e-6 in y, and 3e-6 in z.
# The faces are sheared as well (1e-6, 2e-6, and 3e-6 for xy, yz, and
# zx).  This gives a uniform strain/stress state for all six unique
# tensor components.
# With Young&#x27;s modulus at 1e6 and Poisson&#x27;s ratio at 0, the shear
# modulus is 5e5 (G=E/2/(1+nu)).  Therefore,
#
# stress xx = 1e6 * 1e-6 = 1
# stress yy = 1e6 * 2e-6 = 2
# stress zz = 1e6 * 3e-6 = 3
# stress xy = 2 * 5e5 * 1e-6 / 2 = 0.5
# (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
# stress yz = 2 * 5e5 * 2e-6 / 2 = 1
# stress zx = 2 * 5e5 * 3e-6 / 2 = 1.5

[Mesh]
  # Comment
  # Mesh
  file = patch_mesh.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  # Functions
  [./rampConstant1]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 1e-6
  [../]
  [./rampConstant2]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 2e-6
  [../]
  [./rampConstant3]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 3e-6
  [../]
  [./rampConstant4]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 4e-6
  [../]
  [./rampConstant6]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 6e-6
  [../]
[]

[Variables]
  # Variables
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  # AuxVariables
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  # AuxKernels
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zx
    index_i = 2
    index_j = 0
  [../]
[]

[BCs]
  # BCs
  [./node1_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./node1_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = rampConstant2
  [../]
  [./node1_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 1
    function = rampConstant3
  [../]
  [./node2_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = rampConstant1
  [../]
  [./node2_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = rampConstant2
  [../]
  [./node2_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 2
    function = rampConstant6
  [../]
  [./node3_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 3
    function = rampConstant1
  [../]
  [./node3_y]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
  [./node3_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 3
    function = rampConstant3
  [../]
  [./node4_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./node4_y]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
  [./node4_z]
    type = DirichletBC
    variable = disp_z
    boundary = 4
    value = 0.0
  [../]
  [./node5_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 5
    function = rampConstant1
  [../]
  [./node5_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = rampConstant4
  [../]
  [./node5_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 5
    function = rampConstant3
  [../]
  [./node6_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 6
    function = rampConstant2
  [../]
  [./node6_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 6
    function = rampConstant4
  [../]
  [./node6_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 6
    function = rampConstant6
  [../]
  [./node7_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 7
    function = rampConstant2
  [../]
  [./node7_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 7
    function = rampConstant2
  [../]
  [./node7_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 7
    function = rampConstant3
  [../]
  [./node8_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 8
    function = rampConstant1
  [../]
  [./node8_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 8
    function = rampConstant2
  [../]
  [./node8_z]
    type = DirichletBC
    variable = disp_z
    boundary = 8
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    block = &#x27;1 2 3 4 5 6 7&#x27;
    C_ijkl = &#x27;1.0e6  0.0   0.0 1.0e6  0.0  1.0e6 0.5e6 0.5e6 0.5e6&#x27;
    fill_method = symmetric9
  [../]
  [./strain]
    type = ComputeFiniteStrain
    block = &#x27;1 2 3 4 5 6 7&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2 3 4 5 6 7&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  # Executioner
  type = Transient

  solve_type = &#x27;NEWTON&#x27;


  nl_abs_tol = 1e-10
  l_max_its = 20
  start_time = 0.0
  dt = 1.0
  num_steps = 2
  petsc_options_iname = -pc_type
  petsc_options_value = lu
  end_time = 2.0
[]

[Outputs]
  exodus = true
[] # Output
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3968c358-f22e-46c5-aee3-3622eff0b787"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/thermal_expansion_function/small_linear.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function is a linear function
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# This version of the test uses small deformation theory.  The results
# from the two models are identical.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 3
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain1]
    type = ComputeMeanThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 0.5
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
  [./thermal_expansion_strain2]
    type = ComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 2
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (0.5 * t^2 - 0.5 * tsf^2) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 0.0
               2 2.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="001e7347-a837-413d-adeb-9ad1995d8b28"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking.i</h4><pre class="moose-pre"><code class="language-text">#
# Simple pull test for cracking.
# The stress increases for two steps and then drops to zero.

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3  4&#x27;
    y = &#x27;0 1 0 -1 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pull]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displ
  [../]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 1.68e6
    softening_models = abrupt_softening
  [../]
  [./abrupt_softening]
    type = AbruptSoftening
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.1
  dt = 0.025
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6eb748cd-bc3e-4600-abf7-884b1cd5cb0d"><div class="modal-content"><h4>test/tests/time_steppers/cutback_factor_at_failure/function_dt_cutback.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    x = &#x27;0   0.85  2&#x27;
    y = &#x27;0.2 0.25  0.25&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Problem]
  type = FailingProblem
  fail_step = 3
[]

[Executioner]
  type = Transient
  num_steps = 10
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  [./TimeStepper]
    type = FunctionDT
    function = dts
    min_dt = 0.01
    cutback_factor_at_failure = 0.75
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8b408234-abd5-46d6-81ce-e5ca38b10153"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test14.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_rows_more_data.csv # will generate an error because of more data lines than 2
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e5b00a5e-e185-4b51-b6b1-135b50f66191"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/temperature_dependent_hardening/temp_dep_hardening.i</h4><pre class="moose-pre"><code class="language-text">#
# This is a test of the piece-wise linear strain hardening model using the
# small strain formulation.  This test exercises the temperature-dependent
# hardening curve capability.
#
# Test procedure:
# 1. The element is pulled to and then beyond the yield stress for a given
# temperature.
# 2. The displacement is then constant while the temperature increases and
# the yield stress decreases.  This results in a lower stress with more
# plastic strain.
# 3. The temperature decreases beyond its original value giving a higher
# yield stress.  The displacement increases, causing increases stress to
# the new yield stress.
# 4. The temperature and yield stress are constant with increasing
# displacement giving a constant stress and more plastic strain.
#
# Plotting total_strain_yy on the x axis and stress_yy on the y axis shows
# the stress history in a clear way.
#
#  s |
#  t |            *****
#  r |           *
#  e |   *****  *
#  s |  *    * *
#  s | *     *
#    |*
#    +------------------
#           total strain
#
# The exact same problem was run in Abaqus with exactly the same result.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  # This test uses ElementalVariableValue postprocessors on specific
  # elements, so element numbering needs to stay unchanged
  allow_renumbering = false
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 500.0
  [../]
[]

[AuxKernels]
  [./temp_aux]
    type = FunctionAux
    variable = temp
    function = temp_hist
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1     2    4    5    6&#x27;
    y = &#x27;0 0.025 0.05 0.05 0.06 0.085&#x27;
  [../]
  [./hf1]
    type = PiecewiseLinear
    x = &#x27;0.0  0.01 0.02 0.03 0.1&#x27;
    y = &#x27;5000 5030 5060 5090 5300&#x27;
  [../]
  [./hf2]
    type = PiecewiseLinear
    x = &#x27;0.0  0.01 0.02 0.03 0.1&#x27;
    y = &#x27;4000 4020 4040 4060 4200&#x27;
  [../]
  [./temp_hist]
    type = PiecewiseLinear
    x = &#x27;0   1   2   3   4&#x27;
    y = &#x27;500 500 500 600 400&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy strain_yy plastic_strain_xx plastic_strain_yy plastic_strain_zz&#x27;
  [../]
[]


[BCs]
  [./y_pull_function]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 3
    function = top_pull
  [../]
  [./x_bot]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./z_bot]
    type = DirichletBC
    variable = disp_z
    boundary = 0
    value = 0.0
  [../]
[]

[Postprocessors]
  [./stress_yy_el]
    type = ElementalVariableValue
    variable = stress_yy
    elementid = 0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2e5
    poissons_ratio = 0.3
  [../]
  [./temp_dep_hardening]
    type = TemperatureDependentHardeningStressUpdate
    hardening_functions = &#x27;hf1 hf2&#x27;
    temperatures = &#x27;300.0 800.0&#x27;
    relative_tolerance = 1e-25
    absolute_tolerance = 1e-5
    temperature = temp
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;temp_dep_hardening&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10
  l_tol = 1e-9

  start_time = 0.0
  end_time = 6
  dt = 0.1
[]

[Outputs]
  [./out]
    type = Exodus
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f4bfbabe-dbc2-4c8c-8fab-f23015626647"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/creep.i</h4><pre class="moose-pre"><code class="language-text"># This test is provided as a check to ensure ADComputeMultiplePorousInelasticStress

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmax = 0.002
  ymax = 0.002
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  base_name = &#x27;total&#x27;
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
[]

[Materials]
  active=&#x27;elasticity_tensor porous_stress creep&#x27;
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
    base_name = &#x27;total&#x27;
  [../]
  [./porous_stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = creep
    initial_porosity = 0.1
    outputs = all
    base_name = &#x27;total&#x27;
  [../]
  [./regular_stress]
    type = ADComputeMultipleInelasticStress
    inelastic_models = creep
    outputs = all
    base_name = &#x27;total&#x27;
  [../]
  [./porosity]
    type = ADGenericConstantMaterial
    prop_names = porosity
    prop_values = 0.1
    outputs = all
  [../]
  [./creep]
    type = ADPowerLawCreepStressUpdate
    activation_energy = 4e4
    temperature = 1200
    coefficient = 1e-18
    gas_constant = 1.987
    n_exponent = 3
    base_name = &#x27;creep&#x27;
    outputs = all
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = total_hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = total_vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./eff_creep_strain]
    type = ElementAverageValue
    variable = creep_effective_creep_strain
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6afab823-234f-49a8-abaf-7565af845a67"><div class="modal-content"><h4>test/tests/multiapps/picard/function_dt_master.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  ymin = 0
  xmax = 1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]

  [./dts]
    type = PiecewiseLinear
    x = &#x27;0.1  10&#x27;
    y = &#x27;0.1  10&#x27;
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./ufn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = v_fn
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10
  picard_max_its = 2
  start_time = 0
  num_steps = 3
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;function_dt_sub.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c09b0a08-37f1-4e4e-acbe-288dd2d68b9c"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/rz.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (2) with an interior cavity of volume 8.
#   Block 1 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts T in the following way:
#   T =&gt; T0 + beta * t
# with
#   beta = T0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# At t = 1, p = 200.

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Mesh]
  file = rz.e
[]

[Functions]
  [./temperature]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 2&#x27;
    scale_factor = 240.54443866068704
  [../]
[]

[Variables]
  [./disp_r]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_r
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    preset = false
    boundary = 2
    function = temperature
    variable = temp
  [../]
  [./CavityPressure]
    [./1]
      boundary = 2
      initial_pressure = 100
      R = 8.314472
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elastic_tensor1]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 1
  [../]
  [./strain1]
    type = ADComputeAxisymmetricRZFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elastic_tensor2]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 2
  [../]
  [./strain2]
    type = ADComputeAxisymmetricRZFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_abs_tol = 1e-10

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 2
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = true
  [./checkpoint]
    type = Checkpoint
    num_files = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="54ac402d-dc2d-4bcd-a24f-e69dca56ea8f"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_hht.i</h4><pre class="moose-pre"><code class="language-text"># Wave propogation in 1D using HHT time integration
#
# The test is for an 1D bar element of length 4m  fixed on one end
# with a sinusoidal pulse dirichlet boundary condition applied to the other end.
# alpha, beta and gamma are Newmark  time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel + K*((1+alpha)*disp-alpha*disp_old) = 0
#
# Here M is the mass matrix, K is the stiffness matrix
#
# The displacement at the second, third and fourth node at t = 0.1 are
# -8.097405701570538350e-02, 2.113131879547342634e-02 and -5.182787688751439893e-03, respectively.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 4
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 4.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    alpha = -0.3
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.3025
    gamma = 0.6
    alpha = -0.3
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.3025
    gamma = 0.6
    alpha = -0.3
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.3025
    gamma = 0.6
    alpha = -0.3
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.6
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.6
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.6
    execute_on = timestep_end
  [../]
[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value=0.0
  [../]
  [./right_z]
    type = DirichletBC
    variable = disp_z
    boundary = right
    value=0.0
  [../]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value=0.0
  [../]
  [./left_z]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value=0.0
  [../]
  [./front_x]
    type = DirichletBC
    variable = disp_x
    boundary = front
    value=0.0
  [../]
  [./front_z]
    type = DirichletBC
    variable = disp_z
    boundary = front
    value=0.0
  [../]
  [./back_x]
    type = DirichletBC
    variable = disp_x
    boundary = back
    value=0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = bottom
    function = displacement_bc
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;1 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 6.0
  l_tol = 1e-12
  nl_rel_tol = 1e-12
  dt = 0.1
[]


[Functions]
  [./displacement_bc]
    type = PiecewiseLinear
    data_file = &#x27;sine_wave.csv&#x27;
    format = columns
  [../]

[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp_1]
    type = NodalVariableValue
    nodeid = 1
    variable = vel_y
  [../]
  [./disp_2]
    type = NodalVariableValue
    nodeid = 3
    variable = vel_y
  [../]
  [./disp_3]
    type = NodalVariableValue
    nodeid = 10
    variable = vel_y
  [../]
  [./disp_4]
    type = NodalVariableValue
    nodeid = 14
    variable = vel_y
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f04b332b-3267-4ca1-ac91-d7b4cefc5b06"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test10.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    xy_data = &#x27;1 2&#x27;
    scale_factor = 1.0
    axis = 3
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="13a5f998-5b7f-4009-b586-5a79c58d1fbd"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/plane_stress/weak_plane_stress_small.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
  out_of_plane_strain = strain_zz
[]

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./strain_zz]
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./nl_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./react_z]
    type = MaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
  [./min_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = min
  [../]
  [./max_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = max
  [../]
[]

[Modules/TensorMechanics/Master]
  [plane_stress]
    planar_formulation = WEAK_PLANE_STRESS
    strain = SMALL
    generate_output = &#x27;stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy&#x27;
    eigenstrain_names = eigenstrain
  []
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    use_displaced_mesh = false
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = nl_strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0     1   100&#x27;
    y=&#x27;0  0.00  0.00&#x27;
  [../]
  [./tempfunc]
    type = ParsedFunction
    value = &#x27;(1 - x) * t&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 0.02
    stress_free_temperature = 0.5
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  line_search = none

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-06

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-12

# time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="db8a9ce1-af18-43b3-ac34-200e2b6472b0"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/diffusion_2d_quad9.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 3
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD9
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.35 1.0 0.35 0.2&#x27;
    time_start_cut = 0.0
    time_end_cut = 2.0
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = 3
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d7f2c638-6e1a-4b84-882b-553344f6986e"><div class="modal-content"><h4>modules/richards/test/tests/broadbridge_white/bw02.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 200
  ny = 1
  xmin = -10
  xmax = 10
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-1 5E-1 5E-1&#x27;
    x = &#x27;0 1 10&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 10
    bulk_mod = 2E9
  [../]
  [./SeffBW]
    type = RichardsSeff1BWsmall
    Sn = 0.0
    Ss = 1.0
    C = 1.5
    las = 2
  [../]
  [./RelPermBW]
    type = RichardsRelPermBW
    Sn = 0.0
    Ss = 1.0
    Kn = 0
    Ks = 1
    C = 1.5
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E2
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -9E2
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]


[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffBW
    pressure_vars = pressure
  [../]
[]


[BCs]
  active = &#x27;recharge&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pressure
    boundary = &#x27;right&#x27;
    pressures = &#x27;-1E10 1E10&#x27;
    bare_fluxes = &#x27;-1.25 -1.25&#x27; # corresponds to Rstar being 0.5 because i have to multiply by density*porosity
    use_mobility = false
    use_relperm = false
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.25
    mat_permeability = &#x27;1 0 0  0 1 0  0 0 1&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermBW
    SUPG_UO = SUPGstandard
    sat_UO = Saturation
    seff_UO = SeffBW
    viscosity = 4
    gravity = &#x27;-0.1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 2

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = bw02
  interval = 10000
  execute_on = &#x27;timestep_end final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5c289ba7-efe5-416a-8f0b-8da3af9dad67"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test1tt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test1tt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f62ff17e-5f93-45a2-af22-8d42967432e8"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/planar_xy.i</h4><pre class="moose-pre"><code class="language-text"># 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks in the x-y plane.  Each element block
# is a square. They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
# across each block. The temperature of the far bottom boundary
# is ramped from 100 to 200 over one time unit.  The temperature of the far top
# boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
# Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
# gapK(Tavg) = 1.0*Tavg
#
# The heat flux across the gap at time = 1 is then:
#
# Flux = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors.  These results
# are the same as for the unit 1-D gap heat transfer between two unit cubes.



[Mesh]
  file = simple_2D.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_bottom]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_top]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-14
  l_tol = 1e-3
  l_max_its = 100

  dt = 1e-1
  end_time = 1.0
[]

[Postprocessors]
  [./temp_bottom]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_top]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_bottom]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_top]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d4e43159-a6a6-44ed-a531-decfb322c1f5"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_rz_exponential.i</h4><pre class="moose-pre"><code class="language-text">#
# Test to exercise the exponential stress release
#
# Stress vs. strain should show a linear relationship until cracking,
#   an exponential stress release, a linear relationship back to zero
#   strain, a linear relationship with the original stiffness in
#   compression and then back to zero strain, a linear relationship
#   back to the exponential curve, and finally further exponential
#   stress release.

[Mesh]
  file = cracking_rz_test.e
[]

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./disply]
    type = PiecewiseLinear
    x = &#x27;0 1       2  3      4 5       6&#x27;
    y = &#x27;0 0.00175 0 -0.0001 0 0.00175 0.0035&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pully]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = disply
  [../]
  [./bottom]
    type = ADDirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]

  [./sides]
    type = ADDirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 186.5e9
    poissons_ratio = 0.316
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 119.3e6
    softening_models = exponential_softening
  [../]
  [./exponential_softening]
    type = ADExponentialSoftening
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type&#x27;
  petsc_options_value = &#x27;101                lu&#x27;

  line_search = &#x27;none&#x27;
  l_max_its = 100
  l_tol = 1e-5

  nl_max_its = 10
  nl_rel_tol = 1e-8

  nl_abs_tol = 1e-4

  start_time = 0.0
  end_time = 6.0
  dt = 0.005
  dtmin = 0.005
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d739d369-ca81-4e42-a2da-d6115e931fd9"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/thermal_expansion_function/small_const.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function has a constant value,
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# This version of the test uses small deformation theory.  The results
# from the two models are identical.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 3
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain1]
    type = ComputeMeanThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 0.5
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
  [./thermal_expansion_strain2]
    type = ComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 2
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (t - tsf) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 1.0
               2 1.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2a07b42d-b0d4-496b-b331-4663193c9b4c"><div class="modal-content"><h4>modules/combined/test/tests/thermal_elastic/ad-thermal_elastic.i</h4><pre class="moose-pre"><code class="language-text"># Patch Test

# This test is designed to compute constant xx, yy, zz, xy, yz, and xz
#  stress on a set of irregular hexes.  The mesh is composed of one
#  block with seven elements.  The elements form a unit cube with one
#  internal element.  There is a nodeset for each exterior node.

# The cube is displaced by 1e-6 units in x, 2e-6 in y, and 3e-6 in z.
#  The faces are sheared as well (1e-6, 2e-6, and 3e-6 for xy, yz, and
#  zx).  This gives a uniform strain/stress state for all six unique
#  tensor components.  This displacement is again applied in the second
#  step.

# With Young&#x27;s modulus at 1e6 and Poisson&#x27;s ratio at 0, the shear
#  modulus is 5e5 (G=E/2/(1+nu)).  Therefore, for the mechanical strain,
#
#  stress xx = 1e6 * 1e-6 = 1
#  stress yy = 1e6 * 2e-6 = 2
#  stress zz = 1e6 * 3e-6 = 3
#  stress xy = 2 * 5e5 * 1e-6 / 2 = 0.5
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 5e5 * 2e-6 / 2 = 1
#  stress zx = 2 * 5e5 * 3e-6 / 2 = 1.5

# Young&#x27;s modulus is a function of temperature for this test.  The
#  temperature changes from 100 to 500.  The Young&#x27;s modulus drops
#  due to that temperature change from 1e6 to 6e5.

# Poisson&#x27;s ratio also is a function of temperature and changes from
#  0 to 0.25.

# At the end of the temperature ramp, E=6e5 and nu=0.25.  This gives
#  G=2.4e=5.  lambda=E*nu/(1+nu)/(1-2*nu)=2.4E5.  The final stress
#  is therefore

#  stress xx = 2.4e5 * 12e-6 + 2*2.4e5*2e-6 = 3.84
#  stress yy = 2.4e5 * 12e-6 + 2*2.4e5*4e-6 = 4.80
#  stress zz = 2.4e5 * 12e-6 + 2*2.4e5*6e-6 = 5.76
#  stress xy = 2 * 2.4e5 * 2e-6 / 2 = 0.48
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 2.4e5 * 4e-6 / 2 = 0.96
#  stress xz = 2 * 2.4e5 * 6e-6 / 2 = 1.44

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = thermal_elastic.e
[]

[Functions]
  [./ramp1]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 1e-6
  [../]
  [./ramp2]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 2e-6
  [../]
  [./ramp3]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 3e-6
  [../]
  [./ramp4]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 4e-6
  [../]
  [./ramp6]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 6e-6
  [../]
  [./tempFunc]
    type = PiecewiseLinear
    x = &#x27;0     1     2&#x27;
    y = &#x27;100.0 100.0 500.0&#x27;
  [../]
[]

[Variables]
  [./temp]
    initial_condition = 100.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_xz stress_yz&#x27;
    strain = FINITE
    use_automatic_differentiation = true
  [../]
[]

[Kernels]
  [./heat]
    type = ADDiffusion
    variable = temp
  [../]
[]

[BCs]
  [./node1_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./node1_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = ramp2
  [../]
  [./node1_z]
    type = ADFunctionDirichletBC
    variable = disp_z
    boundary = 1
    function = ramp3
  [../]

  [./node2_x]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = ramp1
  [../]
  [./node2_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = ramp2
  [../]
  [./node2_z]
    type = ADFunctionDirichletBC
    variable = disp_z
    boundary = 2
    function = ramp6
  [../]

  [./node3_x]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 3
    function = ramp1
  [../]
  [./node3_y]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
  [./node3_z]
    type = ADFunctionDirichletBC
    variable = disp_z
    boundary = 3
    function = ramp3
  [../]

  [./node4_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./node4_y]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
  [./node4_z]
    type = DirichletBC
    variable = disp_z
    boundary = 4
    value = 0.0
  [../]

  [./node5_x]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 5
    function = ramp1
  [../]
  [./node5_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = ramp4
  [../]
  [./node5_z]
    type = ADFunctionDirichletBC
    variable = disp_z
    boundary = 5
    function = ramp3
  [../]

  [./node6_x]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 6
    function = ramp2
  [../]
  [./node6_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = 6
    function = ramp4
  [../]
  [./node6_z]
    type = ADFunctionDirichletBC
    variable = disp_z
    boundary = 6
    function = ramp6
  [../]

  [./node7_x]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 7
    function = ramp2
  [../]
  [./node7_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = 7
    function = ramp2
  [../]
  [./node7_z]
    type = ADFunctionDirichletBC
    variable = disp_z
    boundary = 7
    function = ramp3
  [../]

  [./node8_x]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 8
    function = ramp1
  [../]
  [./node8_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = 8
    function = ramp2
  [../]
  [./node8_z]
    type = DirichletBC
    variable = disp_z
    boundary = 8
    value = 0.0
  [../]

  [./temp]
    type = ADFunctionDirichletBC
    variable = temp
    boundary = &#x27;10 12&#x27;
    function = tempFunc
  [../]
[]

[Materials]
  [./youngs_modulus]
    type = ADPiecewiseLinearInterpolationMaterial
    x = &#x27;100 500&#x27;
    y = &#x27;1e6 6e5&#x27;
    property = youngs_modulus
    variable = temp
  [../]
  [./poissons_ratio]
    type = ADPiecewiseLinearInterpolationMaterial
    x = &#x27;100 500&#x27;
    y = &#x27;0   0.25&#x27;
    property = poissons_ratio
    variable = temp
  [../]

  [./elasticity_tensor]
    type = ADComputeVariableIsotropicElasticityTensor
    youngs_modulus = youngs_modulus
    poissons_ratio = poissons_ratio
  [../]

  [./stress]
    type = ADComputeFiniteStrainElasticStress
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-9

  l_max_its = 20

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="26206ce9-3d2d-4f69-ace7-908bd05b8f3b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/acceleration_bc/AccelerationBC_test_ti.i</h4><pre class="moose-pre"><code class="language-text"># Test for  Acceleration boundary condition

# This test contains one brick element which is fixed in the y and z direction.
# Base acceleration is applied in the x direction to all nodes on the bottom surface (y=0).

# The PresetAcceleration converts the given acceleration to a displacement
# using Newmark time integration. This displacement is then prescribed on the boundary.
#
# Result: The acceleration at the bottom node should be same as the input acceleration
# which is a triangular function with peak at t = 0.2 in this case. Width of the triangular function
# is 0.2 s.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./TensorMechanics]
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
  [../]

[]

[AuxKernels]
  [./accel_x] # These auxkernels are only to check output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]

[Functions]
  [./acceleration_bottom]
    type = PiecewiseLinear
    data_file = acceleration.csv
    format = columns
  [../]
[]

[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./preset_accelertion]
    type = PresetAcceleration
    boundary = bottom
    function = acceleration_bottom
    variable = disp_x
    beta = 0.25
    acceleration = accel_x
    velocity = vel_x
   [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
  [../]

  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./density]
    type = GenericConstantMaterial
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      101&#x27;
  start_time = 0
  end_time = 2.0
  dt = 0.01
  dtmin = 0.01
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-8
  l_tol = 1e-8
  timestep_tolerance = 1e-8

  # Time integrator scheme
  schem = &quot;newmark-beta&quot;
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalVariableValue
    variable = disp_x
    nodeid = 1
  [../]
  [./vel]
    type = NodalVariableValue
    variable = vel_x
    nodeid = 1
  [../]
  [./accel]
    type = NodalVariableValue
    variable = accel_x
    nodeid = 1
  [../]
[]

[Outputs]
  file_base = &quot;AccelerationBC_test_out&quot;
  csv = true
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0c93d114-ec0f-44e6-92a2-8e6cf0c0b5df"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_power.i</h4><pre class="moose-pre"><code class="language-text">#
# Simple test of power law softening law for smeared cracking.
# Upon reaching the failure stress in the x direction, the
# softening model abruptly reduces the stress to a fraction
# of its original value, and re-loading occurs at a reduced
# stiffness. This is repeated multiple times.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3  4&#x27;
    y = &#x27;0 1 0 -1 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pull]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = right
    function = displ
  [../]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 1.68e6
    softening_models = power_law_softening
  [../]
  [./power_law_softening]
    type = PowerLawSoftening
    stiffness_reduction = 0.3333
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 1.0
  dt = 0.01
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b56a6566-920c-4ea3-b7f9-e99a8c6aee16"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test6.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    x = &#x27;1&#x27;
    y = &#x27;2&#x27;
    xy_data = &#x27;1 2&#x27;
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6ee68e8b-def9-4568-9b2c-94073fe56a5d"><div class="modal-content"><h4>modules/contact/test/tests/verification/patch_tests/single_pnt_2d/single_point_2d_contact_line_search.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = single_point_2d.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./penetration]
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
[]

[Functions]
  [./appl_disp]
    type = PiecewiseLinear
    x = &#x27;0 0.001  0.101&#x27;
    y = &#x27;0 0.0   -0.10&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    save_in = &#x27;saved_x saved_y&#x27;
  [../]
[]

[AuxKernels]
  [./incslip_x]
    type = PenetrationAux
    variable = inc_slip_x
    quantity = incremental_slip_x
    boundary = 3
    paired_boundary = 2
  [../]
  [./incslip_y]
    type = PenetrationAux
    variable = inc_slip_y
    quantity = incremental_slip_y
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_x]
    type = AccumulateAux
    variable = accum_slip_x
    accumulate_from_variable = inc_slip_x
    execute_on = timestep_end
  [../]
  [./accum_slip_y]
    type = AccumulateAux
    variable = accum_slip_y
    accumulate_from_variable = inc_slip_y
    execute_on = timestep_end
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 3
    paired_boundary = 2
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./topx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = appl_disp
  [../]
  [./topy]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = -0.002001
  [../]
[]

[Materials]
  [./bot_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e9
    poissons_ratio = 0.3
  [../]
  [./bot_strain]
    type = ComputePlaneFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./bot_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./top_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./top_strain]
    type = ComputePlaneFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./top_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = NodalVariableValue
    nodeid = 5
    variable = disp_x
  [../]
  [./disp_y]
    type = NodalVariableValue
    nodeid = 5
    variable = disp_y
  [../]
  [./inc_slip_x]
    type = NodalVariableValue
    nodeid = 5
    variable = inc_slip_x
  [../]
  [./inc_slip_y]
    type = NodalVariableValue
    nodeid = 5
    variable = inc_slip_y
  [../]
  [./accum_slip_x]
    type = NodalVariableValue
    nodeid = 5
    variable = accum_slip_x
  [../]
  [./accum_slip_y]
    type = NodalVariableValue
    nodeid = 5
    variable = accum_slip_y
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package -mat_superlu_dist_iterrefine&#x27;
  petsc_options_value = &#x27;lu    superlu_dist 1&#x27;

  line_search = &#x27;contact&#x27;
  contact_line_search_allowed_lambda_cuts = 0
  contact_line_search_ltol = 0.5

  l_max_its = 15
  nl_max_its = 10
  dt = 0.001
  end_time = 0.002
  num_steps = 10000
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-8
  dtmin = 0.001
  l_tol = 1e-3
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
  perf_graph = true
  csv = true
  [./console]
    type = Console
    max_rows = 5
  [../]
[]

[Contact]
  [./leftright]
    primary = 2
    secondary = 3
    model = frictionless
    formulation = kinematic
    penalty = 1e12
    normalize_penalty = true
    tangential_tolerance = 1e-3
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="35be9f0c-c7c6-4528-b693-57691193c468"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/static/euler_finite_rot_z.i</h4><pre class="moose-pre"><code class="language-text"># Large strain/large rotation cantilever beam test

# A 300 N point load is applied at the end of a 4 m long cantilever beam.
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 1e8
# Poisson&#x27;s ratio (nu) = -0.99995
# shear coefficient (k) = 1.0
# Area (A) = 1.0
# Iy = Iz = 0.16

# The dimensionless parameter alpha = kAGL^2/EI = 1e6
# Since the value of alpha ia quite high, the beam behaves like
# a thin beam where shear effects are not significant.

# Beam deflection:
# small strain+rot = 3.998 m (exact 4.0)
# large strain + small rotation = -0.05 m in x and 3.74 m in z
# large rotations + small strain = -0.92 m in x and 2.38 m in z
# large rotations + large strain = -0.954 m in x and 2.37 m in z (exact -1.0 m in x and 2.4 m in z)

# References:
# K. E. Bisshopp and D.C. Drucker, Quaterly of Applied Mathematics, Vol 3, No. 3, 1945.

[Mesh]
  type = FileMesh
  file = beam_finite_rot_test_2.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = 1
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = 1
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = 1
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_z2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = 2
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 2.0  8.0&#x27;
    y = &#x27;0.0 300.0 300.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre     boomeramg     4&#x27;
  nl_max_its = 50
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-7
  l_max_its = 50
  dt = 0.05
  end_time = 2.1
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1e4
    poissons_ratio = -0.99995
    shear_coefficient = 1.0
    block = 1
  [../]
  [./strain]
    type = ComputeFiniteBeamStrain
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 1.0
    Ay = 0.0
    Az = 0.0
    Iy = 0.16
    Iz = 0.16
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
    large_strain = true
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 1
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_z
  [../]
  [./rot_z]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = rot_y
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a347473b-3b6e-491f-849d-d00c548ca715"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_1/gh21.i</h4><pre class="moose-pre"><code class="language-text"># investigating validity of immobile saturation
# 5 elements, with SUPG

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 5
  xmin = -1
  xmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 10 100 1000 10000&#x27;
    x = &#x27;0 10 100 1000 10000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E3
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.1
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E-6
  [../]
[]

[Variables]
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -1.0
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    SUPG_UO = SUPGstandard
    sat_UO = Saturation
    seff_UO = SeffVG
    viscosity = 1E-3
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1E0
  end_time = 1E5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh21
  execute_on = &#x27;timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cab4e02b-12b3-42c3-b09f-3f7db1644247"><div class="modal-content"><h4>modules/contact/test/tests/verification/patch_tests/single_pnt_2d/single_point_2d_frictional.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = single_point_2d.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./penetration]
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
[]

[Functions]
  [./appl_disp]
    type = PiecewiseLinear
    x = &#x27;0 0.001  0.101&#x27;
    y = &#x27;0 0.0   -0.10&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    save_in = &#x27;saved_x saved_y&#x27;
  [../]
[]

[AuxKernels]
  [./incslip_x]
    type = PenetrationAux
    variable = inc_slip_x
    quantity = incremental_slip_x
    boundary = 3
    paired_boundary = 2
  [../]
  [./incslip_y]
    type = PenetrationAux
    variable = inc_slip_y
    quantity = incremental_slip_y
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_x]
    type = AccumulateAux
    variable = accum_slip_x
    accumulate_from_variable = inc_slip_x
    execute_on = timestep_end
  [../]
  [./accum_slip_y]
    type = AccumulateAux
    variable = accum_slip_y
    accumulate_from_variable = inc_slip_y
    execute_on = timestep_end
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 3
    paired_boundary = 2
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./topx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = appl_disp
  [../]
  [./topy]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = -0.002001
  [../]
[]

[Materials]
  [./bot_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e9
    poissons_ratio = 0.3
  [../]
  [./bot_strain]
    type = ComputePlaneFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./bot_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./top_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./top_strain]
    type = ComputePlaneFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./top_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
[]

[Postprocessors]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 1
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 1
  [../]
  [./top_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 4
  [../]
  [./top_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 4
  [../]
  [./disp_x]
    type = NodalVariableValue
    nodeid = 5
    variable = disp_x
  [../]
  [./disp_y]
    type = NodalVariableValue
    nodeid = 5
    variable = disp_y
  [../]
  [./inc_slip_x]
    type = NodalVariableValue
    nodeid = 5
    variable = inc_slip_x
  [../]
  [./inc_slip_y]
    type = NodalVariableValue
    nodeid = 5
    variable = inc_slip_y
  [../]
  [./accum_slip_x]
    type = NodalVariableValue
    nodeid = 5
    variable = accum_slip_x
  [../]
  [./accum_slip_y]
    type = NodalVariableValue
    nodeid = 5
    variable = accum_slip_y
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu    superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 200
  dt = 0.001
  end_time = 0.001
  num_steps = 10000
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-8
  dtmin = 0.001
  l_tol = 1e-3
[]

[Outputs]
  file_base = single_point_2d_out_frictional_0_2_kin
  exodus = true
  print_linear_residuals = true
  perf_graph = true
  csv = true
  [./console]
    type = Console
    max_rows = 5
  [../]
[]

[Contact]
  [./leftright]
    primary = 2
    secondary = 3
    model = coulomb
    formulation = kinematic
    penalty = 1e12
    normalize_penalty = true
    friction_coefficient = &#x27;0.2&#x27;
    tangential_tolerance = 1e-3
  [../]
[]

 [Dampers]
   [./contact_slip]
     type = ContactSlipDamper
     primary = &#x27;2&#x27;
     secondary = &#x27;3&#x27;
   [../]
 []
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0d37ffe2-cf38-46ed-9114-1a8d8ca70af6"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_gps_small.i</h4><pre class="moose-pre"><code class="language-text"># this test checks the asixymmetric 1D generalized plane strain formulation using incremental small strains

[GlobalParams]
  displacements = disp_x
  scalar_out_of_plane_strain = scalar_strain_yy
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = line.e
[]

[Variables]
  [./disp_x]
  [../]
  [./scalar_strain_yy]
    order = FIRST
    family = SCALAR
  [../]
[]

[AuxVariables]
  [./strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;580 580 680&#x27;
  [../]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 2e-6&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./GeneralizedPlaneStrain]
      [./gps]
      [../]
    [../]
  [../]
[]

[AuxKernels]
  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./temp]
    type = FunctionAux
    variable = temp
    function = temp
    execute_on = &#x27;timestep_begin&#x27;
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1
    value = 0
    variable = disp_x
  [../]
  [./disp_x]
    type = FunctionDirichletBC
    boundary = 2
    function = disp_x
    variable = disp_x
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./strain]
    type = ComputeAxisymmetric1DSmallStrain
    eigenstrain_names = eigenstrain
    scalar_out_of_plane_strain = scalar_strain_yy
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-8
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-6
  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 2
  num_steps = 2
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="33fee500-7fec-420f-bbae-dc8664e95dd8"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/interaction_integral_benchmark/input.i</h4><pre class="moose-pre"><code class="language-text"># Uses InteractionIntegralBenchmarkBC to test the mixed-mode stress intensity
# factor capability. InteractionIntegralBenchmarkBC applies a displacement
# field for which KI = KII = KIII = 1.0. Using the option 2d = true gives a
# q field that is constant along the tangent and returns Ki = 1.0 for all i.
# To get the correct value for all nodes with 2d = false, the mesh around the
# crack tip must be refined and the q-function radii must be reduced by at
# least two orders of magnitude.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 360degree_model.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Problem]
  type = FEProblem
[]

[Functions]
  [./kifunc]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0&#x27;
    y = &#x27;0.0 1.0 2.0&#x27;
  [../]
[]

[DomainIntegral]
  integrals = &#x27;JIntegral InteractionIntegralKI InteractionIntegralKII InteractionIntegralKIII&#x27;
  boundary = 1001
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  radius_inner = &#x27;0.5 1.0 1.5 2.0&#x27;
  radius_outer = &#x27;1.0 1.5 2.0 2.5&#x27;
  youngs_modulus = 30000
  poissons_ratio = 0.3
  block = 1
  2d = true
  axis_2d = 2
  equivalent_k = True
  incremental = true
[]

[AuxVariables]
  [./dq_x]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./dq_y]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./dq_z]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[BCs]
  [./all_x]
    type = InteractionIntegralBenchmarkBC
    variable = disp_x
    component = x
    boundary = 1
    KI_function = kifunc
    KII_function = 1.0
    KIII_function = 1.0
    youngs_modulus = 30000
    poissons_ratio = 0.3
    crack_front_definition = crackFrontDefinition
    crack_front_point_index = 0
  [../]
  [./all_y]
    type = InteractionIntegralBenchmarkBC
    variable = disp_y
    component = y
    boundary = 1
    KI_function = kifunc
    KII_function = 1.0
    KIII_function = 1.0
    youngs_modulus = 30000
    poissons_ratio = 0.3
    crack_front_definition = crackFrontDefinition
    crack_front_point_index = 0
  [../]
  [./all_z]
    type = InteractionIntegralBenchmarkBC
    variable = disp_z
    component = z
    boundary = 1
    KI_function = kifunc
    KII_function = 1.0
    KIII_function = 1.0
    youngs_modulus = 30000
    poissons_ratio = 0.3
    crack_front_definition = crackFrontDefinition
    crack_front_point_index = 0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 30000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-3
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 2
  num_steps = 2
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]

  [./nl_its]
    type = NumNonlinearIterations
  [../]

  [./lin_its]
    type = NumLinearIterations
  [../]

[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = 360degree_model_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0e4600b2-0acb-4caa-b97f-d10a91f792dd"><div class="modal-content"><h4>modules/combined/test/tests/power_law_creep/power_law_creep_restart1.i</h4><pre class="moose-pre"><code class="language-text"># 1x1x1 unit cube with uniform pressure on top face

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1000.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy&#x27;
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./u_top_pull]
    type = Pressure
    variable = disp_y
    component = 1
    boundary = top
    factor = -10.0e6
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp_fix]
    type = DirichletBC
    variable = temp
    boundary = &#x27;bottom top&#x27;
    value = 1000.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2e11
    poissons_ratio = 0.3
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;power_law_creep&#x27;
  [../]
  [./power_law_creep]
    type = PowerLawCreepStressUpdate
    coefficient = 1.0e-15
    n_exponent = 4
    activation_energy = 3.0e5
    temperature = temp
  [../]

  [./thermal]
    type = HeatConductionMaterial
    specific_heat = 1.0
    thermal_conductivity = 100.
  [../]
  [./density]
    type = Density
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.0
  end_time = 1.0
  num_steps = 6
  dt = 0.1
[]

[Outputs]
  exodus = true
  csv = true
  [./out]
    type = Checkpoint
    num_files = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="72bf0acd-71cc-44c9-9650-b3b36a589d84"><div class="modal-content"><h4>modules/richards/test/tests/buckley_leverett/bl20_lumped.i</h4><pre class="moose-pre"><code class="language-text"># two-phase version
[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 30
  xmin = 0
  xmax = 15
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;0.1 0.5 0.5 1 2  4&#x27;
    x = &#x27;0   0.1 1   5 40 42&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E6
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-5
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./w_aux_seff]
  [../]
[]



[Kernels]
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]

[AuxKernels]
  [./w_aux_seff_auxk]
    type = RichardsSeffAux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
    variable = w_aux_seff
  [../]
[]


[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_water
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_gas
  [../]
[]

[BCs]
  [./left_w]
    type = DirichletBC
    variable = pwater
    boundary = left
    value = 1E6
  [../]
  [./left_g]
    type = DirichletBC
    variable = pgas
    boundary = left
    value = 1000
  [../]
  [./right_w]
    type = DirichletBC
    variable = pwater
    boundary = right
    value = -300000
  [../]
  [./right_g]
    type = DirichletBC
    variable = pgas
    boundary = right
    value = 0
  [../]
[]


[Functions]
  [./initial_water]
    type = ParsedFunction
    value = 1000000*(1-min(x/5,1))-if(x&lt;5,0,300000)
  [../]
  [./initial_gas]
    type = ParsedFunction
    value = 1000
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.15
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    viscosity = &#x27;1E-3 1E-6&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  active = &#x27;standard&#x27;

  [./bounded]
  # must use --use-petsc-dm command line argument
    type = SMP
    full = true
    petsc_options_iname = &#x27;-snes_type   -pc_factor_shift_type&#x27;
    petsc_options_value = &#x27;vinewtonssls nonzero&#x27;
  [../]

  [./standard]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-pc_factor_shift_type&#x27;
    petsc_options_value = &#x27;nonzero&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  end_time = 50

  nl_rel_tol = 1.e-9
  nl_max_its = 10

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = bl20_lumped
  execute_on = &#x27;initial timestep_end final&#x27;
  interval = 100000
  exodus = true
  hide = pgas
  [./console_out]
    type = Console
    interval = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a7182977-482c-44f2-a4e2-67ab34a3abb3"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_single.i</h4><pre class="moose-pre"><code class="language-text"># This test provides an example of an individual LPS viscoplasticity model

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmax = 0.002
  ymax = 0.002
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = lps
    initial_porosity = 0.1
    outputs = all
  [../]

  [./lps]
    type = ADViscoplasticityStressUpdate
    coefficient = &#x27;coef&#x27;
    power = 3
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./coef]
    type = ADParsedMaterial
    f_name = coef
    # Example of creep power law
    function = &#x27;1e-18 * exp(-4e4 / 1.987 / 1200)&#x27;
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./eff_creep_strain]
    type = ElementAverageValue
    variable = effective_viscoplasticity
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0da60e36-5f7d-418a-91df-6d078b41000b"><div class="modal-content"><h4>modules/porous_flow/test/tests/dirackernels/bh04.i</h4><pre class="moose-pre"><code class="language-text"># fully-saturated
# production
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1 1E1 1E2 1E3&#x27;
    x = &#x27;0 1E-1 1 1E1 1E2 1E3&#x27;
  [../]
[]

[Variables]
  [./pp]
    initial_condition = 0
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pp
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;pp&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./borehole_total_outflow_mass]
    type = PorousFlowSumQuantity
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.8
    alpha = 1e-5
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      viscosity = 1e-3
      density0 = 1000
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pp
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.1
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-12 0 0 0 1E-12 0 0 0 1E-12&#x27;
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityFLAC
    m = 2
    phase = 0
  [../]
[]

[DiracKernels]
  [./bh]
    type = PorousFlowPeacemanBorehole
    variable = pp
    SumQuantityUO = borehole_total_outflow_mass
    point_file = bh02.bh
    fluid_phase = 0
    bottom_p_or_t = -1E6
    unit_weight = &#x27;0 0 0&#x27;
    use_mobility = true
    character = 1
  [../]
[]

[Postprocessors]
  [./bh_report]
    type = PorousFlowPlotQuantity
    uo = borehole_total_outflow_mass
  [../]

  [./fluid_mass0]
    type = PorousFlowFluidMass
    execute_on = timestep_begin
  [../]

  [./fluid_mass1]
    type = PorousFlowFluidMass
    execute_on = timestep_end
  [../]

  [./zmass_error]
    type = FunctionValuePostprocessor
    function = mass_bal_fcn
    execute_on = timestep_end
  [../]

  [./p0]
    type = PointValue
    variable = pp
    point = &#x27;0 0 0&#x27;
    execute_on = timestep_end
  [../]
[]

[Functions]
  [./mass_bal_fcn]
    type = ParsedFunction
    value = abs((a-c+d)/2/(a+c))
    vars = &#x27;a c d&#x27;
    vals = &#x27;fluid_mass1 fluid_mass0 bh_report&#x27;
  [../]
[]

[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 1E3
  solve_type = NEWTON
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = bh04
  exodus = false
  csv = true
  execute_on = timestep_end
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b9ad119e-0037-4d7a-b869-c67605760cdf"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/planar_yz.i</h4><pre class="moose-pre"><code class="language-text"># 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks in the y-z plane.  Each element block
# is a square. They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
# across each block. The temperature of the far bottom boundary
# is ramped from 100 to 200 over one time unit.  The temperature of the far top
# boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
# Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
# gapK(Tavg) = 1.0*Tavg
#
# The heat flux across the gap at time = 1 is then:
#
# Flux = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors.  These results
# are the same as for the unit 1-D gap heat transfer between two unit cubes.

[Mesh]
  [file]
    type = FileMeshGenerator
    file = simple_2D.e
  []
  [./rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;0 90 90&#x27;
    input = file
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_bottom]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_top]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  l_tol = 1e-3
  l_max_its = 100

  dt = 1e-1
  end_time = 1.0
[]

[Postprocessors]
  [./temp_bottom]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_top]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_bottom]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_top]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1b2e9934-dba4-416e-99cc-055916020629"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/pressure/pressure_test.i</h4><pre class="moose-pre"><code class="language-text">#
# Pressure Test
#
# This test is designed to compute pressure loads on three faces of a unit cube.
#
# The mesh is composed of one block with a single element.  Symmetry bcs are
# applied to the faces opposite the pressures.  Poisson&#x27;s ratio is zero,
# which makes it trivial to check displacements.
#


[Mesh]
  type = FileMesh
  file = pressure_test.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 1.0
  [../]
  [./zeroRamp]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 0. 1.&#x27;
    scale_factor = 1.0
  [../]
  [./rampUnramp]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 0.&#x27;
    scale_factor = 10.0
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 5
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 1
      function = rampConstant
      displacements = &#x27;disp_x disp_y disp_z&#x27;
    [../]
    [./Side2]
      boundary = 2
      function = zeroRamp
      displacements = &#x27;disp_x disp_y disp_z&#x27;
      factor = 2.0
    [../]
    [./Side3]
      boundary = 3
      function = rampUnramp
      displacements = &#x27;disp_x disp_y disp_z&#x27;
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 1
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;0 0.5e6&#x27;
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    block = 1
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = 1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  nl_abs_tol = 1e-10
  l_max_its = 20
  start_time = 0.0
  dt = 1.0
  num_steps = 2
  end_time = 2.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7c74d126-2144-4f56-8c46-de0d8b265ee9"><div class="modal-content"><h4>modules/combined/test/tests/adaptive_timestepping/adapt_tstep_function_force_step.i</h4><pre class="moose-pre"><code class="language-text"># This is a test designed to evaluate the cabability of the
# IterationAdaptiveDT TimeStepper to adjust time step size according to
# a function.  For example, if the power input function for a BISON
# simulation rapidly increases or decreases, the IterationAdaptiveDT
# TimeStepper should take time steps small enough to capture the
# oscillation.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  block = 1
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 1hex8_10mm_cube.e
[]

[Functions]
  [./Fiss_Function]
    type = PiecewiseLinear
    data_file = blip.csv
    format = columns
  [../]
[]

[Variables]
  [./disp_x]
  [../]

  [./disp_y]
  [../]

  [./disp_z]
  [../]

  [./temp]
    initial_condition = 300.0
  [../]
[]


[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    eigenstrain_names = thermal_expansion
    add_variables  = true
    generate_output = &#x27;vonmises_stress&#x27;
  [../]
[]


[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]

  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]

  [./heat_source]
     type = HeatSource
     variable = temp
     value = 1.0
     function = Fiss_Function
  [../]
[]

[BCs]
 [./bottom_temp]
   type = DirichletBC
   variable = temp
   boundary = 1
   value = 300
 [../]
 [./top_bottom_disp_x]
   type = DirichletBC
   variable = disp_x
   boundary = &#x27;1&#x27;
   value = 0
 [../]
 [./top_bottom_disp_y]
   type = DirichletBC
   variable = disp_y
   boundary = &#x27;1&#x27;
   value = 0
 [../]
 [./top_bottom_disp_z]
   type = DirichletBC
   variable = disp_z
   boundary = &#x27;1&#x27;
   value = 0
 [../]
[]

[Materials]
 [./thermal]
    type = HeatConductionMaterial
    temp = temp
    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 300e6
    poissons_ratio = .3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 5e-6
    stress_free_temperature = 300.0
    temperature = temp
    eigenstrain_name = thermal_expansion
  [../]

  [./density]
    type = Density
    density = 10963.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  verbose = true
  nl_abs_tol = 1e-10
  start_time = 0.0
  num_steps = 50000

  end_time = 5.1e3
  [./TimeStepper]
    type = IterationAdaptiveDT
    timestep_limiting_function = Fiss_Function
    max_function_change = 3e20
    force_step_every_function_point = true
    dt = 1e2
  [../]
[]

[Postprocessors]
  [./Temperature_of_Block]
    type = ElementAverageValue
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./vonMises]
    type = ElementAverageValue
    variable = vonmises_stress
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="33f704f8-f5cc-43bc-b7f6-211c2f55af47"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_gps_incremental.i</h4><pre class="moose-pre"><code class="language-text"># this test checks the asixymmetric 1D generalized plane strain formulation using incremental small strains

[GlobalParams]
  displacements = disp_x
  scalar_out_of_plane_strain = scalar_strain_yy
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = line.e
[]

[Variables]
  [./disp_x]
  [../]
  [./scalar_strain_yy]
    order = FIRST
    family = SCALAR
  [../]
[]

[AuxVariables]
  [./strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;580 580 680&#x27;
  [../]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 2e-6&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./GeneralizedPlaneStrain]
      [./gps]
      [../]
    [../]
  [../]
[]

[AuxKernels]
  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./temp]
    type = FunctionAux
    variable = temp
    function = temp
    execute_on = &#x27;timestep_begin&#x27;
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1
    value = 0
    variable = disp_x
  [../]
  [./disp_x]
    type = FunctionDirichletBC
    boundary = 2
    function = disp_x
    variable = disp_x
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./strain]
    type = ComputeAxisymmetric1DIncrementalStrain
    eigenstrain_names = eigenstrain
    scalar_out_of_plane_strain = scalar_strain_yy
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-8
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeStrainIncrementBasedStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-6
  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 2
  num_steps = 2
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ecaa8c67-cf55-4d35-8d39-5b1c5f0da29d"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/1D/1d_consistent_explicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for central difference integration for a 1D element
# Consistent mass matrix

[Mesh]
  type = GeneratedMesh
  xmin = 0
  xmax = 10
  nx = 5
  dim = 1
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
[]

[NodalKernels]
  [./force_x]
    type = UserForcingFunctionNodalKernel
    variable = disp_x
    boundary = right
    function = force_x
  [../]
[]

[Functions]
  [./force_x]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # force
    scale_factor = 1e3
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 2500
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.005
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  l_tol = 1e-10
  [./TimeIntegrator]
    type = CentralDifference
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_x
  [../]
  [./vel_x]
    type = NodalVariableValue
    nodeid = 1
    variable = vel_x
  [../]
  [./accel_x]
    type = NodalVariableValue
    nodeid = 1
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
  perf_graph = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="63d8402d-edef-472a-a215-0c2c0e5d3e08"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_rz_test.i</h4><pre class="moose-pre"><code class="language-text">#
# 2-D RZ Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks containing one element each.  Each
#   element is a unit cube.  They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit, and then held fixed for an additional
#  time unit.  The temperature of the far right boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks, or cylinders in the case of RZ.:
#
#  Flux = (T_left - T_right) * (gapK/(r*ln(r2/r1)))
#
# For gapK = 1 (default value)
#
# The integrated heat flux across the gap at time 2 is then:
#
# 2*pi*h*k*delta_T/(ln(r2/r1))
# 2*pi*1*1*100/(ln(2/1)) = 906.5 watts
#
# For comparison, see results from the flux post processors.
#
# As a second test, use the rectilinear (parallel plate) form of the gap heat transfer.
#
#  Flux = (T_left - T_right) * (gapK/gapL)
#
# For gapK = 1 (default value)
#
# The integrated heat flux across the gap at time 2 is then:
#
# 2*pi*h*k*delta_T/(1)
# 2*pi*1*1*100/(1) = 628.3 watts
#
# For comparison, see results from the flux post processors.
#

[Problem]
  coord_type = RZ
  rz_coord_axis = Y # this is modified through CLI args to test Z-R as opposed to R-Z
[]

[Mesh]
  active = &#x27;file&#x27;
  [file]
    type = FileMeshGenerator
    file = gap_heat_transfer_htonly_rz_test.e
  []
  [rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;90 0 0&#x27;
    input = file
  []
[]
[Functions]

  [./ramp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
  [./thermal_contact2]
    type = GapHeatTransfer
    variable = temp2
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_geometry_type = PLATE
    appended_property_name = 2
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
  [./temp2]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./gap_cond2]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat2]
    type = HeatConduction
    variable = temp2
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = ramp
  [../]

  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]

  [./temp_far_left2]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp2
    function = ramp
  [../]

  [./temp_far_right2]
    type = DirichletBC
    boundary = 4
    variable = temp2
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
  [./conductance2]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond2
    boundary = 2
  [../]
[]

[Materials]

  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1e6
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
#  petsc_options = &#x27;-snes_mf_operator -ksp_monitor -snes_ksp_ew&#x27;

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;




#  petsc_options_iname = &#x27;-snes_type -snes_ls -snes_linesearch_type -ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
#  petsc_options_value = &#x27;ls         basic    basic                    201                hypre    boomeramg      4&#x27;
#  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
#  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  nl_abs_tol = 1e-3
  nl_rel_tol = 1e-8

  l_tol = 1e-6
  l_max_its = 100

  start_time = 0.0
  dt = 1e-1
  dtmin = 1e-1
  end_time = 2.0
[]

[Postprocessors]

  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]

  [./temp_left2]
    type = SideAverageValue
    boundary = 2
    variable = temp2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right2]
    type = SideAverageValue
    boundary = 3
    variable = temp2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left2]
    type = SideFluxIntegral
    variable = temp2
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right2]
    type = SideFluxIntegral
    variable = temp2
    boundary = 3
    diffusivity = thermal_conductivity
  [../]

[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a577f975-2c8c-4449-9c20-a50819c4b3a4"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_rayleigh_hht_action.i</h4><pre class="moose-pre"><code class="language-text"># Test for damped small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# density (rho) = 1.0
# mass proportional rayleigh damping(eta) = 0.1
# stiffness proportional rayleigh damping(eta) = 0.1
# HHT time integration parameter (alpha) = -0.3
# Corresponding Newmark beta time integration parameters beta = 0.4225 and gamma = 0.8

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time  disp_y                vel_y                accel_y
# 0.0   0.0                   0.0                  0.0
# 0.2   0.019898364318588     0.18838688112273     1.1774180070171
# 0.4   0.045577003505278     0.087329917525455   -0.92596052423724
# 0.6   0.063767907208218     0.084330765885995    0.21274543331268
# 0.8   0.073602908614573     0.020029576220975   -0.45506879373455
# 1.0   0.06841704414745     -0.071840076837194   -0.46041813317992

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.2 0.4 10.0&#x27;
    y = &#x27;0.0 0.01  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10
  start_time = 0.0
  dt = 0.2
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Modules/TensorMechanics/LineElementMaster]
  [./all]
    add_variables = true
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;

    # Geometry parameters
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;

    # dynamic simulation using consistent mass/inertia matrix
    dynamic_consistent_inertia = true

    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;

    density = 1.0
    beta = 0.4225 # Newmark time integraion parameter
    gamma = 0.8 # Newmark time integraion parameter

    # optional parameters for numerical (alpha) and Rayleigh damping
    alpha = -0.3 # HHT time integration parameter
    eta = 0.1 # Mass proportional Rayleigh damping
    zeta = 0.1 # Stiffness proportional Rayleigh damping
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  file_base = &#x27;dyn_euler_small_rayleigh_hht_out&#x27;
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8bc4c36e-87ee-4da1-83b6-6aaa2d7b6352"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D.i</h4><pre class="moose-pre"><code class="language-text">#
# 2D Cylindrical Gap Heat Transfer Test.
#
# This test exercises 2D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid cylinder of radius = 1 unit, and outer
# hollow cylinder with an inner radius of 2 in the x-y plane. In other words,
# the gap between them is 1 radial unit in length.
#
# The conductivity of both cylinders is set very large to achieve a uniform
# temperature in each cylinder. The temperature of the center node of the
# inner cylinder is ramped from 100 to 200 over one time unit. The temperature
# of the outside of the outer, hollow cylinder is held fixed at 100.
#
# A simple analytical solution is possible for the integrated heat flux
# between the inner and outer cylinders:
#
#  Integrated Flux = (T_left - T_right) * (gapK/(r*ln(r2/r1))) * Area
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 2 * pi * h * r, where h is the height of the cylinder.
#
# The integrated heat flux across the gap at time 1 is then:
#
# 2*pi*h*k*delta_T/(ln(r2/r1))
# 2*pi*1*1*100/(ln(2/1)) = 906.5 watts
#
# For comparison, see results from the integrated flux post processors.
# This simulation makes use of symmetry, so only 1/4 of the cylinders is meshed
# As such, the integrated flux from the post processors is 1/4 of the total,
# or 226.6 watts.
# The value coming from the post processor is slightly less than this
# but converges as mesh refinement increases.
# Note that the 2D and 3D results are the same.
#
# Simulating contact is challenging. Regression tests that exercise
# contact features can be difficult to solve consistently across multiple
# platforms. While designing these tests, we felt it worth while to note
# some aspects of these tests. The following applies to:
# sphere3D.i, sphere2DRZ.i, cyl2D.i, and cyl3D.i.
# 1. We decided that to perform consistently across multiple platforms we
# would use very small convergence tolerance. In this test we chose an
# nl_rel_tol of 1e-12.
# 2. Due to such a high value for thermal conductivity (used here so that the
# domains come to a uniform temperature) the integrated flux at time = 0
# was relatively large (the value coming from SideIntegralFlux =
#  -_diffusion_coef[_qp]*_grad_u[_qp]*_normals[_qp] where the diffusion coefficient
# here is thermal conductivity).
# Even though _grad_u[_qp] is small, in this case the diffusion coefficient
# is large. The result is a number that isn&#x27;t exactly zero and tends to
# fail exodiff. For this reason the parameter execute_on = initial should not
# be used. That parameter is left to default settings in these regression tests.
#
[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]


[Mesh]
  file = cyl2D.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]


[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]


[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]


[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = CYLINDER
    cylinder_axis_point_1 = &#x27;0 0 0&#x27;
    cylinder_axis_point_2 = &#x27;0 0 1&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
  [./Console]
    type = Console
  [../]
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2ffec56a-fdac-4698-b974-36dbe691812e"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/strain_energy_density/tot_model.i</h4><pre class="moose-pre"><code class="language-text"># Single element test to check the strain energy density calculation

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 2
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = SMALL
    add_variables = true
    incremental = false
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress strain_xx strain_yy strain_zz&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./Pressure]
    [./top]
      boundary = &#x27;top&#x27;
      function = rampConstantUp
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 30e+6
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeLinearElasticStress
  [../]
  [./strain_energy_density]
    type = StrainEnergyDensity
    incremental = false
  [../]
[]

[Executioner]
   type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./epxx]
    type = ElementalVariableValue
    variable = strain_xx
    elementid = 0
  [../]
  [./epyy]
    type = ElementalVariableValue
    variable = strain_yy
    elementid = 0
  [../]
  [./epzz]
    type = ElementalVariableValue
    variable = strain_zz
    elementid = 0
  [../]
  [./sigxx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./sigyy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./sigzz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./SED]
    type = ElementAverageValue
    variable = SED
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0e66896e-4b07-4654-95e0-bbf2d608765d"><div class="modal-content"><h4>modules/contact/test/tests/hertz_spherical/hertz_contact_hex27.i</h4><pre class="moose-pre"><code class="language-text"># Hertz Contact: Sphere on sphere

# Spheres have the same radius, Young&#x27;s modulus, and Poisson&#x27;s ratio.

# Define E:
# 1/E = (1-nu1^2)/E1 + (1-nu2^2)/E2
#
# Effective radius R:
# 1/R = 1/R1 + 1/R2
#
# F is the applied compressive load.
#
# Area of contact a::
# a^3 = 3FR/4E
#
# Depth of indentation d:
# d = a^2/R
#
#
# Let R1 = R2 = 2.  Then R = 1.
#
# Let nu1 = nu2 = 0.25, E1 = E2 = 1.40625e7.  Then E = 7.5e6.
#
# Let F = 10000.  Then a = 0.1, d = 0.01.
#

[GlobalParams]
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  order = SECOND
[]

[Mesh]#Comment
  file = hertz_contact_hex27.e
[] # Mesh

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 795.77471545947674 # 10000/pi/2^2
  [../]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.  1.    2.&#x27;
    y = &#x27;0. -0.01 -0.01&#x27;
  [../]
[] # Functions

[Variables]

  [./disp_x]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_y]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_z]
    order = SECOND
    family = LAGRANGE
  [../]

[] # Variables

[AuxVariables]

  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./hydrostatic]
    order = CONSTANT
    family = MONOMIAL
  [../]

[] # AuxVariables

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = SMALL
  #  extra_vector_tags = &#x27;ref&#x27;
  [../]
[]
[AuxKernels]

  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[] # AuxKernels

[BCs]

  [./base_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1000
    value = 0.0
  [../]
  [./base_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1000
    value = 0.0
  [../]
  [./base_z]
    type = DirichletBC
    variable = disp_z
    boundary = 1000
    value = 0.0
  [../]

  [./symm_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./symm_z]
    type = DirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
  [./disp_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

[] # BCs

[Contact]
  [./dummy_name]
    primary = 1000
    secondary = 100

    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+10
  [../]
[]

[Materials]
  [./tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1.40625e7
    poissons_ratio = 0.25
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = &#x27;1&#x27;
  [../]

  [./tensor_1000]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1000&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]
  [./stress_1000]
    type = ComputeLinearElasticStress
    block = &#x27;1000&#x27;
  [../]

[] # Materials

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  []
[]

[Executioner]

  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-7
  l_max_its = 10
  start_time = 0.0
  dt = 0.5
  end_time = 0.5 # was 2.0

  [./Quadrature]
    order = FIFTH
  [../]

[] # Executioner

[Postprocessors]
  [./maxdisp]
    type = NodalVariableValue
    nodeid = 386 # 387-1 where 387 is the exodus node number of the top-center node
    variable = disp_y
  [../]
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d1cb70f4-1c8d-4cc4-9002-ae7cfc3f6c3d"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/diffusion_2d_tri6.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 3
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = TRI6
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.35 1.0 0.35 0.2&#x27;
    time_start_cut = 0.0
    time_end_cut = 2.0
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = 3
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e5bb58c7-2842-4b19-a121-3567b97ad450"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/3d.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = - (0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# The parameters combined at t = 1 gives p = 301.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 3d.e
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = Diffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = FunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e1
    poissons_ratio = 0
    block = 1
  [../]
  [./strain1]
    type = ComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0
    block = 2
  [../]
  [./strain2]
    type = ComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="91fa075f-a34f-4134-a9d1-b5aa19d0081a"><div class="modal-content"><h4>modules/combined/test/tests/internal_volume/rz_displaced_quad8.i</h4><pre class="moose-pre"><code class="language-text">#
# Volume Test
#
# This test is designed to compute the volume of a space when displacements
#   are imposed.
#
# The mesh is composed of one block (1) with two elements.  The mesh is
#   such that the initial volume is 1.  One element face is displaced to
#   produce a final volume of 2.
#
#     r1
#   +----+   -
#   |    |   |
#   +----+   h    V1 = pi * h * r1^2
#   |    |   |
#   +----+   -
#
#   becomes
#
#   +----+
#   |     \
#   +------+      v2 = pi * h/2 * ( r2^2 + 1/3 * ( r2^2 + r2*r1 + r1^2 ) )
#   |      |
#   +------+
#      r2
#
#   r1 = 1
#   r2 = 1.5380168369562588
#   h  = 1/pi
#
#  Note:  Because the InternalVolume PP computes cavity volumes as positive,
#         the volumes reported are negative.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = meshes/rz_displaced_quad8.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 0.5380168369562588&#x27;
  [../]
  [./disp_x2]
    type = PiecewiseLinear
    scale_factor = 0.5
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 0.5380168369562588&#x27;
  [../]
[]

[Variables]
  [./disp_x]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_y]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = false
    decomposition_method = EigenSolution
    incremental = true
    strain = FINITE
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./x]
    type = FunctionDirichletBC
    boundary = 3
    variable = disp_x
    function = disp_x
  [../]
  [./x2]
    type = FunctionDirichletBC
    boundary = 4
    variable = disp_x
    function = disp_x2
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK

  start_time = 0.0
  dt = 1.0
  end_time = 1.0

  [./Quadrature]
    order = THIRD
  [../]
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="62a04ddf-d5d5-4684-8ab2-bcc0ea30b238"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_1/gh_fu_22.i</h4><pre class="moose-pre"><code class="language-text"># investigating validity of immobile saturation
# 50 elements, full upwinding

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 50
  xmin = -1
  xmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  SUPG_UO = SUPGnone
  sat_UO = Saturation
  seff_UO = SeffVG
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 10 100 1000 10000&#x27;
    x = &#x27;0 10 100 1000 10000&#x27;
  [../]
[]


[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E3
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.1
  [../]
  [./SUPGnone]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -1.0
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFullyUpwindFlux
    variable = pressure
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = 1E-3
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1E0
  end_time = 1E5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh_fu_22
  execute_on = &#x27;timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9d4c1d99-f16b-4a74-aa07-d15bce879f07"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/initial_temperature.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = -(0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# The parameters combined at t = 1 gives p = 301.
#
# This test sets the initial temperature to 500, but the CavityPressure
#   is told that that initial temperature is T0.  Thus, the final solution
#   is unchanged.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3d.e
[]

[GlobalParams]
  volumetric_locking_correction = true
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 500
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = Diffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = FunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      initial_temperature = 240.54443866068704
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 1
  [../]
  [./strain1]
    type = ComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 2
  [../]
  [./strain2]
    type = ComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aecb2d11-03a5-4b07-abd7-2a85d792a0ac"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/3D/3d_lumped_explicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for the central difference time integrator in 3D.

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 1
    ny = 1
    nz = 2
    xmin = 0.0
    xmax = 1
    ymin = 0.0
    ymax = 1
    zmin = 0.0
    zmax = 2
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_x
  [../]
  [./accel_z]
    type = TestNewmarkTI
    variable = accel_z
    displacement = disp_z
    first = false
  [../]
  [./vel_z]
    type = TestNewmarkTI
    variable = vel_z
    displacement = disp_z
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
  [../]
[]

[BCs]
  [./x_bot]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = &#x27;back&#x27;
    function = dispx
    preset = false
  [../]
  [./y_bot]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = &#x27;back&#x27;
    function = dispy
    preset = false
  [../]
  [./z_bot]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = &#x27;back&#x27;
    function = dispz
    preset = false
  [../]
[]

[Functions]
  [./dispx]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
  [./dispy]
    type = ParsedFunction
    value = 0.1*t*t*sin(10*t)
  [../]
  [./dispz]
    type = ParsedFunction
    value = 0.1*t*t*sin(20*t)
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 1e4
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = CentralDifference
    solve_type = lumped
  [../]
[]

[Postprocessors]
  [./accel_10x]
    type = NodalVariableValue
    nodeid = 10
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="18058189-da2d-454e-9d9f-e9dadeec4e7b"><div class="modal-content"><h4>test/tests/postprocessors/function_element_integral/function_element_integral.i</h4><pre class="moose-pre"><code class="language-text">dx = 2
y1 = 3
y2 = 6
y3 = 8
integral = ${fparse dx * ((y1 + y2) * 0.5 + (y2 + y3) * 0.5)}

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 2
  xmax = 4
[]

[Functions]
  [./function]
    type = PiecewiseLinear
    axis = x
    x = &#x27;0 2 4&#x27;
    y = &#x27;${y1} ${y2} ${y3}&#x27;
  [../]
[]

[Postprocessors]
  [./integral_pp]
    type = FunctionElementIntegral
    function = function
    execute_on = &#x27;initial&#x27;
  [../]
  [./integral_rel_err]
    type = RelativeDifferencePostprocessor
    value1 = integral_pp
    value2 = ${integral}
    execute_on = &#x27;initial&#x27;
  [../]
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  csv = true
  show = &#x27;integral_rel_err&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5874182a-ac01-47b7-a3fa-6a2789bb8cea"><div class="modal-content"><h4>modules/porous_flow/test/tests/infiltration_and_drainage/bw02.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 200
  ny = 1
  xmin = -10
  xmax = 10
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-1 5E-1 5E-1&#x27;
    x = &#x27;0 1 10&#x27;
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = pressure
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureBW
    Sn = 0.0
    Ss = 1.0
    C = 1.5
    las = 2
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      viscosity = 4
      density0 = 10
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pressure
    capillary_pressure = pc
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityBW
    Sn = 0.0
    Ss = 1.0
    Kn = 0
    Ks = 1
    C = 1.5
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.25
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0  0 1 0  0 0 1&#x27;
  [../]
[]

[Variables]
  [./pressure]
    initial_condition = -9E2
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pressure
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pressure
    gravity = &#x27;-0.1 0 0&#x27;
  [../]
[]

[AuxVariables]
  [./SWater]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./SWater]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 0
    variable = SWater
  [../]
[]

[BCs]
  [./recharge]
    type = PorousFlowSink
    variable = pressure
    boundary = right
    flux_function = -1.25 # corresponds to Rstar being 0.5 because i have to multiply by density*porosity
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10      1E-10      10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 2

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[VectorPostprocessors]
  [./swater]
    type = LineValueSampler
    variable = SWater
    start_point = &#x27;-10 0 0&#x27;
    end_point = &#x27;10 0 0&#x27;
    sort_by = x
    num_points = 80
    execute_on = timestep_end
  [../]
[]

[Outputs]
  file_base = bw02
  sync_times = &#x27;0.5 2 8&#x27;
  [./exodus]
    type = Exodus
    sync_only = true
  [../]
  [./along_line]
    type = CSV
    sync_only = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b6384c9b-8831-4781-96cb-53afdfb572e2"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test1.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test1_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="71d857f6-fc2b-4a57-90de-d03dff8e0dfd"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_plane_strain_incremental.i</h4><pre class="moose-pre"><code class="language-text">#
# This test checks elastic stress calculations with mechanical and thermal
# strain using incremental small strain formulation. Young&#x27;s modulus is 3600, and Poisson&#x27;s ratio is 0.2.
# The axisymmetric, plane strain 1D mesh is pulled with 1e-6 strain.  Thus,
# the strain is [1e-6, 0, 1e-6] (xx, yy, zz).  This gives stress of
# [5e-3, 2e-3, 5e-3].  After a temperature increase of 100 with alpha of
# 1e-8, the stress becomes [-1e-3, -4e-3, -1e-3].
#

[GlobalParams]
  displacements = disp_x
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = line.e
[]

[Variables]
  [./disp_x]
  [../]
[]

[AuxVariables]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;580 580 680&#x27;
  [../]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 2e-6&#x27;
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./ps]
        planar_formulation = PLANE_STRAIN
        strain = SMALL
        incremental = true
        generate_output = &#x27;strain_xx strain_zz stress_xx stress_yy stress_zz&#x27;
        eigenstrain_names = eigenstrain
      [../]
    [../]
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = temp
    execute_on = &#x27;timestep_begin&#x27;
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1
    value = 0
    variable = disp_x
  [../]
  [./disp_x]
    type = FunctionDirichletBC
    boundary = 2
    function = disp_x
    variable = disp_x
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-8
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeStrainIncrementBasedStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-6
  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 2
  num_steps = 2
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="761df66b-2897-4b0e-9c56-3d1f2e2f0b28"><div class="modal-content"><h4>modules/contact/test/tests/nodal_area/nodal_area_Hex20.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = nodal_area_Hex20.e
[]

[GlobalParams]
  order = SECOND
  displacements = &#x27;displ_x displ_y displ_z&#x27;
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0     1&#x27;
    y = &#x27;0  20e-6&#x27;
  [../]
[]

[Variables]
  [./displ_x]
  [../]
  [./displ_y]
  [../]
  [./displ_z]
  [../]
[]

[AuxVariables]
  [./react_x]
  [../]
  [./react_y]
  [../]
  [./react_z]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    incremental = true
    save_in = &#x27;react_x react_y react_z&#x27;
    add_variables = true
    strain = FINITE
    generate_output = &#x27;stress_xx&#x27;
  [../]
[]

[BCs]
  [./move_right]
    type = FunctionDirichletBC
    boundary = &#x27;1&#x27;
    variable = displ_x
    function = disp
  [../]

  [./fixed_x]
    type = DirichletBC
    boundary = &#x27;3 4&#x27;
    variable = displ_x
    value = 0
  [../]

  [./fixed_y]
    type = DirichletBC
    boundary = 10
    variable = displ_y
    value = 0
  [../]

  [./fixed_z]
    type = DirichletBC
    boundary = 11
    variable = displ_z
    value = 0
  [../]
[]

[Contact]
  [./dummy_name]
    primary = 3
    secondary = 2
    penalty = 1e7
    tangential_tolerance = 1e-5
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-9
  l_tol = 1e-4
  l_max_its = 40

  start_time = 0.0
  dt = 1.0
  end_time = 1.0

  [./Quadrature]
    order = THIRD
  [../]
[]

[Postprocessors]
  [./react_x]
    type = NodalSum
    variable = react_x
    boundary = 1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./total_area]
    type = NodalSum
    variable = nodal_area_dummy_name
    boundary = 2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ae3488d3-e0a4-48e0-86c5-3a05ffad6a15"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/generalized_plane_strain/plane_strain_prescribed.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  scalar_out_of_plane_strain = scalar_strain_zz
  block = 0
[]

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./scalar_strain_zz]
    order = FIRST
    family = SCALAR
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    use_displaced_mesh = false
  [../]
[]

[AuxScalarKernels]
  [./strain_zz]
    type = FunctionScalarAux
    variable = scalar_strain_zz
    function = scalar_strain_zz_func
  [../]
[]

[Functions]
  [./tempfunc]
    type = ParsedFunction
    value = &#x27;(1-x)*t&#x27;
  [../]
  [./scalar_strain_zz_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 0
               1 7.901e-5
               2 1.103021e-2&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    temperature = temp
    generate_output = &#x27;stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy strain_zz&#x27;
    planar_formulation = PLANE_STRAIN
    eigenstrain_names = eigenstrain
    save_in = &#x27;saved_x saved_y&#x27;
  [../]
[]

[Materials]
  [./elastic_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    temperature = temp
    thermal_expansion_coeff = 0.02
    stress_free_temperature = 0.5
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Postprocessors]
  [./react_z]
    type = MaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  line_search = none

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-4

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-5

# time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
  num_steps = 5000
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b7bbe695-2630-465c-84a5-00e35fcaf651"><div class="modal-content"><h4>modules/richards/test/tests/buckley_leverett/bl21.i</h4><pre class="moose-pre"><code class="language-text"># two-phase version
# sharp front version
[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 150
  xmin = 0
  xmax = 15
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-3 1E-2 3E-2 4E-2 0.5 0.5 1&#x27;
    x = &#x27;0    1E-2 1E-1 1    5   40  41&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E6
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 3E-5
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 3E-5
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
  [./bounds_dummy]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
  [./richardsppenalty]
    type = RichardsPPenalty
    variable = pgas
    a = 1E-18
    lower_var = pwater
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[Bounds]
  [./pwater_upper_bounds]
    type = ConstantBoundsAux
    variable = bounds_dummy
    bounded_variable = pwater
    bound_type = upper
    bound_value = 1E7
  [../]
  [./pwater_lower_bounds]
    type = ConstantBoundsAux
    variable = bounds_dummy
    bounded_variable = pwater
    bound_type = lower
    bound_value = -110000
  [../]
[]


[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_water
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_gas
  [../]
[]

[BCs]
  [./left_w]
    type = DirichletBC
    variable = pwater
    boundary = left
    value = 1E6
  [../]
  [./left_g]
    type = DirichletBC
    variable = pgas
    boundary = left
    value = 1E6+1000
  [../]
  [./right_w]
    type = DirichletBC
    variable = pwater
    boundary = right
    value = -100000
  [../]
  [./right_g]
    type = DirichletBC
    variable = pgas
    boundary = right
    value = 0+1000
  [../]
[]


[Functions]
  [./initial_water]
    type = ParsedFunction
    value = 1000000*(1-min(x/5,1))-100000*(max(x-5,0)/max(abs(x-5),1E-10))
  [../]
  [./initial_gas]
    type = ParsedFunction
    value = max(1000000*(1-x/5),0)+1000
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.15
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 1E-6&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  active = &#x27;standard&#x27;

  [./bounded]
  # must use --use-petsc-dm command line argument
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -snes_type -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 50 vinewtonssls 1E-20 1E-20&#x27;
  [../]

  [./standard]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 20 1E-20 1E-20&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  end_time = 50

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = bl21
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c75fbb43-53c8-4c98-b584-b677870eb5aa"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_timoshenko_small.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain Timoshenko beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 2e4
# Shear modulus (G) = 1e4
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 1.0
# Iy = 1.0 = Iz
# Length (L)= 4 m
# density (rho) = 1.0

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 8
# Therefore, the beam behaves like a Timoshenko beam.

# The FEM solution for this beam with 100 elements give first natural period of 0.2731s with a time step of 0.005.
# The acceleration, velocity and displacement time histories obtained from MOOSE matches with those obtained from ABAQUS.

# Values from the first few time steps are as follows:
# time    disp_y                vel_y                 accel_y
# 0.0     0.0                   0.0                   0.0
# 0.005   2.5473249455812e-05   0.010189299782325     4.0757199129299
# 0.01    5.3012872677486e-05   0.00082654950634483  -7.8208200233219
# 0.015   5.8611622914354e-05   0.0014129505884026    8.055380456145
# 0.02    6.766113649781e-05    0.0022068548449798   -7.7378187535141
# 0.025   7.8981810558437e-05   0.0023214147792709    7.7836427272305

# Note that the theoretical first frequency of the beam using Euler-Bernoulli theory is:
# f1 = 1/(2 pi) * (3.5156/L^2) * sqrt(EI/rho) = 4.9455

# This implies that the corresponding time period of this beam (under Euler-Bernoulli assumption) is 0.2022s.

# This shows that Euler-Bernoulli beam theory under-predicts the time period of a thick beam. In other words, the Euler-Bernoulli beam theory predicts a more compliant beam than reality for a thick beam.

[Mesh]
  type = GeneratedMesh
  xmin = 0
  xmax = 4.0
  nx = 100
  dim = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux
    variable = rot_accel_x
    displacement = rot_x
    velocity = rot_vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux
    variable = rot_vel_x
    acceleration = rot_accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux
    variable = rot_accel_y
    displacement = rot_y
    velocity = rot_vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux
    variable = rot_vel_y
    acceleration = rot_accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux
    variable = rot_accel_z
    displacement = rot_z
    velocity = rot_vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux
    variable = rot_vel_z
    acceleration = rot_accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.005 0.01 1.0&#x27;
    y = &#x27;0.0 1.0  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-11
  start_time = 0.0
  dt = 0.005
  end_time = 0.5
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
  [./inertial_force_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 0
    variable = disp_x
  [../]
  [./inertial_force_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 1
    variable = disp_y
  [../]
  [./inertial_force_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 2
    variable = disp_z
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 3
    variable = rot_x
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 4
    variable = rot_y
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 1.0
    Iy = 1.0
    Iz = 1.0
    Ay = 0.0
    Az = 0.0
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 2e4
    poissons_ratio = 0.0
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 1.0
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="551897e5-0590-40aa-be35-07014a9a49d1"><div class="modal-content"><h4>modules/richards/test/tests/theis/th_lumped_22.i</h4><pre class="moose-pre"><code class="language-text"># two-phase, fully-saturated
# production
# lumped
[Mesh]
  type = FileMesh
  file = th02_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 2 4 20&#x27;
    x = &#x27;0 1 10 100&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-5
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]

  [./total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]


[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_pressure
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsPolyLineSink
    pressures = &#x27;-1E9 1E9&#x27;
    fluxes = &#x27;200 200&#x27;
    point_file = th01.points
    SumQuantityUO = total_outflow_mass
    variable = pwater
  [../]
[]


[Postprocessors]
  [./flow_report]
    type = RichardsPlotQuantity
    uo = total_outflow_mass
  [../]
  [./p50]
    type = PointValue
    variable = pwater
    point = &#x27;50 0 0&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E5
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    viscosity = &#x27;1E-3 1E-5&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               2E-7 1E-10 20 1E-10 1E-100&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 100
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = th_lumped_22
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="25f6e0c4-5202-4902-b57f-69b98bb65f25"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test2qtt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test2qtt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.06
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test2qtt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="46ef241a-9f0a-4526-8fdb-267b6fd97b60"><div class="modal-content"><h4>modules/richards/test/tests/recharge_discharge/rd02.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 120
  ny = 1
  xmin = 0
  xmax = 6
  ymin = 0
  ymax = 0.05
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1 10 500 5000 50000&#x27;
    x = &#x27;0 10 100 1000 10000 500000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1E3
    bulk_mod = 2E7
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.336
    al = 1.43E-4
  [../]
  [./RelPermPower]
    type = RichardsRelPermVG1
    scut = 0.99
    simm = 0.0
    m = 0.336
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E+0
  [../]
[]



[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]


[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]




[BCs]
  active = &#x27;fix_bot&#x27;
  [./fix_bot]
    type = DirichletBC
    variable = pressure
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.33
    mat_permeability = &#x27;0.295E-12 0 0  0 0.295E-12 0  0 0 0.295E-12&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    SUPG_UO = SUPGstandard
    sat_UO = Saturation
    seff_UO = SeffVG
    viscosity = 1.01E-3
    gravity = &#x27;-10 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;

    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-13 1E-15 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 345600

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = rd02
  interval = 100000
  execute_on = &#x27;initial final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fa58b152-e37a-4e2d-81b8-59b335021eb1"><div class="modal-content"><h4>modules/porous_flow/test/tests/infiltration_and_drainage/rsc01.i</h4><pre class="moose-pre"><code class="language-text"># RSC test with high-res time and spatial resolution
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 600
  ny = 1
  xmin = 0
  xmax = 10 # x is the depth variable, called zeta in RSC
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  PorousFlowDictator = dictator
  gravity = &#x27;0 0 0&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;3E-3 3E-2 0.05&#x27;
    x = &#x27;0 1 5&#x27;
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;pwater poil&#x27;
    number_fluid_phases = 2
    number_fluid_components = 2
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
[]

[Modules]
  [./FluidProperties]
    [./water]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      density0 = 10
      thermal_expansion = 0
      viscosity = 1e-3
    [../]
    [./oil]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      density0 = 20
      thermal_expansion = 0
      viscosity = 2e-3
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow2PhasePP
    phase0_porepressure = pwater
    phase1_porepressure = poil
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
    mass_fraction_vars = &#x27;massfrac_ph0_sp0 massfrac_ph1_sp0&#x27;
  [../]
  [./water]
    type = PorousFlowSingleComponentFluid
    fp = water
    phase = 0
    compute_enthalpy = false
    compute_internal_energy = false
  [../]
  [./oil]
    type = PorousFlowSingleComponentFluid
    fp = oil
    phase = 1
    compute_enthalpy = false
    compute_internal_energy = false
  [../]
  [./relperm_water]
    type = PorousFlowRelativePermeabilityCorey
    n = 1
    phase = 0
  [../]
  [./relperm_oil]
    type = PorousFlowRelativePermeabilityCorey
    n = 1
    phase = 1
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.25
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
  [../]
[]

[Variables]
  [./pwater]
  [../]
  [./poil]
  [../]
[]

[ICs]
  [./water_init]
    type = ConstantIC
    variable = pwater
    value = 0
  [../]
  [./oil_init]
    type = ConstantIC
    variable = poil
    value = 15
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pwater
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pwater
  [../]
  [./mass1]
    type = PorousFlowMassTimeDerivative
    fluid_component = 1
    variable = poil
  [../]
  [./flux1]
    type = PorousFlowAdvectiveFlux
    fluid_component = 1
    variable = poil
  [../]
[]

[AuxVariables]
  [./SWater]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./SOil]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./massfrac_ph0_sp0]
    initial_condition = 1
  [../]
  [./massfrac_ph1_sp0]
    initial_condition = 0
  [../]
[]

[AuxKernels]
  [./SWater]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 0
    variable = SWater
  [../]
  [./SOil]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 1
    variable = SOil
  [../]
[]

[BCs]
# we are pumping water into a system that has virtually incompressible fluids, hence the pressures rise enormously.  this adversely affects convergence because of almost-overflows and precision-loss problems.  The fixed things help keep pressures low and so prevent these awful behaviours.   the movement of the saturation front is the same regardless of the fixed things.
  active = &#x27;recharge fixedoil fixedwater&#x27;
  [./recharge]
    type = PorousFlowSink
    variable = pwater
    boundary = &#x27;left&#x27;
    flux_function = -1.0
  [../]
  [./fixedwater]
    type = DirichletBC
    variable = pwater
    boundary = &#x27;right&#x27;
    value = 0
  [../]
  [./fixedoil]
    type = DirichletBC
    variable = poil
    boundary = &#x27;right&#x27;
    value = 15
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10      1E-10      10000&#x27;
  [../]
[]

[VectorPostprocessors]
  [./swater]
    type = LineValueSampler
    variable = SWater
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;7 0 0&#x27;
    sort_by = x
    num_points = 21
    execute_on = timestep_end
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 5
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = rsc01
  [./along_line]
    type = CSV
    execute_vector_postprocessors_on = final
  [../]
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial final&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e3730d70-e614-4c9f-b11e-56a2864596a3"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/mandel_fully_saturated.i</h4><pre class="moose-pre"><code class="language-text"># Mandel&#x27;s problem of consolodation of a drained medium
# Using the FullySaturatedDarcyBase and FullySaturatedMassTimeDerivative kernels
# Note the use of consistent_with_displaced_mesh = false in the calculation of volumetric strain
#
# A sample is in plane strain.
# -a &lt;= x &lt;= a
# -b &lt;= y &lt;= b
# It is squashed with constant force by impermeable, frictionless plattens on its top and bottom surfaces (at y=+/-b)
# Fluid is allowed to leak out from its sides (at x=+/-a)
# The porepressure within the sample is monitored.
#
# As is common in the literature, this is simulated by
# considering the quarter-sample, 0&lt;=x&lt;=a and 0&lt;=y&lt;=b, with
# impermeable, roller BCs at x=0 and y=0 and y=b.
# Porepressure is fixed at zero on x=a.
# Porepressure and displacement are initialised to zero.
# Then the top (y=b) is moved downwards with prescribed velocity,
# so that the total force that is inducing this downwards velocity
# is fixed.  The velocity is worked out by solving Mandel&#x27;s problem
# analytically, and the total force is monitored in the simulation
# to check that it indeed remains constant.
#
# Here are the problem&#x27;s parameters, and their values:
# Soil width.  a = 1
# Soil height.  b = 0.1
# Soil&#x27;s Lame lambda.  la = 0.5
# Soil&#x27;s Lame mu, which is also the Soil&#x27;s shear modulus.  mu = G = 0.75
# Soil bulk modulus.  K = la + 2*mu/3 = 1
# Drained Poisson ratio.  nu = (3K - 2G)/(6K + 2G) = 0.2
# Soil bulk compliance.  1/K = 1
# Fluid bulk modulus.  Kf = 8
# Fluid bulk compliance.  1/Kf = 0.125
# Soil initial porosity.  phi0 = 0.1
# Biot coefficient.  alpha = 0.6
# Biot modulus.  M = 1/(phi0/Kf + (alpha - phi0)(1 - alpha)/K) = 4.705882
# Undrained bulk modulus. Ku = K + alpha^2*M = 2.694118
# Undrained Poisson ratio.  nuu = (3Ku - 2G)/(6Ku + 2G) = 0.372627
# Skempton coefficient.  B = alpha*M/Ku = 1.048035
# Fluid mobility (soil permeability/fluid viscosity).  k = 1.5
# Consolidation coefficient.  c = 2*k*B^2*G*(1-nu)*(1+nuu)^2/9/(1-nuu)/(nuu-nu) = 3.821656
# Normal stress on top.  F = 1
#
# The solution for porepressure and displacements is given in
# AHD Cheng and E Detournay &quot;A direct boundary element method for plane strain poroelasticity&quot; International Journal of Numerical and Analytical Methods in Geomechanics 12 (1988) 551-572.
# The solution involves complicated infinite series, so I shall not write it here

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
  ny = 1
  nz = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 0.1
  zmin = 0
  zmax = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./roller_xmin]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left&#x27;
  [../]
  [./roller_ymin]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  [../]
  [./plane_strain]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
  [./xmax_drained]
    type = DirichletBC
    variable = porepressure
    value = 0
    boundary = right
  [../]
  [./top_velocity]
    type = FunctionDirichletBC
    variable = disp_y
    function = top_velocity
    boundary = top
  [../]
[]

[Functions]
  [./top_velocity]
    type = PiecewiseLinear
    x = &#x27;0 0.002 0.006   0.014   0.03    0.046   0.062   0.078   0.094   0.11    0.126   0.142   0.158   0.174   0.19 0.206 0.222 0.238 0.254 0.27 0.286 0.302 0.318 0.334 0.35 0.366 0.382 0.398 0.414 0.43 0.446 0.462 0.478 0.494 0.51 0.526 0.542 0.558 0.574 0.59 0.606 0.622 0.638 0.654 0.67 0.686 0.702&#x27;
    y = &#x27;-0.041824842    -0.042730269    -0.043412712    -0.04428867     -0.045509181    -0.04645965     -0.047268246 -0.047974749      -0.048597109     -0.0491467  -0.049632388     -0.050061697      -0.050441198     -0.050776675     -0.051073238      -0.0513354 -0.051567152      -0.051772022     -0.051953128 -0.052113227 -0.052254754 -0.052379865 -0.052490464 -0.052588233 -0.052674662 -0.052751065 -0.052818606 -0.052878312 -0.052931093 -0.052977751 -0.053018997 -0.053055459 -0.053087691 -0.053116185 -0.053141373 -0.05316364 -0.053183324 -0.053200724 -0.053216106 -0.053229704 -0.053241725 -0.053252351 -0.053261745 -0.053270049 -0.053277389 -0.053283879 -0.053289615&#x27;
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_force]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./tot_force]
    type = ParsedAux
    args = &#x27;stress_yy porepressure&#x27;
    execute_on = timestep_end
    variable = tot_force
    function = &#x27;-stress_yy+0.6*porepressure&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    component = 2
    variable = disp_z
  [../]
  [./mass0]
    type = PorousFlowFullySaturatedMassTimeDerivative
    biot_coefficient = 0.6
    coupling_type = HydroMechanical
    variable = porepressure
  [../]
  [./flux]
    type = PorousFlowFullySaturatedDarcyBase
    variable = porepressure
    gravity = &#x27;0 0 0&#x27;
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 8
      density0 = 1
      thermal_expansion = 0
      viscosity = 1
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0.5 0.75&#x27;
    # bulk modulus is lambda + 2*mu/3 = 0.5 + 2*0.75/3 = 1
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure_qp]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
    consistent_with_displaced_mesh = false
  [../]
  [./ppss]
    type = PorousFlow1PhaseFullySaturated
    porepressure = porepressure
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid_qp]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # only the initial value of this is ever used
    porosity = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    biot_coefficient = 0.6
    solid_bulk_compliance = 1
    fluid_bulk_modulus = 8
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1.5 0 0   0 1.5 0   0 0 1.5&#x27;
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0.0 0 0&#x27;
    variable = porepressure
  [../]
  [./p1]
    type = PointValue
    outputs = csv
    point = &#x27;0.1 0 0&#x27;
    variable = porepressure
  [../]
  [./p2]
    type = PointValue
    outputs = csv
    point = &#x27;0.2 0 0&#x27;
    variable = porepressure
  [../]
  [./p3]
    type = PointValue
    outputs = csv
    point = &#x27;0.3 0 0&#x27;
    variable = porepressure
  [../]
  [./p4]
    type = PointValue
    outputs = csv
    point = &#x27;0.4 0 0&#x27;
    variable = porepressure
  [../]
  [./p5]
    type = PointValue
    outputs = csv
    point = &#x27;0.5 0 0&#x27;
    variable = porepressure
  [../]
  [./p6]
    type = PointValue
    outputs = csv
    point = &#x27;0.6 0 0&#x27;
    variable = porepressure
  [../]
  [./p7]
    type = PointValue
    outputs = csv
    point = &#x27;0.7 0 0&#x27;
    variable = porepressure
  [../]
  [./p8]
    type = PointValue
    outputs = csv
    point = &#x27;0.8 0 0&#x27;
    variable = porepressure
  [../]
  [./p9]
    type = PointValue
    outputs = csv
    point = &#x27;0.9 0 0&#x27;
    variable = porepressure
  [../]
  [./p99]
    type = PointValue
    outputs = csv
    point = &#x27;1 0 0&#x27;
    variable = porepressure
  [../]
  [./xdisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_x
  [../]
  [./ydisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_y
  [../]
  [./total_downwards_force]
     type = ElementAverageValue
     outputs = csv
     variable = tot_force
  [../]
  [./dt]
    type = FunctionValuePostprocessor
    outputs = console
    function = if(0.15*t&lt;0.01,0.15*t,0.01)
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres asm lu 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 0.7
  [./TimeStepper]
    type = PostprocessorDT
    postprocessor = dt
    dt = 0.001
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = mandel_fully_saturated
  [./csv]
    interval = 3
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1dc8f002-3f4e-48f1-b832-8a1840752d48"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test2.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test2.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test2_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4b34ab4c-0f3d-4c35-ade0-51471789dbbf"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh_fu_08.i</h4><pre class="moose-pre"><code class="language-text">#fullyupwind
[Mesh]
  type = FileMesh
  file = bh07_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  sat_UO = Saturation
  seff_UO = Seff1VG
  SUPG_UO = SUPGstandard
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1000 10000&#x27;
    x = &#x27;100 1000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E8
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[BCs]
  [./fix_outer]
    type = DirichletBC
    boundary = perimeter
    variable = pressure
    value = 1E7
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFullyUpwindFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = 0
    point_file = bh08.bh
    borehole_length = 1
    borehole_direction = &#x27;0 0 1&#x27;
    SumQuantityUO = borehole_total_outflow_mass
    variable = pressure
    unit_weight = &#x27;0 0 0&#x27;
    re_constant = 0.1594
    character = 2
    fully_upwind = true
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./fluid_mass]
    type = RichardsMass
    variable = pressure
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E7
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-11 0 0  0 1E-11 0  0 0 1E-11&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 1000
  solve_type = NEWTON

  [./TimeStepper]
    # get only marginally better results for smaller time steps
    type = FunctionDT
    function = dts
  [../]

[]

[Outputs]
  file_base = bh_fu_08
  execute_on = &#x27;initial timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cc71cb65-64f7-422b-89c8-199c776637d0"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/diffusion_2d_quad8.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 3
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD8
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.35 1.0 0.35 0.2&#x27;
    time_start_cut = 0.0
    time_end_cut = 2.0
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = 3
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="51b59bb1-ba62-45ca-a43b-a171e7e8d727"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test4qtt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4qtt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_abs_tol = 1e-7
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test4qtt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5ba28bf2-e4a5-4da8-9cf2-2cee58340698"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/2D/2d_nodalmass_implicit.i</h4><pre class="moose-pre"><code class="language-text"># One element test to test the central difference time integrator.

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = 0
    ymax = 2
    nx = 1
    ny = 2
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;1 2 0&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
  [./accel_y]
  [../]
  [./vel_y]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
[]

[BCs]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./x_bot]
    type = PresetDisplacement
    boundary = bottom
    variable = disp_x
    beta = 0.25
    velocity = vel_x
    acceleration = accel_x
    function = disp
  [../]
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
[]

[NodalKernels]
  [./nodal_mass_x]
    type = NodalTranslationalInertia
    variable = &#x27;disp_x&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    boundary = &#x27;all&#x27;
  [../]
  [./nodal_mass_y]
    type = NodalTranslationalInertia
    variable = &#x27;disp_y&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    boundary = &#x27;all&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_abs_tol = 1e-11
  nl_rel_tol = 1e-11
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./accel_2x]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="46bcb29a-0cd5-4865-b599-be0ced9ef00e"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/plane_stress/weak_plane_stress_finite.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
  out_of_plane_strain = strain_zz
[]

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./strain_zz]
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./nl_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./react_z]
    type = MaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
  [./min_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = min
  [../]
  [./max_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = max
  [../]
[]

[Modules/TensorMechanics/Master]
  [plane_stress]
    planar_formulation = WEAK_PLANE_STRESS
    strain = FINITE
    generate_output = &#x27;stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy&#x27;
    eigenstrain_names = eigenstrain
  []
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    use_displaced_mesh = false
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = nl_strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0     1   100&#x27;
    y=&#x27;0  0.00  0.00&#x27;
  [../]
  [./tempfunc]
    type = ParsedFunction
    value = &#x27;(1 - x) * t&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 0.02
    stress_free_temperature = 0.5
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  line_search = none

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-06

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="07641752-c40b-4598-a885-6bccd5e442db"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh_fu_05.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated
# injection
# fullyupwind
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  sat_UO = Saturation
  seff_UO = Seff1VG
  SUPG_UO = SUPGstandard
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;500 500 1E1&#x27;
    x = &#x27;4000 5000 6500&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E8
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = 0
    point_file = bh03.bh
    SumQuantityUO = borehole_total_outflow_mass
    variable = pressure
    unit_weight = &#x27;0 0 0&#x27;
    character = -1
    fully_upwind = true
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
  [../]

  [./fluid_mass0]
    type = RichardsMass
    variable = pressure
    execute_on = timestep_begin
  [../]

  [./fluid_mass1]
    type = RichardsMass
    variable = pressure
    execute_on = timestep_end
  [../]

  [./zmass_error]
    type = FunctionValuePostprocessor
    function = mass_bal_fcn
    execute_on = timestep_end
  [../]

  [./p0]
    type = PointValue
    variable = pressure
    point = &#x27;1 1 1&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = -2E5
  [../]

  [./mass_bal_fcn]
    type = ParsedFunction
    value = abs((a-c+d)/2/(a+c))
    vars = &#x27;a c d&#x27;
    vals = &#x27;fluid_mass1 fluid_mass0 bh_report&#x27;
  [../]

[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 0
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-12 0 0  0 1E-12 0  0 0 1E-12&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 6500
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  file_base = bh_fu_05
  exodus = false
  csv = true
  execute_on = timestep_end
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8966fb70-3051-4ad6-8e38-526876a72a63"><div class="modal-content"><h4>modules/xfem/test/tests/init_solution_propagation/init_solution_propagation.i</h4><pre class="moose-pre"><code class="language-text"># The purpose of this test is to verify that the procedures for initializing
# the solution on nodes/elements affected by XFEM works correctly in both
# serial and parallel.

# The crack cuts near to domain boundaries in parallel, and the displacement
# solution will be wrong in parallel if this is not done correctly.  This
# test also has multiple aux variables of various types that are only computed
# on initialization, and which will be wrong if the XFEM initializtion
# is not done correctly.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 7
  ny = 7
  xmin = 0.0
  xmax = 25.0
  ymin = -12.5
  ymax = 12.5
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_set_uo]
    type = LineSegmentCutSetUserObject
    cut_data =&#x27;0.0000e+000  0.0000e+000  5.5000e+000  0.0000e+000  0.0   0.0
               5.5000e+000  0.0000e+000  2.5500e+001  0.0000e+000  0.05  1.05&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./const_monomial]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./first_monomial]
    order = FIRST
    family = MONOMIAL
  [../]
  [./first_linear]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./const_monomial]
    type = FunctionAux
    function = &#x27;dummy&#x27;
    variable = const_monomial
    execute_on = &#x27;initial&#x27;
  [../]
  [./first_monomial]
    type = FunctionAux
    function = &#x27;dummy&#x27;
    variable = first_monomial
    execute_on = &#x27;initial&#x27;
  [../]
  [./first_linear]
    type = FunctionAux
    function = &#x27;dummy&#x27;
    variable = first_linear
    execute_on = &#x27;initial&#x27;
  [../]
[]

[Functions]
  [./dummy]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]
  [./disp_top_y]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.1&#x27;
  [../]
[]

[BCs]
  [./top_y]
    type = FunctionDirichletBC
    boundary = 2
    variable = disp_y
    function = disp_top_y
  [../]

  [./bottom_y]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]

  [./right_x]
    type = DirichletBC
    boundary = 1
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;

  l_max_its = 100
  nl_max_its = 25
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-8

  start_time = 0.0
  dt = 0.1
  end_time = 1.0
  max_xfem_update = 1
[]


[Outputs]
  exodus = true
  csv = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ab8c20f2-6c94-4b1c-b85e-8f2e322f4fbc"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/sphere3D.i</h4><pre class="moose-pre"><code class="language-text">#
# 3D Spherical Gap Heat Transfer Test.
#
# This test exercises 3D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid sphere of radius = 1 unit, and outer
# hollow sphere with an inner radius of 2. In other words, the gap between
# them is 1 radial unit in length.
#
# The conductivity of both spheres is set very large to achieve a uniform
# temperature in each sphere. The temperature of the center node of the
# inner sphere is ramped from 100 to 200 over one time unit. The
# temperature of the outside of the outer, hollow sphere is held fixed
# at 100.
#
# A simple analytical solution is possible for the integrated heat flux
# between the inner and outer spheres:
#
#  Integrated Flux = (T_left - T_right) * (gapK/(r^2*((1/r1)-(1/r2)))) * Area
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 4 * pi * 1^2 (4*pi*r^2)
#
# The integrated heat flux across the gap at time 1 is then:
#
# 4*pi*k*delta_T/((1/r1)-(1/r2))
# 4*pi*1*100/((1/1) - (1/2)) =  2513.3 watts
#
# For comparison, see results from the integrated flux post processors.
# This simulation makes use of symmetry, so only 1/8 of the spheres is meshed
# As such, the integrated flux from the post processors is 1/8 of the total,
# or 314.159 watts... i.e. 100*pi.
# The value coming from the post processor is slightly less than this
# but converges as mesh refinement increases.
#
# Simulating contact is challenging. Regression tests that exercise
# contact features can be difficult to solve consistently across multiple
# platforms. While designing these tests, we felt it worth while to note
# some aspects of these tests. The following applies to:
# sphere3D.i, sphere2DRZ.i, cyl2D.i, and cyl3D.i.
# 1. We decided that to perform consistently across multiple platforms we
# would use very small convergence tolerance. In this test we chose an
# nl_rel_tol of 1e-12.
# 2. Due to such a high value for thermal conductivity (used here so that the
# domains come to a uniform temperature) the integrated flux at time = 0
# was relatively large (the value coming from SideIntegralFlux =
#  -_diffusion_coef[_qp]*_grad_u[_qp]*_normals[_qp] where the diffusion coefficient
# here is thermal conductivity).
# Even though _grad_u[_qp] is small, in this case the diffusion coefficient
# is large. The result is a number that isn&#x27;t exactly zero and tends to
# fail exodiff. For this reason the parameter execute_on = initial should not
# be used. That parameter is left to default settings in these regression tests.
#
[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = sphere3D.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]

[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]


[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = SPHERE
    sphere_origin = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 5
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
  [./Console]
    type = Console
  [../]
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7d64c7c9-0fe3-4f97-b24c-dbaeaf13de90"><div class="modal-content"><h4>modules/richards/test/tests/buckley_leverett/bl22.i</h4><pre class="moose-pre"><code class="language-text"># two-phase version
# super-sharp front version
[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 150
  xmin = 0
  xmax = 15
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-4 1E-3 1E-2 2E-2 5E-2 6E-2 0.1 0.2&#x27;
    x =  &#x27;0    1E-2 1E-1 1    5    20   40  41&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E6
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-4
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-4
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
  [./bounds_dummy]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
  [./richardsppenalty]
    type = RichardsPPenalty
    variable = pgas
    a = 1E-18
    lower_var = pwater
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_water
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_gas
  [../]
[]

[BCs]
  [./left_w]
    type = DirichletBC
    variable = pwater
    boundary = left
    value = 1E6
  [../]
  [./left_g]
    type = DirichletBC
    variable = pgas
    boundary = left
    value = 1E6
  [../]
  [./right_w]
    type = DirichletBC
    variable = pwater
    boundary = right
    value = -100000
  [../]
  [./right_g]
    type = DirichletBC
    variable = pgas
    boundary = right
    value = 0
  [../]
[]


[Functions]
  [./initial_water]
    type = ParsedFunction
    value = 1000000*(1-min(x/5,1))-100000*(max(x-5,0)/max(abs(x-5),1E-10))
  [../]
  [./initial_gas]
    type = ParsedFunction
    value = max(1000000*(1-x/5),0)+1000
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.15
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 1E-6&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]

  [./standard]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 20 1E-20 1E-20&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  end_time = 50

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = bl22
  print_linear_converged_reason = false
  print_nonlinear_converged_reason = false
  [./exodus]
    type = Exodus
    interval = 100000
    hide = pgas
    execute_on = &#x27;initial final timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bca4fa82-64a4-426d-ad83-28eb06165f64"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/time_integration/newmark_test.i</h4><pre class="moose-pre"><code class="language-text"># Test for  Newmark time integration

# The test is for an 1D bar element of  unit length fixed on one end
# with a ramped pressure boundary condition applied to the other end.
# beta and gamma are Newmark time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel + K*disp = P*Area
#
# Here M is the mass matrix, K is the stiffness matrix, P is the applied pressure
#
# This equation is equivalent to:
#
# density*accel + Div Stress = P
#
# The first term on the left is evaluated using the Inertial force kernel
# The last term on the left is evaluated using StressDivergenceTensors
# The residual due to Pressure is evaluated using Pressure boundary condition

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.25
    gamma = 0.5
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.25
    gamma = 0.5
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    gamma = 0.5
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = bottom
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
      disp_z = disp_z
      factor = 1
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 2
  dt = 0.1
[]


[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 1.0 2.0 5.0&#x27;
    y = &#x27;0.0 0.1 0.2 1.0 1.0 1.0&#x27;
    scale_factor = 1e9
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalMaxValue
    variable = disp_y
    boundary = bottom
  [../]
  [./vel]
    type = NodalMaxValue
    variable = vel_y
    boundary = bottom
  [../]
  [./accel]
    type = NodalMaxValue
    variable = accel_y
    boundary = bottom
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./strain_yy]
    type = ElementAverageValue
    variable = strain_yy
  [../]

[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5f91786d-ce4b-4a9d-bff2-e4cccab26fd0"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_exponential_deprecated.i</h4><pre class="moose-pre"><code class="language-text">#
# Test to exercise the exponential stress release
#
# Stress vs. strain should show a linear relationship until cracking,
#   an exponential stress release, a linear relationship back to zero
#   strain, a linear relationship with the original stiffness in
#   compression and then back to zero strain, a linear relationship
#   back to the exponential curve, and finally further exponential
#   stress release.
#

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displx]
    type = PiecewiseLinear
    x = &#x27;0 1       2  3      4 5       6&#x27;
    y = &#x27;0 0.00175 0 -0.0001 0 0.00175 0.0035&#x27;
  [../]
  [./disply]
    type = PiecewiseLinear
    x = &#x27;0 5 6&#x27;
    y = &#x27;0 0 .00175&#x27;
  [../]
  [./displz]
    type = PiecewiseLinear
    x = &#x27;0 2 3&#x27;
    y = &#x27;0 0 .0035&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pullx]
    type = ADFunctionDirichletBC
    #type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displx
  [../]
  [./left]
    type = ADDirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]

  [./fix_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]

  [./move_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    function = disply
  [../]

  [./back]
    type = ADDirichletBC
    variable = disp_z
    boundary = &#x27;3&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 186.5e9
    poissons_ratio = .316
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 119.3e6
    cracking_release = exponential
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type&#x27;
  petsc_options_value = &#x27;101                lu&#x27;

  line_search = &#x27;none&#x27;
  l_max_its = 100
  l_tol = 1e-6

  nl_max_its = 10
  nl_rel_tol = 1e-12
  nl_abs_tol = 1.e-4

  start_time = 0.0
  dt = 0.02
  dtmin = 0.02
  num_steps = 300
[]

[Outputs]
  exodus = true
  file_base = cracking_exponential_out
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="36d272b7-1c6f-44f1-9cfe-6644fba4ec8c"><div class="modal-content"><h4>framework/contrib/hit/test/input.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function has a constant value,
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# The two models produce very similar results.  There are slight
# differences due to the large deformation treatment.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[SolidMechanics]
  [./solid]
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 3
    function = 0.02*t
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 1
    function = 0.01*t
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./mean_alpha]
    type = Elastic
    block = 1
    youngs_modulus = 1e6
    poissons_ratio = .3
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
    temp = temp
    thermal_expansion_function = cte_func_mean
    stress_free_temperature = 0.0
    thermal_expansion_reference_temperature = 0.5
    thermal_expansion_function_type = mean
  [../]

  [./inst_alpha]
    type = Elastic
    block = 2
    youngs_modulus = 1e6
    poissons_ratio = .3
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
    temp = temp
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    thermal_expansion_function_type = instantaneous
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (t - tsf) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 1.0
               2 1.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  file_base = const_alpha_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ce42d44e-2287-436e-827c-4ac7507ae430"><div class="modal-content"><h4>test/tests/time_steppers/iteration_adaptive/hit_function_knot.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 50
  ny = 2
  xmax = 5
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./knot]
    type = PiecewiseLinear
    x = &#x27;0 1 2&#x27;
    y = &#x27;0 0 0&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./dt]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 10
  [../]
  [./right]
    type = NeumannBC
    variable = u
    boundary = right
    value = -1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  start_time = 0.0
  end_time = 2.0
  timestep_tolerance = 0.3
  verbose = true
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.9
    optimal_iterations = 10
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a12e0a60-e782-4936-8220-c03a61db1ae4"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test9.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8fffbe2a-8f3f-4825-adce-257bb2b8f5d3"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test1qtt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test1qtt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="03796172-c3a1-4ee5-89e4-0c181d41ea14"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/domain_integral_thermal/j_integral_2d_ctefunc.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./tempfunc]
    type = ParsedFunction
    value = 10.0*(2*x/504)
  [../]
  [./cte_func]
    type = PiecewiseLinear
    x = &#x27;-10 -6 -2 0 2 6 10&#x27;
    y = &#x27;1.484e-5 1.489e-5 1.494e-5 1.496e-5 1.498e-5 1.502e-5 1.505e-5&#x27;
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;60.0 80.0 100.0 120.0&#x27;
  radius_outer = &#x27;80.0 100.0 120.0 140.0&#x27;
  temperature = temp
  incremental = true
  eigenstrain_names = thermal_expansion
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
    eigenstrain_names = thermal_expansion
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    block = 1
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 400
    value = 0.0
  [../]

  [./no_x1]
    type = DirichletBC
    variable = disp_x
    boundary = 900
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = thermal_expansion
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm         31   preonly   lu      1&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 40

  nl_rel_step_tol= 1e-10
  nl_rel_tol = 1e-10

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  csv = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    pc_side = left
    ksp_norm = preconditioned
    full = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="10a5e9f4-46e9-4393-b136-7064147822df"><div class="modal-content"><h4>modules/xfem/test/tests/diffusion_xfem/levelsetcut3d.i</h4><pre class="moose-pre"><code class="language-text"># 3D: Mesh is cut by level set based cutter
# The level set is a MOOSE auxvariable

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 5
  ny = 5
  nz = 5
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 1.0
  elem_type = HEX8
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;sqrt(x*x + y*y + z*z) - 0.5&#x27;
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = DirichletBC
    variable = u
    boundary = left
    value = 2
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="69ad1d82-945a-4533-9e88-960aed61b814"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test3ns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3ns_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2124c247-78f7-4103-b34d-f42d2b3ce4c8"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test2q.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test2q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test2q_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0ce5c9bf-2fde-4297-8a24-f1b3be025071"><div class="modal-content"><h4>modules/contact/test/tests/normalized_penalty/normalized_penalty.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = normalized_penalty.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Functions]
  [./left_x]
    type = PiecewiseLinear
    x = &#x27;0 1 2&#x27;
    y = &#x27;0 0.02 0&#x27;
  [../]
[]

[AuxVariables]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = FINITE
    generate_output = &#x27;stress_xx&#x27;
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  []
[]

[Contact]
  [./m3_s2]
    primary = 3
    secondary = 2
    penalty = 1e10
    normalize_penalty = true
    formulation = penalty
    tangential_tolerance = 1e-3
  [../]
[]

[BCs]
  [./left_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 1
    function = left_x
  [../]

  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2 3 4&#x27;
    value = 0.0
  [../]

  [./right]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    value = 0
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2 3 4 1000&#x27;
    youngs_modulus = 3e8
    poissons_ratio = 0.0
  [../]
  [./stiffStuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2 3 4 1000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       101&#x27;

  line_search = &#x27;none&#x27;

  nl_rel_tol = 1e-12
  nl_abs_tol = 5e-8

  l_max_its = 100
  nl_max_its = 10
  dt = 0.5
  num_steps = 4
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1a52a2dd-4f2d-46b3-968a-c34b284a8e0d"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh_fu_05.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = false
# supg = false
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGnone
  [../]
  [./SUPGgas]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = RandomIC
    min = 0.2
    max = 0.8
    variable = pwater
  [../]
  [./gas_ic]
    type = RandomIC
    min = 1.2
    max = 1.8
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFullyUpwindFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((p0-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((p0-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh_fu_05
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="866ba055-eee6-442c-b4d4-59f02ae74fe0"><div class="modal-content"><h4>modules/combined/test/tests/adaptive_timestepping/adapt_tstep_function_change_restart1.i</h4><pre class="moose-pre"><code class="language-text"># This is a test designed to evaluate the cabability of the
# IterationAdaptiveDT TimeStepper to adjust time step size according to
# a function.  For example, if the power input function for a BISON
# simulation rapidly increases or decreases, the IterationAdaptiveDT
# TimeStepper should take time steps small enough to capture the
# oscillation.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  block = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 1hex8_10mm_cube.e
[]

[Functions]
  [./Fiss_Function]
    type = PiecewiseLinear
    x = &#x27;0 1e6  2e6  2.001e6 2.002e6&#x27;
    y = &#x27;0 3e8  3e8  12e8    0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]

  [./disp_y]
  [../]

  [./disp_z]
  [../]

  [./temp]
    initial_condition = 300.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    volumetric_locking_correction = true
    eigenstrain_names = thermal_expansion
    decomposition_method = EigenSolution
    add_variables  = true
    generate_output = &#x27;vonmises_stress&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]

  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]

  [./heat_source]
     type = HeatSource
     variable = temp
     value = 1.0
     function = Fiss_Function
  [../]
[]

[BCs]
 [./bottom_temp]
   type = DirichletBC
   variable = temp
   boundary = 1
   value = 300
 [../]
 [./top_bottom_disp_x]
   type = DirichletBC
   variable = disp_x
   boundary = &#x27;1&#x27;
   value = 0
 [../]
 [./top_bottom_disp_y]
   type = DirichletBC
   variable = disp_y
   boundary = &#x27;1&#x27;
   value = 0
 [../]
 [./top_bottom_disp_z]
   type = DirichletBC
   variable = disp_z
   boundary = &#x27;1&#x27;
   value = 0
 [../]
[]

[Materials]
 [./thermal]
    type = HeatConductionMaterial
    temp = temp
    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 300e6
    poissons_ratio = .3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 5e-6
    stress_free_temperature = 300.0
    temperature = temp
    eigenstrain_name = thermal_expansion
  [../]

  [./density]
    type = Density
    density = 10963.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  verbose = true
  nl_abs_tol = 1e-10
  start_time = 0.0

  num_steps = 65
  end_time = 2.002e6
  [./TimeStepper]
    type = IterationAdaptiveDT
    timestep_limiting_function = Fiss_Function
    max_function_change = 3e7
    dt = 1e6
  [../]
[]

[Postprocessors]
  [./Temperature_of_Block]
    type = ElementAverageValue
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./vonMises]
    type = ElementAverageValue
    variable = vonmises_stress
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 10
  [../]
  [./checkpoint]
    type = Checkpoint
    num_files = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c0316427-6854-4000-ac85-824bd79b1bfd"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/combined_creep_plasticity/combined_stress_prescribed.i</h4><pre class="moose-pre"><code class="language-text">#
# 1x1x1 unit cube with time-varying pressure on top face
#
# The problem is a one-dimensional creep analysis.  The top face has a
#    pressure load that is a function of time.  The creep strain can be
#    calculated analytically.  There is no practical active linear
#    isotropic plasticity because the yield stress for the plasticity
#    model is set to 1e30 MPa, which will not be reached in this
#    regression test.
#
# The analytic solution to this problem is:
#
#    d ec
#    ---- = a*S^b  with S = c*t^d
#     dt
#
#    d ec = a*c^b*t^(b*d) dt
#
#         a*c^b
#    ec = ----- t^(b*d+1)
#         b*d+1
#
#    where S  = stress
#          ec = creep strain
#          t  = time
#          a  = constant
#          b  = constant
#          c  = constant
#          d  = constant
#
# With a = 3e-24,
#      b = 4,
#      c = 1,
#      d = 1/2, and
#      t = 32400
#   we have
#
#   S = t^(1/2) = 180
#
#   ec = 1e-24*t^3 = 3.4012224e-11
#
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_yy&#x27;
  [../]
[]

[Functions]
  [./pressure]
    type = ParsedFunction
    value = &#x27;sqrt(t)&#x27;
  [../]

  [./dts]
    type = PiecewiseLinear
    y = &#x27;1e-2 1e-1 1e0 1e1 1e2&#x27;
    x = &#x27;0    7e-1 7e0 7e1 1e2&#x27;
  [../]
[]

[BCs]
  [./top_pressure]
    type = Pressure
    variable = disp_y
    component = 1
    boundary = top
    function = pressure
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0.3
  [../]
  [./creep_plas]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;creep plas&#x27;
    tangent_operator = elastic
  [../]
  [./creep]
    type = PowerLawCreepStressUpdate
    coefficient = 3.0e-24
    n_exponent = 4
    m_exponent = 0
    activation_energy = 0
  [../]
  [./plas]
    type = IsotropicPlasticityStressUpdate
    hardening_constant = 1
    yield_stress = 1e30
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27; lu       superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-7
  l_tol = 1e-6
  start_time = 0.0
  end_time = 32400
  dt = 1e-2
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Postprocessors]
  [./timestep]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8614ce41-1b17-4ff8-bed9-d3558a8a7a70"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_3d_as_2d.i</h4><pre class="moose-pre"><code class="language-text">#This tests the Interaction-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with one element
#through the thickness, and calculates the Interaction-Integrals using options
#to treat it as 2d.

[GlobalParams]
  order = FIRST
#  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack_3d_as_2d.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = &#x27;InteractionIntegralKI InteractionIntegralKII InteractionIntegralKIII&#x27;
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;4.0 4.5 5.0 5.5 6.0&#x27;
  radius_outer = &#x27;4.5 5.0 5.5 6.0 6.5&#x27;
  block = 1
  youngs_modulus = 207000
  poissons_ratio = 0.3
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]


[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = interaction_integral_3d_as_2d_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5a136da3-34c1-4b7d-b05b-3db1998742f7"><div class="modal-content"><h4>modules/combined/test/tests/ad_power_law_creep/power_law_creep_restart1.i</h4><pre class="moose-pre"><code class="language-text"># 1x1x1 unit cube with uniform pressure on top face

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1000.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy&#x27;
    use_automatic_differentiation = true
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = ADHeatConduction
    variable = temp
  [../]
  [./heat_ie]
    type = ADHeatConductionTimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./u_top_pull]
    type = ADPressure
    variable = disp_y
    component = 1
    boundary = top
    constant = -10.0e6
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = ADDirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp_fix]
    type = DirichletBC
    variable = temp
    boundary = &#x27;bottom top&#x27;
    value = 1000.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 2e11
    poissons_ratio = 0.3
    constant_on = SUBDOMAIN
  [../]
  [./radial_return_stress]
    type = ADComputeMultipleInelasticStress
    inelastic_models = &#x27;power_law_creep&#x27;
  [../]
  [./power_law_creep]
    type = ADPowerLawCreepStressUpdate
    coefficient = 1.0e-15
    n_exponent = 4
    activation_energy = 3.0e5
    temperature = temp
  [../]

  [./thermal]
    type = ADHeatConductionMaterial
    specific_heat = 1.0
    thermal_conductivity = 100.
  [../]
  [./density]
    type = ADDensity
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.0
  end_time = 1.0
  num_steps = 6
  dt = 0.1
[]

[Outputs]
  exodus = true
  csv = true
  [./out]
    type = Checkpoint
    num_files = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="db25cd60-fde8-40f6-b165-07a0832b470f"><div class="modal-content"><h4>modules/contact/test/tests/normalized_penalty/normalized_penalty_kin.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = normalized_penalty.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Functions]
  [./left_x]
    type = PiecewiseLinear
    x = &#x27;0 1 2&#x27;
    y = &#x27;0 0.02 0&#x27;
  [../]
[]

[AuxVariables]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = FINITE
    generate_output = &#x27;stress_xx&#x27;
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  []
[]

[Contact]
  [./m3_s2]
    primary = 3
    secondary = 2
    penalty = 1e10
    normalize_penalty = true
    tangential_tolerance = 1e-3
  [../]
[]

[BCs]
  [./left_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 1
    function = left_x
  [../]

  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2 3 4&#x27;
    value = 0.0
  [../]

  [./right]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    value = 0
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2 3 4 1000&#x27;
    youngs_modulus = 3e8
    poissons_ratio = 0.0
  [../]
  [./stiffStuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2 3 4 1000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       101&#x27;

  line_search = &#x27;none&#x27;

  nl_rel_tol = 1e-12
  nl_abs_tol = 3e-8

  l_max_its = 100
  nl_max_its = 20
  dt = 0.5
  num_steps = 4
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="26b29524-9e3e-4755-beff-cd04b5f145ed"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/3D/3d_nodalmass_implicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for the Newmark-Beta time integrator

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 1
    ny = 1
    nz = 2
    xmin = 0.0
    xmax = 1
    ymin = 0.0
    ymax = 1
    zmin = 0.0
    zmax = 2
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;1 1 2&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
  [./accel_z]
    type = TestNewmarkTI
    variable = accel_z
    displacement = disp_z
    first = false
  [../]
  [./vel_z]
    type = TestNewmarkTI
    variable = vel_z
    displacement = disp_z
  [../]
[]

[BCs]
  [./x_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_x
    beta = 0.25
    velocity = vel_x
    acceleration = accel_x
    function = dispx
  [../]
  [./y_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_y
    beta = 0.25
    velocity = vel_y
    acceleration = accel_y
    function = dispy
  [../]
  [./z_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_z
    beta = 0.25
    velocity = vel_z
    acceleration = accel_z
    function = dispz
  [../]
[]

[Functions]
  [./dispx]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
  [./dispy]
    type = ParsedFunction
    value = 0.1*t*t*sin(10*t)
  [../]
  [./dispz]
    type = ParsedFunction
    value = 0.1*t*t*sin(20*t)
  [../]
[]

[NodalKernels]
  [./nodal_mass_x]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_x&#x27;
  [../]
  [./nodal_mass_y]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_y&#x27;
  [../]
  [./nodal_mass_z]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_z&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_abs_tol = 1e-08
  nl_rel_tol = 1e-08
  timestep_tolerance = 1e-6
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./accel_10x]
    type = NodalVariableValue
    nodeid = 10
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="60d918b2-3a4d-4581-9d5e-aa55c90d37fc"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4qnstt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4qtt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_abs_tol = 1e-7
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test4qnstt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f7ed441e-1ed0-4e15-88e5-4b1f75dd2a49"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/1D/1d_consistent_implicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for Newmark Beta integration for a 1D element
# Consistent mass matrix

[Mesh]
  type = GeneratedMesh
  xmin = 0
  xmax = 10
  nx = 5
  dim = 1
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
[]

[NodalKernels]
  [./force_x]
    type = UserForcingFunctionNodalKernel
    variable = disp_x
    boundary = right
    function = force_x
  [../]
[]

[Functions]
  [./force_x]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # force
    scale_factor = 1e3
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 2500
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  dtmin = 1e-4
  timestep_tolerance = 1e-6
  start_time = -0.005
  end_time = 0.1
  dt = 0.005
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_x
  [../]
  [./vel_x]
    type = NodalVariableValue
    nodeid = 1
    variable = vel_x
  [../]
  [./accel_x]
    type = NodalVariableValue
    nodeid = 1
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
  perf_graph = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a0e405fa-352a-4f87-ba09-4d905806d5b4"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_1/gh23.i</h4><pre class="moose-pre"><code class="language-text"># investigating validity of immobile saturation
# 50 elements, with SUPG

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 50
  xmin = -1
  xmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 10 100 1000 10000&#x27;
    x = &#x27;0 10 100 1000 10000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E3
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.1
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E-6
  [../]
[]

[Variables]
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -1.0
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    SUPG_UO = SUPGstandard
    sat_UO = Saturation
    seff_UO = SeffVG
    viscosity = 1E-3
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1E0
  end_time = 1E5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh23
  execute_on = &#x27;timestep_end final&#x27;
  interval = 10000
  exodus = true
  [./console]
    interval = 1
    type = Console
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="add13e2c-e44c-4e46-8464-6df885f0b8a4"><div class="modal-content"><h4>modules/combined/test/tests/combined_plasticity_temperature/plasticity_temperature_dep_yield.i</h4><pre class="moose-pre"><code class="language-text">#
# This is a test of the piece-wise linear strain hardening model using the
# small strain formulation.  This test exercises the temperature-dependent
# yield stress.
#
# Test procedure:
# 1. The element is pulled to and then beyond the yield stress for a given
# temperature.
# 2. The displacement is then constant while the temperature increases and
# the yield stress decreases.  This results in a lower stress with more
# plastic strain.
# 3. The temperature decreases beyond its original value giving a higher
# yield stress.  The displacement increases, causing increases stress to
# the new yield stress.
# 4. The temperature and yield stress are constant with increasing
# displacement giving a constant stress and more plastic strain.
#
# Plotting total_strain_yy on the x axis and stress_yy on the y axis shows
# the stress history in a clear way.
#
#  s |
#  t |            *****
#  r |           *
#  e |   *****  *
#  s |  *    * *
#  s | *     *
#    |*
#    +------------------
#           total strain
#

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy plastic_strain_xx plastic_strain_yy plastic_strain_zz&#x27;
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1     2    4    5    6&#x27;
    y = &#x27;0 0.025 0.05 0.05 0.06 0.085&#x27;
  [../]
  [./yield]
    type = PiecewiseLinear
    x = &#x27;400 500 600&#x27;
    y = &#x27;6e3 5e3 4e3&#x27;
  [../]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2   3   4&#x27;
    y = &#x27;500 500 500 600 400&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]

[BCs]
  [./y_pull_function]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = top_pull
  [../]
  [./x_bot]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./z_bot]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp]
    type = FunctionDirichletBC
    variable = temp
    function = temp
    boundary = left
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 0
    youngs_modulus = 2.0e5
    poissons_ratio = 0.3
  [../]
  [./creep_plas]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    block = 0
    inelastic_models = &#x27;plasticity&#x27;
    max_iterations = 50
    absolute_tolerance = 1e-05
  [../]
  [./plasticity]
    type = IsotropicPlasticityStressUpdate
    block = 0
    hardening_constant = 0
    yield_stress_function = yield
    temperature = temp
  [../]
  [./heat_conduction]
    type = HeatConductionMaterial
    block = 0
    specific_heat = 1
    thermal_conductivity = 1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10
  l_tol = 1e-9

  start_time = 0.0
  end_time = 6
  dt = 0.1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2637c936-27ad-4fd2-9bd6-fff681ed2276"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test4qnns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_method = nodal_normal_based
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test4qnns_out
  exodus = true
[]

[NodalNormals]
  boundary = 11
  corner_boundary = 20
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="02d1c7ae-0df8-48e7-83ad-589e0a574a69"><div class="modal-content"><h4>modules/combined/test/tests/thermal_strain/thermal_strain.i</h4><pre class="moose-pre"><code class="language-text"># Patch Test

# This test is designed to compute displacements from a thermal strain.

# The cube is displaced by 1e-6 units in x, 2e-6 in y, and 3e-6 in z.
#  The faces are sheared as well (1e-6, 2e-6, and 3e-6 for xy, yz, and
#  zx).  This gives a uniform strain/stress state for all six unique
#  tensor components.

# The temperature moves 100 degrees, and the coefficient of thermal
#  expansion is 1e-6.  Therefore, the strain (and the displacement
#  since this is a unit cube) is 1e-4.
[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = thermal_strain_test.e
[]

[Functions]
  [./tempFunc]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;117.56 217.56&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]

  [./temp]
    initial_condition = 117.56
  [../]
[]

[Modules/TensorMechanics/Master]
  add_variables = true
  strain = SMALL
  incremental = true
  generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;

  [./block1]
    eigenstrain_names = eigenstrain1
    block = 1
  [../]
  [./block2]
    eigenstrain_names = eigenstrain2
    block = 2
  [../]
  [./block3]
    eigenstrain_names = eigenstrain3
    block = 3
  [../]
  [./block4]
    eigenstrain_names = eigenstrain4
    block = 4
  [../]
  [./block5]
    eigenstrain_names = eigenstrain5
    block = 5
  [../]
  [./block6]
    eigenstrain_names = eigenstrain6
    block = 6
  [../]
  [./block7]
    eigenstrain_names = eigenstrain7
    block = 7
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 10
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 9
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 14
    value = 0
  [../]

  [./temp]
    type = FunctionDirichletBC
    variable = temp
    boundary = &#x27;10 12&#x27;
    function = tempFunc
  [../]
[]

[Materials]
  [./elasticity_tensor1]
    type = ComputeIsotropicElasticityTensor
    block = 1
    bulk_modulus = 0.333333333333e6
    poissons_ratio = 0.0
  [../]
  [./thermal_strain1]
    type = ComputeThermalExpansionEigenstrain
    block = 1
    temperature = temp
    stress_free_temperature = 117.56
    thermal_expansion_coeff = 1e-6
    eigenstrain_name = eigenstrain1
  [../]
  [./stress1]
    type = ComputeStrainIncrementBasedStress
    block = 1
  [../]

  [./elasticity_tensor2]
    type = ComputeIsotropicElasticityTensor
    block = 2
    bulk_modulus = 0.333333333333e6
    lambda = 0.0
  [../]
  [./thermal_strain2]
    type = ComputeThermalExpansionEigenstrain
    block = 2
    temperature = temp
    stress_free_temperature = 117.56
    thermal_expansion_coeff = 1e-6
    eigenstrain_name = eigenstrain2
  [../]
  [./stress2]
    type = ComputeStrainIncrementBasedStress
    block = 2
  [../]

  [./elasticity_tensor3]
    type = ComputeIsotropicElasticityTensor
    block = 3
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]
  [./thermal_strain3]
    type = ComputeThermalExpansionEigenstrain
    block = 3
    temperature = temp
    stress_free_temperature = 117.56
    thermal_expansion_coeff = 1e-6
    eigenstrain_name = eigenstrain3
  [../]
  [./stress3]
    type = ComputeStrainIncrementBasedStress
    block = 3
  [../]

  [./elasticity_tensor4]
    type = ComputeIsotropicElasticityTensor
    block = 4
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]
  [./thermal_strain4]
    type = ComputeThermalExpansionEigenstrain
    block = 4
    temperature = temp
    stress_free_temperature = 117.56
    thermal_expansion_coeff = 1e-6
    eigenstrain_name = eigenstrain4
  [../]
  [./stress4]
    type = ComputeStrainIncrementBasedStress
    block = 4
  [../]

  [./elasticity_tensor5]
    type = ComputeIsotropicElasticityTensor
    block = 5
    youngs_modulus = 1e6
    lambda = 0.0
  [../]
  [./thermal_strain5]
    type = ComputeThermalExpansionEigenstrain
    block = 5
    temperature = temp
    stress_free_temperature = 117.56
    thermal_expansion_coeff = 1e-6
    eigenstrain_name = eigenstrain5
  [../]
  [./stress5]
    type = ComputeStrainIncrementBasedStress
    block = 5
  [../]

  [./elasticity_tensor6]
    type = ComputeIsotropicElasticityTensor
    block = 6
    youngs_modulus = 1e6
    shear_modulus = 5e5
  [../]
  [./thermal_strain6]
    type = ComputeThermalExpansionEigenstrain
    block = 6
    temperature = temp
    stress_free_temperature = 117.56
    thermal_expansion_coeff = 1e-6
    eigenstrain_name = eigenstrain6
  [../]
  [./stress6]
    type = ComputeStrainIncrementBasedStress
    block = 6
  [../]

  [./elasticity_tensor7]
    type = ComputeIsotropicElasticityTensor
    block = 7
    shear_modulus = 5e5
    poissons_ratio = 0.0
  [../]
  [./thermal_strain7]
    type = ComputeThermalExpansionEigenstrain
    block = 7
    temperature = temp
    stress_free_temperature = 117.56
    thermal_expansion_coeff = 1e-6
    eigenstrain_name = eigenstrain7
  [../]
  [./stress7]
    type = ComputeStrainIncrementBasedStress
    block = 7
  [../]

  [./heat]
    type = HeatConductionMaterial
    block = &#x27;1 2 3 4 5 6 7&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./density]
    type = Density
    block = &#x27;1 2 3 4 5 6 7&#x27;
    density = 1.0
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10

  l_max_its = 20

  start_time = 0.0
  dt = 0.5
  num_steps = 2
  end_time = 1.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0db5fb81-dc64-4505-b64b-072e04bcfa86"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/truss/truss_2d_action.i</h4><pre class="moose-pre"><code class="language-text">#
# Truss in two dimensional space
#
# The truss is made of five equilateral triangles supported at each end.
# The truss starts at (0,0).  At (1,0), there is a point load of 25.
# The reactions are therefore
#  Ryleft  = 2/3 * 25 = 16.7
#  Ryright = 1/3 * 25 = 8.33
# The area of each member is 0.8.
# Statics gives the stress in each member.  For example, for element 6 (from
#   (0,0) to (1/2,sqrt(3)/2)), the force is
#   f = 2/3 * 25 * 2/sqrt(3) = 100/3/sqrt(3) (compressive)
#   and the stress is
#   s = -100/3/sqrt(3)/0.8 = -24.06
#

[Mesh]
  type = FileMesh
  file = truss_2d.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[AuxVariables]
  [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./x2]
    type = PiecewiseLinear
    x = &#x27;0  1 2 3&#x27;
    y = &#x27;0 .5 1 1&#x27;
  [../]
  [./y2]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3&#x27;
    y = &#x27;0 0 .5 1&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./fixy4]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0
  [../]
[]

[DiracKernels]
  [./pull]
    type = ConstantPointSource
    value = -25
    point = &#x27;1 0 0&#x27;
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    block = 1
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    block = 1
    property = e_over_l
    variable = e_over_l
  [../]
  [./area]
    type = ConstantAux
    block = 1
    variable = area
    value = 0.8
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;jacobi   101&#x27;

  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10

  dt = 1
  num_steps = 1
  end_time = 1
[]

[Modules/TensorMechanics/LineElementMaster]
  [./block]
    truss = true
    add_variables = true
    displacements = &#x27;disp_x disp_y&#x27;

#    area = area # commented out for error check

    block = 1
    save_in = &#x27;react_x react_y&#x27;
  [../]
[]

[Materials]
  [./linelast]
    type = LinearElasticTruss
    block = 1
    youngs_modulus = 1e6
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
[]

[Outputs]
  file_base = &#x27;truss_2d_out&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d9f1ebb3-38d1-45aa-8aff-8838b0e112ec"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/finite_linear.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function is a linear function
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# This version of the test uses finite deformation theory.
# The two models produce very similar results.  There are slight
# differences due to the large deformation treatment.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 3
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ADComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion_strain1]
    type = ADComputeMeanThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 0.5
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
  [./thermal_expansion_strain2]
    type = ADComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 2
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (0.5 * t^2 - 0.5 * tsf^2) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 0.0
               2 2.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = NEWTON
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="842ff250-1e92-4e5a-9d8b-aa8a7a887f7f"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral_vtest/c_int_surfbreak_ellip_crack_sym_mm.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = c_integral_coarse.e
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./resid_z]
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 0.1 100.0&#x27;
    y = &#x27;0. 1 1&#x27;
    scale_factor = -68.95 #MPa
  [../]
  [./dts]
  type = PiecewiseLinear
  x = &#x27;0   1&#x27;
  y = &#x27;1   400000&#x27;
[../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 12
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 5
      function = rampConstantUp
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.0
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
  [./powerlawcrp]
    type = PowerLawCreepStressUpdate
    coefficient = 3.125e-21 # 7.04e-17 #
    n_exponent = 4.0
    m_exponent = 0.0
    activation_energy = 0.0
    # max_inelastic_increment = 0.01
  [../]
[]

[DomainIntegral]
  integrals = CIntegral
  boundary = 1001
  crack_direction_method = CurvedCrackFront
  crack_end_direction_method = CrackDirectionVector
  crack_direction_vector_end_1 = &#x27;0.0 1.0 0.0&#x27;
  crack_direction_vector_end_2 = &#x27;1.0 0.0 0.0&#x27;
  radius_inner = &#x27;12.5 25.0 37.5&#x27;
  radius_outer = &#x27;25.0 37.5 50.0&#x27;
  intersecting_boundary = &#x27;1 2&#x27;
  symmetry_plane = 2
  incremental = true
  inelastic_models = &#x27;powerlawcrp&#x27;
[]

[Executioner]

   type = Transient
  # Two sets of linesearch options are for petsc 3.1 and 3.3 respectively
  #Preconditioned JFNK (default)
  solve_type = &#x27;NEWTON&#x27;

#  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;
  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 1e-3
   nl_rel_tol = 1e-11
   l_tol = 1e-2

   start_time = 0.0
   end_time = 401

   [./TimeStepper]
     type = FunctionDT
     function = dts
     min_dt = 1.0
   [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./nl_its]
    type = NumNonlinearIterations
  [../]
  [./lin_its]
    type = NumLinearIterations
  [../]
  [./react_z]
    type = NodalSum
    variable = resid_z
    boundary = 5
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="614a298a-8813-493a-bbbf-3f9ee9ed857b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free_orientation_inclined_hht.i</h4><pre class="moose-pre"><code class="language-text"># Test to verify the fundamental natural frequency of a one element ADComputeShellStress
# BCs: Clamped on one end, free on others.
# Initial perturbation applied to edge of the beam. After that, the shell vibrates freely.
#
# Results have been compared for various thicknesses with the following approximate Results
# (Moose results were obtained with 8 elements along the length)
# Thickness = 0.1. Reference freq: 10.785 Hz, Moose freq: 10.612 Hz
# Thickness = 0.05. Reference freq: 5.393 Hz, Moose freq: 5.335 Hz
# Thickness = 0.025. Reference freq: 2.696 Hz, Moose freq: 2.660 Hz
#
# Reference values have been obtained from Robert Blevins, &quot;Formulas for Dynamics, Acoustics and Vibration&quot;,
# Table 5.3 case 11. Formula looks like: f = lambda^2/(2*pi*a^2) * sqrt(E*h^2/(12*(1-nu*nu))), where lambda
# changes as a function of shell dimensions.

# This test uses one single element for speed reasons.

# Here, the shell, instead of being on the XY plane, is oriented at a 45 deg. angle
# with respect to the Y axis.

[Mesh]
  type = FileMesh
  file = shell_inclined.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./rot_x]
  [../]
  [./rot_y]
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  # aux variables for dynamics
  [./vel_x]
  [../]
  [./vel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_x]
  [../]
  [./accel_y]
  [../]
  [./accel_z]
  [../]
  [./rot_vel_x]
  [../]
  [./rot_vel_y]
  [../]
  [./rot_accel_x]
  [../]
  [./rot_accel_y]
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    variable = stress_yy
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    variable = stress_yz
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 2
  [../]

# Kernels for dynamics
[./accel_x]
  type = NewmarkAccelAux
  variable = accel_x
  displacement = disp_x
  velocity = vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_x]
  type = NewmarkVelAux
  variable = vel_x
  acceleration = accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_y]
  type = NewmarkAccelAux
  variable = accel_y
  displacement = disp_y
  velocity = vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_y]
  type = NewmarkVelAux
  variable = vel_y
  acceleration = accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_z]
  type = NewmarkAccelAux
  variable = accel_z
  displacement = disp_z
  velocity = vel_z
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_z]
  type = NewmarkVelAux
  variable = vel_z
  acceleration = accel_z
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_x]
  type = NewmarkAccelAux
  variable = rot_accel_x
  displacement = rot_x
  velocity = rot_vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_x]
  type = NewmarkVelAux
  variable = rot_vel_x
  acceleration = rot_accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_y]
  type = NewmarkAccelAux
  variable = rot_accel_y
  displacement = rot_y
  velocity = rot_vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_y]
  type = NewmarkVelAux
  variable = rot_vel_y
  acceleration = rot_accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_function]
    type = PiecewiseLinear
    x = &#x27;0.0 0.01 0.15 10.0&#x27;
    y = &#x27;0.0 0.01 0.0 0.0&#x27;
  [../]
[]
[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;2&#x27;
    function = force_function
  [../]
[]
[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
  [../]

  [./inertial_force_x]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 0
    variable = disp_x
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]

  [./inertial_force_y]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 1
    variable = disp_y
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]

  [./inertial_force_z]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 2
    variable = disp_z
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]

  [./inertial_force_rot_x]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 3
    variable = rot_x
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]

  [./inertial_force_rot_y]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 4
    variable = rot_y
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 2100000
    poissons_ratio = 0.3
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeIncrementalShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 0.1
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_z_tip]
    type = PointValue
    point = &#x27;0.0 1.06 1.06&#x27;
    variable = disp_z
  [../]
  [./rot_x_tip]
    type = PointValue
    point = &#x27;0.0 1.06 1.06&#x27;
    variable = rot_x
  [../]
  [./stress_yy_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yy
  [../]
  [./stress_yy_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yy
  [../]
  [./stress_yy_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yy
  [../]
  [./stress_yy_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yy
  [../]
  [./stress_yz_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yz
  [../]
  [./stress_yz_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yz
  [../]
  [./stress_yz_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yz
  [../]
  [./stress_yz_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yz
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-10
  l_max_its = 20
  dt = 0.005
  dtmin = 0.005
  timestep_tolerance = 2e-13
  end_time = 0.5

  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]

[]

[Outputs]
  perf_graph = true
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="656bca78-7c7b-4342-85b0-dc7a68d4e0ee"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_multiple_softening.i</h4><pre class="moose-pre"><code class="language-text"># Test of cracking with direction-specific release models in 3
# directions. Block is first pulled in one direction, and then
# held while it is sequentially pulled in the other two
# directions. Poisson&#x27;s ratio is zero so that the cracking in one
# direction doesn&#x27;t affect the others.

# Softening in the three directions should follow the laws for the
# prescribed models in the three directions, which are power law (x),
# exponential (y), and abrupt (z).

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displx]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3&#x27;
    y = &#x27;0 1 1 1&#x27;
  [../]
  [./disply]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3&#x27;
    y = &#x27;0 0 1 1&#x27;
  [../]
  [./displz]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3&#x27;
    y = &#x27;0 0 0 1&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pullx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = right
    function = displx
  [../]
  [./pully]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = disply
  [../]
  [./pullz]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = front
    function = displz
  [../]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 1.68e6
    softening_models = &#x27;power_law_softening exponential_softening abrupt_softening&#x27;
    prescribed_crack_directions = &#x27;x y z&#x27;
  [../]
  [./power_law_softening]
    type = PowerLawSoftening
    stiffness_reduction = 0.3333
  [../]
  [./exponential_softening]
    type = ExponentialSoftening
  [../]
  [./abrupt_softening]
    type = AbruptSoftening
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 3.0
  dt = 0.01
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="38f5a8e3-a48f-491f-9b87-e7ca4469d3be"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test1tt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1tt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test1tt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="42442cfd-08c2-4279-adf9-4be7e39ef822"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_hht_ti.i</h4><pre class="moose-pre"><code class="language-text"># Test for rayleigh damping implemented using HHT time integration
#
# The test is for an 1D bar element of  unit length fixed on one end
# with a ramped pressure boundary condition applied to the other end.
# zeta and eta correspond to the stiffness and mass proportional rayleigh damping
# alpha, beta and gamma are HHT time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel + (eta*M+zeta*K)*[(1+alpha)vel-alpha vel_old]
# + alpha*(K*disp - K*disp_old) + K*disp = P(t+alpha dt)*Area
#
# Here M is the mass matrix, K is the stiffness matrix, P is the applied pressure
#
# This equation is equivalent to:
#
# density*accel + eta*density*[(1+alpha)vel-alpha vel_old]
# + zeta*[(1+alpha)*d/dt(Div stress)- alpha*d/dt(Div stress_old)]
# + alpha *(Div stress - Div stress_old) +Div Stress= P(t+alpha dt)
#
# The first two terms on the left are evaluated using the Inertial force kernel
# The next three terms on the left involving zeta and alpha are evaluated using
# the DynamicStressDivergenceTensors Kernel
# The residual due to Pressure is evaluated using Pressure boundary condition
#
# The system will come to steady state slowly after the pressure becomes constant.
# Alpha equal to zero will result in Newmark integration.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    zeta = 0.1
    alpha = 0.11
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    eta=0.1
    alpha = 0.11
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    eta=0.1
    alpha = 0.11
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    eta = 0.1
    alpha = 0.11
  [../]

[]

[AuxKernels]
  [./accel_x] # These auxkernels are only to check output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = bottom
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
      disp_z = disp_z
      factor = 1
      alpha  = 0.11
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 2
  dt = 0.1

  # Time integrator scheme
  scheme = &quot;newmark-beta&quot;
[]


[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 1.0 2.0 5.0&#x27;
    y = &#x27;0.0 0.1 0.2 1.0 1.0 1.0&#x27;
    scale_factor = 1e9
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalMaxValue
    variable = disp_y
    boundary = bottom
  [../]
  [./vel]
    type = NodalMaxValue
    variable = vel_y
    boundary = bottom
  [../]
  [./accel]
    type = NodalMaxValue
    variable = accel_y
    boundary = bottom
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./strain_yy]
    type = ElementAverageValue
    variable = strain_yy
  [../]
[]

[Outputs]
  file_base = &#x27;rayleigh_hht_out&#x27;
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b8041719-87c3-4848-bf79-959537bbc7bd"><div class="modal-content"><h4>modules/geochemistry/test/tests/time_dependent_reactions/seawater_evaporation_flow_through.i</h4><pre class="moose-pre"><code class="language-text">#Progressively remove H2O until virtually none remains, all the while removing any minerals that precipitate
[UserObjects]
  [./definition]
    type = GeochemicalModelDefinition
    database_file = &quot;../../../database/moose_geochemdb.json&quot;
    basis_species = &quot;H2O H+ Cl- Ca++ Mg++ Na+ K+ SO4-- HCO3-&quot;
    equilibrium_minerals = &quot;Dolomite Epsomite Gypsum Halite Magnesite Mirabilite Sylvite&quot;
    equilibrium_gases = &quot;CO2(g)&quot;
    piecewise_linear_interpolation = true # for precise agreement with GWB
  [../]
[]

[TimeDependentReactionSolver]
  model_definition = definition
  geochemistry_reactor_name = reactor
  swap_out_of_basis = &quot;H+&quot;
  swap_into_basis = &quot;  CO2(g)&quot;
  charge_balance_species = &quot;Cl-&quot; # this means the bulk moles of Cl- will not be exactly as set below
  constraint_species = &quot;H2O              CO2(g)       Cl-                Na+                SO4--              Mg++               Ca++               K+                 HCO3-&quot;
  constraint_value = &quot;  1.0              0.0003162278 0.5656             0.4850             0.02924            0.05501            0.01063            0.010576055        0.002412&quot;
  constraint_meaning = &quot;kg_solvent_water fugacity     moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species&quot;
  source_species_names = &quot;H2O&quot;
  source_species_rates = &quot;-1.0&quot; # 1kg H2O = 55.51 moles, each time step removes 1 mole
  mode = mode
  ramp_max_ionic_strength_initial = 0 # not needed in this simple example
  stoichiometric_ionic_str_using_Cl_only = true # for precise agreement with GWB
  execute_console_output_on = &#x27;&#x27; # only CSV output for this example
[]

[Functions]
  [./timestepper]
    type = PiecewiseLinear
    x = &#x27;0 50 55&#x27;
    y = &#x27;5 5 1&#x27;
  [../]
[]
[Executioner]
  type = Transient
  [./TimeStepper]
    type = FunctionDT
    function = timestepper
  [../]
  end_time = 55
[]

[AuxVariables]
  [./mode]
  [../]
  [./dolomite_mol]
  [../]
  [./halite_mol]
  [../]
  [./gypsum_mol]
  [../]
  [./mirabilite_mol]
  [../]
[]

[AuxKernels]
  [./mode_auxk]
    type = FunctionAux
    variable = mode
    function = &#x27;if(t&lt;=1.0, 1.0, 2.0)&#x27; # initial &quot;dump&quot; then &quot;flow_through&quot;
    execute_on = &#x27;timestep_begin&#x27;
  [../]
  [./dolomite_mol_auxk]
    type = GeochemistryQuantityAux
    reactor = reactor
    variable = dolomite_mol
    species = Dolomite
    quantity = moles_dumped
  [../]
  [./gypsum_mol_auxk]
    type = GeochemistryQuantityAux
    reactor = reactor
    variable = gypsum_mol
    species = Gypsum
    quantity = moles_dumped
  [../]
  [./halite_mol]
    type = GeochemistryQuantityAux
    reactor = reactor
    variable = halite_mol
    species = Halite
    quantity = moles_dumped
  [../]
  [./mirabilite_mol]
    type = GeochemistryQuantityAux
    reactor = reactor
    variable = mirabilite_mol
    species = Mirabilite
    quantity = moles_dumped
  [../]
[]

[GlobalParams]
  point = &#x27;0 0 0&#x27;
[]
[Postprocessors]
  [./solvent_kg]
    type = PointValue
    variable = &#x27;kg_solvent_H2O&#x27;
  [../]
  [./dolomite_mol]
    type = PointValue
    variable = dolomite_mol
  [../]
  [./gypsum_mol]
    type = PointValue
    variable = &#x27;gypsum_mol&#x27;
  [../]
  [./halite_mol]
    type = PointValue
    variable = &#x27;halite_mol&#x27;
  [../]
  [./mirabilite_mol]
    type = PointValue
    variable = &#x27;mirabilite_mol&#x27;
  [../]
[]

[Outputs]
  csv = true
[]

</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c5c1f45d-f2fc-4cf2-bad9-3ab5f553f467"><div class="modal-content"><h4>modules/xfem/test/tests/pressure_bc/edge_3d_pressure.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = false
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 2
  ny = 9
  nz = 10
  xmin = -0.1
  xmax = 0.1
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
  elem_type = HEX8
[]

[UserObjects]
  [./square_planar_cut_uo]
    type = RectangleCutUserObject
    cut_data = &#x27;-0.2  0.0 -0.5
                -0.2  0.0  0.0
                 0.2  0.0  0.0
                 0.2  0.0 -0.5&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz&#x27;
  [../]
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0 2.0 4.0 6.0 8.0&#x27;
    y = &#x27;0 1000 0 1000 0&#x27;
  [../]
[]

[DiracKernels]
  [./p_x]
    type = XFEMPressure
    variable = disp_x
    component = 0
    function = pressure
  [../]
  [./p_y]
    type = XFEMPressure
    variable = disp_y
    component = 1
    function = pressure
  [../]
  [./p_z]
    type = XFEMPressure
    variable = disp_z
    component = 2
    function = pressure
  [../]
[]

[BCs]
  [./bottom_x]
    type = DirichletBC
    boundary = &#x27;bottom top&#x27;
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = &#x27;bottom top&#x27;
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    boundary = &#x27;bottom top&#x27;
    variable = disp_z
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  file_base = edge_3d_pressure_out
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e9b0f56f-cf9d-434a-965b-205e019fc013"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_test.i</h4><pre class="moose-pre"><code class="language-text">#
# 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks containing one element each.  Each
#   element is a unit cube.  They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit.  The temperature of the far right
#  boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
#  Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
#  gapK(Tavg) = 1.0*Tavg
#
#
# The heat flux across the gap at time = 1 is then:
#
#  Flux(2) = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors
#
# This test has been augmented with a second scalar field that solves nearly
#   the same problem.  The conductivity has been changed to 10.  Thus, the
#   flux for the second field is 1000.
#


[Mesh]
  file = gap_heat_transfer_htonly_test.e
[]

[Functions]

  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
  [./awesomium_contact]
    type = GapHeatTransfer
    variable = awesomium
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 10
    appended_property_name = _awesomium
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
  [./awesomium]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./gap_cond_awesomium]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./awe]
    type = HeatConduction
    variable = awesomium
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
  [./awesomium_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = awesomium
    function = temp
  [../]
  [./awesomium_far_right]
    type = DirichletBC
    boundary = 4
    variable = awesomium
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
  [./conductance_awe]
    type = MaterialRealAux
    property = gap_conductance_awesomium
    variable = gap_cond_awesomium
    boundary = 2
  [../]
[]

[Materials]

  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  l_tol = 1e-3
  l_max_its = 100

  dt = 1e-1
  end_time = 1.0
[]

[Postprocessors]

  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./awe_left]
    type = SideAverageValue
    boundary = 2
    variable = awesomium
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./awe_right]
    type = SideAverageValue
    boundary = 3
    variable = awesomium
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./awe_flux_left]
    type = SideFluxIntegral
    variable = awesomium
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./awe_flux_right]
    type = SideFluxIntegral
    variable = awesomium
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="878d9601-327b-4a17-ac44-1acced0ea6e6"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/3D/3d_consistent_implicit.i</h4><pre class="moose-pre"><code class="language-text"># One element test for the Newmark-Beta time integrator.

[Mesh]
  type = GeneratedMesh # Can generate simple lines, rectangles and rectangular prisms
  dim = 3 # Dimension of the mesh
  nx = 1 # Number of elements in the x direction
  ny = 1 # Number of elements in the y direction
  nz = 2 # Number of elements in the z direction
  xmin = 0.0
  xmax = 1
  ymin = 0.0
  ymax = 1
  zmin = 0.0
  zmax = 2
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
  [./accel_z]
    type = TestNewmarkTI
    variable = accel_z
    displacement = disp_z
    first = false
  [../]
  [./vel_z]
    type = TestNewmarkTI
    variable = vel_z
    displacement = disp_z
  [../]
[]

[BCs]
  [./x_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_x
    beta = 0.25
    velocity = vel_x
    acceleration = accel_x
    function = dispx
  [../]
  [./y_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_y
    beta = 0.25
    velocity = vel_y
    acceleration = accel_y
    function = dispy
  [../]
  [./z_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_z
    beta = 0.25
    velocity = vel_z
    acceleration = accel_z
    function = dispz
  [../]
  [./Periodic]
    [./x_dir]
      variable = &#x27;disp_x disp_y disp_z&#x27;
      primary = &#x27;left&#x27;
      secondary = &#x27;right&#x27;
      translation = &#x27;1.0 0.0 0.0&#x27;
    [../]
    [./y_dir]
      variable = &#x27;disp_x disp_y disp_z&#x27;
      primary = &#x27;bottom&#x27;
      secondary = &#x27;top&#x27;
      translation = &#x27;0.0 1.0 0.0&#x27;
    [../]
  [../]
[]

[Functions]
  [./dispx]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
  [./dispy]
    type = ParsedFunction
    value = 0.1*t*t*sin(10*t)
  [../]
  [./dispz]
    type = ParsedFunction
    value = 0.1*t*t*sin(20*t)
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 1e4
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_abs_tol = 1e-08
  nl_rel_tol = 1e-08
  timestep_tolerance = 1e-6
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./accel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="47ec753e-4b04-44c8-8585-f328c2c3ef51"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/mandel_basicthm.i</h4><pre class="moose-pre"><code class="language-text"># using a BasicTHM Action
#
# Mandel&#x27;s problem of consolodation of a drained medium
# Using the FullySaturatedDarcyBase and FullySaturatedFullySaturatedMassTimeDerivative kernels
# with multiply_by_density = false, so that this problem becomes linear
# Note the use of consistent_with_displaced_mesh = false in the calculation of volumetric strain
#
# A sample is in plane strain.
# -a &lt;= x &lt;= a
# -b &lt;= y &lt;= b
# It is squashed with constant force by impermeable, frictionless plattens on its top and bottom surfaces (at y=+/-b)
# Fluid is allowed to leak out from its sides (at x=+/-a)
# The porepressure within the sample is monitored.
#
# As is common in the literature, this is simulated by
# considering the quarter-sample, 0&lt;=x&lt;=a and 0&lt;=y&lt;=b, with
# impermeable, roller BCs at x=0 and y=0 and y=b.
# Porepressure is fixed at zero on x=a.
# Porepressure and displacement are initialised to zero.
# Then the top (y=b) is moved downwards with prescribed velocity,
# so that the total force that is inducing this downwards velocity
# is fixed.  The velocity is worked out by solving Mandel&#x27;s problem
# analytically, and the total force is monitored in the simulation
# to check that it indeed remains constant.
#
# Here are the problem&#x27;s parameters, and their values:
# Soil width.  a = 1
# Soil height.  b = 0.1
# Soil&#x27;s Lame lambda.  la = 0.5
# Soil&#x27;s Lame mu, which is also the Soil&#x27;s shear modulus.  mu = G = 0.75
# Soil bulk modulus.  K = la + 2*mu/3 = 1
# Drained Poisson ratio.  nu = (3K - 2G)/(6K + 2G) = 0.2
# Soil bulk compliance.  1/K = 1
# Fluid bulk modulus.  Kf = 8
# Fluid bulk compliance.  1/Kf = 0.125
# Soil initial porosity.  phi0 = 0.1
# Biot coefficient.  alpha = 0.6
# Biot modulus.  M = 1/(phi0/Kf + (alpha - phi0)(1 - alpha)/K) = 4.705882
# Undrained bulk modulus. Ku = K + alpha^2*M = 2.694118
# Undrained Poisson ratio.  nuu = (3Ku - 2G)/(6Ku + 2G) = 0.372627
# Skempton coefficient.  B = alpha*M/Ku = 1.048035
# Fluid mobility (soil permeability/fluid viscosity).  k = 1.5
# Consolidation coefficient.  c = 2*k*B^2*G*(1-nu)*(1+nuu)^2/9/(1-nuu)/(nuu-nu) = 3.821656
# Normal stress on top.  F = 1
#
# The solution for porepressure and displacements is given in
# AHD Cheng and E Detournay &quot;A direct boundary element method for plane strain poroelasticity&quot; International Journal of Numerical and Analytical Methods in Geomechanics 12 (1988) 551-572.
# The solution involves complicated infinite series, so I shall not write it here

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
  ny = 1
  nz = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 0.1
  zmin = 0
  zmax = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./roller_xmin]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left&#x27;
  [../]
  [./roller_ymin]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  [../]
  [./plane_strain]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
  [./xmax_drained]
    type = DirichletBC
    variable = porepressure
    value = 0
    boundary = right
  [../]
  [./top_velocity]
    type = FunctionDirichletBC
    variable = disp_y
    function = top_velocity
    boundary = top
  [../]
[]

[Functions]
  [./top_velocity]
    type = PiecewiseLinear
    x = &#x27;0 0.002 0.006   0.014   0.03    0.046   0.062   0.078   0.094   0.11    0.126   0.142   0.158   0.174   0.19 0.206 0.222 0.238 0.254 0.27 0.286 0.302 0.318 0.334 0.35 0.366 0.382 0.398 0.414 0.43 0.446 0.462 0.478 0.494 0.51 0.526 0.542 0.558 0.574 0.59 0.606 0.622 0.638 0.654 0.67 0.686 0.702&#x27;
    y = &#x27;-0.041824842    -0.042730269    -0.043412712    -0.04428867     -0.045509181    -0.04645965     -0.047268246 -0.047974749      -0.048597109     -0.0491467  -0.049632388     -0.050061697      -0.050441198     -0.050776675     -0.051073238      -0.0513354 -0.051567152      -0.051772022     -0.051953128 -0.052113227 -0.052254754 -0.052379865 -0.052490464 -0.052588233 -0.052674662 -0.052751065 -0.052818606 -0.052878312 -0.052931093 -0.052977751 -0.053018997 -0.053055459 -0.053087691 -0.053116185 -0.053141373 -0.05316364 -0.053183324 -0.053200724 -0.053216106 -0.053229704 -0.053241725 -0.053252351 -0.053261745 -0.053270049 -0.053277389 -0.053283879 -0.053289615&#x27;
  [../]
[]

[AuxVariables]
  [./tot_force]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./tot_force]
    type = ParsedAux
    args = &#x27;stress_yy porepressure&#x27;
    execute_on = timestep_end
    variable = tot_force
    function = &#x27;-stress_yy+0.6*porepressure&#x27;
  [../]
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.0
      bulk_modulus = 8.0
      viscosity = 1.0
      density0 = 1.0
    [../]
  [../]
[]

[PorousFlowBasicTHM]
  coupling_type = HydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  multiply_by_density = false
  porepressure = porepressure
  biot_coefficient = 0.6
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0.5 0.75&#x27;
    # bulk modulus is lambda + 2*mu/3 = 0.5 + 2*0.75/3 = 1
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # only the initial value of this is ever used
    porosity = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    biot_coefficient = 0.6
    solid_bulk_compliance = 1
    fluid_bulk_modulus = 8
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1.5 0 0   0 1.5 0   0 0 1.5&#x27;
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0.0 0 0&#x27;
    variable = porepressure
  [../]
  [./p1]
    type = PointValue
    outputs = csv
    point = &#x27;0.1 0 0&#x27;
    variable = porepressure
  [../]
  [./p2]
    type = PointValue
    outputs = csv
    point = &#x27;0.2 0 0&#x27;
    variable = porepressure
  [../]
  [./p3]
    type = PointValue
    outputs = csv
    point = &#x27;0.3 0 0&#x27;
    variable = porepressure
  [../]
  [./p4]
    type = PointValue
    outputs = csv
    point = &#x27;0.4 0 0&#x27;
    variable = porepressure
  [../]
  [./p5]
    type = PointValue
    outputs = csv
    point = &#x27;0.5 0 0&#x27;
    variable = porepressure
  [../]
  [./p6]
    type = PointValue
    outputs = csv
    point = &#x27;0.6 0 0&#x27;
    variable = porepressure
  [../]
  [./p7]
    type = PointValue
    outputs = csv
    point = &#x27;0.7 0 0&#x27;
    variable = porepressure
  [../]
  [./p8]
    type = PointValue
    outputs = csv
    point = &#x27;0.8 0 0&#x27;
    variable = porepressure
  [../]
  [./p9]
    type = PointValue
    outputs = csv
    point = &#x27;0.9 0 0&#x27;
    variable = porepressure
  [../]
  [./p99]
    type = PointValue
    outputs = csv
    point = &#x27;1 0 0&#x27;
    variable = porepressure
  [../]
  [./xdisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_x
  [../]
  [./ydisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_y
  [../]
  [./total_downwards_force]
     type = ElementAverageValue
     outputs = csv
     variable = tot_force
  [../]
  [./dt]
    type = FunctionValuePostprocessor
    outputs = console
    function = if(0.15*t&lt;0.01,0.15*t,0.01)
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres asm lu 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 0.7
  [./TimeStepper]
    type = PostprocessorDT
    postprocessor = dt
    dt = 0.001
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = mandel_basicthm
  [./csv]
    interval = 3
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="29eac931-7d7b-41a9-9808-d5eeca92ec7c"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/constraints/frictionless_constraint.i</h4><pre class="moose-pre"><code class="language-text"># Test for frictionless beam constraint.
#
# Using a simple L-shaped geometry with a frictionless constraint at the
# corner between the two beams. The longer beam properties and loading is
# taken from an earlier beam regression test for static loading. The maximum
# applied load of 50000 lb should result in a displacement of 3.537e-3. Since
# the constraint is frictionless, the y-dir displacement of the long beam is
# 3.537e-3 and the short beam y-dir displacement is zero.

[Mesh]
  file = beam_cons_patch.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
[]

[Constraints]
  [./tie_y_fuel]
    type = NodalFrictionalConstraint
    normal_force = 1000
    tangential_penalty = 1.2e6
    friction_coefficient = 0.0
    boundary = 1005
    secondary = 1004
    variable = disp_y
  [../]
  [./tie_x_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = disp_x
  [../]
  [./tie_z_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = disp_z
  [../]
  [./tie_rot_y_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_y
  [../]
  [./tie_rot_x_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_x
  [../]
  [./tie_rot_z_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_z
  [../]
[]

[Functions]
  [./force_loading]
    type = PiecewiseLinear
    x = &#x27;0.0 5.0&#x27;
    y = &#x27;0.0 50000.0&#x27;
  [../]
[]

[NodalKernels]
  [./force_x2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = &#x27;1004&#x27;
    function = force_loading
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]
[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-8

  dt = 1
  dtmin = 1
  end_time = 5
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity_pipe]
    type = ComputeElasticityBeam
    shear_coefficient = 1.0
    youngs_modulus = 30e6
    poissons_ratio = 0.3
    block = 1
    outputs = exodus
    output_properties = &#x27;material_stiffness material_flexure&#x27;
  [../]
  [./strain_pipe]
    type = ComputeIncrementalBeamStrain
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 28.274
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 0.0 1.0&#x27;
  [../]
  [./stress_pipe]
    type = ComputeBeamResultants
    block = 1
    outputs = exodus
    output_properties = &#x27;forces moments&#x27;
  [../]
  [./elasticity_cons]
    type = ComputeElasticityBeam
    shear_coefficient = 1.0
    youngs_modulus = 10e2
    poissons_ratio = 0.3
    block = 2
    outputs = exodus
    output_properties = &#x27;material_stiffness material_flexure&#x27;
  [../]
  [./strain_cons]
    type = ComputeIncrementalBeamStrain
    block = &#x27;2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 1.0
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 0.0 1.0&#x27;
  [../]
  [./stress_cons]
    type = ComputeBeamResultants
    block = 2
    outputs = exodus
    output_properties = &#x27;forces moments&#x27;
  [../]
[]

[Postprocessors]
  [./disp_y_n4]
    type = NodalVariableValue
    variable = disp_y
    nodeid = 3
  [../]
  [./disp_y_n2]
    type = NodalVariableValue
    variable = disp_y
    nodeid = 1
  [../]
  [./forces_y]
    type = PointValue
    point = &#x27;10.0 59.9 0.0&#x27;
    variable = forces_y
  [../]
[]

[Outputs]
  csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0b145dfe-0d9d-4b46-a00d-fe309008102f"><div class="modal-content"><h4>modules/richards/test/tests/rogers_stallybrass_clements/rsc02.i</h4><pre class="moose-pre"><code class="language-text"># RSC test with low-res time and spatial resolution
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 200
  ny = 1
  xmin = 0
  xmax = 10 # x is the depth variable, called zeta in RSC
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;3E-2 5E-1 8E-1&#x27;
    x = &#x27;0 1 5&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater poil&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 10
    bulk_mod = 2E9
  [../]
  [./DensityOil]
    type = RichardsDensityConstBulk
    dens0 = 20
    bulk_mod = 2E9
  [../]
  [./SeffWater]
    type = RichardsSeff2waterRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./SeffOil]
    type = RichardsSeff2gasRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./RelPerm]
    type = RichardsRelPermMonomial
    simm = 0
    n = 1
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E-2
  [../]
[]


[Variables]
  [./pwater]
  [../]
  [./poil]
  [../]
[]

[ICs]
  [./water_init]
    type = ConstantIC
    variable = pwater
    value = 0
  [../]
  [./oil_init]
    type = ConstantIC
    variable = poil
    value = 15
  [../]
[]

[Kernels]
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstoil]
    type = RichardsMassChange
    variable = poil
  [../]
  [./richardsfoil]
    type = RichardsFlux
    variable = poil
  [../]
[]


[AuxVariables]
  [./SWater]
  [../]
  [./SOil]
  [../]
[]


[AuxKernels]
  [./Seff1VGwater_AuxK]
    type = RichardsSeffAux
    variable = SWater
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
  [./Seff1VGoil_AuxK]
    type = RichardsSeffAux
    variable = SOil
    seff_UO = SeffOil
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
[]


[BCs]
# we are pumping water into a system that has virtually incompressible fluids, hence the pressures rise enormously.  this adversely affects convergence because of almost-overflows and precision-loss problems.  The fixed things help keep pressures low and so prevent these awful behaviours.   the movement of the saturation front is the same regardless of the fixed things.
  active = &#x27;recharge fixedoil fixedwater&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pwater
    boundary = &#x27;left&#x27;
    pressures = &#x27;-1E10 1E10&#x27;
    bare_fluxes = &#x27;-1 -1&#x27;
    use_mobility = false
    use_relperm = false
  [../]
  [./fixedwater]
    type = DirichletBC
    variable = pwater
    boundary = &#x27;right&#x27;
    value = 0
  [../]
  [./fixedoil]
    type = DirichletBC
    variable = poil
    boundary = &#x27;right&#x27;
    value = 15
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.25
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityOil&#x27;
    relperm_UO = &#x27;RelPerm RelPerm&#x27;
    SUPG_UO = &#x27;SUPGstandard SUPGstandard&#x27;
    sat_UO = &#x27;Saturation Saturation&#x27;
    seff_UO = &#x27;SeffWater SeffOil&#x27;
    viscosity = &#x27;1E-3 2E-3&#x27;
    gravity = &#x27;0E-0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = rsc02
  interval = 100000
  execute_on = &#x27;initial timestep_end final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="99855d40-af89-46b0-9872-c95da71183a8"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free.i</h4><pre class="moose-pre"><code class="language-text"># Test to verify the fundamental natural frequency of a one element ADComputeShellStress
# BCs: Clamped on one end, free on others.
# Initial perturbation applied to edge of the beam. After that, the shell vibrates freely.
#
# Results have been compared for various thicknesses with the following approximate Results
# (Moose results were obtained with 8 elements along the length)
# Thickness = 0.1. Reference freq: 10.785 Hz, Moose freq: 10.612 Hz
# Thickness = 0.05. Reference freq: 5.393 Hz, Moose freq: 5.335 Hz
# Thickness = 0.025. Reference freq: 2.696 Hz, Moose freq: 2.660 Hz
#
# Reference values have been obtained from Robert Blevins, &quot;Formulas for Dynamics, Acoustics and Vibration&quot;,
# Table 5.3 case 11. Formula looks like: f = lambda^2/(2*pi*a^2) * sqrt(E*h^2/(12*(1-nu*nu))), where lambda
# changes as a function of shell dimensions.

# This test uses one single element for speed reasons.

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1 # 1
  ny = 1# 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.5
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./rot_x]
  [../]
  [./rot_y]
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  # aux variables for dynamics
  [./vel_x]
  [../]
  [./vel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_x]
  [../]
  [./accel_y]
  [../]
  [./accel_z]
  [../]
  [./rot_vel_x]
  [../]
  [./rot_vel_y]
  [../]
  [./rot_accel_x]
  [../]
  [./rot_accel_y]
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    variable = stress_yy
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    variable = stress_yz
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 2
  [../]

# Kernels for dynamics
[./accel_x]
  type = NewmarkAccelAux
  variable = accel_x
  displacement = disp_x
  velocity = vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_x]
  type = NewmarkVelAux
  variable = vel_x
  acceleration = accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_y]
  type = NewmarkAccelAux
  variable = accel_y
  displacement = disp_y
  velocity = vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_y]
  type = NewmarkVelAux
  variable = vel_y
  acceleration = accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_z]
  type = NewmarkAccelAux
  variable = accel_z
  displacement = disp_z
  velocity = vel_z
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_z]
  type = NewmarkVelAux
  variable = vel_z
  acceleration = accel_z
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_x]
  type = NewmarkAccelAux
  variable = rot_accel_x
  displacement = rot_x
  velocity = rot_vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_x]
  type = NewmarkVelAux
  variable = rot_vel_x
  acceleration = rot_accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_y]
  type = NewmarkAccelAux
  variable = rot_accel_y
  displacement = rot_y
  velocity = rot_vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_y]
  type = NewmarkVelAux
  variable = rot_vel_y
  acceleration = rot_accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_function]
    type = PiecewiseLinear
    x = &#x27;0.0 0.01 0.15 10.0&#x27;
    y = &#x27;0.0 0.01 0.0 0.0&#x27;
  [../]
[]
[NodalKernels]
  [./force_z2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;top&#x27;
    function = force_function
  [../]
[]
[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
  [../]

  [./inertial_force_x]
    type = ADInertialForceShell
    # use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 0
    variable = disp_x
    thickness = 0.1
  [../]

  [./inertial_force_y]
    type = ADInertialForceShell
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 1
    variable = disp_y
    thickness = 0.1

  [../]

  [./inertial_force_z]
    type = ADInertialForceShell
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 2
    variable = disp_z
    thickness = 0.1

  [../]

  [./inertial_force_rot_x]
    type = ADInertialForceShell
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 3
    variable = rot_x
    thickness = 0.1
  [../]

  [./inertial_force_rot_y]
    type = ADInertialForceShell
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 4
    variable = rot_y
    thickness = 0.1
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 2100000
    poissons_ratio = 0.3
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeIncrementalShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 0.1
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_z_tip]
    type = PointValue
    point = &#x27;1.0 1.0 0.0&#x27;
    variable = disp_z
  [../]
  [./rot_x_tip]
    type = PointValue
    point = &#x27;0.0 1.0 0.0&#x27;
    variable = rot_x
  [../]
  [./stress_yy_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yy
  [../]
  [./stress_yy_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yy
  [../]
  [./stress_yy_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yy
  [../]
  [./stress_yy_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yy
  [../]
  [./stress_yz_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yz
  [../]
  [./stress_yz_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yz
  [../]
  [./stress_yz_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yz
  [../]
  [./stress_yz_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yz
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-10
  l_max_its = 20
  dt = 0.005
  dtmin = 0.005
  timestep_tolerance = 2e-13
  end_time = 0.5

  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Outputs]
  perf_graph = true
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5d2dd839-db74-4cf7-b300-3c7d65231bc8"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/diffusion_3d_hex27.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 3
  ny = 4
  nz = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.2
  elem_type = HEX27
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./square_planar_cut_uo]
    type = RectangleCutUserObject
    cut_data = &#x27;  0.35 1.01 -0.001
                  0.35 0.49 -0.001
                  0.35 0.49  0.201
                  0.35 1.01  0.201&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = left
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="18aaeebe-6a4f-4553-a14e-501256afdb80"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/generalized_plane_strain/out_of_plane_pressure.i</h4><pre class="moose-pre"><code class="language-text"># Tests for application of out-of-plane pressure in generalized plane strain.

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  [../]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./scalar_strain_zz]
    order = FIRST
    family = SCALAR
  [../]
[]

[AuxVariables]
  [./saved_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./saved_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  [./strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./react_z]
    type = MaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./GeneralizedPlaneStrain]
      [./gps]
        use_displaced_mesh = true
        displacements = &#x27;disp_x disp_y&#x27;
        scalar_out_of_plane_strain = scalar_strain_zz
        out_of_plane_pressure = traction_function
        factor = 1e5
      [../]
    [../]
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = false
    displacements = &#x27;disp_x disp_y&#x27;
    save_in = &#x27;saved_x saved_y&#x27;
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]

  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_xy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./traction_function]
    type = PiecewiseLinear
    x = &#x27;0  2&#x27;
    y = &#x27;0  1&#x27;
  [../]
[]

[BCs]
  [./leftx]
    type = DirichletBC
    boundary = 3
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elastic_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./strain]
    type = ComputePlaneSmallStrain
    displacements = &#x27;disp_x disp_y&#x27;
    scalar_out_of_plane_strain = scalar_strain_zz
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  line_search = none

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-4

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-11

# time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
  num_steps = 5000
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cce58486-248b-423e-be43-48d7102e4c03"><div class="modal-content"><h4>modules/navier_stokes/test/tests/ins/jeffery_hamel/wedge_dirichlet.i</h4><pre class="moose-pre"><code class="language-text"># This input file tests whether we can converge to the semi-analytical
# solution for flow in a 2D wedge.
[GlobalParams]
  gravity = &#x27;0 0 0&#x27;

  # Params used by the WedgeFunction for computing the exact solution.
  # The value of K is only required for comparing the pressure to the
  # exact solution, and is computed by the associated jeffery_hamel.py
  # script.
  alpha_degrees = 15
  Re = 30
  K = -9.78221333616
  f = f_theta
[]

[Mesh]
  [file]
    type = FileMeshGenerator
    # file = wedge_4x6.e
    file = wedge_8x12.e
    # file = wedge_16x24.e
    # file = wedge_32x48.e
    # file = wedge_64x96.e
  []
  [./corner_node]
    # Pin is on the centerline of the channel on the left-hand side of
    # the domain at r=1.  If you change the domain, you will need to
    # update this pin location for the pressure exact solution to
    # work.
    type = ExtraNodesetGenerator
    new_boundary = pinned_node
    coord = &#x27;1 0&#x27;
    input = file
  [../]
[]


[Variables]
  [./vel_x]
    order = SECOND
    family = LAGRANGE
  [../]
  [./vel_y]
    order = SECOND
    family = LAGRANGE
  [../]
  [./p]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./mass]
    type = INSMass
    variable = p
    u = vel_x
    v = vel_y
    p = p
  [../]
  [./x_momentum_time]
    type = INSMomentumTimeDerivative
    variable = vel_x
  [../]
  [./x_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_x
    u = vel_x
    v = vel_y
    p = p
    component = 0
  [../]
  [./y_momentum_time]
    type = INSMomentumTimeDerivative
    variable = vel_y
  [../]
  [./y_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_y
    u = vel_x
    v = vel_y
    p = p
    component = 1
  [../]
[]

[BCs]
  [./vel_x_no_slip]
    type = DirichletBC
    variable = vel_x
    boundary = &#x27;top_wall bottom_wall&#x27;
    value = 0.0
  [../]
  [./vel_y_no_slip]
    type = DirichletBC
    variable = vel_y
    boundary = &#x27;top_wall bottom_wall&#x27;
    value = 0.0
  [../]
  [./vel_x_inlet]
    type = FunctionDirichletBC
    variable = vel_x
    boundary = &#x27;inlet outlet&#x27;
    function = &#x27;vel_x_exact&#x27;
  [../]
  [./vel_y_inlet]
    type = FunctionDirichletBC
    variable = vel_y
    boundary = &#x27;inlet outlet&#x27;
    function = &#x27;vel_y_exact&#x27;
  [../]
  [./pressure_pin]
    type = DirichletBC
    variable = p
    boundary = &#x27;pinned_node&#x27;
    value = 0
  [../]
[]

[Materials]
  [./const]
    type = GenericConstantMaterial
    block = 1
    prop_names = &#x27;rho mu&#x27;
    prop_values = &#x27;1  1&#x27;
  [../]
[]

[Preconditioning]
  [./SMP_PJFNK]
    type = SMP
    full = true
    solve_type = NEWTON
  [../]
[]

[Executioner]
  type = Transient
  dt = 1.e-2
  dtmin = 1.e-2
  num_steps = 5
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type -sub_pc_factor_levels&#x27;
  petsc_options_value = &#x27;300                bjacobi  ilu          4&#x27;
  line_search = none
  nl_rel_tol = 1e-13
  nl_abs_tol = 1e-11
  nl_max_its = 10
  l_tol = 1e-6
  l_max_its = 300
[]

[Outputs]
  exodus = true
[]

[Functions]
  [./f_theta]
    # Non-dimensional solution values f(eta), 0 &lt;= eta &lt;= 1 for
    # alpha=15 deg, Re=30.  Note: this introduces an input file
    # ordering dependency: this Function must appear *before* the two
    # functions below which use it since apparently proper dependency
    # resolution is not done in this scenario.
    type = PiecewiseLinear
    data_file = &#x27;f.csv&#x27;
    format = &#x27;columns&#x27;
  [../]
  [./vel_x_exact]
    type = WedgeFunction
    var_num = 0
    mu = 1
    rho = 1
  [../]
  [./vel_y_exact]
    type = WedgeFunction
    var_num = 1
    mu = 1
    rho = 1
  [../]
  [./p_exact]
    type = WedgeFunction
    var_num = 2
    mu = 1
    rho = 1
  [../]
[]

[Postprocessors]
  [./vel_x_L2_error]
    type = ElementL2Error
    variable = vel_x
    function = vel_x_exact
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./vel_y_L2_error]
    type = ElementL2Error
    variable = vel_y
    function = vel_y_exact
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./p_L2_error]
    type = ElementL2Error
    variable = p
    function = p_exact
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6dc2e1b9-edf6-48b0-8da8-84929b37200b"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test15.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_rows_more_data.csv
    xy_in_file_only = false
    x_index_in_file = 3 # will generate an error because no forth row of data
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6b601c43-bbbc-47f9-b1f2-394fa2b534ff"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/scalar_material_damage/scalar_material_damage_creep.i</h4><pre class="moose-pre"><code class="language-text"># This is a basic test of the system for continuum damage mechanics
# materials. It uses ScalarMaterialDamage for the damage model,
# which simply gets its damage index from another material. In this
# case, we prescribe the evolution of the damage index using a
# function. A single element has a fixed prescribed displacement
# on one side that puts the element in tension, and then the
# damage index evolves from 0 to 1 over time, and this verifies
# that the stress correspondingly drops to 0.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX8
[]

[AuxVariables]
  [damage_index]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Modules/TensorMechanics/Master]
  [all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_xx strain_xx creep_strain_xx&#x27;
  []
[]

[AuxKernels]
  [damage_index]
    type = MaterialRealAux
    variable = damage_index
    property = damage_index_prop
    execute_on = timestep_end
  []
[]

[BCs]
  [symmy]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0
  []
  [symmx]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0
  []
  [symmz]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0
  []
  [axial_load]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0.01
  []
[]

[Functions]
  [damage_evolution]
    type = PiecewiseLinear
    xy_data = &#x27;0.0   0.0
               0.1   0.0
               2.1   2.0&#x27;
  []
[]

[Materials]
  [damage_index]
    type = GenericFunctionMaterial
    prop_names = damage_index_prop
    prop_values = damage_evolution
  []
  [damage]
    type = ScalarMaterialDamage
    damage_index = damage_index_prop
  []
  [stress]
    type = ComputeMultipleInelasticStress
    damage_model = damage
    inelastic_models = &#x27;creep&#x27;
  []
  [kelvin_voigt]
    type = GeneralizedKelvinVoigtModel
    creep_modulus = &#x27;10e9 10e9&#x27;
    creep_viscosity = &#x27;1 10&#x27;
    poisson_ratio = 0.2
    young_modulus = 10e9
  []
  [creep]
    type = LinearViscoelasticStressUpdate
  []
[]

[UserObjects]
  [./update]
    type = LinearViscoelasticityManager
    viscoelastic_model = kelvin_voigt
  [../]
[]

[Postprocessors]
  [stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  []
  [strain_xx]
    type = ElementAverageValue
    variable = strain_xx
  []
  [./creep_strain_xx]
    type = ElementAverageValue
    variable = creep_strain_xx
  [../]
  [damage_index]
    type = ElementAverageValue
    variable = damage_index
  []
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  l_max_its  = 50
  l_tol      = 1e-8
  nl_max_its = 20
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-8

  dt = 0.1
  dtmin = 0.001
  end_time = 1.1
[]

[Outputs]
  csv=true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8b460a21-bd60-47d4-9e43-32f0d3bd9613"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test2q.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test2q.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_abs_tol = 1e-7
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test2q_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="57055127-330e-4e49-89af-ee3d30c0269b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_gravity.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction
# Test uses NodalGravity instead of UserForcingFunctionNodalKernel to apply the
# force.

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass = 0.01899772 at the cantilever end
# mass = 2.0 at the fixed end (just for file testing purposes does not alter result)

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first frequency of this beam is:
# f1 = 1/(2 pi) * sqrt(3EI/(mL^3)) = 0.25

# This implies that the corresponding time period of this beam is 4s.

# The FEM solution for this beam with 10 element gives time periods of 4s with time step of 0.01s.
# A higher time step of 0.1 s is used in the test to reduce computational time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y                vel_y                accel_y
# 0.0    0.0                   0.0                  0.0
# 0.1    0.0013076435060869    0.026152870121738    0.52305740243477
# 0.2    0.0051984378734383    0.051663017225289   -0.01285446036375
# 0.3    0.010269120909367     0.049750643493289   -0.02539301427625
# 0.4    0.015087433925158     0.046615616822532   -0.037307519138892
# 0.5    0.019534963888307     0.042334982440433   -0.048305168503101

[Mesh]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  nx = 10
  dim = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = NodalGravity
    variable = disp_y
    boundary = &#x27;left right&#x27;
    gravity_value = 52.6378954948 # inverse of nodal mass at cantilever end
    function = force
  #  nodal_mass_file = nodal_mass.csv # commented out for testing purposes
  # mass = 0.01899772 # commented out for testing purposes
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  file_base = dyn_euler_small_added_mass_out
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c949d621-e698-41f2-a72e-72d07641486a"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh08.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = true
# supg = true
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-3
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-3
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 2
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh08
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="68bc077e-9ac3-4723-b7a3-fb1c49105323"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/elastic_patch/elastic_patch.i</h4><pre class="moose-pre"><code class="language-text"># Patch Test

# This test is designed to compute constant xx, yy, zz, xy, yz, and zx
#  stress on a set of irregular hexes.  The mesh is composed of one
#  block with seven elements.  The elements form a unit cube with one
#  internal element.  There is a nodeset for each exterior node.

# The cube is displaced by 1e-6 units in x, 2e-6 in y, and 3e-6 in z.
#  The faces are sheared as well (1e-6, 2e-6, and 3e-6 for xy, yz, and
#  zx).  This gives a uniform strain/stress state for all six unique
#  tensor components.

# With Young&#x27;s modulus at 1e6 and Poisson&#x27;s ratio at 0, the shear
#  modulus is 5e5 (G=E/2/(1+nu)).  Therefore,
#
#  stress xx = 1e6 * 1e-6 = 1
#  stress yy = 1e6 * 2e-6 = 2
#  stress zz = 1e6 * 3e-6 = 3
#  stress xy = 2 * 5e5 * 1e-6 / 2 = 0.5
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 5e5 * 2e-6 / 2 = 1
#  stress zx = 2 * 5e5 * 3e-6 / 2 = 1.5

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  block = &#x27;1 2 3 4 5 6 7&#x27;
[]

[Mesh]#Comment
  file = elastic_patch.e
[] # Mesh

[Functions]
  [./rampConstant1]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 1e-6
  [../]
  [./rampConstant2]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 2e-6
  [../]
  [./rampConstant3]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 3e-6
  [../]
  [./rampConstant4]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 4e-6
  [../]
  [./rampConstant6]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 6e-6
  [../]
[] # Functions

[Variables]

  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]

[] # Variables

[AuxVariables]

  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_energy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./hydrostatic]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./firstinv]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./secondinv]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./thirdinv]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./maxprincipal]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./midprincipal]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./minprincipal]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./direction]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./max_shear]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./sint]
    order = CONSTANT
    family = MONOMIAL
  [../]

[] # AuxVariables

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]

  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zx
    index_i = 2
    index_j = 0
  [../]
  [./elastic_energy]
    type = ElasticEnergyAux
    variable = elastic_energy
  [../]
  [./vonmises]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = vonmises
    scalar_type = vonmisesStress
  [../]
  [./hydrostatic]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = hydrostatic
    scalar_type = hydrostatic
  [../]
  [./fi]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = firstinv
    scalar_type = firstinvariant
  [../]
  [./si]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = secondinv
    scalar_type = secondinvariant
  [../]
  [./ti]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = thirdinv
    scalar_type = thirdinvariant
  [../]
  [./maxprincipal]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = maxprincipal
    scalar_type = MaxPRiNCIpAl
  [../]
  [./midprincipal]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = midprincipal
    scalar_type = MidPRiNCIpAl
  [../]
  [./minprincipal]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = minprincipal
    scalar_type = MiNPRiNCIpAl
  [../]
  [./direction]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = direction
    scalar_type = direction
    direction = &#x27;1 1 1&#x27;
  [../]
  [./max_shear]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = max_shear
    scalar_type = MaxShear
  [../]
  [./sint]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = sint
    scalar_type = StressIntensity
  [../]


[] # AuxKernels

[BCs]

  [./node1_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./node1_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = rampConstant2
  [../]
  [./node1_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 1
    function = rampConstant3
  [../]

  [./node2_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = rampConstant1
  [../]
  [./node2_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = rampConstant2
  [../]
  [./node2_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 2
    function = rampConstant6
  [../]

  [./node3_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 3
    function = rampConstant1
  [../]
  [./node3_y]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
  [./node3_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 3
    function = rampConstant3
  [../]

  [./node4_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./node4_y]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
  [./node4_z]
    type = DirichletBC
    variable = disp_z
    boundary = 4
    value = 0.0
  [../]

  [./node5_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 5
    function = rampConstant1
  [../]
  [./node5_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = rampConstant4
  [../]
  [./node5_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 5
    function = rampConstant3
  [../]

  [./node6_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 6
    function = rampConstant2
  [../]
  [./node6_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 6
    function = rampConstant4
  [../]
  [./node6_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 6
    function = rampConstant6
  [../]

  [./node7_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 7
    function = rampConstant2
  [../]
  [./node7_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 7
    function = rampConstant2
  [../]
  [./node7_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 7
    function = rampConstant3
  [../]

  [./node8_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 8
    function = rampConstant1
  [../]
  [./node8_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 8
    function = rampConstant2
  [../]
  [./node8_z]
    type = DirichletBC
    variable = disp_z
    boundary = 8
    value = 0.0
  [../]


[] # BCs

[Materials]

  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./strain]
    type = ComputeFiniteStrain
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

[] # Materials

[Executioner]

  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10

  l_max_its = 20

  start_time = 0.0
  dt = 1.0
  num_steps = 2
  end_time = 2.0
[] # Executioner

[Outputs]
  exodus = true
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="055eaebe-2d31-4676-b518-8731fc65c1ea"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh_fu_17.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = false
# gravity = true
# full upwinding = true
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 0.1
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 0.01
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 1
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFullyUpwindFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-15 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh_fu_17
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7972801f-21ab-4c58-a9c1-19de4d11eb99"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/1D/1d_lumped_explicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for central difference integration for a 1D element

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    xmin = 0
    xmax = 10
    nx = 5
    dim = 1
  [../]
[]

[Variables]
  [./disp_x]
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
[]

[NodalKernels]
  [./force_x]
    type = UserForcingFunctionNodalKernel
    variable = disp_x
    boundary = right
    function = force_x
  [../]
[]

[Functions]
  [./force_x]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # force
    scale_factor = 1e3
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 2500
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.01
  end_time = 0.1
  timestep_tolerance = 2e-10
  dt = 0.005
  [./TimeIntegrator]
    type = CentralDifference
    solve_type = lumped
  [../]
[]

[Postprocessors]
  [./accel_x]
    type = PointValue
    point = &#x27;10.0 0.0 0.0&#x27;
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="830dd845-95d4-4fca-849b-c86f59db194d"><div class="modal-content"><h4>test/tests/functions/vector_postprocessor_function/vector_postprocessor_function.i</h4><pre class="moose-pre"><code class="language-text">#This function linearly interpolates the data generated by a vector post
#processor. The purpose is to have a function take points and a field variable
#(aux or primary) as arguments.
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 4
  xmin = 0.0
  xmax = 0.004
  ymin = 0.0
  ymax = 0.008
[]

[Variables]
  [./u]
    initial_condition = 0
  [../]
[]

[AuxVariables]
  [./v]
    initial_condition = 1
  [../]
[]

[Functions]
  [./ramp_u]
    type = ParsedFunction
    value = &#x27;t&#x27;
  [../]
  [./point_value_function_u]
    type = VectorPostprocessorFunction
    component = y
    argument_column = y
    value_column = u
    vectorpostprocessor_name = point_value_vector_postprocessor_u
  [../]
  [./line_value_function_v]
    type = VectorPostprocessorFunction
    component = y
    argument_column = y
    value_column = v
    vectorpostprocessor_name = line_value_vector_postprocessor_v
  [../]
  [./function_v]
    type = PiecewiseLinear
    x = &#x27;0 0.008&#x27;
    y = &#x27;1 2&#x27;
    axis = y
  [../]
[]

[Kernels]
  [./diffusion_u]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
[./aux_v]
  type = FunctionAux
  variable = v
  function = function_v
[../]
[]

[BCs]
  [./top_u]
    type = FunctionDirichletBC
    boundary = top
    variable = u
    function = ramp_u
  [../]
  [./bottom_u]
    type = DirichletBC
    boundary = bottom
    variable = u
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27; lu       superlu_dist                 51&#x27;
  line_search = &#x27;none&#x27;
  l_max_its = 50
  l_tol = 1e-3
  nl_max_its = 20
  nl_rel_tol = 1e-4
  nl_abs_tol = 1e-6
  start_time = 0
  num_steps = 1
  dt = 1
[]
[Postprocessors]
  [./point_value_postprocessor_u]
    type = FunctionValuePostprocessor
    function = point_value_function_u
    point = &#x27;0.002 0.004 0&#x27;
  [../]
  [./line_value_postprocessor_v]
    type = FunctionValuePostprocessor
    function = line_value_function_v
    point = &#x27;0.002 0.004 0&#x27;
  [../]
  [./postprocessor_average_u]
    type = ElementAverageValue
    variable = u
  [../]
  [./postprocessor_average_v]
    type = ElementAverageValue
    variable = v
  [../]
[]
[VectorPostprocessors]
  [./point_value_vector_postprocessor_u]
    type = PointValueSampler
    variable = u
    points = &#x27;0 0.001 0 0 0.004 0 0 0.008 0&#x27;
    #points = &#x27;0.001 0 0 0.002 0 0&#x27;
    sort_by = y
    execute_on = linear
  [../]
  [./line_value_vector_postprocessor_v]
    type = LineValueSampler
    variable = v
    start_point = &#x27;0 0.001 0&#x27;
    end_point = &#x27;0 0.008 0&#x27;
    num_points = 5
    sort_by = y
    execute_on = linear
  [../]
[]
[Outputs]
  interval = 1
  csv = false
  exodus = true
  file_base = out
  [./console]
    type = Console
    output_linear = true
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d77fce90-3eee-4dd0-9bc3-9bc47a2c3c2d"><div class="modal-content"><h4>modules/contact/test/tests/ring_contact/ring_contact.i</h4><pre class="moose-pre"><code class="language-text">#
# A test of contact with quadratic (Hex20) elements
#
# A stiff ring is pushed into a soft base.  The base shows a circular impression.
#

[GlobalParams]
  order = SECOND
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = false
[]

[Mesh]
  file = ring_contact.e
[]

[Functions]
  [./ring_y]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 1&#x27;
    scale_factor = -0.2
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = FINITE
  [../]
[]

[Contact]
  [./dummy_name]
    primary = 3
    secondary = 2
    penalty = 1e3
    tension_release = -1
  [../]
[]

[BCs]
  [./plane]
    type = DirichletBC
    variable = disp_z
    boundary = 10
    value = 0.0
  [../]

  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]

  [./bottom_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]

  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]

  [./ring_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]

  [./ring_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = ring_y
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stiffStuff2]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e3
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]  # Materials

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       101&#x27;
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1.e-10
  l_max_its = 100
  nl_max_its = 10
  dt = 0.1
  end_time = 0.5

  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="424c52a3-2bd4-4eb3-86a2-d95045eeff0d"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_convex/gap_heat_transfer_convex_gap_offsets.i</h4><pre class="moose-pre"><code class="language-text">#The two blocks were moved apart by the value of 0.005 in the y-direction, respectively.
#This value was compensated by the gap offsets from both slave and master sides
[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  temperature = temp
[]

[Mesh]
  file = gap_heat_transfer_convex_gap_offsets.e
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0 2.0&#x27;
    y = &#x27;0 1.0&#x27;
  [../]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0     1&#x27;
    y = &#x27;200 200&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]

  [./temp]
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./primary_gap_offset]
  [../]
  [./secondary_gap_offset]
  [../]
  [./mapped_primary_gap_offset]
  [../]
[]

[AuxKernels]
  [./primary_gap_offset]
    type = ConstantAux
    variable = primary_gap_offset
    value = -0.005
    boundary = 2
  [../]
  [./mapped_primary_gap_offset]
    type = GapValueAux
    variable = mapped_primary_gap_offset
    paired_variable = primary_gap_offset
    boundary = 3
    paired_boundary = 2
  [../]
  [./secondary_gap_offset]
    type = ConstantAux
    variable = secondary_gap_offset
    value = -0.005
    boundary = 3
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    master = 2
    slave = 3
    emissivity_master = 0
    emissivity_slave = 0
    secondary_gap_offset = secondary_gap_offset
    mapped_primary_gap_offset = mapped_primary_gap_offset
  [../]
[]

[Modules/TensorMechanics/Master/All]
  volumetric_locking_correction = true
  strain = FINITE
  eigenstrain_names = eigenstrain
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]

[BCs]
  [./move_right]
    type = FunctionDirichletBC
    boundary = &#x27;3&#x27;
    variable = disp_x
    function = disp
  [../]

  [./fixed_x]
    type = DirichletBC
    boundary = &#x27;1&#x27;
    variable = disp_x
    value = 0
  [../]
  [./fixed_y]
    type = DirichletBC
    boundary = &#x27;1 2 3 4&#x27;
    variable = disp_y
    value = 0
  [../]
  [./fixed_z]
    type = DirichletBC
    boundary = &#x27;1 2 3 4&#x27;
    variable = disp_z
    value = 0
  [../]

  [./temp_bottom]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_top]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    stress_free_temperature = 100
    thermal_expansion_coeff = 0
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

  [./heat1]
    type = HeatConductionMaterial
    block = 1

    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]
  [./heat2]
    type = HeatConductionMaterial
    block = 2

    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  dt = 0.1
  end_time = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d6dfa47a-3b2a-431e-98d7-252caab66286"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh_lumped_17.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = false
# gravity = true
# supg = true
# transient = true
# lumped = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
  viscosity = &#x27;1E-3 0.5E-3&#x27;
  gravity = &#x27;-1 0 0&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 0.1
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 0.01
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 1
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-15 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh_lumped_17
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c3feffd1-c180-480b-98f8-30340a87fda2"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/time_integration/hht_test_ti.i</h4><pre class="moose-pre"><code class="language-text"># Test for  HHT time integration

# The test is for an 1D bar element of  unit length fixed on one end
# with a ramped pressure boundary condition applied to the other end.
# alpha, beta and gamma are HHT time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel + alpha*(K*disp - K*disp_old) + K*disp = P(t+alpha dt)*Area
#
# Here M is the mass matrix, K is the stiffness matrix, P is the applied pressure
#
# This equation is equivalent to:
#
# density*accel + alpha*(Div stress - Div stress_old) +Div Stress= P(t+alpha dt)
#
# The first term on the left is evaluated using the Inertial force kernel
# The next two terms on the left involving alpha are evaluated using the
# DynamicStressDivergenceTensors Kernel
# The residual due to Pressure is evaluated using Pressure boundary condition
#
# The system will come to steady state slowly after the pressure becomes constant.
# Alpha equal to zero will result in Newmark integration.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    alpha = 0.11
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
  [../]

[]

[AuxKernels]
  [./accel_x] # These auxkernls are only for checking output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]
[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = bottom
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
      disp_z = disp_z
      factor = 1
      alpha = 0.11
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 2
  dt = 0.1

  # Time integration scheme
  scheme = &#x27;newmark-beta&#x27;
[]


[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 1.0 2.0 5.0&#x27;
    y = &#x27;0.0 0.1 0.2 1.0 1.0 1.0&#x27;
    scale_factor = 1e9
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalMaxValue
    variable = disp_y
    boundary = bottom
  [../]
  [./vel]
    type = NodalMaxValue
    variable = vel_y
    boundary = bottom
  [../]
  [./accel]
    type = NodalMaxValue
    variable = accel_y
    boundary = bottom
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./strain_yy]
    type = ElementAverageValue
    variable = strain_yy
  [../]
[]

[Outputs]
  file_base = &#x27;hht_test_out&#x27;
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="de5bff04-fd51-4393-b9d8-6369f40b7f0e"><div class="modal-content"><h4>modules/combined/test/tests/elastic_thermal_patch/elastic_thermal_patch.i</h4><pre class="moose-pre"><code class="language-text"># Patch Test

# This test is designed to compute constant xx, yy, zz, xy, yz, and zx
#  stress on a set of irregular hexes.  The mesh is composed of one
#  block with seven elements.  The elements form a unit cube with one
#  internal element.  There is a nodeset for each exterior node.

# The cube is displaced by 1e-6 units in x, 2e-6 in y, and 3e-6 in z.
#  The faces are sheared as well (1e-6, 2e-6, and 3e-6 for xy, yz, and
#  zx).  This gives a uniform strain/stress state for all six unique
#  tensor components.

# With Young&#x27;s modulus at 1e6 and Poisson&#x27;s ratio at 0, the shear
#  modulus is 5e5 (G=E/2/(1+nu)).  Therefore, for the mechanical strain,
#
#  stress xx = 1e6 * 1e-6 = 1
#  stress yy = 1e6 * 2e-6 = 2
#  stress zz = 1e6 * 3e-6 = 3
#  stress xy = 2 * 5e5 * 1e-6 / 2 = 0.5
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 5e5 * 2e-6 / 2 = 1
#  stress zx = 2 * 5e5 * 3e-6 / 2 = 1.5

# However, we must also consider the thermal strain.
# The temperature moves 100 degrees, and the coefficient of thermal
#  expansion is 1e-8.  Therefore, the thermal strain (and the displacement
#  since this is a unit cube) is 1e-6.

# Therefore, the overall effect is (at time 1, with a 50 degree delta):
#
#  stress xx = 1e6 * (1e-6-0.5e-6) = 0.5
#  stress yy = 1e6 * (2e-6-0.5e-6) = 1.5
#  stress zz = 1e6 * (3e-6-0.5e-6) = 2.5
#  stress xy = 2 * 5e5 * 1e-6 / 2 = 0.5
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 5e5 * 2e-6 / 2 = 1
#  stress zx = 2 * 5e5 * 3e-6 / 2 = 1.5
#
# At time 2:
#
#  stress xx = 1e6 * (1e-6-1e-6) = 0
#  stress yy = 1e6 * (2e-6-1e-6) = 1
#  stress zz = 1e6 * (3e-6-1e-6) = 2
#  stress xy = 2 * 5e5 * 1e-6 / 2 = 0.5
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 5e5 * 2e-6 / 2 = 1
#  stress zx = 2 * 5e5 * 3e-6 / 2 = 1.5

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  temperature = temp
[]

[Mesh]
  file = elastic_thermal_patch_test.e
[]

[Functions]
  [./rampConstant1]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 1e-6
  [../]
  [./rampConstant2]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 2e-6
  [../]
  [./rampConstant3]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 3e-6
  [../]
  [./rampConstant4]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 4e-6
  [../]
  [./rampConstant6]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 6e-6
  [../]
  [./tempFunc]
    type = PiecewiseLinear
    x = &#x27;0. 2.&#x27;
    y = &#x27;117.56 217.56&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]

  [./temp]
    initial_condition = 117.56
  [../]
[]

[Modules/TensorMechanics/Master/All]
  add_variables = true
  strain = FINITE
  eigenstrain_names = eigenstrain
  generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]

[BCs]
  [./node1_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./node1_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = rampConstant2
  [../]
  [./node1_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 1
    function = rampConstant3
  [../]

  [./node2_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = rampConstant1
  [../]
  [./node2_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = rampConstant2
  [../]
  [./node2_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 2
    function = rampConstant6
  [../]

  [./node3_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 3
    function = rampConstant1
  [../]
  [./node3_y]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
  [./node3_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 3
    function = rampConstant3
  [../]

  [./node4_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./node4_y]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
  [./node4_z]
    type = DirichletBC
    variable = disp_z
    boundary = 4
    value = 0.0
  [../]

  [./node5_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 5
    function = rampConstant1
  [../]
  [./node5_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = rampConstant4
  [../]
  [./node5_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 5
    function = rampConstant3
  [../]

  [./node6_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 6
    function = rampConstant2
  [../]
  [./node6_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 6
    function = rampConstant4
  [../]
  [./node6_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 6
    function = rampConstant6
  [../]

  [./node7_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 7
    function = rampConstant2
  [../]
  [./node7_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 7
    function = rampConstant2
  [../]
  [./node7_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 7
    function = rampConstant3
  [../]

  [./node8_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 8
    function = rampConstant1
  [../]
  [./node8_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 8
    function = rampConstant2
  [../]
  [./node8_z]
    type = DirichletBC
    variable = disp_z
    boundary = 8
    value = 0.0
  [../]

  [./temp]
    type = FunctionDirichletBC
    variable = temp
    boundary = &#x27;10 12&#x27;
    function = tempFunc
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    bulk_modulus = 0.333333333333333e6
    shear_modulus = 0.5e6
  [../]
  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    stress_free_temperature = 117.56
    thermal_expansion_coeff = 1e-8
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

  [./heat]
    type = HeatConductionMaterial
    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./density]
    type = Density
    density = 1.0
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-12

  l_max_its = 20

  start_time = 0.0
  dt = 1.0
  num_steps = 2
  end_time = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dff24c6c-d5d6-4208-b432-b30455409248"><div class="modal-content"><h4>modules/combined/test/tests/evolving_mass_density/uniform_expand_compress_test_tensors.i</h4><pre class="moose-pre"><code class="language-text">#  Element mass tests

#  This series of tests is designed to compute the mass of elements based on
#  an evolving mass density calculation.  The tests consist of expansion and compression
#  of the elastic patch test model along each axis, uniform expansion and compression,
#  and shear in each direction.  The expansion and compression tests change the volume of
#  the elements.  The corresponding change in density should compensate for this so the
#  mass remains constant.  The shear tests should not result in a volume change, and this
#  is checked too.  The mass calculation is done with the post processor called Mass.

#  The tests/file names are as follows:

#  Expansion and compression along a single axis
#  expand_compress_x_test_out.e
#  expand_compress_y_test_out.e
#  expand_compress_z_test_out.e

#  Volumetric expansion and compression
#  uniform_expand_compress_test.i

#  Zero volume change shear along each axis
#  shear_x_test_out.e
#  shear_y_test_out.e
#  shear_z_test_out.e

#  The resulting mass calculation for these tests should always be = 1.

# This test is a duplicate of the uniform_expand_compress_test.i test for solid mechanics, and the
#   output of this tensor mechanics test is compared to the original
#   solid mechanics output.  The duplication is necessary to test the
#   migrated tensor mechanics version while maintaining tests for solid mechanics.

[Mesh]
  file = elastic_patch.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./rampConstant2]
    type = PiecewiseLinear
    x = &#x27;0.00 1.00  2.0   3.00&#x27;
    y = &#x27;0.00 0.25  0.0  -0.25&#x27;
    scale_factor = 1
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./TensorMechanics]
  [../]
[]

[BCs]
  [./9_y]
    type = DirichletBC
    variable = disp_y
    boundary = 9
    value = 0
  [../]
  [./10_y]
    type = DirichletBC
    variable = disp_x
    boundary = 10
    value = 0
  [../]
  [./14_y]
    type = DirichletBC
    variable = disp_z
    boundary = 14
    value = 0
  [../]

  [./top]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 11
    function = rampConstant2
  [../]
  [./front]
    type = FunctionDirichletBC
    variable = disp_z
    preset = false
    boundary = 13
    function = rampConstant2
  [../]
  [./side]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = 12
    function = rampConstant2
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2 3 4 5 6 7&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./small_strain]
    type = ComputeSmallStrain
    block = &#x27; 1 2 3 4 5 6 7&#x27;
  [../]

  [./elastic_stress]
    type = ComputeLinearElasticStress
    block = &#x27;1 2 3 4 5 6 7&#x27;
  [../]
[]

[Executioner]

  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10
  l_max_its = 20
  start_time = 0.0
  dt = 1.0
  num_steps = 3
  end_time =3.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
    file_base = uniform_expand_compress_test_out
  [../]
[]

[Postprocessors]
  [./Mass]
    type = Mass
    variable = disp_x
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="29ea5cd9-e45e-4697-abfa-5e51337a452f"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3qns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3q.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.025
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test3qns_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="37b41898-ee0f-4434-aae0-e8d39eacab5c"><div class="modal-content"><h4>modules/combined/test/tests/generalized_plane_strain_tm_contact/out_of_plane_pressure.i</h4><pre class="moose-pre"><code class="language-text"># Tests for application of out-of-plane pressure in generalized plane strain.

[Mesh]
  type = GeneratedMesh
  nx = 2
  ny = 2
  dim = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./scalar_strain_zz]
    order = FIRST
    family = SCALAR
  [../]
[]

[AuxVariables]
  [./saved_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./saved_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./saved_zz]
    order = FIRST
    family = SCALAR
  [../]

  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  [./strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./react_z]
    type = MaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./GeneralizedPlaneStrain]
      [./gps]
        displacements = &#x27;disp_x disp_y&#x27;
        scalar_out_of_plane_strain = scalar_strain_zz
        out_of_plane_pressure = traction_function
        factor = 1e5
      [../]
    [../]
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    displacements = &#x27;disp_x disp_y&#x27;
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[AuxScalarKernels]
  [./gps_ref_res]
    type = GeneralizedPlaneStrainReferenceResidual
    variable = saved_zz
    generalized_plane_strain = gps_GeneralizedPlaneStrainUserObject
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]

  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_xy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./traction_function]
    type = PiecewiseLinear
    x = &#x27;0  2&#x27;
    y = &#x27;0  1&#x27;
  [../]
[]

[BCs]
  [./leftx]
    type = DirichletBC
    boundary = left
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elastic_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./strain]
    type = ComputePlaneSmallStrain
    displacements = &#x27;disp_x disp_y&#x27;
    scalar_out_of_plane_strain = scalar_strain_zz
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  line_search = none

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-4

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-11

# time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
  num_steps = 5000
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8dee9511-faf5-4256-9878-bf5cf6b54b79"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_rz.i</h4><pre class="moose-pre"><code class="language-text">#

[Mesh]
  file = cracking_rz_test.e
[]

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3  4&#x27;
    y = &#x27;0 1 0 -1 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pull]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = displ
  [../]
  [./left]
    type = ADDirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./bottom]
    type = ADDirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 4.0e7
    poissons_ratio = 0.0
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 1.68e6
    softening_models = abrupt_softening
  [../]
  [./abrupt_softening]
    type = ADAbruptSoftening
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton

  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101               &#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-2
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.1
  dt = 0.025
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6fb13707-1b68-4634-89bf-006759523c3a"><div class="modal-content"><h4>modules/contact/test/tests/normal-nodal-lm-tan-tolerance/normal-nodal-lm-tan-tolerance.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  preset = false
[]

[Mesh]
  [file]
    type = FileMeshGenerator
    file = 2blk-gap_no1000.e
  []
[]

[Modules/TensorMechanics/Master]
  [./all]
    displacements = &#x27;disp_x disp_y&#x27;
    strain = FINITE
    add_variables = true
    block = &#x27;1 2&#x27;
    use_automatic_differentiation = true
    scaling = 1e-4
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e5
    poissons_ratio = 0.345
    block = &#x27;1 2&#x27;
  [../]

  [./_elastic_strain]
    type = ADComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Contact]
  [mortar]
    mesh = file
    secondary = 101
    primary = 100
    model = frictionless
    formulation = mortar
    c_normal = 1e4
    tangential_tolerance = .05
    normal_lm_scaling = 1e-3
  []
[]

[Functions]
  [./disp_bc]
    type = PiecewiseLinear
    x = &#x27;0 10.0&#x27;
    y = &#x27;0 -0.30&#x27;
  [../]

[]

[BCs]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./left_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./right_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = &#x27;right&#x27;
    function = disp_bc # &#x27;-30e-3 * t&#x27;
  [../]
  [./right_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = &#x27;right&#x27;
    function = 0
  [../]
[]

[Preconditioning]
  [./fmp]
    type = FDP
    full = true
    finite_difference_type = standard
  [../]
[]

[Executioner]
  solve_type = NEWTON
  type = Transient
  num_steps = 10
  dt = 1
  dtmin = 1
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-13

  petsc_options = &#x27;-ksp_monitor_true_residual -snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type  -snes_linesearch_type -pc_factor_shift_type -snes_max_it  -ksp_max_it&#x27;
  petsc_options_value = &#x27;lu        basic                 NONZERO               20            30&#x27;

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
[]

[Outputs]
  checkpoint = true
  exodus = true
  print_linear_residuals = false
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="22954ce8-78ef-479e-ad27-ded889912783"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test1qtt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1qtt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.06
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test1qtt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0209061b-8378-42a6-ac28-c5ec416767c4"><div class="modal-content"><h4>modules/contact/test/tests/verification/hertz_cyl/quart_symm_q8/hertz_cyl_qsym_1deg_template1.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = hertz_cyl_qsym_1deg_q8.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
  [./tang_force_x]
  [../]
  [./tang_force_y]
  [../]
[]

[Functions]
  [./disp_ramp_vert]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. -0.0020 -0.0020&#x27;
  [../]
  [./disp_ramp_zero]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 0.0 0.0&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./inc_slip_x]
    type = PenetrationAux
    variable = inc_slip_x
    execute_on = timestep_end
    boundary = 4
    paired_boundary = 3
  [../]
  [./inc_slip_y]
    type = PenetrationAux
    variable = inc_slip_y
    execute_on = timestep_end
    boundary = 4
    paired_boundary = 3
  [../]
  [./accum_slip_x]
    type = PenetrationAux
    variable = accum_slip_x
    execute_on = timestep_end
    boundary = 4
    paired_boundary = 3
  [../]
  [./accum_slip_y]
    type = PenetrationAux
    variable = accum_slip_y
    execute_on = timestep_end
    boundary = 4
    paired_boundary = 3
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 4
    paired_boundary = 3
  [../]
  [./tang_force_x]
    type = PenetrationAux
    variable = tang_force_x
    quantity = tangential_force_x
    boundary = 4
    paired_boundary = 3
  [../]
  [./tang_force_y]
    type = PenetrationAux
    variable = tang_force_y
    quantity = tangential_force_y
    boundary = 4
    paired_boundary = 3
  [../]
[]

[Postprocessors]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 1
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 1
  [../]
  [./top_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 5
  [../]
  [./top_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 5
  [../]
  [./disp_x281]
    type = NodalVariableValue
    nodeid = 280
    variable = disp_x
  [../]
  [./_dt]
    type = TimestepSize
  [../]
  [./num_lin_it]
    type = NumLinearIterations
  [../]
  [./num_nonlin_it]
    type = NumNonlinearIterations
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 3&#x27;
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./top_y_disp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = disp_ramp_vert
  [../]
[]

[Materials]
  [./stuff1_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e10
    poissons_ratio = 0.0
  [../]
  [./stuff1_strain]
    type = ComputeFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./stuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./stuff2_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff2_strain]
    type = ComputeFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./stuff2_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
  [./stuff3_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;3&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff3_strain]
    type = ComputeFiniteStrain
    block = &#x27;3&#x27;
  [../]
  [./stuff3_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;3&#x27;
  [../]
  [./stuff4_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;4&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff4_strain]
    type = ComputeFiniteStrain
    block = &#x27;4&#x27;
  [../]
  [./stuff4_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;4&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-7
  nl_rel_tol = 1e-6
  l_max_its = 50
  nl_max_its = 100

  start_time = 0.0
  dt = 0.1
  dtmin = 0.1
  num_steps = 10
  end_time = 1.0
  l_tol = 1e-4
[]

[VectorPostprocessors]
  [./x_disp]
    type = NodalValueSampler
    variable = disp_x
    boundary = &#x27;3 4 5&#x27;
    sort_by = id
  [../]
  [./y_disp]
    type = NodalValueSampler
    variable = disp_y
    boundary = &#x27;3 4 5&#x27;
    sort_by = id
  [../]
  [./cont_press]
    type = NodalValueSampler
    variable = contact_pressure
    boundary = &#x27;4&#x27;
    sort_by = id
  [../]
[]

[Outputs]
  print_linear_residuals = true
  perf_graph = true
  [./exodus]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 5
  [../]
  [./chkfile]
    type = CSV
    show = &#x27;bot_react_x bot_react_y disp_x281 top_react_x top_react_y x_disp y_disp cont_press&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./outfile]
    type = CSV
    delimiter = &#x27; &#x27;
    execute_vector_postprocessors_on = none
  [../]
[]

[Contact]
  [./interface]
    primary = 3
    secondary = 4
    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+11
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e15eead2-6b7e-4b2a-82fd-7cf5903ff093"><div class="modal-content"><h4>modules/richards/test/tests/buckley_leverett/bl20.i</h4><pre class="moose-pre"><code class="language-text"># two-phase version
[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 30
  xmin = 0
  xmax = 15
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;0.1 0.5 0.5 1 2  4&#x27;
    x = &#x27;0   0.1 1   5 40 42&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E6
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-5
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
  [./bounds_dummy]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
  [./richardsppenalty]
    type = RichardsPPenalty
    variable = pgas
    a = 1E-18
    lower_var = pwater
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
  [../]
[]

[Bounds]
  [./pwater_upper_bounds]
    type = ConstantBoundsAux
    variable = bounds_dummy
    bounded_variable = pwater
    bound_type = upper
    bound_value = 1E7
  [../]
  [./pwater_lower_bounds]
    type = ConstantBoundsAux
    variable = bounds_dummy
    bounded_variable = pwater
    bound_type = lower
    bound_value = -310000
  [../]
[]


[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_water
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_gas
  [../]
[]

[BCs]
  [./left_w]
    type = DirichletBC
    variable = pwater
    boundary = left
    value = 1E6
  [../]
  [./left_g]
    type = DirichletBC
    variable = pgas
    boundary = left
    value = 1E6
  [../]
  [./right_w]
    type = DirichletBC
    variable = pwater
    boundary = right
    value = -300000
  [../]
  [./right_g]
    type = DirichletBC
    variable = pgas
    boundary = right
    value = 0
  [../]
[]


[Functions]
  [./initial_water]
    type = ParsedFunction
    value = 1000000*(1-min(x/5,1))-300000*(max(x-5,0)/max(abs(x-5),1E-10))
  [../]
  [./initial_gas]
    type = ParsedFunction
    value = max(1000000*(1-x/5),0)+1000
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.15
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 1E-6&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  active = &#x27;standard&#x27;

  [./bounded]
  # must use --use-petsc-dm command line argument
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -snes_type -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 50 vinewtonssls 1E-20 1E-20&#x27;
  [../]

  [./standard]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -snes_atol -snes_rtol -snes_max_it -ksp_rtol -ksp_atol&#x27;
    petsc_options_value = &#x27;gmres asm lu NONZERO 1E-10 1E-10 20 1E-20 1E-20&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  end_time = 50

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = bl20
  execute_on = &#x27;initial timestep_end final&#x27;
  interval = 10000
  exodus = true
  hide = pgas
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="65fe7852-6750-49b5-94ee-f6d15ba6c6dc"><div class="modal-content"><h4>modules/contact/test/tests/tension_release/4ElemTensionRelease.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = 4ElemTensionRelease.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = false
[]

[Functions]
  [./up]
    type = PiecewiseLinear
    x = &#x27;0 1      2 3&#x27;
    y = &#x27;0 0.0001 0 -.0001&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = FINITE
  []
[]

[Contact]
  [./dummy_name]
    primary = 2
    secondary = 3
    penalty = 1e6
    model = frictionless
    tangential_tolerance = 0.01
  [../]
[]

[BCs]
  [./lateral]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 4&#x27;
    value = 0
  [../]

  [./bottom_up]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = up
  [../]

  [./top]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1.0e6
    poissons_ratio = 0.3
  [../]
  [./stiffStuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      101&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-4

  l_max_its = 100
  nl_max_its = 10
  dt = 0.2
  dtmin = 0.2
  end_time = 3

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="210b62bb-5aa8-450c-84c5-6e18fc85f1e5"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_2d_points.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 2d plane strain model
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  crack_front_points = &#x27;0 -10 0&#x27;
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;4.0 4.5 5.0 5.5 6.0&#x27;
  radius_outer = &#x27;4.5 5.0 5.5 6.0 6.5&#x27;
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = j_integral_2d_points_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bfa48199-38d5-4e19-a832-39b967e68461"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/thermal_expansion_function/finite_const.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function has a constant value,
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# This version of the test uses finite deformation theory.
# The two models produce very similar results.  There are slight
# differences due to the large deformation treatment.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 3
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion_strain1]
    type = ComputeMeanThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 0.5
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
  [./thermal_expansion_strain2]
    type = ComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 2
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (t - tsf) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 1.0
               2 1.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="da3ca1e6-cadb-4078-b199-94b54dd5c7ee"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh04.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated
# production
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1 1E1 1E2 1E3&#x27;
    x = &#x27;0 1E-1 1 1E1 1E2 1E3&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E8
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = -1E6
    point_file = bh02.bh
    SumQuantityUO = borehole_total_outflow_mass
    variable = pressure
    unit_weight = &#x27;0 0 0&#x27;
    character = 1
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
  [../]

  [./fluid_mass0]
    type = RichardsMass
    variable = pressure
    execute_on = timestep_begin
  [../]

  [./fluid_mass1]
    type = RichardsMass
    variable = pressure
    execute_on = timestep_end
  [../]

  [./zmass_error]
    type = FunctionValuePostprocessor
    function = mass_bal_fcn
    execute_on = timestep_end
  [../]

  [./p0]
    type = PointValue
    variable = pressure
    point = &#x27;1 1 1&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 0
  [../]

  [./mass_bal_fcn]
    type = ParsedFunction
    value = abs((a-c+d)/2/(a+c))
    vars = &#x27;a c d&#x27;
    vals = &#x27;fluid_mass1 fluid_mass0 bh_report&#x27;
  [../]

[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 0
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-12 0 0  0 1E-12 0  0 0 1E-12&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    sat_UO = Saturation
    seff_UO = Seff1VG
    SUPG_UO = SUPGstandard
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 1E3
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  file_base = bh04
  exodus = false
  csv = true
  execute_on = timestep_end
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a78ba1b0-a69e-4382-837e-94a0259024e4"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test3qnns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_method = nodal_normal_based
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test3qnns_out
  exodus = true
[]

[NodalNormals]
  boundary = 11
  corner_boundary = 20
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8a9abb76-60d2-4c9a-844c-4e165d840737"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/test_crack_counter.i</h4><pre class="moose-pre"><code class="language-text"># This test is used to verify that the pure test object (TestCrackCounter)
# is correctly using the API for extracting the crack_tip_origin_direction_map
# from XFEM.  The map contains information of the location of all the crack tips
# computed by XFEM.  The TestCrackCounter postprocessor simply returns the
# number of elements in the map which corresponds to the number of cracks.
#
# In this test case 4 prescribed cracks are applied.  Therefore, the
# TestCrackCounter postprocessor returns a value of 4.

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 11
  ny = 11
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;1.0  0.5  0.7  0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
  [./line_seg_cut_uo2]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.0  0.5  0.3  0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
  [./line_seg_cut_uo3]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.5  0.0  0.5  0.3&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
  [./line_seg_cut_uo4]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.5  1.0  0.5  0.7&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    planar_formulation = plane_strain
    add_variables = true
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0  50   100&#x27;
    y=&#x27;0  0.02 0.1&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = bottom
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
  [./topx]
    type = DirichletBC
    boundary = top
    variable = disp_x
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    boundary = top
    variable = disp_y
    function = pull
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 0
  [../]

  [./_elastic_strain]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Postprocessors]
  [./number_of_cracks]
    type = TestCrackCounter
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-9

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 1.0
  num_steps = 5000

  max_xfem_update = 1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c17b4629-197e-4e29-8341-b44709caf44d"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test4tt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4tt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4tt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f38442da-6e97-4d0d-95a0-b815d3136297"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh05.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = false
# supg = false
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGnone
  [../]
  [./SUPGgas]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = RandomIC
    min = 0.2
    max = 0.8
    variable = pwater
  [../]
  [./gas_ic]
    type = RandomIC
    min = 1.2
    max = 1.8
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((p0-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((p0-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh05
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fb0ee7c0-cdce-470e-b437-cde6c875dc5b"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh_fu_07.i</h4><pre class="moose-pre"><code class="language-text">#fullyupwind
[Mesh]
  type = FileMesh
  file = bh07_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  sat_UO = Saturation
  seff_UO = Seff1VG
  SUPG_UO = SUPGstandard
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1000 10000&#x27;
    x = &#x27;100 1000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E8
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[BCs]
  [./fix_outer]
    type = DirichletBC
    boundary = perimeter
    variable = pressure
    value = 1E7
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFullyUpwindFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = 0
    point_file = bh07.bh
    SumQuantityUO = borehole_total_outflow_mass
    variable = pressure
    unit_weight = &#x27;0 0 0&#x27;
    re_constant = 0.1594
    character = 2
    fully_upwind = true
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./fluid_mass]
    type = RichardsMass
    variable = pressure
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E7
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-11 0 0  0 1E-11 0  0 0 1E-11&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 1000
  solve_type = NEWTON

  [./TimeStepper]
    # get only marginally better results for smaller time steps
    type = FunctionDT
    function = dts
  [../]

[]

[Outputs]
  file_base = bh_fu_07
  execute_on = &#x27;initial timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7afeaea7-631a-4258-8652-804107088c3f"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test11.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_columns_more_data.csv #Will generate error because data has more than two columns
    format = columns
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0ee4d248-6af6-49ef-be9b-c4c1f87c082f"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/domain_integral_thermal/interaction_integral_2d_c.i</h4><pre class="moose-pre"><code class="language-text">#This problem from [Wilson 1979] tests the thermal strain term in the
#interaction integral
#
#theta_e = 10 degrees C; a = 252; E = 207000; nu = 0.3; alpha = 1.35e-5
#
#With uniform_refine = 3, KI converges to
#KI = 5.602461e+02 (interaction integral)
#KI = 5.655005e+02 (J-integral)
#
#Both are in good agreement with [Shih 1986]:
#average_value = 0.4857 = KI / (sigma_theta * sqrt(pi * a))
#sigma_theta = E * alpha * theta_e / (1 - nu)
# = 207000 * 1.35e-5 * 10 / (1 - 0.3) = 39.9214
#KI = average_value * sigma_theta * sqrt(pi * a) = 5.656e+02
#
#References:
#W.K. Wilson, I.-W. Yu, Int J Fract 15 (1979) 377-387
#C.F. Shih, B. Moran, T. Nakamura, Int J Fract 30 (1986) 79-102

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = False
[]

[Mesh]
  file = crack2d.e
  displacements = &#x27;disp_x disp_y&#x27;
#  uniform_refine = 3
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./SERD]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 0.1 100.0&#x27;
    y = &#x27;0. 1 1&#x27;
    scale_factor = -68.95 #MPa
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
  [./SERD]
    type = MaterialRealAux
    variable = SERD
    property = strain_energy_rate_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 400
    value = 0.0
  [../]
  [./no_x1]
    type = DirichletBC
    variable = disp_x
    boundary = 900
    value = 0.0
  [../]
  [./Pressure]
    [./crack_pressure]
      boundary = 700
      function = rampConstantUp
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.0
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
  [./powerlawcrp]
    type = PowerLawCreepStressUpdate
    coefficient = 3.125e-21 # 7.04e-17 #
    n_exponent = 3.0
    m_exponent = 0.0
    activation_energy = 0.0
  [../]
[]

[DomainIntegral]
  integrals = &#x27;CIntegral InteractionIntegralKI&#x27;
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;60.0 80.0 100.0 120.0&#x27;
  radius_outer = &#x27;80.0 100.0 120.0 140.0&#x27;
  symmetry_plane = 1
  incremental = true

  # interaction integral parameters
  disp_x = disp_x
  disp_y = disp_y
  block = 1
  youngs_modulus = 207000
  poissons_ratio = 0.3
  inelastic_models = &#x27;powerlawcrp&#x27;
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm         31   preonly   lu      1&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 40

   nl_rel_step_tol= 1e-10
   nl_rel_tol = 1e-10


   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1

[]

[Outputs]
  exodus = true
  csv = true
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [./smp]
    type = SMP
    pc_side = left
    ksp_norm = preconditioned
    full = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e3b5c267-4e0d-4eb4-a3e3-91a4323143b1"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_gps_finite.i</h4><pre class="moose-pre"><code class="language-text"># this test checks the asixymmetric 1D generalized plane strain formulation using finite strains

[GlobalParams]
  displacements = disp_x
  scalar_out_of_plane_strain = scalar_strain_yy
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = line.e
[]

[Variables]
  [./disp_x]
  [../]
  [./scalar_strain_yy]
    order = FIRST
    family = SCALAR
  [../]
[]

[AuxVariables]
  [./strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;580 580 680&#x27;
  [../]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 2e-3&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./GeneralizedPlaneStrain]
      [./gps]
      [../]
    [../]
  [../]
[]

[AuxKernels]
  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./temp]
    type = FunctionAux
    variable = temp
    function = temp
    execute_on = &#x27;timestep_begin&#x27;
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1
    value = 0
    variable = disp_x
  [../]
  [./disp_x]
    type = FunctionDirichletBC
    boundary = 2
    function = disp_x
    variable = disp_x
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./strain]
    type = ComputeAxisymmetric1DFiniteStrain
    eigenstrain_names = eigenstrain
    scalar_out_of_plane_strain = scalar_strain_yy
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-6
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-6
  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 2
  num_steps = 2
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d15a5f49-833a-464e-876c-d36d30190431"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/prescribed_displacement/3D_QStatic_1_Ramped_Displacement.i</h4><pre class="moose-pre"><code class="language-text"># One 3D element under ramped displacement loading.
#
# loading:
# time : 0.0 0.1  0.2  0.3
# disp : 0.0 0.0 -0.01 -0.01

# This displacement loading is applied using the PresetDisplacement boundary condition.

# Here, the given displacement time history is converted to an acceleration
# time history using Backward Euler time differentiation. Then, the resulting
# acceleration is integrated using Newmark time integration to obtain a
# displacement time history which is then applied to the boundary.

# This is done because if the displacement is applied using Dirichlet BC, the
# resulting acceleration is very noisy.

# Boundaries:
# x = 0 left
# x = 1 right
# y = 0 bottom
# y = 1 top
# z = 0 back
# z = 1 front

# Result: The displacement at the top node in the z direction should match
# the prescribed displacement. Also, the z acceleration should
# be two triangular pulses, one peaking at 0.1 and another peaking at
# 0.2.


[Mesh]
  type = GeneratedMesh
  dim = 3 # Dimension of the mesh
  nx = 1 # Number of elements in the x direction
  ny = 1 # Number of elements in the y direction
  nz = 1 # Number of elements in the z direction
  xmin = 0.0
  xmax = 1
  ymin = 0.0
  ymax = 1
  zmin = 0.0
  zmax = 1
  allow_renumbering = false # So NodalVariableValue can index by id
[]

[Variables] # variables that are solved
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables] # variables that are calculated for output
  [./accel_x]
  [../]
  [./vel_x]
  [../]
  [./accel_y]
  [../]
  [./vel_y]
  [../]
  [./accel_z]
  [../]
  [./vel_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics] # zeta*K*vel + K * disp
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    zeta = 0.000025
  [../]
  [./inertia_x] # M*accel + eta*M*vel
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.25 # Newmark time integration
    gamma = 0.5 # Newmark time integration
    eta = 19.63
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.25
    gamma = 0.5
    eta = 19.63
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    gamma = 0.5
    eta = 19.63
  [../]
[]

[AuxKernels]
  [./accel_x] # Calculates and stores acceleration at the end of time step
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x] # Calculates and stores velocity at the end of the time step
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./displacement_front]
    type = PiecewiseLinear
    data_file = &#x27;displacement.csv&#x27;
    format = columns
  [../]
[]

[BCs]
  [./Preset_displacement]
    type = PresetDisplacement
    variable = disp_z
    function = displacement_front
    boundary = front
    beta = 0.25
    velocity = vel_z
    acceleration = accel_z
  [../]
  [./anchor_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./anchor_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./anchor_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    youngs_modulus = 325e6 #Pa
    poissons_ratio = 0.3
    type = ComputeIsotropicElasticityTensor
    block = 0
  [../]
  [./strain]
    #Computes the strain, assuming small strains
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    #Computes the stress, using linear elasticity
    type = ComputeLinearElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 2000 #kg/m3
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 3.0
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  dt = 0.1
  timestep_tolerance = 1e-6
[]

[Postprocessors] # These quantites are printed to a csv file at every time step
  [./_dt]
    type = TimestepSize
  [../]
  [./accel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_x
  [../]
  [./accel_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_y
  [../]
  [./accel_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_z
  [../]
  [./vel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_x
  [../]
  [./vel_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_y
  [../]
  [./vel_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_z
  [../]
  [./disp_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_x
  [../]
  [./disp_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_y
  [../]
  [./disp_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_z
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5476a6bb-1c7b-469a-90d4-5ab93ce1b836"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_it_plot_test.i</h4><pre class="moose-pre"><code class="language-text">#
# 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks containing one element each.  Each
#   element is a unit cube.  They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit, and then held fixed for an additional
#  time unit.  The temperature of the far right boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
#  Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
#  gapK(Tavg) = 1.0*Tavg
#
#
# The heat flux across the gap at time = 2 is then:
#
#  Flux(2) = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors
#


[Mesh]
  file = gap_heat_transfer_htonly_test.e
[]

[Functions]

  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]

  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Materials]

  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]

  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;




  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;


  line_search = &#x27;none&#x27;


  nl_abs_tol = 1e-5
  nl_rel_tol = 1e-12

  l_tol = 1e-10
  l_max_its = 100

  start_time = 0.0
  dt = 1e-1
  end_time = 2.0
[]

[Postprocessors]

  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]


[Outputs]
  file_base = out_it_plot
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial timestep_end nonlinear&#x27;
    nonlinear_residual_dt_divisor = 100
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="98d5c579-8574-4e2d-9d17-bec1ce7d8816"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_exponential_deprecated.i</h4><pre class="moose-pre"><code class="language-text">#
# Test to exercise the exponential stress release
#
# Stress vs. strain should show a linear relationship until cracking,
#   an exponential stress release, a linear relationship back to zero
#   strain, a linear relationship with the original stiffness in
#   compression and then back to zero strain, a linear relationship
#   back to the exponential curve, and finally further exponential
#   stress release.
#

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displx]
    type = PiecewiseLinear
    x = &#x27;0 1       2  3      4 5       6&#x27;
    y = &#x27;0 0.00175 0 -0.0001 0 0.00175 0.0035&#x27;
  [../]
  [./disply]
    type = PiecewiseLinear
    x = &#x27;0 5 6&#x27;
    y = &#x27;0 0 .00175&#x27;
  [../]
  [./displz]
    type = PiecewiseLinear
    x = &#x27;0 2 3&#x27;
    y = &#x27;0 0 .0035&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pullx]
    type = FunctionDirichletBC
    #type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displx
  [../]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]

  [./fix_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]

  [./move_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    function = disply
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;3&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 186.5e9
    poissons_ratio = .316
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 119.3e6
    cracking_release = exponential
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type&#x27;
  petsc_options_value = &#x27;101                lu&#x27;

  line_search = &#x27;none&#x27;
  l_max_its = 100
  l_tol = 1e-6

  nl_max_its = 10
  nl_rel_tol = 1e-12
  nl_abs_tol = 1.e-4

  start_time = 0.0
  dt = 0.02
  dtmin = 0.02
  num_steps = 300
[]

[Outputs]
  exodus = true
  file_base = cracking_exponential_out
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b06411e1-18b8-4d95-a4ba-f315382d2be8"><div class="modal-content"><h4>modules/contact/test/tests/verification/hertz_cyl/quart_symm_q4/hertz_cyl_qsym_1deg_template1.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = hertz_cyl_qsym_1deg_q4.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
  [./tang_force_x]
  [../]
  [./tang_force_y]
  [../]
[]

[Functions]
  [./disp_ramp_vert]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. -0.0020 -0.0020&#x27;
  [../]
  [./disp_ramp_zero]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 0.0 0.0&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./inc_slip_x]
    type = PenetrationAux
    variable = inc_slip_x
    execute_on = timestep_end
    boundary = 4
    paired_boundary = 3
  [../]
  [./inc_slip_y]
    type = PenetrationAux
    variable = inc_slip_y
    execute_on = timestep_end
    boundary = 4
    paired_boundary = 3
  [../]
  [./accum_slip_x]
    type = PenetrationAux
    variable = accum_slip_x
    execute_on = timestep_end
    boundary = 4
    paired_boundary = 3
  [../]
  [./accum_slip_y]
    type = PenetrationAux
    variable = accum_slip_y
    execute_on = timestep_end
    boundary = 4
    paired_boundary = 3
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 4
    paired_boundary = 3
  [../]
  [./tang_force_x]
    type = PenetrationAux
    variable = tang_force_x
    quantity = tangential_force_x
    boundary = 4
    paired_boundary = 3
  [../]
  [./tang_force_y]
    type = PenetrationAux
    variable = tang_force_y
    quantity = tangential_force_y
    boundary = 4
    paired_boundary = 3
  [../]
[]

[Postprocessors]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 1
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 1
  [../]
  [./top_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 5
  [../]
  [./top_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 5
  [../]
  [./ref_resid_x]
    type = NodalL2Norm
    execute_on = timestep_end
    variable = saved_x
  [../]
  [./ref_resid_y]
    type = NodalL2Norm
    execute_on = timestep_end
    variable = saved_y
  [../]
  [./disp_x281]
    type = NodalVariableValue
    nodeid = 280
    variable = disp_x
  [../]
  [./_dt]
    type = TimestepSize
  [../]
  [./num_lin_it]
    type = NumLinearIterations
  [../]
  [./num_nonlin_it]
    type = NumNonlinearIterations
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 3&#x27;
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./top_y_disp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = disp_ramp_vert
  [../]
[]

[Materials]
  [./stuff1_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e10
    poissons_ratio = 0.0
  [../]
  [./stuff1_strain]
    type = ComputeFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./stuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./stuff2_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff2_strain]
    type = ComputeFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./stuff2_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
  [./stuff3_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;3&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff3_strain]
    type = ComputeFiniteStrain
    block = &#x27;3&#x27;
  [../]
  [./stuff3_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;3&#x27;
  [../]
  [./stuff4_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;4&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff4_strain]
    type = ComputeFiniteStrain
    block = &#x27;4&#x27;
  [../]
  [./stuff4_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;4&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-6
  nl_rel_tol = 1e-5
  l_max_its = 50
  nl_max_its = 100

  start_time = 0.0
  dt = 0.1
  dtmin = 0.1
  num_steps = 10
  end_time = 1.0
  l_tol = 1e-3
[]

[VectorPostprocessors]
  [./x_disp]
    type = NodalValueSampler
    variable = disp_x
    boundary = &#x27;3 4 5&#x27;
    sort_by = id
  [../]
  [./y_disp]
    type = NodalValueSampler
    variable = disp_y
    boundary = &#x27;3 4 5&#x27;
    sort_by = id
  [../]
  [./cont_press]
    type = NodalValueSampler
    variable = contact_pressure
    boundary = &#x27;4&#x27;
    sort_by = id
  [../]
[]

[Outputs]
  print_linear_residuals = true
  perf_graph = true
  [./exodus]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 5
  [../]
  [./chkfile]
    type = CSV
    show = &#x27;bot_react_x bot_react_y disp_x281 top_react_x top_react_y x_disp y_disp cont_press&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./outfile]
    type = CSV
    delimiter = &#x27; &#x27;
    execute_vector_postprocessors_on = none
  [../]
[]

[Contact]
  [./interface]
    primary = 3
    secondary = 4
    model = glued
    formulation = kinematic
    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+9
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fcdc9b25-f2f5-4014-bd22-4da721c1a025"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_exponential.i</h4><pre class="moose-pre"><code class="language-text">#
# Test to exercise the exponential stress release
#
# Stress vs. strain should show a linear relationship until cracking,
#   an exponential stress release, a linear relationship back to zero
#   strain, a linear relationship with the original stiffness in
#   compression and then back to zero strain, a linear relationship
#   back to the exponential curve, and finally further exponential
#   stress release.
#

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displx]
    type = PiecewiseLinear
    x = &#x27;0 1       2  3      4 5       6&#x27;
    y = &#x27;0 0.00175 0 -0.0001 0 0.00175 0.0035&#x27;
  [../]
  [./disply]
    type = PiecewiseLinear
    x = &#x27;0 5 6&#x27;
    y = &#x27;0 0 .00175&#x27;
  [../]
  [./displz]
    type = PiecewiseLinear
    x = &#x27;0 2 3&#x27;
    y = &#x27;0 0 .0035&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pullx]
    type = FunctionDirichletBC
    #type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displx
  [../]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]

  [./fix_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]

  [./move_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    function = disply
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;3&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 186.5e9
    poissons_ratio = .316
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 119.3e6
    softening_models = exponential_softening
  [../]
  [./exponential_softening]
    type = ExponentialSoftening
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type&#x27;
  petsc_options_value = &#x27;101                lu&#x27;

  line_search = &#x27;none&#x27;
  l_max_its = 100
  l_tol = 1e-6

  nl_max_its = 10
  nl_rel_tol = 1e-12
  nl_abs_tol = 1.e-4

  start_time = 0.0
  dt = 0.02
  dtmin = 0.02
  num_steps = 300
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="860f63bd-9944-4fff-b96c-f1a5b4fd016c"><div class="modal-content"><h4>test/tests/time_steppers/iteration_adaptive/piecewise_linear.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 50
  ny = 2
  xmax = 5
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./temp_spike]
    type = PiecewiseLinear
    x = &#x27;0 1 1.1 1.2 2&#x27;
    y = &#x27;1 1 2   1   1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./dt]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = u
    boundary = left
    function = temp_spike
  [../]
  [./right]
    type = NeumannBC
    variable = u
    boundary = right
    value = -1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  start_time = 0.0
  end_time = 2.0
  verbose = true
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.9
    optimal_iterations = 10
    timestep_limiting_function = temp_spike
    max_function_change = 0.5
  [../]
[]

[Postprocessors]
  [./dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7c92e63d-cddc-4422-8e6a-0e6909d06ee7"><div class="modal-content"><h4>test/tests/controls/control_piecewise/controlled_piecewise.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./generated]
    type = GeneratedMeshGenerator
    dim = 1
    xmin = 0
    xmax = 1
    nx = 10
  [../]
[]

[Problem]
  kernel_coverage_check = false
[]

[Variables]
  [./u]
    initial_condition = 0.1
  [../]
[]

[AuxVariables]
  [./v]
  [../]
  [./x]
  [../]
[]

[ICs]
  [./x_ic]
    type = FunctionIC
    variable = x
    function = &#x27;x&#x27;
  [../]
[]

[AuxKernels]
  [./v_aux]
    type = FunctionAux
    variable = v
    function = func
  [../]
[]

[Controls]
  [./func_control]
    type = RealFunctionControl
    parameter = &#x27;*/*/scale_factor&#x27;
    function = &#x27;2&#x27;
    execute_on = &#x27;initial&#x27;
  [../]
[]

[Materials]
  [./mat]
    type = PiecewiseLinearInterpolationMaterial
    property = matprop
    variable = x
    x = &#x27;0 1&#x27;
    y = &#x27;0 10&#x27;
    outputs = all
  [../]
[]

[Functions]
  [./func]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 10&#x27;
    axis = x
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dfdab61a-4091-4849-b15e-cf44828166d7"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/line_material_rank_two_sampler/rank_two_sampler.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;x_disp y_disp z_disp&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 3
  ny = 3
  nz = 3
  elem_type = HEX
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = 1e-6
  [../]
[]

[Variables]
  [./x_disp]
    order = FIRST
    family = LAGRANGE
  [../]
  [./y_disp]
    order = FIRST
    family = LAGRANGE
  [../]
  [./z_disp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
 [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
 [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
[]

[VectorPostprocessors]
  [./stress_xx]
    type = LineMaterialRankTwoSampler
    start = &#x27;0.1667 0.4 0.45&#x27;
    end   = &#x27;0.8333 0.6 0.55&#x27;
    property = stress
    index_i = 0
    index_j = 0
    sort_by = id
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./front]
    type = FunctionDirichletBC
    variable = z_disp
    boundary = 5
    function = rampConstant
  [../]
  [./back_x]
    type = DirichletBC
    variable = x_disp
    boundary = 0
    value = 0.0
  [../]
  [./back_y]
    type = DirichletBC
    variable = y_disp
    boundary = 0
    value = 0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = z_disp
    boundary = 0
    value = 0.0
  [../]
[]

[Materials]
  [./elast_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = .3
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  l_max_its = 100

  start_time = 0.0
  num_steps = 99999
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  file_base = rank_two_sampler_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="95289863-5c47-4e49-9dc2-df7d2ac20ebf"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test3.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_mixed_lengths.csv #Will generate error because length of data doesn&#x27;t match on all rows
    format = rows
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d386856c-59d7-4058-bc3a-a2c6dd489f13"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/recompute_radial_return/isotropic_plasticity_errors.i</h4><pre class="moose-pre"><code class="language-text"># This simulation uses the piece-wise linear strain hardening model
# with the incremental small strain formulation; incremental small strain
# is required to produce the strain_increment for the DiscreteRadialReturnStressIncrement
# class, which handles the calculation of the stress increment to return
# to the yield surface in a J2 (isotropic) plasticity problem.
#
#  This test is used to check the error messages in the discrete radial return
# model DiscreteRRIsotropicPlasticity; cli_args are used to check all of the
# error messages in the DiscreteRRIsotropicPlasticity model.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./top_pull]
    type = ParsedFunction
    value = t*(0.0625)
  [../]
  [./harden_func]
    type = PiecewiseLinear
    x = &#x27;0  0.0003 0.0007 0.0009&#x27;
    y = &#x27;50    52    54    56&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy plastic_strain_xx plastic_strain_yy plastic_strain_zz&#x27;
  [../]
[]

[BCs]
  [./y_pull_function]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = top_pull
  [../]

  [./x_bot]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./z_bot]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
  [../]
  [./isotropic_plasticity]
    type = IsotropicPlasticityStressUpdate
    relative_tolerance = 1e-25
    absolute_tolerance = 1e-5
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;isotropic_plasticity&#x27;
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-18
  nl_abs_tol = 1e-10
  l_tol = 1e-12

  start_time = 0.0
  end_time = 0.025
  dt = 0.00125
  dtmin = 0.0001
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d78049b8-4aeb-4c05-adc2-8f5d96e5e8f7"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test4q.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4q.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.025
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test4q_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="876a9b81-7f11-483d-81ab-c0cb5a9a8a1f"><div class="modal-content"><h4>modules/richards/test/tests/theis/th01.i</h4><pre class="moose-pre"><code class="language-text"># fully-saturated
# production
[Mesh]
  type = FileMesh
  file = th01_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;0.5 1 2 10&#x27;
    x = &#x27;0 1 10 100&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]

  [./total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsPolyLineSink
    pressures = &#x27;-1E9 1E9&#x27;
    fluxes = &#x27;200 200&#x27;
    point_file = th01.points
    SumQuantityUO = total_outflow_mass
    variable = pressure
  [../]
[]


[Postprocessors]
  [./flow_report]
    type = RichardsPlotQuantity
    uo = total_outflow_mass
  [../]
  [./p50]
    type = PointValue
    variable = pressure
    point = &#x27;50 0 0&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E5
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    sat_UO = Saturation
    seff_UO = Seff1VG
    SUPG_UO = SUPGstandard
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-6 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 100
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = th01
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bdcda029-92b9-4526-8b9c-7878c5556cce"><div class="modal-content"><h4>modules/xfem/test/tests/diffusion_xfem/levelsetcut2d.i</h4><pre class="moose-pre"><code class="language-text"># 2D: Mesh is cut by level set based cutter
# The level set is a MOOSE variable

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 3
  ny = 3
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
  [../]
[]

[Variables]
  [./u]
  [../]
  [./ls]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;3   5&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./diff_ls]
    type = Diffusion
    variable = ls
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 3
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]

  [./left_ls]
    type = DirichletBC
    variable = ls
    boundary = 3
    value = 3
  [../]

  [./right_ls]
    type = DirichletBC
    variable = ls
    boundary = 1
    value = -3
  [../]

[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ef6190b8-c54a-4fa5-89d9-95c1673544f3"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh_lumped_08.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = true
# supg = true
# transient = true
# lumped = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
  viscosity = &#x27;1E-3 0.5E-3&#x27;
  gravity = &#x27;-1 0 0&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-3
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-3
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 2
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh_lumped_08
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ae8798dd-aeb7-4b42-a054-c1f43cde9758"><div class="modal-content"><h4>modules/geochemistry/test/tests/time_dependent_reactions/seawater_evaporation_no_flow_through.i</h4><pre class="moose-pre"><code class="language-text">#Progressively remove H2O until virtually none remains
[UserObjects]
  [./definition]
    type = GeochemicalModelDefinition
    database_file = &quot;../../../database/moose_geochemdb.json&quot;
    basis_species = &quot;H2O H+ Cl- Ca++ Mg++ Na+ K+ SO4-- HCO3-&quot;
    equilibrium_minerals = &quot;Dolomite Epsomite Gypsum Halite Magnesite Mirabilite Sylvite&quot;
    equilibrium_gases = &quot;CO2(g)&quot;
    piecewise_linear_interpolation = true # for precise agreement with GWB
  [../]
[]

[TimeDependentReactionSolver]
  model_definition = definition
  geochemistry_reactor_name = reactor
  swap_out_of_basis = &quot;H+&quot;
  swap_into_basis = &quot;  CO2(g)&quot;
  charge_balance_species = &quot;Cl-&quot; # this means the bulk moles of Cl- will not be exactly as set below
  constraint_species = &quot;H2O              CO2(g)       Cl-                Na+                SO4--              Mg++               Ca++               K+                 HCO3-&quot;
  constraint_value = &quot;  1.0              0.0003162278 0.5656             0.4850             0.02924            0.05501            0.01063            0.010576055        0.002412&quot;
  constraint_meaning = &quot;kg_solvent_water fugacity     moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species&quot;
  close_system_at_time = 0
  source_species_names = &quot;H2O&quot;
  source_species_rates = &quot;-1.0&quot; # 1kg H2O = 55.51 moles, each time step removes 1 mole
  mode = mode
  ramp_max_ionic_strength_initial = 0 # not needed in this simple example
  stoichiometric_ionic_str_using_Cl_only = true # for precise agreement with GWB
  execute_console_output_on = &#x27;&#x27; # only CSV output for this example
[]

[Functions]
  [./timestepper]
    type = PiecewiseLinear
    x = &#x27;0 50 55&#x27;
    y = &#x27;5 5 1&#x27;
  [../]
[]

[Executioner]
  type = Transient
  [./TimeStepper]
    type = FunctionDT
    function = timestepper
  [../]
  end_time = 55
[]

[AuxVariables]
  [./mode]
  [../]
[]

[AuxKernels]
  [./mode]
    type = FunctionAux
    variable = mode
    function = &#x27;if(t&lt;=1.0, 1.0, 0.0)&#x27; # initial &quot;dump&quot; then &quot;normal&quot;
    execute_on = &#x27;timestep_begin&#x27;
  [../]
[]

[GlobalParams]
  point = &#x27;0 0 0&#x27;
[]
[Postprocessors]
  [./solvent_kg]
    type = PointValue
    variable = &#x27;kg_solvent_H2O&#x27;
  [../]
  [./dolomite]
    type = PointValue
    variable = &#x27;free_cm3_Dolomite&#x27;
  [../]
  [./gypsum]
    type = PointValue
    variable = &#x27;free_cm3_Gypsum&#x27;
  [../]
  [./halite]
    type = PointValue
    variable = &#x27;free_cm3_Halite&#x27;
  [../]
  [./mirabilite]
    type = PointValue
    variable = &#x27;free_cm3_Mirabilite&#x27;
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d5857590-4323-49e7-b8e0-995c9d52b2f1"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test3q.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3q.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.025
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test3q_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e08b1cff-6080-4cf8-bb1d-299b8f626e0d"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/strain_energy_density/rate_model.i</h4><pre class="moose-pre"><code class="language-text"># Single element test to check the strain energy density calculation

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 2
[]

[AuxVariables]
  [./SERD]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress strain_xx strain_yy strain_zz&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SERD]
    type = MaterialRealAux
    variable = SERD
    property = strain_energy_rate_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./Pressure]
    [./top]
      boundary = &#x27;top&#x27;
      function = rampConstantUp
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.0
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
  [./powerlawcrp]
    type = PowerLawCreepStressUpdate
    coefficient = 3.125e-21 # 7.04e-17 #
    n_exponent = 4.0
    m_exponent = 0.0
    activation_energy = 0.0
    # max_inelastic_increment = 0.01
  [../]
  [./strain_energy_rate_density]
    type = StrainEnergyRateDensity
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
[]

[Executioner]
   type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./epxx]
    type = ElementalVariableValue
    variable = strain_xx
    elementid = 0
  [../]
  [./epyy]
    type = ElementalVariableValue
    variable = strain_yy
    elementid = 0
  [../]
  [./epzz]
    type = ElementalVariableValue
    variable = strain_zz
    elementid = 0
  [../]
  [./sigxx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./sigyy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./sigzz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./SERD]
    type = ElementAverageValue
    variable = SERD
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b37fc298-cbea-44c4-88e6-0f6ec247b943"><div class="modal-content"><h4>modules/combined/test/tests/internal_volume/rz_cone.i</h4><pre class="moose-pre"><code class="language-text">#
# Internal Volume Test
#
# This test is designed to compute the internal volume of a cone.
#
# The mesh is composed of one block (1).  The height is 3/pi, and the radius
#   is 1.  Thus, the volume is 1/3*pi*r^2*h = 1.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = meshes/rz_cone.e
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = 1e4
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = true
    incremental = true
    strain = FINITE
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]

  [./Pressure]
    [./fred]
      boundary = 1
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  nl_abs_tol = 1e-9

  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d9781cb1-960b-4d4b-a9a6-bcae05a76d23"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_deprecated.i</h4><pre class="moose-pre"><code class="language-text">#
# Simple pull test for cracking.
# The stress increases for two steps and then drops to zero.

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3  4&#x27;
    y = &#x27;0 1 0 -1 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pull]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displ
  [../]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 1.68e6
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.1
  dt = 0.025
[]

[Outputs]
  exodus = true
  file_base = cracking_out
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ec14dd8d-5489-4065-8b13-c14da55c93d5"><div class="modal-content"><h4>modules/combined/test/tests/axisymmetric_2d3d_solution_function/2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  disp_x = disp_x
  disp_y = disp_y
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = 2d.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./temp]
    initial_condition = 400
  [../]
[]

[AuxVariables]
  [./hoop_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./temp_inner_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 400
               1 350&#x27;
  [../]
  [./temp_outer_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 400
               1 400&#x27;
  [../]
  [./press_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 15
               1 15&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = true
    add_variables  = true
    incremental = true
    strain = FINITE
    eigenstrain_names = thermal_expansion
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress hydrostatic_stress&#x27;
  [../]
[]

[AuxKernels]
  [./hoop_stress]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = hoop_stress
    scalar_type = HoopStress
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1&#x27;
    value = 0.0
  [../]

  [./Pressure]
    [./internal_pressure]
      boundary = &#x27;4&#x27;
      factor = 1.e6
      function = press_func
    [../]
  [../]

  [./t_in]
    type = FunctionDirichletBC
    variable = temp
    boundary = &#x27;4&#x27;
    function = temp_inner_func
  [../]

  [./t_out]
    type = FunctionDirichletBC
    variable = temp
    boundary = &#x27;2&#x27;
    function = temp_outer_func
  [../]
[]

[Constraints]
  [./disp_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    primary = &#x27;65&#x27;
    secondary = &#x27;3&#x27;
    penalty = 1e18
  [../]
[]

[Materials]
  [./thermal1]
    type = HeatConductionMaterial
    block = &#x27;1&#x27;
    thermal_conductivity = 25.0
    specific_heat = 490.0
    temp = temp
  [../]

  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 193.05e9
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 13e-6
    stress_free_temperature = 295.00
    temperature = temp
    eigenstrain_name = thermal_expansion
  [../]

  [./density]
    type = Density
    block = &#x27;1&#x27;
    density = 8000.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-ksp_snes_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27; 201                hypre    boomeramg      4&#x27;
  line_search = &#x27;none&#x27;
  l_max_its = 25
  nl_max_its = 20
  nl_rel_tol = 1e-9
  l_tol = 1e-2

  start_time = 0.0
  dt = 1
  end_time = 1
  dtmin = 1
[]

[Outputs]
  file_base = 2d_out
  exodus = true
  [./console]
    type = Console
    max_rows = 25
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="653d09fc-d9a6-4a1a-8874-a92872a50697"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh_lumped_07.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = bh07_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  sat_UO = Saturation
  seff_UO = Seff1VG
  SUPG_UO = SUPGstandard
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1000 10000&#x27;
    x = &#x27;100 1000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E8
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[BCs]
  [./fix_outer]
    type = DirichletBC
    boundary = perimeter
    variable = pressure
    value = 1E7
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsLumpedMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = 0
    point_file = bh07.bh
    SumQuantityUO = borehole_total_outflow_mass
    variable = pressure
    unit_weight = &#x27;0 0 0&#x27;
    re_constant = 0.1594
    character = 2
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./fluid_mass]
    type = RichardsMass
    variable = pressure
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E7
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-11 0 0  0 1E-11 0  0 0 1E-11&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 1000
  solve_type = NEWTON

  [./TimeStepper]
    # get only marginally better results for smaller time steps
    type = FunctionDT
    function = dts
  [../]

[]

[Outputs]
  file_base = bh_lumped_07
  execute_on = &#x27;initial timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bd0c9e7a-6988-472d-bbcf-493e1c9e76f6"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_as_2d_topo_q_func.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with one element
#through the thickness, and calculates the J-Integrals using options
#to treat it as 2d.
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack_3d_as_2d.e
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  q_function_type = Topology
  ring_first = 1
  ring_last = 3
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]

   type = Transient
  # Two sets of linesearch options are for petsc 3.1 and 3.3 respectively
  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 1e-5
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Outputs]
  file_base = j_integral_3d_as_2d_topo_q_func_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="211e2382-d9ae-46f8-8041-82b959fe0784"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test4ns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4ns_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fc74181e-d540-469a-bc4f-ef39965e2eb6"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_2d.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 2d plane strain model
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;4.0 4.5 5.0 5.5 6.0&#x27;
  radius_outer = &#x27;4.5 5.0 5.5 6.0 6.5&#x27;
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = j_integral_2d_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f36d6477-18bf-4cb0-abe0-77b7ba193445"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_mouth_dir.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with 2 elements
#through the thickness, and calculates the J-Integrals using options
#to treat it as 3d.
#Crack direction is defined using the crack mouth coordinates.
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack3d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackMouth
  crack_mouth_boundary = 900
  radius_inner = &#x27;4.0 5.5&#x27;
  radius_outer = &#x27;5.5 7.0&#x27;
  output_variable = &#x27;disp_x&#x27;
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_z2]
    type = DirichletBC
    variable = disp_z
    boundary = 510
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]

[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]


[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Postprocessors]
  [./disp_x_centercrack]
    type = CrackFrontData
    crack_front_definition = crackFrontDefinition
    variable = disp_x
    crack_front_point_index = 1
  [../]
[]

[Outputs]
  file_base = j_integral_3d_mouth_dir_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fd3f0b6d-24f3-45df-b74d-76eca803a6be"><div class="modal-content"><h4>modules/xfem/test/tests/pressure_bc/2d_pressure_displaced_mesh.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = false
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 5
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.0 0.5 1.0 0.5&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    planar_formulation = PLANE_STRAIN
    generate_output = &#x27;stress_xx stress_yy&#x27;
  [../]
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0 1.0&#x27;
    y = &#x27;500 500&#x27;
  [../]
  [./bc_func_tx]
    type = ParsedFunction
    value = &#x27;0.5-(0.5-x)*cos(pi*t/2.0)-x&#x27;
  [../]
  [./bc_func_ty]
    type = ParsedFunction
    value = &#x27;(0.5-x)*sin(pi*t/2.0)+0.5&#x27;
  [../]
[]

[BCs]
  [./bottom_y]
    type = DirichletBC
    boundary = 0
    preset = false
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = 0
    preset = false
    variable = disp_x
    value = 0.0
  [../]
  [./top_right_y]
    type = FunctionDirichletBC
    boundary = 2
    preset = false
    variable = disp_y
    function = bc_func_ty
  [../]
  [./top_right_x]
    type = FunctionDirichletBC
    boundary = 2
    preset = false
    variable = disp_x
    function = bc_func_tx
  [../]
[]

[DiracKernels]
  [./pressure_x]
    type = XFEMPressure
    variable = disp_x
    component = 0
    function = pressure
    use_displaced_mesh = true
  [../]
  [./pressure_y]
    type = XFEMPressure
    variable = disp_y
    component = 1
    function = pressure
    use_displaced_mesh = true
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-14

# time control
  start_time = 0.0
  dt = 0.1
  end_time = 1.0
[]

[Outputs]
  file_base = 2d_pressure_displaced_mesh_out
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4868102e-f59e-45bd-b610-e01429ab1039"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/diffusion_quad9_levelsetcut.i</h4><pre class="moose-pre"><code class="language-text"># A simple diffusion problem with quad9 elements
# The mesh is cut using levle set based cutter

[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 3
  ny = 3
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD9
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;3   5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;x-0.53&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 3
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]

[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ee8c46f7-ed6e-4ef3-b548-a3ac7c4faff9"><div class="modal-content"><h4>modules/richards/test/tests/theis/th_lumped_02.i</h4><pre class="moose-pre"><code class="language-text"># fully-saturated
# production
# lumped
[Mesh]
  type = FileMesh
  file = th02_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  sat_UO = Saturation
  seff_UO = Seff1VG
  SUPG_UO = SUPGstandard
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 2 4 20&#x27;
    x = &#x27;0 1 10 100&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]

  [./total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsLumpedMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsPolyLineSink
    pressures = &#x27;-1E9 1E9&#x27;
    fluxes = &#x27;200 200&#x27;
    point_file = th01.points
    SumQuantityUO = total_outflow_mass
    variable = pressure
  [../]
[]


[Postprocessors]
  [./flow_report]
    type = RichardsPlotQuantity
    uo = total_outflow_mass
  [../]
  [./p50]
    type = PointValue
    variable = pressure
    point = &#x27;50 0 0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E5
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-6 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 100
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  file_base = th_lumped_02
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7d1ddf0d-d21e-4ddf-a703-670613a01543"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test4nns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_method = nodal_normal_based
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4nns_out
  exodus = true
[]

[NodalNormals]
  boundary = 11
  corner_boundary = 20
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="79179453-f2ba-412d-a288-3350afbc52da"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test7.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    x = &#x27;1&#x27;
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="08139623-52c0-4616-a548-0febfbe16ccd"><div class="modal-content"><h4>modules/contact/test/tests/verification/patch_tests/single_pnt_2d/single_point_2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = single_point_2d.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./penetration]
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
[]

[Functions]
  [./appl_disp]
    type = PiecewiseLinear
    x = &#x27;0 0.001  0.101&#x27;
    y = &#x27;0 0.0   -0.10&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    save_in = &#x27;saved_x saved_y&#x27;
  [../]
[]

[AuxKernels]
  [./incslip_x]
    type = PenetrationAux
    variable = inc_slip_x
    quantity = incremental_slip_x
    boundary = 3
    paired_boundary = 2
  [../]
  [./incslip_y]
    type = PenetrationAux
    variable = inc_slip_y
    quantity = incremental_slip_y
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_x]
    type = AccumulateAux
    variable = accum_slip_x
    accumulate_from_variable = inc_slip_x
    execute_on = timestep_end
  [../]
  [./accum_slip_y]
    type = AccumulateAux
    variable = accum_slip_y
    accumulate_from_variable = inc_slip_y
    execute_on = timestep_end
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 3
    paired_boundary = 2
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./topx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = appl_disp
  [../]
  [./topy]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = -0.002001
  [../]
[]

[Materials]
  [./bot_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e9
    poissons_ratio = 0.3
  [../]
  [./bot_strain]
    type = ComputePlaneFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./bot_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./top_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./top_strain]
    type = ComputePlaneFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./top_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
[]

[Postprocessors]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 1
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 1
  [../]
  [./top_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 4
  [../]
  [./top_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 4
  [../]
  [./disp_x]
    type = NodalVariableValue
    nodeid = 5
    variable = disp_x
  [../]
  [./disp_y]
    type = NodalVariableValue
    nodeid = 5
    variable = disp_y
  [../]
  [./inc_slip_x]
    type = NodalVariableValue
    nodeid = 5
    variable = inc_slip_x
  [../]
  [./inc_slip_y]
    type = NodalVariableValue
    nodeid = 5
    variable = inc_slip_y
  [../]
  [./accum_slip_x]
    type = NodalVariableValue
    nodeid = 5
    variable = accum_slip_x
  [../]
  [./accum_slip_y]
    type = NodalVariableValue
    nodeid = 5
    variable = accum_slip_y
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package -mat_superlu_dist_iterrefine&#x27;
  petsc_options_value = &#x27;lu    superlu_dist 1&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 200
  dt = 0.001
  end_time = 0.001
  num_steps = 10000
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-8
  dtmin = 0.001
  l_tol = 1e-3
[]

[Outputs]
  file_base = single_point_2d_out_glued_kin
  exodus = true
  print_linear_residuals = true
  perf_graph = true
  csv = true
  [./console]
    type = Console
    max_rows = 5
  [../]
[]

[Contact]
  [./leftright]
    primary = 2
    secondary = 3
    model = glued
    formulation = kinematic
    penalty = 1e12
    normalize_penalty = true
    tangential_tolerance = 1e-3
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="08d4f434-20cf-481b-93d9-9ad300bf72c6"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/diffusion_3d_tet10.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 3
  ny = 5
  nz = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.2
  elem_type = TET10
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./square_planar_cut_uo]
    type = RectangleCutUserObject
    cut_data = &#x27;  0.35 1.01 -0.001
                  0.35 0.49 -0.001
                  0.35 0.49  0.201
                  0.35 1.01  0.201&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = left
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e86608ef-4c61-45c9-a0be-f1ee8b7ae79c"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3nnstt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3tt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
    normal_smoothing_method = nodal_normal_based
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3nnstt_out
  exodus = true
[]

[NodalNormals]
  boundary = 11
  corner_boundary = 20
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="42956e9a-58a2-46cf-b8f8-85fa3f8299f2"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/strain_energy_density/incr_model_elas_plas.i</h4><pre class="moose-pre"><code class="language-text"># Single element test to check the strain energy density calculation

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 2
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
  [./ramp_disp_y]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 6.8e-6 1.36e-5&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = SMALL
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress elastic_strain_xx elastic_strain_yy elastic_strain_zz plastic_strain_xx plastic_strain_yy plastic_strain_zz strain_xx strain_yy strain_zz&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./top_disp]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = &#x27;top&#x27;
    function = ramp_disp_y
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 30e+6
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;isoplas&#x27;
  [../]
  [./isoplas]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 1e2
    hardening_constant = 0.0
  [../]
  [./strain_energy_density]
    type = StrainEnergyDensity
    incremental = true
  [../]
[]

[Executioner]
   type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 2
   num_steps = 2
[]

[Postprocessors]
  [./epxx]
    type = ElementalVariableValue
    variable = elastic_strain_xx
    elementid = 0
  [../]
  [./epyy]
    type = ElementalVariableValue
    variable = elastic_strain_yy
    elementid = 0
  [../]
  [./epzz]
    type = ElementalVariableValue
    variable = elastic_strain_zz
    elementid = 0
  [../]
  [./eplxx]
    type = ElementalVariableValue
    variable = plastic_strain_xx
    elementid = 0
  [../]
  [./eplyy]
    type = ElementalVariableValue
    variable = plastic_strain_yy
    elementid = 0
  [../]
  [./eplzz]
    type = ElementalVariableValue
    variable = plastic_strain_zz
    elementid = 0
  [../]
  [./etxx]
    type = ElementalVariableValue
    variable = strain_xx
    elementid = 0
  [../]
  [./etyy]
    type = ElementalVariableValue
    variable = strain_yy
    elementid = 0
  [../]
  [./etzz]
    type = ElementalVariableValue
    variable = strain_zz
    elementid = 0
  [../]
  [./sigxx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./sigyy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./sigzz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./SED]
    type = ElementAverageValue
    variable = SED
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="372792c7-8919-4db9-8138-e68c8ab0032a"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test2qtt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test2q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test2qtt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c639f428-0768-4cd4-ae50-e637f943103e"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/scalar_material_damage/combined_scalar_damage.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX8
[]

[AuxVariables]
  [damage_index]
    order = CONSTANT
    family = MONOMIAL
  []
  [damage_index_a]
    order = CONSTANT
    family = MONOMIAL
  []
  [damage_index_b]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Modules/TensorMechanics/Master]
  [all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_xx strain_xx&#x27;
  []
[]

[AuxKernels]
  [damage_index]
    type = MaterialRealAux
    variable = damage_index
    property = damage_index
    execute_on = timestep_end
  []
  [damage_index_a]
    type = MaterialRealAux
    variable = damage_index_a
    property = damage_index_a
    execute_on = timestep_end
  []
  [damage_index_b]
    type = MaterialRealAux
    variable = damage_index_b
    property = damage_index_b
    execute_on = timestep_end
  []
[]

[BCs]
  [symmy]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0
  []
  [symmx]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0
  []
  [symmz]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0
  []
  [axial_load]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0.01
  []
[]

[Functions]
  [damage_evolution_a]
    type = PiecewiseLinear
    xy_data = &#x27;0.0   0.0
               0.1   0.0
               2.1   2.0&#x27;
  []
  [damage_evolution_b]
    type = PiecewiseLinear
    xy_data = &#x27;0.0   0.2
               0.1   0.2
               2.1   0.7&#x27;
  []
[]

[Materials]
  [damage_index_a]
    type = GenericFunctionMaterial
    prop_names = damage_index_prop_a
    prop_values = damage_evolution_a
  []
  [damage_index_b]
    type = GenericFunctionMaterial
    prop_names = damage_index_prop_b
    prop_values = damage_evolution_b
  []
  [damage_a]
    type = ScalarMaterialDamage
    damage_index = damage_index_prop_a
    damage_index_name = damage_index_a
  []
  [damage_b]
    type = ScalarMaterialDamage
    damage_index = damage_index_prop_b
    damage_index_name = damage_index_b
  []
  [damage]
    type = CombinedScalarDamage
    damage_models = &#x27;damage_a damage_b&#x27;
  []
  [stress]
    type = ComputeDamageStress
    damage_model = damage
  []
  [elasticity]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.2
    youngs_modulus = 10e9
  []
[]

[Postprocessors]
  [stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  []
  [strain_xx]
    type = ElementAverageValue
    variable = strain_xx
  []
  [damage_index]
    type = ElementAverageValue
    variable = damage_index
  []
  [damage_index_a]
    type = ElementAverageValue
    variable = damage_index_a
  []
  [damage_index_b]
    type = ElementAverageValue
    variable = damage_index_b
  []
[]

[Executioner]
  type = Transient

  l_max_its  = 50
  l_tol      = 1e-8
  nl_max_its = 20
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-8

  dt = 0.1
  dtmin = 0.1
  end_time = 1.1
[]

[Outputs]
  csv=true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7fa4f3a8-302f-43f5-9394-ff2b923a4d3a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/recompute_radial_return/affine_plasticity.i</h4><pre class="moose-pre"><code class="language-text"># Affine Plasticity Test for Transient Stress Eigenvalues with Stationary Eigenvectors

# This test is taken from K. Jamojjala, R. Brannon, A. Sadeghirad, J. Guilkey,
#  &quot;Verification tests in solid mechanics,&quot; Engineering with Computers, Vol 31.,
#  p. 193-213.

# The test involves applying particular strains and expecting particular stresses.

# The material properties are:
#  Yield in shear     165 MPa
#  Shear modulus       79 GPa
#  Poisson&#x27;s ratio    1/3

# The strains are:
#  Time        e11        e22        e33
#  0             0          0          0
#  1        -0.003     -0.003      0.006
#  2    -0.0103923          0  0.0103923

# The expected stresses are:
#  sigma11:
#   -474*t                             0 &lt; t &lt;= 0.201
#   -95.26                             0.201 &lt; t &lt;= 1
#   (189.4+0.1704*sqrt(a)-0.003242*a)
#   ---------------------------------  1 &lt; t &lt;= 2
#            1+0.00001712*a
#   -189.4                             t &gt; 2 (paper erroneously gives a positive value)
#
#  sigma22:
#   -474*t                             0 &lt; t &lt;= 0.201
#   -95.26                             0.201 &lt; t &lt;= 1
#   -(76.87+1.443*sqrt(a)-0.001316*a)
#   ---------------------------------  1 &lt; t &lt;= 2 (paper gives opposite sign)
#             1+0.00001712*a
#   76.87                              t &gt; 2
#
#  sigma33:
#   948*t                              0 &lt; t &lt;= 0.201
#   190.5                              0.201 &lt; t &lt;= 1
#   -(112.5-1.272*sqrt(a)-0.001926*a)
#   ---------------------------------  1 &lt; t &lt;= 2 (paper has two sign errors here)
#            1+0.00001712*a
#   112.5                              t &gt; 2
#
#  where a = exp(12.33*t).
#
# Note: If planning to run this case with strain type ComputeFiniteStrain, the
#   displacement function must be adjusted.  Instead of
#     strain = (l - l0)/l0 = (u+l0 - l0)/l0 = u/l0
#   with l0=1.0, we would have
#     strain = log(l/l0) = log((u+l0)/l0)
#   with l0=1.0.  So, for strain = -0.003,
#     -0.003 = log((u+l0)/l0) -&gt;
#     u = exp(-0.003)*l0 - l0 = -0.0029955044966269995.
#


[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  block = &#x27;0&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  # This test uses ElementalVariableValue postprocessors on specific
  # elements, so element numbering needs to stay unchanged
  allow_renumbering = false
[]

[Functions]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0.  1.     2.&#x27;
    y = &#x27;0. -0.003 -0.0103923&#x27;
  [../]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.  1.    2.&#x27;
    y = &#x27;0. -0.003 0.&#x27;
  [../]
  [./disp_z]
    type = PiecewiseLinear
    x = &#x27;0. 1.    2.&#x27;
    y = &#x27;0. 0.006 0.0103923&#x27;
  [../]
  [./stress_xx]
    type = ParsedFunction
    # The paper gives 0.201 as the time at initial yield, but 0.20097635952803425 is the exact value.
    # The paper gives -95.26 MPa as the stress at yield, but -95.26279441628823 is the exact value.
    # The paper gives 12.33 as the factor in the exponential, but 12.332921390339125 is the exact value.
    # 189.409039923814000, 0.170423791206825, -0.003242011311945, 1.711645501845780E-05 - exact values
    vars = &#x27;timeAtYield stressAtYield expFac a b c d&#x27;
    vals = &#x27;0.20097635952803425 -95.26279441628823 12.332921390339125 189.409039923814000 0.170423791206825 -0.003242011311945 1.711645501845780E-05&#x27;
    value = &#x27;1e6*
             if(t&lt;=timeAtYield, -474*t,
             if(t&lt;=1, stressAtYield,
             (a+b*sqrt(exp(expFac*t))+c*exp(expFac*t))/(1.0+d*exp(expFac*t))))&#x27; # tends to -a
  [../]
  [./stress_yy]
    type = ParsedFunction
    # The paper gives 0.201 as the time at initial yield, but 0.20097635952803425 is the exact value.
    # the paper gives -95.26 MPa as the stress at yield, but -95.26279441628823 is the exact value.
    # The paper gives 12.33 as the factor in the exponential, but 12.332921390339125 is the exact value.
    # -76.867432297315000, -1.442488120272900, 0.001315697947301, 1.711645501845780E-05 - exact values
    vars = &#x27;timeAtYield stressAtYield expFac a b c d&#x27;
    vals = &#x27;0.20097635952803425 -95.26279441628823 12.332921390339125 -76.867432297315000 -1.442488120272900 0.001315697947301 1.711645501845780E-05&#x27;
    value = &#x27;1e6*
             if(t&lt;=timeAtYield, -474*t,
             if(t&lt;=1, stressAtYield,
             (a+b*sqrt(exp(expFac*t))+c*exp(expFac*t))/(1.0+d*exp(expFac*t))))&#x27; # tends to -a
  [../]
  [./stress_zz]
    type = ParsedFunction
    # The paper gives 0.201 as the time at initial yield, but 0.20097635952803425 is the exact value.
    # the paper gives 190.5 MPa as the stress at yield, but 190.52558883257645 is the exact value.
    # The paper gives 12.33 as the factor in the exponential, but 12.332921390339125 is the exact value.
    # -112.541607626499000, 1.272064329066080, 0.001926313364644, 1.711645501845780E-05 - exact values
    vars = &#x27;timeAtYield stressAtYield expFac a b c d&#x27;
    vals = &#x27;0.20097635952803425 190.52558883257645 12.332921390339125 -112.541607626499000 1.272064329066080 0.001926313364644 1.711645501845780E-05&#x27;
    value = &#x27;1e6*
             if(t&lt;=timeAtYield, 948*t,
             if(t&lt;=1, stressAtYield,
             (a+b*sqrt(exp(expFac*t))+c*exp(expFac*t))/(1.0+d*exp(expFac*t))))&#x27; # tends to -a
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]

  [./plastic_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./TensorMechanics]
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./vonmises]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = vonmises
    scalar_type = vonmisesStress
    execute_on = &#x27;timestep_end&#x27;
  [../]

  [./plastic_strain_xx]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_xx
    index_i = 0
    index_j = 0
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./plastic_strain_yy]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_yy
    index_i = 1
    index_j = 1
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./plastic_strain_zz]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_zz
    index_i = 2
    index_j = 2
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[BCs]
  [./fixed_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixed_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./fixed_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]

  [./disp_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = right
    function = disp_x
  [../]
  [./disp_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = disp_y
  [../]
  [./disp_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = front
    function = disp_z
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 210666666666.666667
    poissons_ratio = 0.3333333333333333
  [../]

  [./strain]
    type = ComputeIncrementalSmallStrain
  [../]

  [./isotropic_plasticity]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 285788383.2488647 # = sqrt(3)*165e6 = sqrt(3) * yield in shear
    hardening_constant = 0.0
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;isotropic_plasticity&#x27;
  [../]
[]

[Executioner]

  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;

  nl_abs_tol = 1e-10

  l_max_its = 20

  start_time = 0.0
  dt = 0.01 # use 0.0001 for a nearly exact match
  end_time = 2.0
[]

[Postprocessors]
  [./analytic_xx]
    type = FunctionValuePostprocessor
    function = stress_xx
  [../]
  [./analytic_yy]
    type = FunctionValuePostprocessor
    function = stress_yy
  [../]
  [./analytic_zz]
    type = FunctionValuePostprocessor
    function = stress_zz
  [../]

  [./stress_xx]
    type = ElementalVariableValue
    variable = stress_xx
    elementid = 0
  [../]
  [./stress_yy]
    type = ElementalVariableValue
    variable = stress_yy
    elementid = 0
  [../]
  [./stress_zz]
    type = ElementalVariableValue
    variable = stress_zz
    elementid = 0
  [../]

  [./stress_xx_l2_error]
    type = ElementL2Error
    variable = stress_xx
    function = stress_xx
  [../]
  [./stress_yy_l2_error]
    type = ElementL2Error
    variable = stress_yy
    function = stress_yy
  [../]
  [./stress_zz_l2_error]
    type = ElementL2Error
    variable = stress_zz
    function = stress_zz
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="33d863eb-1023-42cc-9a40-d110868fe82a"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_radiation/gap_heat_transfer_radiation_test.i</h4><pre class="moose-pre"><code class="language-text">#
# 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a helium-filled gap including radiation.
#
# The mesh consists of two element blocks containing one element each.  Each
#   element is a unit cube.  They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit, and then held fixed for an additional
#  time unit.  The temperature of the far right boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
#  Flux = (T_left - T_right) * h_gap
#
#    where  h_gap = h_gas + h_cont + h_rad
#
# By setting the contact pressure, roughnesses, and jump distances to zero, the gap
#   conductance simplifies to:
#
#    h_gap = gapK/d_gap + sigma*Fe*(T_left^2 + T_right^2)*(T_left + T_right)
#
#      where Fe = 1/(1/eps_left + 1/eps_right - 1)
#            eps = emissivity
#
# For pure helium, BISON computes the gas conductivity as:
#
#  gapK(Tavg) = 2.639e-3*Tavg^0.7085
#
# For the test, the final (t=2) average gas temperature is (200 +100)/2 = 150,
#  giving gapK(150) = 0.09187557
#
# Assuming ems_left = ems_right = 0.5, Fe = 1/3
#
# The heat flux across the gap at that time is then:
#
#  Flux(2) = 100 * ((0.09187557/1.0) + (5.669e-8/3)*(200^2 + 100^2)*(200 + 100))
#          = 37.532557
#
# The flux post processors give 37.53255
#

[Mesh]
  file = gap_heat_transfer_radiation_test.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;200 200&#x27;
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]

  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[ThermalContact]
  [./gap]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    gap_conductivity = 0.09187557
    emissivity_primary = 0.5
    emissivity_secondary = 0.5
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 10000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-6
  nl_rel_tol = 1e-10

  l_tol = 1e-3
  l_max_its = 100

  start_time = 0.0
  dt = 1
  end_time = 1.0
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="60df40e7-a667-4e8b-8787-bb467cfd8005"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test17.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_rows_more_data.csv
    xy_in_file_only = false
    x_index_in_file = 0
    y_index_in_file = 0 # will generate an error because x and y index are equal
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b12fc0e6-7f5d-4d34-910f-7bc679ff0b04"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test4.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a6ec3497-3e06-4d70-b120-b5379ac9a592"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_newmark_material_dependent.i</h4><pre class="moose-pre"><code class="language-text"># Test for rayleigh damping implemented using Newmark time integration

# The test is for an 1D bar element of  unit length fixed on one end
# with a ramped pressure boundary condition applied to the other end.
# zeta and eta correspond to the stiffness and mass proportional rayleigh damping
# beta and gamma are Newmark time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel + eta*M*vel + zeta*K*vel + K*disp = P*Area
#
# Here M is the mass matrix, K is the stiffness matrix, P is the applied pressure
#
# This equation is equivalent to:
#
# density*accel + eta*density*vel + zeta*d/dt(Div stress) + Div stress = P
#
# The first two terms on the left are evaluated using the Inertial force kernel
# The next two terms on the left involving zeta are evaluated using the
# DynamicStressDivergenceTensors Kernel
# The residual due to Pressure is evaluated using Pressure boundary condition
#
# The system will come to steady state slowly after the pressure becomes constant.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    zeta = &#x27;zeta_rayleigh&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.25
    gamma = 0.5
    eta = &#x27;eta_rayleigh&#x27;
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.25
    gamma = 0.5
    eta = &#x27;eta_rayleigh&#x27;
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    gamma = 0.5
    eta = &#x27;eta_rayleigh&#x27;
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = bottom
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
      disp_z = disp_z
      factor = 1
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]
  [./material_zeta]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;zeta_rayleigh&#x27;
    prop_values = &#x27;0.1&#x27;
  [../]
  [./material_eta]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;eta_rayleigh&#x27;
    prop_values = &#x27;0.1&#x27;
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 2
  dt = 0.1
[]


[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 1.0 2.0 5.0&#x27;
    y = &#x27;0.0 0.1 0.2 1.0 1.0 1.0&#x27;
    scale_factor = 1e9
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalMaxValue
    variable = disp_y
    boundary = bottom
  [../]
  [./vel]
    type = NodalMaxValue
    variable = vel_y
    boundary = bottom
  [../]
  [./accel]
    type = NodalMaxValue
    variable = accel_y
    boundary = bottom
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./strain_yy]
    type = ElementAverageValue
    variable = strain_yy
  [../]

[]

[Outputs]
  file_base = &#x27;rayleigh_newmark_out&#x27;
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e155e1c2-c5b0-4fff-93f8-e5e067339ce9"><div class="modal-content"><h4>test/tests/auxkernels/time_integration/time_integration.i</h4><pre class="moose-pre"><code class="language-text"># This test covers the usage of the VariableTimeIntegrationAux
# kernel. Here we test three different schemes for integrating a field
# variable in time.  Midpoint, Trapezoidal, and Simpson&#x27;s rule are
# used.  For this test, we use a manufactured solution and we compare
# the Trapezoidal and Simpson&#x27;s rule, which must be exact for this
# exact solution, which is a linear function of time.
#
# The set up problem is
#
#  du/dt - Laplacian(u) = Q
#
# with exact solution: u = t*(x*x+y*y).
[Mesh]
  type = GeneratedMesh
  dim = 2
  elem_type = QUAD9
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    x = &#x27;0.01 0.1&#x27;
    y = &#x27;0.005 0.05&#x27;
  [../]
[]

[Variables]
  [./u]
    initial_condition = 0.0
    family = LAGRANGE
    order = SECOND
  [../]
[]

[Kernels]
  active = &#x27;diff timederivative sourceterm&#x27;
  [./diff]
     type = Diffusion
     variable = u
  [../]
  [./timederivative]
     type = TimeDerivative
     variable = u
  [../]
  [./sourceterm]
     type = BodyForce
     variable = u
     function = Source
  [../]
[]

[AuxVariables]
  active = &#x27;v_midpoint v_trapazoid v_simpson&#x27;
  [./v_midpoint]
  [../]
  [./v_trapazoid]
  [../]
  [./v_simpson]
  [../]
[]

[AuxKernels]
  [./MidpointTimeIntegrator]
    type = VariableTimeIntegrationAux
    variable_to_integrate = u
    variable = v_midpoint
    order = 1
  [../]
  [./TrapazoidalTimeIntegrator]
    type = VariableTimeIntegrationAux
    variable_to_integrate = u
    variable = v_trapazoid
    order = 2
  [../]
  [./SimpsonsTimeIntegrator]
    type = VariableTimeIntegrationAux
    variable_to_integrate = u
    variable = v_simpson
    order = 3
  [../]
[]

[BCs]
  active = &#x27;RightBC LeftBC TopBC BottomBC&#x27;
 [./RightBC]
    type = FunctionDirichletBC
    variable = u
    function = RightBC
    boundary = &#x27;right&#x27;
 [../]
 [./LeftBC]
    type = FunctionDirichletBC
    variable = u
    function = LeftBC
    boundary = &#x27;left&#x27;
 [../]
 [./TopBC]
    type = FunctionDirichletBC
    variable = u
    function = TopBC
    boundary = &#x27;top&#x27;
 [../]
 [./BottomBC]
    type = FunctionDirichletBC
    variable = u
    function = BottomBC
    boundary = &#x27;bottom&#x27;
 [../]
[]

[Functions]
  active = &#x27;Soln Source TopBC BottomBC RightBC LeftBC&#x27;
 [./Soln]
    type = ParsedFunction
    value = &#x27;t*(x*x+y*y)&#x27;
 [../]
 [./Source]
    type = ParsedFunction
    value = &#x27;(x*x + y*y) - 4*t&#x27;
 [../]
 [./TopBC]
    type = ParsedFunction
    value = &#x27;t*(x*x+1)&#x27;
 [../]
 [./BottomBC]
    type = ParsedFunction
    value = &#x27;t*x*x&#x27;
 [../]
 [./RightBC]
   type = ParsedFunction
   value = &#x27;t*(y*y+1)&#x27;
 [../]
 [./LeftBC]
    type = ParsedFunction
    value = &#x27;t*y*y&#x27;
  [../]
[]
[Postprocessors]
  [./l2_error]
    type = NodalL2Error
    variable = u
    function = Soln
  [../]
[]

[Executioner]
  type = Transient

  end_time = 0.1
#  dt = 0.1
#  num_steps = 10
  [./TimeStepper]
     type = FunctionDT
     function = dts
  [../]

  nl_abs_tol = 1.e-15
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="17dc52a2-5c77-48d8-b6b8-df7ee8d5ba2a"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/diffusion_2d_quad9_test.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD9
[]

[XFEM]
  cut_data = &#x27;0.35 1.0 0.35 0.4 0 0&#x27;
  qrule = volfrac
  output_cut_plane = true
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = 3
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="87bb2cc9-a403-410f-9e26-015e939cda4d"><div class="modal-content"><h4>modules/contact/test/tests/verification/hertz_cyl/half_symm_q8/hertz_cyl_half_1deg_template1.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = hertz_cyl_half_1deg.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
  [./tang_force_x]
  [../]
  [./tang_force_y]
  [../]
[]

[Functions]
  [./disp_ramp_vert]
    type = PiecewiseLinear
    x = &#x27;0. 1. 3.5&#x27;
    y = &#x27;0. -0.0020 -0.0020&#x27;
  [../]
  [./disp_ramp_horz]
    type = PiecewiseLinear
    x = &#x27;0. 1. 3.5&#x27;
    y = &#x27;0. 0.0 0.0014&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./inc_slip_x]
    type = PenetrationAux
    variable = inc_slip_x
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./inc_slip_y]
    type = PenetrationAux
    variable = inc_slip_y
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_x]
    type = PenetrationAux
    variable = accum_slip_x
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_y]
    type = PenetrationAux
    variable = accum_slip_y
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./tang_force_x]
    type = PenetrationAux
    variable = tang_force_x
    quantity = tangential_force_x
    boundary = 3
    paired_boundary = 2
  [../]
  [./tang_force_y]
    type = PenetrationAux
    variable = tang_force_y
    quantity = tangential_force_y
    boundary = 3
    paired_boundary = 2
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 3
    paired_boundary = 2
  [../]
[]

[Postprocessors]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 1
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 1
  [../]
  [./top_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 4
  [../]
  [./top_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 4
  [../]
  [./disp_x639]
    type = NodalVariableValue
    nodeid = 638
    variable = disp_x
  [../]
  [./disp_y639]
    type = NodalVariableValue
    nodeid = 638
    variable = disp_y
  [../]
  [./_dt]
    type = TimestepSize
  [../]
  [./num_lin_it]
    type = NumLinearIterations
  [../]
  [./num_nonlin_it]
    type = NumNonlinearIterations
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./top_y_disp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = disp_ramp_vert
  [../]
  [./top_x_disp]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = disp_ramp_horz
  [../]
[]

[Materials]
  [./stuff1_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e10
    poissons_ratio = 0.0
  [../]
  [./stuff1_strain]
    type = ComputeFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./stuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./stuff2_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff2_strain]
    type = ComputeFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./stuff2_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
  [./stuff3_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;3&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff3_strain]
    type = ComputeFiniteStrain
    block = &#x27;3&#x27;
  [../]
  [./stuff3_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;3&#x27;
  [../]
  [./stuff4_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;4&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff4_strain]
    type = ComputeFiniteStrain
    block = &#x27;4&#x27;
  [../]
  [./stuff4_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;4&#x27;
  [../]
  [./stuff5_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;5&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff5_strain]
    type = ComputeFiniteStrain
    block = &#x27;5&#x27;
  [../]
  [./stuff5_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;5&#x27;
  [../]
  [./stuff6_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;6&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff6_strain]
    type = ComputeFiniteStrain
    block = &#x27;6&#x27;
  [../]
  [./stuff6_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;6&#x27;
  [../]
  [./stuff7_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;7&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff7_strain]
    type = ComputeFiniteStrain
    block = &#x27;7&#x27;
  [../]
  [./stuff7_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;7&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-6
  nl_rel_tol = 1e-5
  l_max_its = 100
  nl_max_its = 200

  start_time = 0.0
  end_time = 3.5
  l_tol = 1e-3
  dt = 0.1
  dtmin = 0.1
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[VectorPostprocessors]
  [./x_disp]
    type = NodalValueSampler
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    sort_by = id
  [../]
  [./y_disp]
    type = NodalValueSampler
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    sort_by = id
  [../]
  [./cont_press]
    type = NodalValueSampler
    variable = contact_pressure
    boundary = &#x27;3&#x27;
    sort_by = id
  [../]
[]

[Outputs]
  print_linear_residuals = true
  perf_graph = true
  [./exodus]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 5
  [../]
  [./chkfile]
    type = CSV
    show = &#x27;x_disp y_disp cont_press&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./chkfile2]
    type = CSV
    show = &#x27;bot_react_x bot_react_y disp_x639 disp_y639 top_react_x top_react_y&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./outfile]
    type = CSV
    delimiter = &#x27; &#x27;
    execute_vector_postprocessors_on = none
  [../]
[]

[Contact]
  [./interface]
    primary = 2
    secondary = 3
    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2eaaa47f-12bb-419e-a071-c31e82ff0e30"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_function.i</h4><pre class="moose-pre"><code class="language-text">#
# Simple pull test for cracking. This tests the option to prescribe the
# cracking strength using an AuxVariable. In this case, an elemental
# AuxVariable is used, and a function is used to prescribe its value.
# One of the elements is weaker than the others, so the crack localizes
# in that element.
#
[Mesh]
   file = plate.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[AuxVariables]
  [./cracking_stress_fn]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./crack_flags2]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 0.1 0.2 0.3 0.4&#x27;
    y = &#x27;0 0.001 0 -0.001 0&#x27;
  [../]
  [./fstress]
    type = ParsedFunction
    value = &#x27;if(x &gt; 0.667, 1.1e6, 1.2e6)&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx strain_xx strain_yy strain_xy strain_yz&#x27;
  [../]
[]

[AuxKernels]
  [./cracking_stress_fn]
    type = FunctionAux
    variable = cracking_stress_fn
    function = fstress
    execute_on = initial
  [../]
  [./crack_flags2]
    type = MaterialRealVectorValueAux
    property = crack_flags
    variable = crack_flags2
   component = 2
  [../]
[]

[BCs]
  [./pull]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    function = displ
  [../]

  [./pin_x]
    type = DirichletBC
    variable = disp_x
    boundary =  &#x27;1 2&#x27;
    value = 0
  [../]
  [./pin_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 4&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 200.0e7
    poissons_ratio = 0.0
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = cracking_stress_fn
    softening_models = abrupt_softening
  [../]
  [./abrupt_softening]
    type = AbruptSoftening
    residual_stress = 0.0
  [../]
[]

[Postprocessors]
  [./elem_stress_xx]
    type = ElementalVariableValue
    variable = stress_xx
    elementid = 2
  [../]
  [./elem_strain_xx]
    type = ElementalVariableValue
    variable = strain_xx
    elementid = 2
  [../]
  [./elem_crack_flags_x]
    type = ElementalVariableValue
    variable = crack_flags2
    elementid = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101               &#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.2
  dt = 0.0025
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8b1f2c8f-3a49-49e0-af28-84aebb3ce60e"><div class="modal-content"><h4>modules/combined/test/tests/internal_volume/hex20.i</h4><pre class="moose-pre"><code class="language-text">#
# Internal Volume Test
#
# This test is designed to compute the internal volume of a space considering
#   an embedded volume inside.
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total volume
#   is 7.
#
[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = meshes/hex20.e
[]

[Functions]
  [./step]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2. 3.&#x27;
    y = &#x27;0. 0. 1e-2 0.&#x27;
    scale_factor = 0.5
  [../]
[]

[Variables]
  [./disp_x]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_y]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_z]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    incremental = true
    strain = FINITE
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 100
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./prescribed_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 100
    function = step
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  solve_type = PJFNK

  start_time = 0.0
  dt = 1.0
  end_time = 3.0

  [./Quadrature]
    order = THIRD
  [../]
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./dispZ]
    type = ElementAverageValue
    block = &#x27;1 2&#x27;
    variable = disp_z
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2920bc09-7f06-47df-9bab-3b275c89dad8"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test1.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_columns.csv #Will generate error because data is expected in rows
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="87c80e3b-0d68-4215-9fed-931beb42d449"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_1/gh22.i</h4><pre class="moose-pre"><code class="language-text"># investigating validity of immobile saturation
# 50 elements, no SUPG

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 50
  xmin = -1
  xmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 10 100 1000 10000&#x27;
    x = &#x27;0 10 100 1000 10000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E3
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.1
  [../]
  [./SUPGnone]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -1.0
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    SUPG_UO = SUPGnone
    sat_UO = Saturation
    seff_UO = SeffVG
    viscosity = 1E-3
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1E0
  end_time = 1E5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh22
  execute_on = &#x27;timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="79e0744d-bf25-4463-abd4-aac3a85bab2b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_rayleigh_hht_ti.i</h4><pre class="moose-pre"><code class="language-text"># Test for damped small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# density (rho) = 1.0
# mass proportional rayleigh damping(eta) = 0.1
# stiffness proportional rayleigh damping(eta) = 0.1
# HHT time integration parameter (alpha) = -0.3
# Corresponding Newmark beta time integration parameters beta = 0.4225 and gamma = 0.8

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time  disp_y                vel_y                accel_y
# 0.0   0.0                   0.0                  0.0
# 0.2   0.019898364318588     0.18838688112273     1.1774180070171
# 0.4   0.045577003505278     0.087329917525455   -0.92596052423724
# 0.6   0.063767907208218     0.084330765885995    0.21274543331268
# 0.8   0.073602908614573     0.020029576220975   -0.45506879373455
# 1.0   0.06841704414745     -0.071840076837194   -0.46041813317992

[Mesh]
  type = GeneratedMesh
  nx = 10
  dim = 1
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x] # These auxkernels are only to check output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
  [./rot_accel_x]
    type = TestNewmarkTI
    displacement = rot_x
    variable = rot_accel_x
    first = false
  [../]
  [./rot_accel_y]
    type = TestNewmarkTI
    displacement = rot_y
    variable = rot_accel_y
    first = false
  [../]
  [./rot_accel_z]
    type = TestNewmarkTI
    displacement = rot_z
    variable = rot_accel_z
    first = false
  [../]
  [./rot_vel_x]
    type = TestNewmarkTI
    displacement = rot_x
    variable = rot_vel_x
  [../]
  [./rot_vel_y]
    type = TestNewmarkTI
    displacement = rot_y
    variable = rot_vel_y
  [../]
  [./rot_vel_z]
    type = TestNewmarkTI
    displacement = rot_z
    variable = rot_vel_z
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.2 0.4 10.0&#x27;
    y = &#x27;0.0 0.01  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10
  start_time = 0.0
  dt = 0.2
  end_time = 5.0
  timestep_tolerance = 1e-6

  # Time integrator
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.4225
    gamma = 0.8
  [../]
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
    zeta = 0.1
    alpha = -0.3
  [../]
  [./inertial_force_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 0
    variable = disp_x
    alpha = -0.3
  [../]
  [./inertial_force_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 1
    variable = disp_y
    alpha = -0.3
  [../]
  [./inertial_force_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 2
    variable = disp_z
    alpha = -0.3
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 3
    variable = rot_x
    alpha = -0.3
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 4
    variable = rot_y
    alpha = -0.3
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 5
    variable = rot_z
    alpha = -0.3
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  file_base = &#x27;dyn_euler_small_rayleigh_hht_out&#x27;
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="be548480-b6af-4812-8ad7-7167368b703e"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/diffusion_3d_hex20.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 3
  ny = 4
  nz = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.2
  elem_type = HEX20
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./square_planar_cut_uo]
    type = RectangleCutUserObject
    cut_data = &#x27;  0.35 1.01 -0.001
                  0.35 0.49 -0.001
                  0.35 0.49  0.201
                  0.35 1.01  0.201&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = left
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ed9f8075-80ce-4c38-9a25-f9f1d8de2690"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment.i</h4><pre class="moose-pre"><code class="language-text"># Test that models bending of a cantilever beam using shell elements

# A cantilever beam of length 10 m (in Y direction) and cross-section
# 1 m x 0.1 m is modeled using 4 shell elements placed along the length
# (Figure 6a from Dvorkin and Bathe, 1984). All displacements and
# X rotations are fixed on the bottom boundary. E = 2100000 and v = 0.0.
# A load of 0.5 N (in the Z direction) is applied at each node on the top
# boundary resulting in a total load of 1 N.

# The analytical solution for displacement at tip using small strain/rotations # is PL^3/3EI + PL/AG = 1.90485714 m
# The FEM solution using 4 shell elements is 1.875095 m with a relative error
# of 1.5%.

# Similarly, the analytical solution for slope at tip is PL^2/2EI = 0.285714286
# The FEM solution is 0.2857143 and the relative error is 5e-6%.

# The stress_yy for the four elements at z = -0.57735 * (t/2) (first qp below mid-surface of shell) are:
# 3031.089 Pa, 2165.064 Pa, 1299.038 Pa and 433.0127 Pa.
# Note the above values are the average stresses in each element.

# Analytically, stress_yy decreases linearly from y = 0 to y = 10 m.
# The maximum value of stress_yy at y = 0 is Mz/I = PL * 0.57735*(t/2)/I = 3464.1 Pa
# Therefore, the analytical value of stress at z = -0.57735 * (t/2) at the mid-point
# of the four elements are:
# 3031.0875 Pa, 2165.0625 Pa, 1299.0375 Pa ,433.0125 Pa

# The relative error in stress_yy is in the order of 5e-5%.

# The stress_yz at z = -0.57735 * (t/2) at all four elements from the simulation is 10 Pa.
# The analytical solution for the shear stress is: V/2/I *((t^2)/4 - z^2), where the shear force (V)
# is 1 N at any y along the length of the beam. Therefore, the analytical shear stress at
# z = -0.57735 * (t/2) is 10 Pa at any location along the length of the beam.

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 10.0
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  # aux variables for dynamics
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    variable = stress_yy
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    variable = stress_yz
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 2
  [../]

# Kernels for dynamics
[./accel_x]
  type = NewmarkAccelAux
  variable = accel_x
  displacement = disp_x
  velocity = vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_x]
  type = NewmarkVelAux
  variable = vel_x
  acceleration = accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_y]
  type = NewmarkAccelAux
  variable = accel_y
  displacement = disp_y
  velocity = vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_y]
  type = NewmarkVelAux
  variable = vel_y
  acceleration = accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_z]
  type = NewmarkAccelAux
  variable = accel_z
  displacement = disp_z
  velocity = vel_z
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_z]
  type = NewmarkVelAux
  variable = vel_z
  acceleration = accel_z
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_x]
  type = NewmarkAccelAux
  variable = rot_accel_x
  displacement = rot_x
  velocity = rot_vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_x]
  type = NewmarkVelAux
  variable = rot_vel_x
  acceleration = rot_accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_y]
  type = NewmarkAccelAux
  variable = rot_accel_y
  displacement = rot_y
  velocity = rot_vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_y]
  type = NewmarkVelAux
  variable = rot_vel_y
  acceleration = rot_accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]

[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_function]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0&#x27;
    y = &#x27;0.0 0.5&#x27;
  [../]
[]
[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;top&#x27;
    function = force_function
  [../]
[]
[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
  [../]

  [./inertial_force_x]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 0
    variable = disp_x
    thickness = 0.1
  [../]

  [./inertial_force_y]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 1
    variable = disp_y
    thickness = 0.1
  [../]

  [./inertial_force_z]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 2
    variable = disp_z
    thickness = 0.1
  [../]

  [./inertial_force_rot_x]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 3
    variable = rot_x
    thickness = 0.1
  [../]

  [./inertial_force_rot_y]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 4
    variable = rot_y
    thickness = 0.1
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 2100000
    poissons_ratio = 0.0
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeIncrementalShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 0.1
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_z_tip]
    type = PointValue
    point = &#x27;1.0 10.0 0.0&#x27;
    variable = disp_z
  [../]
  [./rot_x_tip]
    type = PointValue
    point = &#x27;0.0 10.0 0.0&#x27;
    variable = rot_x
  [../]
  [./stress_yy_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yy
  [../]
  [./stress_yy_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yy
  [../]
  [./stress_yy_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yy
  [../]
  [./stress_yy_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yy
  [../]
  [./stress_yz_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yz
  [../]
  [./stress_yz_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yz
  [../]
  [./stress_yz_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yz
  [../]
  [./stress_yz_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yz
  [../]
[]
[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_max_its = 2
  nl_rel_tol = 1e-10
  nl_abs_tol = 5e-4

  dt = 0.0005
  dtmin = 0.0005
  end_time = 1

#  [./TimeIntegrator]
#    type = NewmarkBeta
#    beta = 0.25
#    gamma = 0.5
#  [../]

[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cbfc96f6-29e4-4496-bf29-873c2e7b7f12"><div class="modal-content"><h4>modules/porous_flow/test/tests/buckley_leverett/bl01.i</h4><pre class="moose-pre"><code class="language-text"># Buckley-Leverett 1-phase.
# The front starts at (around) x=5, and at t=50 it should
# have moved to x=9.6.  The version below has a nonzero
# suction function, and at t=50, the front sits between
# (about) x=9.6 and x=9.9.  Changing the van-Genuchten
# al parameter to 1E-4 softens the front so it sits between
# (about) x=9.7 and x=10.4, and the simulation runs much faster.
# With al=1E-2 and nx=600, the front sits between x=9.6 and x=9.8,
# but takes about 100 times longer to run.

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 150
  xmin = 0
  xmax = 15
[]

[GlobalParams]
  PorousFlowDictator = dictator
  compute_enthalpy = false
  compute_internal_energy = false
[]

[Variables]
  [./pp]
    [./InitialCondition]
      type = FunctionIC
      function = &#x27;max((1000000-x/5*1000000)-20000,-20000)&#x27;
    [../]
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pp
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pp
    gravity = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = pp
    boundary = left
    value = 980000
  [../]
[]

[AuxVariables]
  [./sat]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./sat]
    type = MaterialStdVectorAux
    variable = sat
    execute_on = timestep_end
    index = 0
    property = PorousFlow_saturation_qp
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;pp&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.8
    alpha = 1e-3
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e6
      viscosity = 1e-3
      density0 = 1000
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pp
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityCorey
    n = 2
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.15
  [../]
[]

[Preconditioning]
  active = andy
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres bjacobi 1E-10 1E-10 20&#x27;
  [../]
[]

[Functions]
  [./timestepper]
    type = PiecewiseLinear
    x = &#x27;0    0.01 0.1 1   1.5 2   20  30  40  50&#x27;
    y = &#x27;0.01 0.1  0.2 0.3 0.1 0.3 0.3 0.4 0.4 0.5&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 50
  [./TimeStepper]
    type = FunctionDT
    function = timestepper
  [../]
[]

[VectorPostprocessors]
  [./pp]
    type = LineValueSampler
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;15 0 0&#x27;
    num_points = 150
    sort_by = x
    variable = pp
  [../]
  [./sat]
    type = LineValueSampler
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;15 0 0&#x27;
    num_points = 150
    sort_by = x
    variable = sat
  [../]
[]


[Outputs]
  file_base = bl01
  [./csv]
    type = CSV
    sync_only = true
    sync_times = &#x27;0.01 50&#x27;
  [../]
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial final&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="32eff997-b02b-4d77-9f90-9602d17ca112"><div class="modal-content"><h4>modules/combined/test/tests/fdp_geometric_coupling/fdp_geometric_coupling.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = twoBlocksContactDiceSecondary2OffsetGap.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 100.0
  [../]
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0 1 2&#x27;
    y = &#x27;0 1 1&#x27;
    scale_factor = 10.0
  [../]

  [./tempFunc]
    type = PiecewiseLinear
    x = &#x27;0. 3.&#x27;
    y = &#x27;100.0 440.0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./block1]
    block = 1
    volumetric_locking_correction = true
    incremental = true
    strain = FINITE
    eigenstrain_names = &#x27;thermal_expansion1&#x27;
    decomposition_method = EigenSolution
  [../]
  [./block2]
    block = 2
    volumetric_locking_correction = true
    incremental = true
    strain = FINITE
    eigenstrain_names = &#x27;thermal_expansion2&#x27;
    decomposition_method = EigenSolution
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]

[BCs]
  [./left_right_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 4&#x27;
    value = 0.0
  [../]

  [./left_right_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 4&#x27;
    value = 0.0
  [../]

  [./left_right_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1 4&#x27;
    value = 0.0
  [../]

  [./temp]
    type = FunctionDirichletBC
    variable = temp
    boundary = &#x27;2 3&#x27;
    function = tempFunc
  [../]
[]

[Contact]
  [./dummy_name]
    primary = 2
    secondary = 3
    penalty = 1e8
  [../]
[]

[Materials]

  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]

  [./thermal_expansion1]
    type = ComputeThermalExpansionEigenstrain
    block = 1
    thermal_expansion_coeff = 1e-4
    stress_free_temperature = 100.0
    temperature = temp
    eigenstrain_name = thermal_expansion1
  [../]

  [./thermal_expansion2]
    type = ComputeThermalExpansionEigenstrain
    block = 2
    thermal_expansion_coeff = 1e-5
    stress_free_temperature = 100.0
    temperature = temp
    eigenstrain_name = thermal_expansion2
  [../]

  [./heat]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
  [../]
[]

[Preconditioning]
  [./FDP]
    type = FDP
    full = true
    implicit_geometric_coupling = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -mat_fd_coloring_err -mat_fd_type&#x27;
  petsc_options_value = &#x27;lu       1e-8                 ds&#x27;

  nl_rel_tol = 1e-10

  l_max_its = 5
  nl_max_its = 3
  dt = 5.0e-1
  num_steps = 2
[]

[Outputs]
  file_base = fdp_geometric_coupling_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="35f6f244-007b-4599-8324-3fd90ae74d84"><div class="modal-content"><h4>modules/combined/test/tests/internal_volume/rspherical.i</h4><pre class="moose-pre"><code class="language-text">#
# Internal Volume Test
#
# This test is designed to compute the internal volume of a space considering
#   an embedded volume inside.
#
# The mesh is composed of two blocks with an interior cavity of volume 3.
#   The volume of each of the blocks is also 3.  The volume of the entire sphere
#   is 9.
#
[GlobalParams]
  displacements = &#x27;disp_x&#x27;
[]

[Problem]
  coord_type = RSPHERICAL
[]

[Mesh]
  file = meshes/rspherical.e
  construct_side_list_from_node_list = true
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = 1e4
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    incremental = true
    strain = FINITE
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2 3 4&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 3&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 3&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK

  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 10
    component = 0
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./intVol1]
    type = InternalVolume
    boundary = 2
    component = 0
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./intVol1Again]
    type = InternalVolume
    boundary = 9
    component = 0
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./intVol2]
    type = InternalVolume
    boundary = 11
    component = 0
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./intVolTotal]
    type = InternalVolume
    boundary = 4
    component = 0
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="910790e9-d992-4db5-9e2d-1341cee8e40f"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test1.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test1_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f3556b79-4da0-4899-95ac-660fd5c4862d"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/1D/1d_nodalmass_implicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for central difference integration for 1D elements

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    xmin = 0
    xmax = 10
    nx = 5
    dim = 1
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;10 0 0&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x&#x27;
  [../]
[]

[NodalKernels]
  [./force_x]
    type = UserForcingFunctionNodalKernel
    variable = disp_x
    boundary = right
    function = force_x
  [../]
  [./nodal_masses]
    type = NodalTranslationalInertia
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_x&#x27;
    boundary = &#x27;all&#x27;
  [../]
[]

[Functions]
  [./force_x]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27; # force
    scale_factor = 1e3
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 2e-10
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./accel_x]
    type = PointValue
    point = &#x27;10.0 0.0 0.0&#x27;
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1c37af33-cad1-4a1f-852d-b27b49037d41"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test2tt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test2tt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test2tt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bcee3f25-1138-4850-b2e1-abe579dba16a"><div class="modal-content"><h4>modules/combined/test/tests/thermal_conductivity_temperature_function_test/thermal_conductivity_temperature_function_test.i</h4><pre class="moose-pre"><code class="language-text">#
# This test evaluates the capability of HeatConductionMaterial to define
# thermal conductivity as a function of temperature.  The test uses the patch test
# cube mesh with a flux bc on one side and a temperature bc on the opposite side.
# The temperature bc changes as a function of time from 100 to 200.  The thermal
# conductivity is a function of temperature, with k = 1 for temps = 100-199, k = 2
# for temps _&gt;_ 200. The flux, q = 10 is constant.  The Transient Executioner is used here
# although the interial kernel is omitted, so this is really a series of two steady-state
# solutions.
#
#                         ---------------
#                        |               |
#                        |               |
#                q    -&gt; |       k       |  T2
#                        |               |
#             T1 = ?     |               |
#                         ---------------
#                              dx = 1
#
#
#                         q = -k dT/dx
#
#                         q = -k (T1 - T2)/dx
#
#                         T1 = (q/-k)*dx + T2
#
#                         for: T2 = 100, k = 1, q = -10
#
#                         T1 = 110
#                         --------
#
#                         for: T2 = 200, k = 2, q = -10
#
#                         T1 = 205
#                         --------
#

[Mesh]#Comment
  file = fe_patch.e
[] # Mesh

[Functions]
  [./k_func]
    type = PiecewiseLinear
    x = &#x27;100 199 200&#x27;
    y = &#x27;1   1   2&#x27;
  [../]

  [./c_func]
    type = PiecewiseLinear
    x = &#x27;100    200&#x27;
    y = &#x27;0.116  0.116&#x27;
  [../]

  [./t_func]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 100 200&#x27;
  [../]
[] # Functions

[Variables]

  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]

[] # Variables

[Kernels]

  [./heat_r]
    type = HeatConduction
    variable = temp
  [../]


[] # Kernels

[BCs]

  [./temps_function]
    type = FunctionDirichletBC
    variable = temp
    boundary = 1000
    function = t_func
  [../]

  [./flux_in]
    type = NeumannBC
    variable = temp
    boundary = 100
    value = 10
  [../]

[] # BCs

[Materials]

  [./heat]
    type = HeatConductionMaterial
    block = 1
    temp = temp
    thermal_conductivity_temperature_function = k_func
    specific_heat_temperature_function = c_func
  [../]

  [./density]
    type = Density
    block = 1
    density = 0.283
  [../]

[] # Materials


[Executioner]

  type = Transient


  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;



  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       101&#x27;


  line_search = &#x27;none&#x27;


  l_max_its = 100
  l_tol = 8e-3

  nl_max_its = 15
  nl_rel_tol = 1e-4
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1
  end_time = 2
  num_steps = 2


[] # Executioner

[Outputs]
  file_base = out
  exodus = true
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="afbe06d1-184d-47ca-aaaf-9521797b4de9"><div class="modal-content"><h4>test/tests/test_harness/csv_validation_tester_01.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 3
  xmax = 3
[]

[Functions]
  [./fn]
    type = PiecewiseLinear
    axis = x
    x = &#x27;0 2&#x27;
    y = &#x27;1.01 2.99&#x27;
  [../]
[]

[AuxVariables]
  [./a]
  [../]
[]

[AuxKernels]
  [./a_ak]
    type = FunctionAux
    variable = a
    function = fn
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Postprocessors]
  [./value1]
    type = PointValue
    variable = a
    point = &#x27;0 0 0&#x27;
  [../]

  [./value2]
    type = PointValue
    variable = a
    point = &#x27;1 0 0&#x27;
  [../]

  [./value3]
    type = PointValue
    variable = a
    point = &#x27;2 0 0&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  dt = 0.1
  solve_type = NEWTON
[]

[Outputs]
  [./csv]
    type = CSV
    file_base = csv_validation_tester_01
    execute_on = &#x27;final&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="03b9d3a1-eb88-4e8c-9ebb-5903d23a7300"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_xyz.i</h4><pre class="moose-pre"><code class="language-text">#

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displx]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.00175&#x27;
  [../]
  [./velocity_y]
    type = ParsedFunction
    value = &#x27;if(t &lt; 2, 0.00175, 0)&#x27;
  [../]
  [./velocity_z]
    type = ParsedFunction
    value = 0.00175
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./fix_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./move_x]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displx
  [../]

  [./fix_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
  [./move_y]
    type = PresetVelocity
    variable = disp_y
    boundary = 5
    function = velocity_y
#    time_periods = &#x27;p2 p3&#x27;
  [../]

  [./fix_z]
    type = ADDirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
  [./move_z]
    type = PresetVelocity
    variable = disp_z
    boundary = 6
    function = velocity_z
#    time_periods = &#x27;p3&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 186.5e9
    poissons_ratio = .316
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 119.3e6
    softening_models = exponential_softening
  [../]
  [./exponential_softening]
    type = ADExponentialSoftening
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type&#x27;
  petsc_options_value = &#x27;101                lu&#x27;


  line_search = &#x27;none&#x27;


  l_max_its = 100
  l_tol = 1e-5

  nl_max_its = 100
  nl_abs_tol = 1e-4
  #nl_rel_tol = 1e-4
  nl_rel_tol = 1e-6

  start_time = 0.0
  end_time = 3.0
  dt = 0.01
[]

[Controls]
  [./p1]
    type = TimePeriod
    start_time = 0.0
    end_time = 1.0
    disable_objects = &#x27;BCs/move_y BCs/move_z&#x27;
    reverse_on_false = false
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]

  [./p2]
    type = TimePeriod
    start_time = 1.0
    end_time = 2.0
    disable_objects = &#x27;BCs/move_z&#x27;
    enable_objects = &#x27;BCs/move_y&#x27;
    reverse_on_false = false
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]

  [./p3]
    type = TimePeriod
    start_time = 2.0
    end_time = 3.0
    enable_objects = &#x27;BCs/move_y BCs/move_z&#x27;
    reverse_on_false = false
    execute_on = &#x27;initial timestep_begin&#x27;
    set_sync_times = true
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="acacfa24-12c6-4877-9a9e-be159701c061"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_hht.i</h4><pre class="moose-pre"><code class="language-text"># Test for rayleigh damping implemented using HHT time integration
#
# The test is for an 1D bar element of  unit length fixed on one end
# with a ramped pressure boundary condition applied to the other end.
# zeta and eta correspond to the stiffness and mass proportional rayleigh damping
# alpha, beta and gamma are HHT time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel + (eta*M+zeta*K)*[(1+alpha)vel-alpha vel_old]
# + alpha*(K*disp - K*disp_old) + K*disp = P(t+alpha dt)*Area
#
# Here M is the mass matrix, K is the stiffness matrix, P is the applied pressure
#
# This equation is equivalent to:
#
# density*accel + eta*density*[(1+alpha)vel-alpha vel_old]
# + zeta*[(1+alpha)*d/dt(Div stress)- alpha*d/dt(Div stress_old)]
# + alpha *(Div stress - Div stress_old) +Div Stress= P(t+alpha dt)
#
# The first two terms on the left are evaluated using the Inertial force kernel
# The next three terms on the left involving zeta and alpha are evaluated using
# the DynamicStressDivergenceTensors Kernel
# The residual due to Pressure is evaluated using Pressure boundary condition
#
# The system will come to steady state slowly after the pressure becomes constant.
# Alpha equal to zero will result in Newmark integration.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    zeta = 0.1
    alpha = 0.11
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.25
    gamma = 0.5
    eta=0.1
    alpha = 0.11
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.25
    gamma = 0.5
    eta=0.1
    alpha = 0.11
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    gamma = 0.5
    eta = 0.1
    alpha = 0.11
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = bottom
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
      disp_z = disp_z
      factor = 1
      alpha  = 0.11
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 2
  dt = 0.1
[]


[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 1.0 2.0 5.0&#x27;
    y = &#x27;0.0 0.1 0.2 1.0 1.0 1.0&#x27;
    scale_factor = 1e9
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalMaxValue
    variable = disp_y
    boundary = bottom
  [../]
  [./vel]
    type = NodalMaxValue
    variable = vel_y
    boundary = bottom
  [../]
  [./accel]
    type = NodalMaxValue
    variable = accel_y
    boundary = bottom
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./strain_yy]
    type = ElementAverageValue
    variable = strain_yy
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7894f2a4-2661-435c-86c4-197464cfbed6"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh06.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = true
# supg = false
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGnone
  [../]
  [./SUPGgas]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 2
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-13 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh06
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dcc93163-22a6-41fd-b764-9b7f88a1309c"><div class="modal-content"><h4>modules/contact/test/tests/hertz_spherical/hertz_contact.i</h4><pre class="moose-pre"><code class="language-text"># Hertz Contact: Sphere on sphere

# Spheres have the same radius, Young&#x27;s modulus, and Poisson&#x27;s ratio.

# Define E:
# 1/E = (1-nu1^2)/E1 + (1-nu2^2)/E2
#
# Effective radius R:
# 1/R = 1/R1 + 1/R2
#
# F is the applied compressive load.
#
# Area of contact a::
# a^3 = 3FR/4E
#
# Depth of indentation d:
# d = a^2/R
#
#
# Let R1 = R2 = 2.  Then R = 1.
#
# Let nu1 = nu2 = 0.25, E1 = E2 = 1.40625e7.  Then E = 7.5e6.
#
# Let F = 10000.  Then a = 0.1, d = 0.01.
#
[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]


[Mesh]#Comment
  file = hertz_contact.e
[] # Mesh

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 795.77471545947674 # 10000/pi/2^2
  [../]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.  1.    2.&#x27;
    y = &#x27;0. -0.01 -0.01&#x27;
  [../]
[] # Functions

[Variables]

  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]

[] # Variables

[AuxVariables]

  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./hydrostatic]
    order = CONSTANT
    family = MONOMIAL
  [../]

[] # AuxVariables

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = SMALL
  #  extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[AuxKernels]

  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]

[] # AuxKernels

[BCs]

  [./base_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1000
    value = 0.0
  [../]
  [./base_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1000
    value = 0.0
  [../]
  [./base_z]
    type = DirichletBC
    variable = disp_z
    boundary = 1000
    value = 0.0
  [../]

  [./symm_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./symm_z]
    type = DirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
  [./disp_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

[] # BCs

[Contact]
  [./dummy_name]
    primary = 1000
    secondary = 100
    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+10
  [../]
[]

[Materials]

  [./tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1.40625e7
    poissons_ratio = 0.25
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = &#x27;1&#x27;
  [../]

  [./tensor_1000]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1000&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]
  [./stress_1000]
    type = ComputeLinearElasticStress
    block = &#x27;1000&#x27;
  [../]

[] # Materials

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  []
[]

[Executioner]

  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;
  line_search = &#x27;none&#x27;


  nl_abs_tol = 1e-7
  l_max_its = 200
  start_time = 0.0
  dt = 0.5
  end_time = 2.0
[] # Executioner

[Postprocessors]
  [./maxdisp]
    type = NodalVariableValue
    nodeid = 122 # 123-1 where 123 is the exodus node number of the top-center node
    variable = disp_y
  [../]
[]

[Outputs]
  [./out]
    type = Exodus
  [../]
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="46beff83-824c-45fd-9b1c-7059b6dfa039"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_dual.i</h4><pre class="moose-pre"><code class="language-text"># This test provides an example of combining two LPS viscoplasticity models with different stress
# exponents.

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmax = 0.002
  ymax = 0.002
[]

[Variables]
  [./temp]
    initial_condition = 1000
  [../]
[]

[Kernels]
  [./dt]
    type = ADTimeDerivative
    variable = temp
  [../]
  [./diff]
    type = ADDiffusion
    variable = temp
  [../]
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
  [./tot_effective_viscoplasticity]
    type = ParsedFunction
    vals = &#x27;lps_1_eff_creep_strain lps_3_eff_creep_strain&#x27;
    vars = &#x27;lps_1_eff_creep_strain lps_3_eff_creep_strain&#x27;
    value = &#x27;lps_1_eff_creep_strain+lps_3_eff_creep_strain&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = &#x27;one two&#x27;
    initial_porosity = 0.1
    outputs = all
  [../]

  [./one]
    type = ADViscoplasticityStressUpdate
    coefficient = &#x27;coef_3&#x27;
    power = 3
    base_name = &#x27;lps_1&#x27;
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./two]
    type = ADViscoplasticityStressUpdate
    coefficient = 1e-10
    power = 1
    base_name = &#x27;lps_3&#x27;
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./coef]
    type = ADParsedMaterial
    f_name = coef_3
    # Example of creep power law
    args = temp
    function = &#x27;0.5e-18 * exp(-4e4 / 1.987 / temp)&#x27;
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
  [./temp_ramp]
    type = ADFunctionDirichletBC
    boundary = right
    function = &#x27;1000 + 400 * t / 0.12&#x27;
    variable = temp
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./lps_1_eff_creep_strain]
    type = ElementAverageValue
    variable = lps_1_effective_viscoplasticity
  [../]
  [./lps_3_eff_creep_strain]
    type = ElementAverageValue
    variable = lps_3_effective_viscoplasticity
  [../]
  [./lps_1_gauge_stress]
    type = ElementAverageValue
    variable = lps_1_gauge_stress
  [../]
  [./lps_3_gauge_stress]
    type = ElementAverageValue
    variable = lps_3_gauge_stress
  [../]
  [./eff_creep_strain_tot]
    type = FunctionValuePostprocessor
    function = tot_effective_viscoplasticity
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7d75cb4b-d511-45c8-b0b6-3a5bf3d9b01d"><div class="modal-content"><h4>modules/combined/test/tests/internal_volume/rz_quad8.i</h4><pre class="moose-pre"><code class="language-text">#
# Internal Volume Test
#
# This test is designed to compute the internal volume of a space considering
#   an embedded volume inside.
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total volume
#   is 7.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = meshes/rz_quad8.e
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = 1e4
  [../]
[]

[Variables]
  [./disp_x]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_y]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    incremental = true
    strain = FINITE
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]

  [./Pressure]
    [./the_pressure]
      boundary = 3
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK

  start_time = 0.0
  dt = 1.0
  end_time = 1.0

  [./Quadrature]
    order = THIRD
  [../]
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f6fb6c27-0a3a-436e-95cf-1375b3d5a114"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/3d.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = - (0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# The parameters combined at t = 1 gives p = 301.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 3d.e
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = ADDiffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = ADFunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e1
    poissons_ratio = 0
    block = 1
  [../]
  [./strain1]
    type = ADComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0
    block = 2
  [../]
  [./strain2]
    type = ADComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cf970470-2d72-4479-a48f-34a86d978783"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_2d_rot.i</h4><pre class="moose-pre"><code class="language-text">#This tests the Interaction-Integral evaluation capability.
#This is a 2d nonlinear-plane strain model

[GlobalParams]
  order = FIRST
#  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d_rot.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = &#x27;InteractionIntegralKI InteractionIntegralKII InteractionIntegralKIII&#x27;
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;0 1 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;4.0 4.5 5.0 5.5 6.0&#x27;
  radius_outer = &#x27;4.5 5.0 5.5 6.0 6.5&#x27;
  block = 1
  youngs_modulus = 207000
  poissons_ratio = 0.3
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_x
    boundary = 100
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_y
    boundary = 700
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = interaction_integral_2d_rot_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1fe79850-7458-444e-998d-944e79f27292"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3nstt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3tt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3nstt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="332fada5-de34-4032-bfbd-18fcfbeffb4a"><div class="modal-content"><h4>modules/xfem/test/tests/mechanical_constraint/glued_penalty.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = false
[]

[XFEM]
  geometric_cut_userobjects = &#x27;line_seg_cut_uo&#x27;
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 11
  ny = 11
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;1.0  0.5  0.0  0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    planar_formulation = plane_strain
    add_variables = true
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0  50   100&#x27;
    y=&#x27;0  0.02 0.1&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = bottom
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
  [./topx]
    type = DirichletBC
    boundary = top
    variable = disp_x
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    boundary = top
    variable = disp_y
    function = pull
  [../]
[]

[Constraints]
  [./disp_x]
    type = XFEMSingleVariableConstraint
    variable = disp_x
    use_penalty = true
    alpha = 1.0e8
    use_displaced_mesh = true
    geometric_cut_userobject = &#x27;line_seg_cut_uo&#x27;
  [../]
  [./disp_y]
    type = XFEMSingleVariableConstraint
    variable = disp_y
    use_penalty = true
    alpha = 1.0e8
    use_displaced_mesh = true
    geometric_cut_userobject = &#x27;line_seg_cut_uo&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 0
  [../]

  [./_elastic_strain]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-9

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 2.0
  num_steps = 5000

  max_xfem_update = 1
[]

[Outputs]
  exodus = true
  execute_on = timestep_end
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b6ad4b8f-f81b-4c82-9779-60ee38966466"><div class="modal-content"><h4>modules/combined/test/tests/adaptive_timestepping/adapt_tstep_function_change.i</h4><pre class="moose-pre"><code class="language-text"># This is a test designed to evaluate the cabability of the
# IterationAdaptiveDT TimeStepper to adjust time step size according to
# a function.  For example, if the power input function for a BISON
# simulation rapidly increases or decreases, the IterationAdaptiveDT
# TimeStepper should take time steps small enough to capture the
# oscillation.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  order = FIRST
  family = LAGRANGE
  block = 1
[]

[Mesh]
  file = 1hex8_10mm_cube.e
[]

[Functions]
  [./Fiss_Function]
    type = PiecewiseLinear
    x = &#x27;0 1e6  2e6  2.001e6 2.002e6&#x27;
    y = &#x27;0 3e8  3e8  12e8    0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]

  [./disp_y]
  [../]

  [./disp_z]
  [../]

  [./temp]
    initial_condition = 300.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    volumetric_locking_correction = true
    incremental = true
    eigenstrain_names = thermal_expansion
    decomposition_method = EigenSolution
    add_variables  = true
    generate_output = &#x27;vonmises_stress&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]

  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]

  [./heat_source]
     type = HeatSource
     variable = temp
     value = 1.0
     function = Fiss_Function
  [../]
[]

[BCs]
  [./bottom_temp]
    type = DirichletBC
    variable = temp
    boundary = 1
    value = 300
  [../]
  [./top_bottom_disp_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1&#x27;
    value = 0
  [../]
  [./top_bottom_disp_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1&#x27;
    value = 0
  [../]
  [./top_bottom_disp_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1&#x27;
    value = 0
  [../]
[]

[Materials]
 [./thermal]
    type = HeatConductionMaterial
    temp = temp
    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 300e6
    poissons_ratio = .3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 5e-6
    stress_free_temperature = 300.0
    temperature = temp
    eigenstrain_name = thermal_expansion
  [../]

  [./density]
    type = Density
    density = 10963.0
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  verbose = true
  nl_abs_tol = 1e-10
  start_time = 0.0
  num_steps = 50000
  end_time = 2.002e6
  [./TimeStepper]
    type = IterationAdaptiveDT
    timestep_limiting_function = Fiss_Function
    max_function_change = 3e7
    dt = 1e6
  [../]
[]

[Postprocessors]
  [./Temperature_of_Block]
    type = ElementAverageValue
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./vonMises]
    type = ElementAverageValue
    variable = vonmises_stress
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d67477e3-c01f-4251-9f00-43498e4c0e83"><div class="modal-content"><h4>modules/porous_flow/test/tests/infiltration_and_drainage/bw01.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 400
  ny = 1
  xmin = -10
  xmax = 10
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-5 1E-2 1E-2 1E-1&#x27;
    x = &#x27;0 1E-5 1 10&#x27;
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = pressure
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureBW
    Sn = 0.0
    Ss = 1.0
    C = 1.5
    las = 2
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      viscosity = 4
      density0 = 10
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pressure
    capillary_pressure = pc
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityBW
    Sn = 0.0
    Ss = 1.0
    Kn = 0
    Ks = 1
    C = 1.5
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.25
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0  0 1 0  0 0 1&#x27;
  [../]
[]

[Variables]
  [./pressure]
    initial_condition = -9E2
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pressure
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pressure
    gravity = &#x27;-0.1 0 0&#x27;
  [../]
[]

[AuxVariables]
  [./SWater]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./SWater]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 0
    variable = SWater
  [../]
[]

[BCs]
  [./recharge]
    type = PorousFlowSink
    variable = pressure
    boundary = right
    flux_function = -1.25 # corresponds to Rstar being 0.5 because i have to multiply by density*porosity
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10      1E-10      10000&#x27;
  [../]
[]

[VectorPostprocessors]
  [./swater]
    type = LineValueSampler
    variable = SWater
    start_point = &#x27;-10 0 0&#x27;
    end_point = &#x27;10 0 0&#x27;
    sort_by = x
    num_points = 101
    execute_on = timestep_end
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 8

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = bw01
  sync_times = &#x27;0.5 2 8&#x27;
  [./exodus]
    type = Exodus
    sync_only = true
  [../]
  [./along_line]
    type = CSV
    sync_only = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="eefb81f5-dc8c-499c-8d40-60042c684fb0"><div class="modal-content"><h4>modules/geochemistry/test/tests/solubilities_and_activities/gypsum_solubility.i</h4><pre class="moose-pre"><code class="language-text">[TimeDependentReactionSolver]
  model_definition = definition
  swap_out_of_basis = &quot;Ca++&quot;
  swap_into_basis = &quot;Gypsum&quot;
  charge_balance_species = &quot;SO4--&quot;
  constraint_species = &quot;H2O              Cl-           Na+           SO4--              Gypsum&quot;
  constraint_value = &quot;  1.0              1E-10         1E-10         1E-6               0.5814&quot;
  constraint_meaning = &quot;kg_solvent_water free_molality free_molality moles_bulk_species free_moles_mineral_species&quot;
  source_species_names = &#x27;NaCl&#x27;
  source_species_rates = &#x27;1.0&#x27;
  add_aux_pH = false # there is no H+ in the problem
  ramp_max_ionic_strength_initial = 0 # not needed in this simple problem
  stoichiometric_ionic_str_using_Cl_only = true # for comparison with GWB
  abs_tol = 1E-12
  execute_console_output_on = &#x27;&#x27; # only CSV output in this example
[]

[UserObjects]
  [./definition]
    type = GeochemicalModelDefinition
    database_file = &quot;../../../database/moose_geochemdb.json&quot;
    basis_species = &quot;H2O Cl- Na+ SO4-- Ca++&quot;
    equilibrium_minerals = &quot;Gypsum&quot;
    piecewise_linear_interpolation = true # for comparison with GWB
  [../]
[]

[Functions]
  [./timestepper]
    type = PiecewiseLinear
    x = &#x27;0    0.1&#x27;
    y = &#x27;0.01 0.1&#x27;
  [../]
[]

[Executioner]
  type = Transient
  [./TimeStepper]
    type = FunctionDT
    function = timestepper
  [../]
  end_time = 3
[]

[Outputs]
  csv = true
[]

[AuxVariables]
  [./dissolved_gypsum_moles]
  [../]
[]
[AuxKernels]
  [./dissolved_gypsum_moles]
    type = ParsedAux
    args = &#x27;bulk_moles_Gypsum free_mg_Gypsum&#x27;
    function = &#x27;bulk_moles_Gypsum - free_mg_Gypsum / 1000 / 172.168 &#x27;
    variable = dissolved_gypsum_moles
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[Postprocessors]
  [./cl_molal]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &#x27;molal_Cl-&#x27;
  [../]
  [./dissolved_gypsum_mol]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = dissolved_gypsum_moles
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2f2f9f3a-1d60-401c-82a2-1cec0849077d"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test5.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = dummy
    xy_data = &#x27;1 2&#x27;
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2468baf0-7d5a-4ab0-a9dc-d9436587272c"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/square_branch_quad8_2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = false
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD8
[]

[UserObjects]
  [./line_seg_cut_set_uo]
    type = LineSegmentCutSetUserObject
    cut_data = &#x27;-1.0000e-10   6.6340e-01   6.6340e-01  -1.0000e-10  0.0  1.0
                 3.3120e-01   3.3200e-01   1.0001e+00   3.3200e-01  1.0  2.0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    planar_formulation = PLANE_STRAIN
  [../]
[]

[Functions]
  [./right_disp_x]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
  [./top_disp_y]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
[]

[BCs]
  [./right_x]
    type = FunctionDirichletBC
    boundary = 1
    variable = disp_x
    function = right_disp_x
  [../]
  [./top_y]
    type = FunctionDirichletBC
    boundary = 2
    variable = disp_y
    function = top_disp_y
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
  [./left_x]
    type = DirichletBC
    boundary = 3
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-16
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 2.2
  num_steps = 5000
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="78a21757-1a09-4490-8987-ea1a94ca2180"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D_xz.i</h4><pre class="moose-pre"><code class="language-text">#
# 2D Cylindrical Gap Heat Transfer Test.
#
# This test exercises 2D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid cylinder of radius = 1 unit, and outer
# hollow cylinder with an inner radius of 2 in the x-z plane. In other words,
# the gap between them is 1 radial unit in length.
#
# The calculated results are the same as for the cyl2D.i case in the x-y plane.

[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  [file]
    type = FileMeshGenerator
    file = cyl2D.e
  []
  [./rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;0 90 0&#x27;
    input = file
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]

[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]

[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = CYLINDER
    cylinder_axis_point_1 = &#x27;0 0 0&#x27;
    cylinder_axis_point_2 = &#x27;0 1 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9b995ed6-0a66-4110-96ee-f63d097996da"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_multiple_softening.i</h4><pre class="moose-pre"><code class="language-text"># Test of cracking with direction-specific release models in 3
# directions. Block is first pulled in one direction, and then
# held while it is sequentially pulled in the other two
# directions. Poisson&#x27;s ratio is zero so that the cracking in one
# direction doesn&#x27;t affect the others.

# Softening in the three directions should follow the laws for the
# prescribed models in the three directions, which are power law (x),
# exponential (y), and abrupt (z).

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displx]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3&#x27;
    y = &#x27;0 1 1 1&#x27;
  [../]
  [./disply]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3&#x27;
    y = &#x27;0 0 1 1&#x27;
  [../]
  [./displz]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3&#x27;
    y = &#x27;0 0 0 1&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pullx]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = right
    function = displx
  [../]
  [./pully]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = disply
  [../]
  [./pullz]
    type = ADFunctionDirichletBC
    variable = disp_z
    boundary = front
    function = displz
  [../]
  [./left]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./bottom]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./back]
    type = ADDirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 1.68e6
    softening_models = &#x27;power_law_softening exponential_softening abrupt_softening&#x27;
    prescribed_crack_directions = &#x27;x y z&#x27;
  [../]
  [./power_law_softening]
    type = ADPowerLawSoftening
    stiffness_reduction = 0.3333
  [../]
  [./exponential_softening]
    type = ADExponentialSoftening
  [../]
  [./abrupt_softening]
    type = ADAbruptSoftening
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 3.0
  dt = 0.01
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="de7c50e4-2173-4e0a-bccb-2e539e147025"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/planar_xz.i</h4><pre class="moose-pre"><code class="language-text"># 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks in the x-z plane.  Each element block
# is a square. They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
# across each block. The temperature of the far bottom boundary
# is ramped from 100 to 200 over one time unit.  The temperature of the far top
# boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
# Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
# gapK(Tavg) = 1.0*Tavg
#
# The heat flux across the gap at time = 1 is then:
#
# Flux = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors.  These results
# are the same as for the unit 1-D gap heat transfer between two unit cubes.

[Mesh]
  [file]
    type = FileMeshGenerator
    file = simple_2D.e
  []
  [./rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;0 90 0&#x27;
    input = file
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_bottom]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_top]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  l_tol = 1e-3
  l_max_its = 100

  dt = 1e-1
  end_time = 1.0
[]

[Postprocessors]
  [./temp_bottom]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_top]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_bottom]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_top]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e06694f7-54ed-4671-acfa-7601e35e491c"><div class="modal-content"><h4>modules/xfem/test/tests/second_order_elements/square_branch_quad9_2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = false
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD9
[]

[UserObjects]
  [./line_seg_cut_set_uo]
    type = LineSegmentCutSetUserObject
    cut_data = &#x27;-1.0000e-10   6.6340e-01   6.6340e-01  -1.0000e-10  0.0  1.0
                 3.3120e-01   3.3200e-01   1.0001e+00   3.3200e-01  1.0  2.0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
  [../]
[]

[Functions]
  [./right_disp_x]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
  [./top_disp_y]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
[]

[BCs]
  [./right_x]
    type = FunctionDirichletBC
    boundary = 1
    variable = disp_x
    function = right_disp_x
  [../]
  [./top_y]
    type = FunctionDirichletBC
    boundary = 2
    variable = disp_y
    function = top_disp_y
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
  [./left_x]
    type = DirichletBC
    boundary = 3
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-16
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 2.2
  num_steps = 5000
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ce25f89a-a51e-4b9d-acc6-dab42728d037"><div class="modal-content"><h4>modules/combined/test/tests/internal_volume/rz_displaced.i</h4><pre class="moose-pre"><code class="language-text">#
# Volume Test
#
# This test is designed to compute the volume of a space when displacements
#   are imposed.
#
# The mesh is composed of one block (1) with two elements.  The mesh is
#   such that the initial volume is 1.  One element face is displaced to
#   produce a final volume of 2.
#
#     r1
#   +----+   -
#   |    |   |
#   +----+   h    V1 = pi * h * r1^2
#   |    |   |
#   +----+   -
#
#   becomes
#
#   +----+
#   |     \
#   +------+      v2 = pi * h/2 * ( r2^2 + 1/3 * ( r2^2 + r2*r1 + r1^2 ) )
#   |      |
#   +------+
#      r2
#
#   r1 = 1
#   r2 = 1.5380168369562588
#   h  = 1/pi
#
#  Note:  Because the InternalVolume PP computes cavity volumes as positive,
#         the volumes reported are negative.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = meshes/rz_displaced.e
  # This test uses ElementalVariableValue postprocessors on specific
  # elements, so element numbering needs to stay unchanged
  allow_renumbering = false
[]

[Functions]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 0.5380168369562588&#x27;
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./volumetric_strain]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = false
    decomposition_method = EigenSolution
    incremental = true
    strain = FINITE
  [../]
[]

[AuxKernels]
  [./fred]
    type = RankTwoScalarAux
    rank_two_tensor = total_strain
    variable = volumetric_strain
    scalar_type = VolumetricStrain
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./x]
    type = FunctionDirichletBC
    boundary = 3
    variable = disp_x
    function = disp_x
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK

  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./volStrain0]
    type = ElementalVariableValue
    elementid = 0
    variable = volumetric_strain
  [../]
  [./volStrain1]
    type = ElementalVariableValue
    elementid = 1
    variable = volumetric_strain
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="76d0a1bc-ab47-4761-a69d-e05a84545d96"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_3d.i</h4><pre class="moose-pre"><code class="language-text">#This tests the Interaction-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with 2 elements
#through the thickness, and calculates the Interaction-Integrals using options
#to treat it as 3d.

[GlobalParams]
  order = FIRST
#  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack3d.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = &#x27;InteractionIntegralKI InteractionIntegralKII InteractionIntegralKIII&#x27;
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  radius_inner = &#x27;4.0 5.5&#x27;
  radius_outer = &#x27;5.5 7.0&#x27;
  block = 1
  youngs_modulus = 207000
  poissons_ratio = 0.3
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_z2]
    type = DirichletBC
    variable = disp_z
    boundary = 510
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]


[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = interaction_integral_3d_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3987b606-4ab1-42e9-9f85-8f648c7f0cdb"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4nnstt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4tt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
    normal_smoothing_method = nodal_normal_based
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4nnstt_out
  exodus = true
[]

[NodalNormals]
  boundary = 11
  corner_boundary = 20
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="69acd70d-da84-4c2b-bf4c-c4cb0fbcb40a"><div class="modal-content"><h4>modules/combined/test/tests/internal_volume/hex8.i</h4><pre class="moose-pre"><code class="language-text">#
# Internal Volume Test
#
# This test is designed to compute the internal volume of a space considering
#   an embedded volume inside.
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total volume
#   is 7.
#
# The internal volume is then adjusted by a piecewise linear time varying
# function.  Thus, the total volume is 7 plus the addition at the particular
# time.
#
#  Time |  Addition  | Total volume
#   0   |    0.0     |     7.0
#   1   |    3.0     |    10.0
#   2   |    7.0     |    14.0
#   3   |   -3.0     |     4.0
#
[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = meshes/hex8.e
[]

[Functions]
  [./step]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2. 3.&#x27;
    y = &#x27;0. 0. 1e-2 0.&#x27;
    scale_factor = 0.5
  [../]
  [./addition]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2. 3.&#x27;
    y = &#x27;0. 3. 7. -3.&#x27;
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = true
    incremental = true
    strain = FINITE
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 100
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./prescribed_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 100
    function = step
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  dt = 1.0
  end_time = 3.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    addition = addition
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./dispZ]
    type = ElementAverageValue
    block = &#x27;1 2&#x27;
    variable = disp_z
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5a580c75-4499-4045-abcd-8f6d0566340d"><div class="modal-content"><h4>test/tests/multiapps/sub_cycling_failure/master_gold.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Functions]
  # These mimic the behavior of the failing solve
  [./dts]
    type = PiecewiseLinear
    x = &#x27;0    0.1   0.15&#x27;
    y = &#x27;0.1  0.05  0.1&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 0.1

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./sub]
    type = TransientMultiApp
    app_type = MooseTestApp
    execute_on = timestep_end
    positions = &#x27;0 0 0&#x27;
    input_files = sub_gold.i
    sub_cycling = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4e51f044-561b-44c8-8abb-edf172f4af93"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral_vtest/j_int_surfbreak_ellip_crack_sym_mm_cfp_cm.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = ellip_crack_4sym_norad_mm.e
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./resid_z]
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 0.1&#x27;
    scale_factor = -689.5 #MPa
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  crack_direction_method = CrackMouth
  crack_mouth_boundary = 11
  crack_end_direction_method = CrackDirectionVector
  crack_direction_vector_end_1 = &#x27;0.0 1.0 0.0&#x27;
  crack_direction_vector_end_2 = &#x27;1.0 0.0 0.0&#x27;
  crack_front_points = &#x27;0             254           0
                        127.308       248.843       0
                        249.446       233.581       0
                        361.455       208.835       0
                        508.003       152.398       0
                        602.415       80.3208       0
                        635           0             0&#x27;
  radius_inner = &#x27;12.5 25.0 37.5&#x27;
  radius_outer = &#x27;25.0 37.5 50.0&#x27;
  intersecting_boundary = &#x27;1 2&#x27;
  symmetry_plane = 2
  position_type = angle
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 12
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 5
      function = rampConstantUp
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]

   type = Transient
  # Two sets of linesearch options are for petsc 3.1 and 3.3 respectively
  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

#  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 1e-5
   nl_rel_tol = 1e-11
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./nl_its]
    type = NumNonlinearIterations
  [../]
  [./lin_its]
    type = NumLinearIterations
  [../]
  [./react_z]
    type = NodalSum
    variable = resid_z
    boundary = 5
  [../]
[]


[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = j_int_surfbreak_ellip_crack_sym_mm_cfp_cm_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5e0688fe-d126-48ee-842a-de82c1bfc6d0"><div class="modal-content"><h4>test/tests/time_steppers/iteration_adaptive/adapt_tstep_pps_lim.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 50
  ny = 2
  xmax = 5
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./timestep_fn]
    type = PiecewiseLinear
    x = &#x27;0.  40.&#x27;
    y = &#x27;10. 1. &#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./dt]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 10
  [../]
  [./right]
    type = NeumannBC
    variable = u
    boundary = right
    value = -1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  start_time = 0.0
  end_time = 40.0
  n_startup_steps = 2
  dtmax = 6.0
  [./TimeStepper]
    type = IterationAdaptiveDT
    optimal_iterations = 10
    timestep_limiting_postprocessor = timestep_pp
    dt = 1.0
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]

# Just use a simple postprocessor to test capability to limit the time step length to the postprocessor value
  [./timestep_pp]
    type = FunctionValuePostprocessor
    function = timestep_fn
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5543b679-1356-405c-90e7-6ceb5aa6a2f6"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_xyz.i</h4><pre class="moose-pre"><code class="language-text">#

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displx]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.00175&#x27;
  [../]
  [./velocity_y]
    type = ParsedFunction
    value = &#x27;if(t &lt; 2, 0.00175, 0)&#x27;
  [../]
  [./velocity_z]
    type = ParsedFunction
    value = 0.00175
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./fix_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./move_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displx
  [../]

  [./fix_y]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
  [./move_y]
    type = PresetVelocity
    variable = disp_y
    boundary = 5
    function = velocity_y
#    time_periods = &#x27;p2 p3&#x27;
  [../]

  [./fix_z]
    type = DirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
  [./move_z]
    type = PresetVelocity
    variable = disp_z
    boundary = 6
    function = velocity_z
#    time_periods = &#x27;p3&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 186.5e9
    poissons_ratio = .316
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 119.3e6
    softening_models = exponential_softening
  [../]
  [./exponential_softening]
    type = ExponentialSoftening
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type&#x27;
  petsc_options_value = &#x27;101                lu&#x27;


  line_search = &#x27;none&#x27;


  l_max_its = 100
  l_tol = 1e-5

  nl_max_its = 100
  nl_abs_tol = 1e-4
  #nl_rel_tol = 1e-4
  nl_rel_tol = 1e-6

  start_time = 0.0
  end_time = 3.0
  dt = 0.01
[]

[Controls]
  [./p1]
    type = TimePeriod
    start_time = 0.0
    end_time = 1.0
    disable_objects = &#x27;BCs/move_y BCs/move_z&#x27;
    reverse_on_false = false
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]

  [./p2]
    type = TimePeriod
    start_time = 1.0
    end_time = 2.0
    disable_objects = &#x27;BCs/move_z&#x27;
    enable_objects = &#x27;BCs/move_y&#x27;
    reverse_on_false = false
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]

  [./p3]
    type = TimePeriod
    start_time = 2.0
    end_time = 3.0
    enable_objects = &#x27;BCs/move_y BCs/move_z&#x27;
    reverse_on_false = false
    execute_on = &#x27;initial timestep_begin&#x27;
    set_sync_times = true
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="85046aa6-3a7b-4fb6-9552-caa42d8bef1a"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test3.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0238a1f6-b2ad-4b06-ac7b-871ecf4371a1"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/thermal_expansion_function/finite_linear.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function is a linear function
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# This version of the test uses finite deformation theory.
# The two models produce very similar results.  There are slight
# differences due to the large deformation treatment.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 3
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion_strain1]
    type = ComputeMeanThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 0.5
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
  [./thermal_expansion_strain2]
    type = ComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 2
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (0.5 * t^2 - 0.5 * tsf^2) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 0.0
               2 2.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d8a905f0-9466-40ef-ac05-bfe707fda4d0"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_rspherical.i</h4><pre class="moose-pre"><code class="language-text">#
# 1-D spherical Gap Heat Transfer Test
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two &quot;blocks&quot; with a mesh biased toward the gap
#   between them.  Each block is unit length.  The gap between them is one
#   unit in length.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit, and then held fixed for an additional
#  time unit.  The temperature of the far right boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks, or spheres in the case of RSPHERICAL.:
#
#  Flux = (T_left - T_right) * (gapK/(r^2*((1/r1)-(1/r2))))
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 4 * pi * 1 * 1
#
# The integrated heat flux across the gap at time 2 is then:
#
# 4*pi*k*delta_T/((1/r1)-(1/r2))
# 4*pi*1*100/((1/1) - (1/2)) =  2513.3 watts
#
# For comparison, see results from the flux post processors.
#
#

[Problem]
  coord_type = RSPHERICAL
[]

[Mesh]
  file = gap_heat_transfer_htonly_rspherical.e
  construct_side_list_from_node_list = true
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]

  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1e6
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  # I don&#x27;t know enough about this test to say why it needs such a
  # loose nl_abs_tol... after timestep 10 the residual basically can&#x27;t
  # be reduced much beyond the initial residual.  The test probably
  # needs to be revisited to determine why.
  nl_abs_tol = 1e-3
  nl_rel_tol = 1e-10
  l_tol = 1e-6
  l_max_its = 100
  line_search = &#x27;none&#x27;
  nl_max_its = 10

  dt = 1e-1
  dtmin = 1e-1
  end_time = 2.0
[]

[Postprocessors]

  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]


[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7a5174fa-a955-4d8f-a31c-2d3ffcad6919"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/thermal_expansion_function/dilatation.i</h4><pre class="moose-pre"><code class="language-text"># This test checks the thermal expansion calculated via an dilatation function.
# The coefficient is selected so as to result in a 1e-4 strain in the x-axis, and to cross over
# from positive to negative strain.

[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = &#x27;1 + t&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ComputeDilatationThermalExpansionFunctionEigenstrain
    dilatation_function = cte_dilatation
    stress_free_temperature = 1.5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_dilatation]
    type = PiecewiseLinear
    x = &#x27;1 2&#x27;
    y = &#x27;-1e-4 1e-4&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x_max]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./temp_avg]
    type = ElementAverageValue
    variable = temp
  [../]
[]

[Executioner]
  type = Transient

  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="926523b5-6974-43f1-8b3b-4dcacb286992"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test12.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_columns_more_data.csv
    format = columns
    xy_in_file_only = false
    y_index_in_file = 3 #Will generate error because data does not contain 4 columns
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e96275b1-d46e-4086-a6fa-23513f4f119f"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/1D/1d_nodalmass_explicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for central difference integration for 1D elements

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    xmin = 0
    xmax = 10
    nx = 5
    dim = 1
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;10 0 0&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x&#x27;
  [../]
[]

[NodalKernels]
  [./force_x]
    type = UserForcingFunctionNodalKernel
    variable = disp_x
    boundary = right
    function = force_x
  [../]
  [./nodal_masses]
    type = NodalTranslationalInertia
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_x&#x27;
    boundary = &#x27;all&#x27;
  [../]
[]

[Functions]
  [./force_x]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27; # force
    scale_factor = 1e3
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 2e-10
  [./TimeIntegrator]
    type = CentralDifference
  [../]
[]

[Postprocessors]
  [./accel_x]
    type = PointValue
    point = &#x27;10.0 0.0 0.0&#x27;
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4c6d60b4-324b-42f1-a5bc-aa55d3c7e8df"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_single_split.i</h4><pre class="moose-pre"><code class="language-text"># This test provides an example of combining two LPS viscoplasticity model.
# The answer should be close, but not exactly the same, as lps_single.i

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmax = 0.002
  ymax = 0.002
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
  [./tot_effective_viscoplasticity]
    type = ParsedFunction
    vals = &#x27;lps_1_eff_creep_strain lps_2_eff_creep_strain&#x27;
    vars = &#x27;lps_1_eff_creep_strain lps_2_eff_creep_strain&#x27;
    value = &#x27;lps_1_eff_creep_strain+lps_2_eff_creep_strain&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = &#x27;one two&#x27;
    initial_porosity = 0.1
    outputs = all
  [../]

  [./one]
    type = ADViscoplasticityStressUpdate
    coefficient = &#x27;coef&#x27;
    power = 3
    base_name = &#x27;lps_first&#x27;
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./two]
    type = ADViscoplasticityStressUpdate
    coefficient = &#x27;coef&#x27;
    power = 3
    base_name = &#x27;lps_second&#x27;
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./coef]
    type = ADParsedMaterial
    f_name = coef
    # Example of creep power law
    function = &#x27;0.5e-18 * exp(-4e4 / 1.987 / 1200)&#x27;
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./lps_1_eff_creep_strain]
    type = ElementAverageValue
    variable = lps_first_effective_viscoplasticity
    outputs = none
  [../]
  [./lps_2_eff_creep_strain]
    type = ElementAverageValue
    variable = lps_second_effective_viscoplasticity
    outputs = none
  [../]
  [./eff_creep_strain_tot]
    type = FunctionValuePostprocessor
    function = tot_effective_viscoplasticity
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e3b0bb92-ecfa-4487-aa2f-fadde683fef7"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_newmark.i</h4><pre class="moose-pre"><code class="language-text"># Wave propogation in 1D using Newmark time integration in the presence of Rayleigh damping
#
# The test is for an 1D bar element of length 4m  fixed on one end
# with a sinusoidal pulse dirichlet boundary condition applied to the other end.
# beta and gamma are Newmark  time integration parameters
# eta and zeta are mass dependent and stiffness dependent Rayleigh damping
# coefficients, respectively.
# The equation of motion in terms of matrices is:
#
# M*accel + (eta*M+zeta*K)*vel +K*disp = 0
#
# Here M is the mass matrix, K is the stiffness matrix
#
# The displacement at the second, third and fourth node at t = 0.1 are
# -7.776268399030435152e-02, 1.949967184623528985e-02 and -4.615737877580032046e-03, respectively

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 4
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 4.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    zeta = 0.1
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.3025
    gamma = 0.6
    eta=0.1
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.3025
    gamma = 0.6
    eta=0.1
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.3025
    gamma = 0.6
    eta = 0.1
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.6
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.6
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.3025
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.6
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value=0.0
  [../]
  [./right_z]
    type = DirichletBC
    variable = disp_z
    boundary = right
    value=0.0
  [../]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value=0.0
  [../]
  [./left_z]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value=0.0
  [../]
  [./front_x]
    type = DirichletBC
    variable = disp_x
    boundary = front
    value=0.0
  [../]
  [./front_z]
    type = DirichletBC
    variable = disp_z
    boundary = front
    value=0.0
  [../]
  [./back_x]
    type = DirichletBC
    variable = disp_x
    boundary = back
    value=0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = bottom
    function = displacement_bc
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;1 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 6.0
  l_tol = 1e-12
  nl_rel_tol = 1e-12
  dt = 0.1
[]


[Functions]
  [./displacement_bc]
    type = PiecewiseLinear
    data_file = &#x27;sine_wave.csv&#x27;
    format = columns
  [../]

[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_y
  [../]
  [./disp_2]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./disp_3]
    type = NodalVariableValue
    nodeid = 10
    variable = disp_y
  [../]
  [./disp_4]
    type = NodalVariableValue
    nodeid = 14
    variable = disp_y
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aaafa7b3-e7bb-4389-ae4d-af039e866b56"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_rayleigh_hht.i</h4><pre class="moose-pre"><code class="language-text"># Test for damped small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# density (rho) = 1.0
# mass proportional rayleigh damping(eta) = 0.1
# stiffness proportional rayleigh damping(eta) = 0.1
# HHT time integration parameter (alpha) = -0.3
# Corresponding Newmark beta time integration parameters beta = 0.4225 and gamma = 0.8

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time  disp_y                vel_y                accel_y
# 0.0   0.0                   0.0                  0.0
# 0.2   0.019898364318588     0.18838688112273     1.1774180070171
# 0.4   0.045577003505278     0.087329917525455   -0.92596052423724
# 0.6   0.063767907208218     0.084330765885995    0.21274543331268
# 0.8   0.073602908614573     0.020029576220975   -0.45506879373455
# 1.0   0.06841704414745     -0.071840076837194   -0.46041813317992

[Mesh]
  type = GeneratedMesh
  nx = 10
  dim = 1
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.4225
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.4225
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.4225
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux
    variable = rot_accel_x
    displacement = rot_x
    velocity = rot_vel_x
    beta = 0.4225
    execute_on = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux
    variable = rot_vel_x
    acceleration = rot_accel_x
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux
    variable = rot_accel_y
    displacement = rot_y
    velocity = rot_vel_y
    beta = 0.4225
    execute_on = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux
    variable = rot_vel_y
    acceleration = rot_accel_y
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux
    variable = rot_accel_z
    displacement = rot_z
    velocity = rot_vel_z
    beta = 0.4225
    execute_on = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux
    variable = rot_vel_z
    acceleration = rot_accel_z
    gamma = 0.8
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.2 0.4 10.0&#x27;
    y = &#x27;0.0 0.01  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10
  start_time = 0.0
  dt = 0.2
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
    zeta = 0.1
    alpha = -0.3
  [../]
  [./inertial_force_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.4225
    gamma = 0.8
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 0
    variable = disp_x
    alpha = -0.3
  [../]
  [./inertial_force_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.4225
    gamma = 0.8
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 1
    variable = disp_y
    alpha = -0.3
  [../]
  [./inertial_force_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.4225
    gamma = 0.8
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 2
    variable = disp_z
    alpha = -0.3
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.4225
    gamma = 0.8
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 3
    variable = rot_x
    alpha = -0.3
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.4225
    gamma = 0.8
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 4
    variable = rot_y
    alpha = -0.3
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.4225
    gamma = 0.8
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 5
    variable = rot_z
    alpha = -0.3
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="61b7f2f3-e6ba-4649-8101-acc85eb38ee6"><div class="modal-content"><h4>modules/xfem/test/tests/moment_fitting/diffusion_moment_fitting_four_points.i</h4><pre class="moose-pre"><code class="language-text"># Test for a diffusion problem which uses four points moment_fitting approach.
# See this paper (https://doi.org/10.1007/s00466-018-1544-2) for more details about moment_fitting approach.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 6
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  geometric_cut_userobjects = &#x27;line_seg_cut_uo&#x27;
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.5 1.0 0.5 0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = 3
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0d54d2d0-9d69-4c68-b73e-2ce802f8fdbc"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/square_branch_tri_2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = TRI3
[]

[UserObjects]
  [./line_seg_cut_uo0]
    type = LineSegmentCutUserObject
    cut_data = &#x27;-1.0000e-10   6.6340e-01   6.6340e-01  -1.0000e-10&#x27;
    time_start_cut = 0.0
    time_end_cut = 1.0
  [../]
  [./line_seg_cut_uo1]
    type = LineSegmentCutUserObject
    cut_data = &#x27;3.3120e-01   3.3200e-01   1.0001e+00   3.3200e-01&#x27;
    time_start_cut = 1.0
    time_end_cut = 2.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    planar_formulation = PLANE_STRAIN
    add_variables = true
  [../]
[]

[Functions]
  [./right_disp_x]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
  [./top_disp_y]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
[]

[BCs]
  [./right_x]
    type = FunctionDirichletBC
    boundary = 1
    variable = disp_x
    function = right_disp_x
  [../]
  [./top_y]
    type = FunctionDirichletBC
    boundary = 2
    variable = disp_y
    function = top_disp_y
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
  [./left_x]
    type = DirichletBC
    boundary = 3
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-16
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 2.2
  num_steps = 5000
[]

[Outputs]
  file_base = square_branch_tri_2d_out
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="af840b96-b6da-4c00-ad3c-f1e2dbc48f0d"><div class="modal-content"><h4>modules/combined/test/tests/power_law_creep/power_law_creep_restart2.i</h4><pre class="moose-pre"><code class="language-text"># 1x1x1 unit cube with uniform pressure on top face

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1000.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy&#x27;
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./u_top_pull]
    type = Pressure
    variable = disp_y
    component = 1
    boundary = top
    factor = -10.0e6
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp_fix]
    type = DirichletBC
    variable = temp
    boundary = &#x27;bottom top&#x27;
    value = 1000.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2e11
    poissons_ratio = 0.3
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;power_law_creep&#x27;
    tangent_operator = elastic
  [../]
  [./power_law_creep]
    type = PowerLawCreepStressUpdate
    coefficient = 1.0e-15
    n_exponent = 4
    activation_energy = 3.0e5
    temperature = temp
  [../]

  [./thermal]
    type = HeatConductionMaterial
    specific_heat = 1.0
    thermal_conductivity = 100.
  [../]
  [./density]
    type = Density
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.6
  end_time = 1.0
  num_steps = 12
  dt = 0.1
[]

[Outputs]
  file_base = power_law_creep_out
  exodus = true
[]

[Problem]
  restart_file_base = power_law_creep_restart1_out_cp/0006
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c0660e9c-af97-4e2b-becc-6d00e6496857"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test4q.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test4q_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3f0eac92-6fcc-4f73-8591-583244308f88"><div class="modal-content"><h4>modules/xfem/test/tests/moment_fitting/diffusion_moment_fitting_six_points.i</h4><pre class="moose-pre"><code class="language-text"># Test for a diffusion problem which uses six points moment_fitting approach.
# To use six points rule, add Quadrature block with order = FOURTH and type = MONOMIAL.
# See this paper (https://doi.org/10.1007/s00466-018-1544-2) for more details about moment_fitting approach.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 6
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  geometric_cut_userobjects = &#x27;line_seg_cut_uo&#x27;
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.5 1.0 0.5 0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = 3
    function = u_left
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  [./Quadrature]
    order = FOURTH
    type = MONOMIAL
  [../]

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c4344f83-65b9-4c10-bed4-d1e7e6f1dde9"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh17.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = false
# gravity = true
# supg = true
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 0.1
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 0.01
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 1
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-15 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh17
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="01e4c9e1-797f-4480-8f6b-bc609bb7c5c9"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_mouth_dir_end_dir_vec.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with 2 elements
#through the thickness, and calculates the J-Integrals using options
#to treat it as 3d.
#Crack direction is defined using the crack mouth coordinates.
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack3d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackMouth
  crack_mouth_boundary = 900
  crack_end_direction_method = CrackDirectionVector
  crack_direction_vector_end_1 = &#x27;1.0 0.0 0.0&#x27;
  crack_direction_vector_end_2 = &#x27;1.0 0.0 0.0&#x27;
  radius_inner = &#x27;4.0 5.5&#x27;
  radius_outer = &#x27;5.5 7.0&#x27;
  output_variable = &#x27;disp_x&#x27;
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_z2]
    type = DirichletBC
    variable = disp_z
    boundary = 510
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]

[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]


[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Postprocessors]
  [./disp_x_centercrack]
    type = CrackFrontData
    crack_front_definition = crackFrontDefinition
    variable = disp_x
    crack_front_point_index = 1
  [../]
[]

[Outputs]
  file_base = j_integral_3d_mouth_dir_end_dir_vec_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="73f8755d-a8c5-401e-a99b-ce5769b7c09c"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/additional_volume.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
# p = n * R * / (V_cavity / T_cavity + V_add / T_add)
# where
#  p is the pressure
#  n is the amount of material in the volume (moles)
#  R is the universal gas constant
#  T_cavity is the temperature in the cavity
#  T_add is the temperature of the additional volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7. An additional volume of 2 is added.
#
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V_cavity0 + gamma * t + V_add
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = -(0.003322259...) * V0
#   T0 = 240.54443866068704
#   V_cavity0 = 7
#   V_add = 2
#   T_add = 100
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
#  An additional volume of 2 with a temperature of 100.0 is included.
#
# So, n0 = p0 * (V_cavity / T_cavity + V_add / T_add) / R
#        = 100 * (7 / 240.544439 + 2 / 100) / 8.314472
#        = 0.59054
#
# The parameters combined at t = 1 gives p = 249.647.
#
# This test sets the initial temperature to 500, but the CavityPressure
#   is told that that initial temperature is T0.  Thus, the final solution
#   is unchanged.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3d.e
[]

[GlobalParams]
  volumetric_locking_correction = true
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.59054&#x27;
  [../]
  [./additional_volume]
    type = ConstantFunction
    value = 2
  [../]
  [./temperature_of_additional_volume]
    type = ConstantFunction
    value = 100
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 500
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = Diffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = FunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      initial_temperature = 240.54443866068704
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      additional_volumes = volume1
      temperature_of_additional_volumes = temperature1
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 1
  [../]
  [./strain1]
    type = ComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 2
  [../]
  [./strain2]
    type = ComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0

  snesmf_reuse_base = false
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
  [./volume1]
    type = FunctionValuePostprocessor
    function = additional_volume
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./temperature1]
    type = FunctionValuePostprocessor
    function = temperature_of_additional_volume
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="515a4a7d-9f3c-4064-9096-19e3aaccd2a7"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/line_material_rank_two_sampler/rank_two_scalar_sampler.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;x_disp y_disp z_disp&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 3
  ny = 3
  nz = 3
  elem_type = HEX
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = 1e-6
  [../]
[]

[Variables]
  [./x_disp]
    order = FIRST
    family = LAGRANGE
  [../]
  [./y_disp]
    order = FIRST
    family = LAGRANGE
  [../]
  [./z_disp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
 [../]
 [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
 [../]
[]

[AuxKernels]
  [./vonmises]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = vonmises
    scalar_type = VonMisesStress
  [../]
[]

[VectorPostprocessors]
  [./vonmises]
    type = LineMaterialRankTwoScalarSampler
    start = &#x27;0.1667 0.4 0.45&#x27;
    end   = &#x27;0.8333 0.6 0.55&#x27;
    property = stress
    scalar_type = VonMisesStress
    sort_by = id
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./front]
    type = FunctionDirichletBC
    variable = z_disp
    boundary = 5
    function = rampConstant
  [../]
  [./back_x]
    type = DirichletBC
    variable = x_disp
    boundary = 0
    value = 0.0
  [../]
  [./back_y]
    type = DirichletBC
    variable = y_disp
    boundary = 0
    value = 0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = z_disp
    boundary = 0
    value = 0.0
  [../]
[]

[Materials]
  [./elast_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = .3
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  l_max_its = 100

  start_time = 0.0
  num_steps = 99999
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  file_base = rank_two_scalar_sampler_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8a51396d-38c8-48e9-9dc3-94dc9b8fe59a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/gtn_single.i</h4><pre class="moose-pre"><code class="language-text"># This test provides an example of an individual GTN viscoplasticity model

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmax = 0.002
  ymax = 0.002
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  base_name = &#x27;total&#x27;
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
    base_name = &#x27;total&#x27;
  [../]
  [./stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = gtn
    initial_porosity = 0.1
    outputs = all
    base_name = &#x27;total&#x27;
  [../]

  [./gtn]
    type = ADViscoplasticityStressUpdate
    total_strain_base_name = &#x27;total&#x27;
    coefficient = &#x27;coef&#x27;
    power = 3
    viscoplasticity_model = GTN
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./coef]
    type = ADParsedMaterial
    f_name = coef
    # Example of creep power law
    function = &#x27;1e-18 * exp(-4e4 / 1.987 / 1200)&#x27;
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = total_hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = total_vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./eff_creep_strain]
    type = ElementAverageValue
    variable = effective_viscoplasticity
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="033e80b1-9e10-473c-bacb-b32385ddfc48"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/material_limit_time_step/elas_plas/nafems_nl1_lim.i</h4><pre class="moose-pre"><code class="language-text">#
# Tests material model IsotropicPlasticity with material based time stepper
# Boundary conditions from NAFEMS test NL1
#
[GlobalParams]
  order = FIRST
  family = LAGRANGE
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]#Comment
  file = one_elem2.e
[] # Mesh

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[] # Variables

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_eff]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
[] # AuxVariables

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./vonmises]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = vonmises
    scalar_type = VonMisesStress
    execute_on = timestep_end
  [../]
  [./elastic_strain_yy]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./plastic_strain_eff]
    type = MaterialRealAux
    property = effective_plastic_strain
    variable = plastic_strain_eff
  [../]
  [./tot_strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_yy
    index_i = 1
    index_j = 1
  [../]
[] # AuxKernels

[Functions]
  [./appl_dispx]
    type = PiecewiseLinear
    x = &#x27;0   1.0   2.0   3.0  4.0   5.0  6.0  7.0  8.0&#x27;
    y = &#x27;0.0 0.25e-4 0.50e-4 0.50e-4 0.50e-4 0.25e-4 0.0 0.0 0.0&#x27;
  [../]
  [./appl_dispy]
    type = PiecewiseLinear
    x = &#x27;0   1.0   2.0   3.0  4.0   5.0  6.0  7.0  8.0&#x27;
    y = &#x27;0.0 0.0  0.0 0.25e-4 0.50e-4 0.50e-4 0.50e-4  0.25e-4 0.0 &#x27;
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_x
    boundary = 101
    value = 0.0
  [../]
  [./origin_x]
    type = DirichletBC
    variable = disp_x
    boundary = 103
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_y
    boundary = 102
    value = 0.0
  [../]
  [./origin_y]
    type = DirichletBC
    variable = disp_y
    boundary = 103
    value = 0.0
  [../]
  [./top_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = appl_dispy
  [../]
  [./right_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = appl_dispx
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 1
    youngs_modulus = 250e9
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputePlaneFiniteStrain
    block = 1
  [../]
  [./stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;isoplas&#x27;
    block = 1
  [../]
  [./isoplas]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 5e6
    hardening_constant = 0.0
    relative_tolerance = 1e-20
    absolute_tolerance = 1e-8
    max_inelastic_increment = 0.000001
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 20

  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.1
    time_t = &#x27;1.0  2.0  3.0  4.0  5.0  6.0  7.0  8.0&#x27;
    time_dt = &#x27;0.1 0.1  0.1  0.1  0.1  0.1  0.1  0.1&#x27;
    optimal_iterations = 30
    iteration_window = 9
    growth_factor = 2.0
    cutback_factor = 0.5
    timestep_limiting_postprocessor = matl_ts_min
  [../]

  start_time = 0.0
  num_steps = 1000
  end_time = 8.0
[] # Executioner

[Postprocessors]
  [./matl_ts_min]
    type = MaterialTimeStepPostprocessor
  [../]
  [./stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./vonmises]
    type = ElementAverageValue
    variable = vonmises
  [../]
  [./el_strain_yy]
    type = ElementAverageValue
    variable = elastic_strain_yy
  [../]
  [./plas_strain_eff]
    type = ElementAverageValue
    variable = plastic_strain_eff
  [../]
  [./tot_strain_yy]
    type = ElementAverageValue
    variable = tot_strain_yy
  [../]
  [./disp_x1]
    type = NodalVariableValue
    nodeid = 0
    variable = disp_x
  [../]
  [./disp_x4]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_x
  [../]
  [./disp_y1]
    type = NodalVariableValue
    nodeid = 0
    variable = disp_y
  [../]
  [./disp_y4]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./_dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  [./console]
    type = Console
    output_linear = true
  [../]
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="45fcadcb-39c3-4c78-bc21-e9e4a65ecf52"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/2D/2d_consistent_explicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for the central difference time integrator for a 2D mesh

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 2.0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
[]

[BCs]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./x_bot]
    type = FunctionDirichletBC
    boundary = bottom
    variable = disp_x
    function = disp
    preset = false
  [../]
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 1e4
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = CentralDifference
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./accel_2x]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_x
  [../]
  [./accel_2y]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="207a33b0-bdf2-4959-ad4c-3faebec93a94"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/mandel_constM.i</h4><pre class="moose-pre"><code class="language-text"># Mandel&#x27;s problem of consolodation of a drained medium
#
# A sample is in plane strain.
# -a &lt;= x &lt;= a
# -b &lt;= y &lt;= b
# It is squashed with constant force by impermeable, frictionless plattens on its top and bottom surfaces (at y=+/-b)
# Fluid is allowed to leak out from its sides (at x=+/-a)
# The porepressure within the sample is monitored.
#
# As is common in the literature, this is simulated by
# considering the quarter-sample, 0&lt;=x&lt;=a and 0&lt;=y&lt;=b, with
# impermeable, roller BCs at x=0 and y=0 and y=b.
# Porepressure is fixed at zero on x=a.
# Porepressure and displacement are initialised to zero.
# Then the top (y=b) is moved downwards with prescribed velocity,
# so that the total force that is inducing this downwards velocity
# is fixed.  The velocity is worked out by solving Mandel&#x27;s problem
# analytically, and the total force is monitored in the simulation
# to check that it indeed remains constant.
#
# Here are the problem&#x27;s parameters, and their values:
# Soil width.  a = 1
# Soil height.  b = 0.1
# Soil&#x27;s Lame lambda.  la = 0.5
# Soil&#x27;s Lame mu, which is also the Soil&#x27;s shear modulus.  mu = G = 0.75
# Soil bulk modulus.  K = la + 2*mu/3 = 1
# Drained Poisson ratio.  nu = (3K - 2G)/(6K + 2G) = 0.2
# Soil bulk compliance.  1/K = 1
# Fluid bulk modulus.  Kf = 8
# Fluid bulk compliance.  1/Kf = 0.125
# Soil initial porosity.  phi0 = 0.1
# Biot coefficient.  alpha = 0.6
# Biot modulus.  M = 1/(phi0/Kf + (alpha - phi0)(1 - alpha)/K) = 4.705882
# Undrained bulk modulus. Ku = K + alpha^2*M = 2.694118
# Undrained Poisson ratio.  nuu = (3Ku - 2G)/(6Ku + 2G) = 0.372627
# Skempton coefficient.  B = alpha*M/Ku = 1.048035
# Fluid mobility (soil permeability/fluid viscosity).  k = 1.5
# Consolidation coefficient.  c = 2*k*B^2*G*(1-nu)*(1+nuu)^2/9/(1-nuu)/(nuu-nu) = 3.821656
# Normal stress on top.  F = 1
#
# The solution for porepressure and displacements is given in
# AHD Cheng and E Detournay &quot;A direct boundary element method for plane strain poroelasticity&quot; International Journal of Numerical and Analytical Methods in Geomechanics 12 (1988) 551-572.
# The solution involves complicated infinite series, so I shall not write it here

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
  ny = 1
  nz = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 0.1
  zmin = 0
  zmax = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.8
    alpha = 1e-5
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./roller_xmin]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left&#x27;
  [../]
  [./roller_ymin]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  [../]
  [./plane_strain]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
  [./xmax_drained]
    type = DirichletBC
    variable = porepressure
    value = 0
    boundary = right
  [../]
  [./top_velocity]
    type = FunctionDirichletBC
    variable = disp_y
    function = top_velocity
    boundary = top
  [../]
[]

[Functions]
  [./top_velocity]
    type = PiecewiseLinear
    x = &#x27;0 0.002 0.006   0.014   0.03    0.046   0.062   0.078   0.094   0.11    0.126   0.142   0.158   0.174   0.19 0.206 0.222 0.238 0.254 0.27 0.286 0.302 0.318 0.334 0.35 0.366 0.382 0.398 0.414 0.43 0.446 0.462 0.478 0.494 0.51 0.526 0.542 0.558 0.574 0.59 0.606 0.622 0.638 0.654 0.67 0.686 0.702&#x27;
    y = &#x27;-0.041824842    -0.042730269    -0.043412712    -0.04428867     -0.045509181    -0.04645965     -0.047268246 -0.047974749      -0.048597109     -0.0491467  -0.049632388     -0.050061697      -0.050441198     -0.050776675     -0.051073238      -0.0513354 -0.051567152      -0.051772022     -0.051953128 -0.052113227 -0.052254754 -0.052379865 -0.052490464 -0.052588233 -0.052674662 -0.052751065 -0.052818606 -0.052878312 -0.052931093 -0.052977751 -0.053018997 -0.053055459 -0.053087691 -0.053116185 -0.053141373 -0.05316364 -0.053183324 -0.053200724 -0.053216106 -0.053229704 -0.053241725 -0.053252351 -0.053261745 -0.053270049 -0.053277389 -0.053283879 -0.053289615&#x27;
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_force]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./tot_force]
    type = ParsedAux
    args = &#x27;stress_yy porepressure&#x27;
    execute_on = timestep_end
    variable = tot_force
    function = &#x27;-stress_yy+0.6*porepressure&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    component = 2
    variable = disp_z
  [../]
  [./poro_vol_exp]
    type = PorousFlowMassVolumetricExpansion
    variable = porepressure
    fluid_component = 0
  [../]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = porepressure
  [../]
  [./flux]
    type = PorousFlowAdvectiveFlux
    variable = porepressure
    gravity = &#x27;0 0 0&#x27;
    fluid_component = 0
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 8
      density0 = 1
      thermal_expansion = 0
      viscosity = 1
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0.5 0.75&#x27;
    # bulk modulus is lambda + 2*mu/3 = 0.5 + 2*0.75/3 = 1
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = porepressure
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityHMBiotModulus
    porosity_zero = 0.1
    biot_coefficient = 0.6
    solid_bulk = 1
    constant_fluid_bulk_modulus = 8
    constant_biot_modulus = 4.7058823529
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1.5 0 0   0 1.5 0   0 0 1.5&#x27;
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityCorey
    n = 0 # unimportant in this fully-saturated situation
    phase = 0
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0.0 0 0&#x27;
    variable = porepressure
  [../]
  [./p1]
    type = PointValue
    outputs = csv
    point = &#x27;0.1 0 0&#x27;
    variable = porepressure
  [../]
  [./p2]
    type = PointValue
    outputs = csv
    point = &#x27;0.2 0 0&#x27;
    variable = porepressure
  [../]
  [./p3]
    type = PointValue
    outputs = csv
    point = &#x27;0.3 0 0&#x27;
    variable = porepressure
  [../]
  [./p4]
    type = PointValue
    outputs = csv
    point = &#x27;0.4 0 0&#x27;
    variable = porepressure
  [../]
  [./p5]
    type = PointValue
    outputs = csv
    point = &#x27;0.5 0 0&#x27;
    variable = porepressure
  [../]
  [./p6]
    type = PointValue
    outputs = csv
    point = &#x27;0.6 0 0&#x27;
    variable = porepressure
  [../]
  [./p7]
    type = PointValue
    outputs = csv
    point = &#x27;0.7 0 0&#x27;
    variable = porepressure
  [../]
  [./p8]
    type = PointValue
    outputs = csv
    point = &#x27;0.8 0 0&#x27;
    variable = porepressure
  [../]
  [./p9]
    type = PointValue
    outputs = csv
    point = &#x27;0.9 0 0&#x27;
    variable = porepressure
  [../]
  [./p99]
    type = PointValue
    outputs = csv
    point = &#x27;1 0 0&#x27;
    variable = porepressure
  [../]
  [./xdisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_x
  [../]
  [./ydisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_y
  [../]
  [./total_downwards_force]
     type = ElementAverageValue
     outputs = csv
     variable = tot_force
  [../]
  [./dt]
    type = FunctionValuePostprocessor
    outputs = console
    function = if(0.15*t&lt;0.01,0.15*t,0.01)
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres asm lu 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 0.7
  [./TimeStepper]
    type = PostprocessorDT
    postprocessor = dt
    dt = 0.001
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = mandel_constM
  [./csv]
    interval = 3
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ffe05a53-eab8-4c69-84a9-f549998ae6b1"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/creep_tangent_operator/creep.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  second_order = true
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = false
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 10&#x27;
    y = &#x27;0 1e-3&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    use_finite_deform_jacobian = true
    generate_output = &#x27;hydrostatic_stress&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
  [../]

  [./elastic_strain]
    type = ComputeMultipleInelasticStress
    # inelastic_models = &#x27;&#x27;
    tangent_operator = nonlinear
  [../]

  [./creep_ten]
    type = PowerLawCreepStressUpdate
    coefficient = 10e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_ten
  [../]
  [./creep_ten2]
    type = PowerLawCreepStressUpdate
    coefficient = 10e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_ten2
  [../]
  [./creep_one]
    type = PowerLawCreepStressUpdate
    coefficient = 1e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_one
  [../]
  [./creep_nine]
    type = PowerLawCreepStressUpdate
    coefficient = 9e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_nine
  [../]
  [./creep_zero]
    type = PowerLawCreepStressUpdate
    coefficient = 0e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_zero
  [../]
[]

[BCs]
  [./no_disp_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./no_disp_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./pull_disp_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-5

  num_steps = 5
  dt = 1e-1
[]

[Postprocessors]
  [./max_disp_x]
    type = ElementExtremeValue
    variable = disp_x
  [../]
  [./max_disp_y]
    type = ElementExtremeValue
    variable = disp_y
  [../]
  [./max_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
[]

[Outputs]
  csv = true
  perf_graph = true
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="85f9d575-26bc-442d-972e-953751bb660e"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/square_branch_quad_2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_uo0]
    type = LineSegmentCutUserObject
    cut_data = &#x27;-1.0000e-10   6.6340e-01   6.6340e-01  -1.0000e-10&#x27;
    time_start_cut = 0.0
    time_end_cut = 1.0
  [../]
  [./line_seg_cut_uo1]
    type = LineSegmentCutUserObject
    cut_data = &#x27;3.3120e-01   3.3200e-01   1.0001e+00   3.3200e-01&#x27;
    time_start_cut = 1.0
    time_end_cut = 2.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    planar_formulation = PLANE_STRAIN
    add_variables = true
  [../]
[]

[Functions]
  [./right_disp_x]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
  [./top_disp_y]
    type = PiecewiseLinear
    x = &#x27;0  1.0    2.0   3.0&#x27;
    y = &#x27;0  0.005  0.01  0.01&#x27;
  [../]
[]

[BCs]
  [./right_x]
    type = FunctionDirichletBC
    boundary = 1
    variable = disp_x
    function = right_disp_x
  [../]
  [./top_y]
    type = FunctionDirichletBC
    boundary = 2
    variable = disp_y
    function = top_disp_y
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
  [./left_x]
    type = DirichletBC
    boundary = 3
    variable = disp_x
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-16
  nl_abs_tol = 1e-10

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 2.2
  num_steps = 5000
[]

[Outputs]
  file_base = square_branch_quad_2d_out
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dcdd9a46-6699-43cf-8d37-616c3d914eb8"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/initial_temperature.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = -(0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# The parameters combined at t = 1 gives p = 301.
#
# This test sets the initial temperature to 500, but the CavityPressure
#   is told that that initial temperature is T0.  Thus, the final solution
#   is unchanged.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3d.e
[]

[GlobalParams]
  volumetric_locking_correction = true
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 500
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = ADDiffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = ADFunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      initial_temperature = 240.54443866068704
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ADComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 1
  [../]
  [./strain1]
    type = ADComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ADComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 2
  [../]
  [./strain2]
    type = ADComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="acad31d1-426a-4725-95ef-21a8df147a2a"><div class="modal-content"><h4>modules/porous_flow/test/tests/gravity/grav02d.i</h4><pre class="moose-pre"><code class="language-text"># Checking that gravity head is established in the transient situation when 0&lt;=saturation&lt;=1 (note the less-than-or-equal-to).
# 2phase (PP), 2components, vanGenuchten, constant fluid bulk-moduli for each phase, constant viscosity, constant permeability, Corey relative perm.
# A boundary condition enforces porepressures at the right boundary
# For better agreement with the analytical solution (ana_pp), just increase nx

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = -1
  xmax = 0
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    x = &#x27;1E-3 1E-2 1E-1 2E-1&#x27;
    y = &#x27;1E-3 1E-2 0.2E-1 1E-1&#x27;
  [../]
[]

[Variables]
  [./ppwater]
    initial_condition = 0
  [../]
  [./ppgas]
    initial_condition = 0.5
  [../]
[]

[AuxVariables]
  [./massfrac_ph0_sp0]
    initial_condition = 1
  [../]
  [./massfrac_ph1_sp0]
    initial_condition = 0
  [../]
[]

[BCs]
  [./ppwater]
    type = DirichletBC
    boundary = right
    variable = ppwater
    value = 0
  [../]
  [./ppgas]
    type = DirichletBC
    boundary = right
    variable = ppgas
    value = 0.5
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = ppwater
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = ppwater
    gravity = &#x27;-1 0 0&#x27;
  [../]
  [./mass1]
    type = PorousFlowMassTimeDerivative
    fluid_component = 1
    variable = ppgas
  [../]
  [./flux1]
    type = PorousFlowAdvectiveFlux
    fluid_component = 1
    variable = ppgas
    gravity = &#x27;-1 0 0&#x27;
  [../]
[]

[Functions]
  [./ana_ppwater]
    type = ParsedFunction
    vars = &#x27;g B p0 rho0&#x27;
    vals = &#x27;1 2 pp_water_top 1&#x27;
    value = &#x27;-B*log(exp(-p0/B)+g*rho0*x/B)&#x27; # expected pp at base
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;ppwater ppgas&#x27;
    number_fluid_phases = 2
    number_fluid_components = 2
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.5
    alpha = 1
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid0]
      type = SimpleFluidProperties
      bulk_modulus = 1.2
      density0 = 1
      viscosity = 1
      thermal_expansion = 0
    [../]
    [./simple_fluid1]
      type = SimpleFluidProperties
      bulk_modulus = 1
      density0 = 0.1
      viscosity = 0.5
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow2PhasePP
    phase0_porepressure = ppwater
    phase1_porepressure = ppgas
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
    mass_fraction_vars = &#x27;massfrac_ph0_sp0 massfrac_ph1_sp0&#x27;
  [../]
  [./simple_fluid0]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid0
    phase = 0
  [../]
  [./simple_fluid1]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid1
    phase = 1
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.1
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0  0 2 0  0 0 3&#x27;
  [../]
  [./relperm_water]
    type = PorousFlowRelativePermeabilityCorey
    n = 1
    phase = 0
  [../]
  [./relperm_gas]
    type = PorousFlowRelativePermeabilityCorey
    n = 1
    phase = 1
  [../]
[]

[Postprocessors]
  [./pp_water_top]
    type = PointValue
    variable = ppwater
    point = &#x27;0 0 0&#x27;
  [../]
  [./pp_water_base]
    type = PointValue
    variable = ppwater
    point = &#x27;-1 0 0&#x27;
  [../]
  [./pp_water_analytical]
    type = FunctionValuePostprocessor
    function = ana_ppwater
    point = &#x27;-1 0 0&#x27;
  [../]
  [./ppwater_00]
    type = PointValue
    variable = ppwater
    point = &#x27;0 0 0&#x27;
  [../]
  [./ppwater_01]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.1 0 0&#x27;
  [../]
  [./ppwater_02]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.2 0 0&#x27;
  [../]
  [./ppwater_03]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.3 0 0&#x27;
  [../]
  [./ppwater_04]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.4 0 0&#x27;
  [../]
  [./ppwater_05]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.5 0 0&#x27;
  [../]
  [./ppwater_06]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.6 0 0&#x27;
  [../]
  [./ppwater_07]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.7 0 0&#x27;
  [../]
  [./ppwater_08]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.8 0 0&#x27;
  [../]
  [./ppwater_09]
    type = PointValue
    variable = ppwater
    point = &#x27;-0.9 0 0&#x27;
  [../]
  [./ppwater_10]
    type = PointValue
    variable = ppwater
    point = &#x27;-1 0 0&#x27;
  [../]
  [./ppgas_00]
    type = PointValue
    variable = ppgas
    point = &#x27;0 0 0&#x27;
  [../]
  [./ppgas_01]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.1 0 0&#x27;
  [../]
  [./ppgas_02]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.2 0 0&#x27;
  [../]
  [./ppgas_03]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.3 0 0&#x27;
  [../]
  [./ppgas_04]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.4 0 0&#x27;
  [../]
  [./ppgas_05]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.5 0 0&#x27;
  [../]
  [./ppgas_06]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.6 0 0&#x27;
  [../]
  [./ppgas_07]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.7 0 0&#x27;
  [../]
  [./ppgas_08]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.8 0 0&#x27;
  [../]
  [./ppgas_09]
    type = PointValue
    variable = ppgas
    point = &#x27;-0.9 0 0&#x27;
  [../]
  [./ppgas_10]
    type = PointValue
    variable = ppgas
    point = &#x27;-1 0 0&#x27;
  [../]
[]

[Preconditioning]
  active = andy
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-12 1E-10 10000&#x27;
  [../]
  [./check]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -snes_type&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-12 1E-10 10000 test&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
  end_time = 1.0
[]

[Outputs]
  [./csv]
    type = CSV
    execute_on = &#x27;initial final&#x27;
    file_base = grav02d
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bfbeebfb-fa75-4d80-b171-28e4d2b2a1d2"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/t_stress/t_stress_crack_infinite_plate_2d.i</h4><pre class="moose-pre"><code class="language-text"># T-stress test for a through crack in a wide (&quot;infinite&quot;) plate.
# For a finer mesh this problem converges to the solution T = -sigma.
# Ref: T.L. Anderson, Fracture Mechanics: Fundamentals and Applications

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack_infinite_plate.e
  displacements = &#x27;disp_x disp_y&#x27;
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
[]

[DomainIntegral]
  integrals = &#x27;JIntegral InteractionIntegralKI InteractionIntegralT&#x27;
  boundary = 1001
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  radius_inner = &#x27;0.06 0.08 0.10&#x27;
  radius_outer = &#x27;0.08 0.10 0.12&#x27;
  block = 1
  youngs_modulus = 30e+6
  poissons_ratio = 0.3
  2d = true
  axis_2d = 2
  symmetry_plane = 1
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 300
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./Pressure]
    [./top]
      boundary = 200
      function = rampConstantUp
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 30e+6
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
   type = Transient

#  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Outputs]
  file_base = t_stress_crack_infinite_plate_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6f5d1bfe-0609-4617-9cbd-9deb381743c5"><div class="modal-content"><h4>modules/contact/test/tests/tension_release/4ElemTensionRelease_mechanical_constraint.i</h4><pre class="moose-pre"><code class="language-text"># This is a mechanical constraint (contact formulation) version of 4ElemTensionRelease.i
[Mesh]
  file = 4ElemTensionRelease.e
[]

[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./up]
    type = PiecewiseLinear
    x = &#x27;0 1      2 3&#x27;
    y = &#x27;0 0.0001 0 -.0001&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = SMALL
    generate_output = &#x27;stress_yy&#x27;
  []
[]

[Contact]
  [./dummy_name]
    primary = 2
    secondary = 3
    penalty = 1e6
    model = frictionless
    tangential_tolerance = 0.01
  [../]
[]

[BCs]
  [./lateral]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 4&#x27;
    value = 0
  [../]

  [./bottom_up]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = up
  [../]

  [./top]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1.0e6
    poissons_ratio = 0.3
  [../]
  [./stiffStuff1_stress]
    type = ComputeLinearElasticStress
    block = &#x27;1 2&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      101&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10
  l_tol = 1e-4

  l_max_its = 100
  nl_max_its = 10
  dt = 0.2
  dtmin = 0.2
  end_time = 3

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="de812cd3-d443-4b48-a7b3-6764d034aba2"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_inertia_damping_action.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam. The lumped
# mass also has a moment of inertia associated with it.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772
# Moment of inertia of lumped mass:
# Ixx = 0.2
# Iyy = 0.1
# Izz = 0.1
# mass proportional damping coefficient (eta) = 0.1

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y              vel_y               accel_y
# 0.0    0.0                 0.0                 0.0
# 0.1    0.001278249649738   0.025564992994761   0.51129985989521
# 0.2    0.0049813090917644  0.048496195845768  -0.052675802875074
# 0.3    0.0094704658873002  0.041286940064947  -0.091509312741339
# 0.4    0.013082280729802   0.03094935678508   -0.115242352856
# 0.5    0.015588313103503   0.019171290688959  -0.12031896906642

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Modules/TensorMechanics/LineElementMaster]
  [./all]
    add_variables = true
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;

    # Geometry parameters
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;

    # dynamic simulation using consistent mass/inertia matrix
    dynamic_nodal_translational_inertia = true
    nodal_mass = 0.01899772

    dynamic_nodal_rotational_inertia = true
    nodal_Ixx = 2e-1
    nodal_Iyy = 1e-1
    nodal_Izz = 1e-1

    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;

    beta = 0.25 # Newmark time integration parameter
    gamma = 0.5 # Newmark time integration parameter

    boundary = right # Node set where nodal mass and nodal inertia are applied

    # optional parameters for Rayleigh damping
    eta = 0.1 # Mass proportional Rayleigh damping
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  file_base = &#x27;dyn_euler_small_added_mass_inertia_damping_out&#x27;
  exodus = true
  csv = true

  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8433c1e9-a011-47a5-b9bb-88dfe9d6bbf3"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test3tt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3tt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d41a8268-1037-4306-8b2a-d73cb6a2ed6d"><div class="modal-content"><h4>modules/richards/test/tests/buckley_leverett/bl20_lumped_fu.i</h4><pre class="moose-pre"><code class="language-text"># two-phase version
[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 30
  xmin = 0
  xmax = 15
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;0.1 0.5 0.5 1 2  4&#x27;
    x = &#x27;0   0.1 1   5 40 42&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E6
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 2E6
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1E-5
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./w_aux_seff]
  [../]
[]



[Kernels]
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFullyUpwindFlux
    variable = pgas
  [../]
[]

[AuxKernels]
  [./w_aux_seff_auxk]
    type = RichardsSeffAux
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater pgas&#x27;
    variable = w_aux_seff
  [../]
[]


[ICs]
  [./water_ic]
    type = FunctionIC
    variable = pwater
    function = initial_water
  [../]
  [./gas_ic]
    type = FunctionIC
    variable = pgas
    function = initial_gas
  [../]
[]

[BCs]
  [./left_w]
    type = DirichletBC
    variable = pwater
    boundary = left
    value = 1E6
  [../]
  [./left_g]
    type = DirichletBC
    variable = pgas
    boundary = left
    value = 1000
  [../]
  [./right_w]
    type = DirichletBC
    variable = pwater
    boundary = right
    value = -300000
  [../]
  [./right_g]
    type = DirichletBC
    variable = pgas
    boundary = right
    value = 0
  [../]
[]


[Functions]
  [./initial_water]
    type = ParsedFunction
    value = 1000000*(1-min(x/5,1))-if(x&lt;5,0,300000)
  [../]
  [./initial_gas]
    type = ParsedFunction
    value = 1000
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.15
    mat_permeability = &#x27;1E-10 0 0  0 1E-10 0  0 0 1E-10&#x27;
    viscosity = &#x27;1E-3 1E-6&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  active = &#x27;standard&#x27;

  [./bounded]
  # must use --use-petsc-dm command line argument
    type = SMP
    full = true
    petsc_options_iname = &#x27;-snes_type -pc_factor_shift_type&#x27;
    petsc_options_value = &#x27;vinewtonssls nonzero&#x27;
  [../]

  [./standard]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-pc_factor_shift_type&#x27;
    petsc_options_value = &#x27;nonzero&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  end_time = 50

  nl_rel_tol = 1.e-9
  nl_max_its = 10

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = bl20_lumped_fu
  execute_on = &#x27;initial timestep_end final&#x27;
  interval = 100000
  exodus = true
  hide = pgas
  [./console_out]
    type = Console
    interval = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dae9bb67-5dbb-41e5-a331-51317b5445d2"><div class="modal-content"><h4>modules/combined/test/tests/inelastic_strain/elas_plas/elas_plas_nl1_cycle.i</h4><pre class="moose-pre"><code class="language-text">#
# Test for effective strain calculation.
# Boundary conditions from NAFEMS test NL1
#
#
# This is not a verification test. The boundary conditions are applied such
# that the first step generates only elastic stresses. The rest of the load
# steps generate cycles of tension and compression in the axial (i.e., y-axis)
# direction. The axial stresses and strains also cycle, however the effective
# plastic strain increases in value throughout the analysis.
#
[GlobalParams]
  order = FIRST
  family = LAGRANGE
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = one_elem2.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./pressure]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./plastic_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./eff_plastic_strain]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./vonmises]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = vonmises
    scalar_type = VonMisesStress
    execute_on = timestep_end
  [../]
  [./pressure]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = pressure
    scalar_type = Hydrostatic
    execute_on = timestep_end
  [../]
  [./elastic_strain_xx]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./elastic_strain_yy]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./elastic_strain_zz]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./plastic_strain_xx]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./plastic_strain_yy]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./plastic_strain_zz]
    type = RankTwoAux
    rank_two_tensor = plastic_strain
    variable = plastic_strain_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./tot_strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./tot_strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./tot_strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./eff_plastic_strain]
    type = MaterialRealAux
    property = effective_plastic_strain
    variable = eff_plastic_strain
  [../]
[]

[Functions]
  [./appl_dispy]
    type = PiecewiseLinear
    x = &#x27;0     1.0     2.0     3.0     4.0     5.0      6.0    7.0     8.0    9.0     10.0      11.0     12.0&#x27;
    y = &#x27;0.0 0.208e-4 0.50e-4 1.00e-4 0.784e-4 0.50e-4  0.0  0.216e-4 0.5e-4 1.0e-4 0.785e-4  0.50e-4  0.0&#x27;
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_x
    boundary = 101
    value = 0.0
  [../]
  [./origin_x]
    type = DirichletBC
    variable = disp_x
    boundary = 103
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_y
    boundary = 102
    value = 0.0
  [../]
  [./origin_y]
    type = DirichletBC
    variable = disp_y
    boundary = 103
    value = 0.0
  [../]
  [./top_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = appl_dispy
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 1
    youngs_modulus = 250e9
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputePlaneFiniteStrain
    block = 1
  [../]
  [./stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;isoplas&#x27;
    block = 1
  [../]
  [./isoplas]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 5e6
    hardening_constant = 0.0
    relative_tolerance = 1e-20
    absolute_tolerance = 1e-8
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 20

  dt = 1.0
  start_time = 0.0
  num_steps = 100
  end_time = 12.0
[]

[Postprocessors]
  [./stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ElementAverageValue
    variable = stress_xy
  [../]
  [./vonmises]
    type = ElementAverageValue
    variable = vonmises
  [../]
  [./pressure]
    type = ElementAverageValue
    variable = pressure
  [../]
  [./el_strain_xx]
    type = ElementAverageValue
    variable = elastic_strain_xx
  [../]
  [./el_strain_yy]
    type = ElementAverageValue
    variable = elastic_strain_yy
  [../]
  [./el_strain_zz]
    type = ElementAverageValue
    variable = elastic_strain_zz
  [../]
  [./pl_strain_xx]
    type = ElementAverageValue
    variable = plastic_strain_xx
  [../]
  [./pl_strain_yy]
    type = ElementAverageValue
    variable = plastic_strain_yy
  [../]
  [./pl_strain_zz]
    type = ElementAverageValue
    variable = plastic_strain_zz
  [../]
  [./eff_plastic_strain]
    type = ElementAverageValue
    variable = eff_plastic_strain
  [../]
  [./tot_strain_xx]
    type = ElementAverageValue
    variable = tot_strain_xx
  [../]
  [./tot_strain_yy]
    type = ElementAverageValue
    variable = tot_strain_yy
  [../]
  [./tot_strain_zz]
    type = ElementAverageValue
    variable = tot_strain_zz
  [../]
  [./disp_x1]
    type = NodalVariableValue
    nodeid = 0
    variable = disp_x
  [../]
  [./disp_x4]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_x
  [../]
  [./disp_y1]
    type = NodalVariableValue
    nodeid = 0
    variable = disp_y
  [../]
  [./disp_y4]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./_dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="64ac14dc-e49a-48cc-a620-69fd909da5c2"><div class="modal-content"><h4>test/tests/time_steppers/function_dt/function_dt_min.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]

  [./dts]
    type = PiecewiseLinear
    x = &#x27;0   0.85 2&#x27;
    y = &#x27;0.2 0.2  0.2&#x27;
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  start_time = 0
  num_steps = 10
  [./TimeStepper]
    type = FunctionDT
    function = dts
    min_dt = 0.1
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c89762a8-9202-4fb4-b0b4-b1d34f36a22e"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral_vtest/j_int_surfbreak_ellip_crack_sym_mm_cfp.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = ellip_crack_4sym_norad_mm.e
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./resid_z]
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 0.1&#x27;
    scale_factor = -689.5 #MPa
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  crack_direction_method = CurvedCrackFront
  crack_end_direction_method = CrackDirectionVector
  crack_direction_vector_end_1 = &#x27;0.0 1.0 0.0&#x27;
  crack_direction_vector_end_2 = &#x27;1.0 0.0 0.0&#x27;
  crack_front_points = &#x27;0             254           0
                        127.308       248.843       0
                        249.446       233.581       0
                        361.455       208.835       0
                        508.003       152.398       0
                        602.415       80.3208       0
                        635           0             0&#x27;
  radius_inner = &#x27;12.5 25.0 37.5&#x27;
  radius_outer = &#x27;25.0 37.5 50.0&#x27;
  intersecting_boundary = &#x27;1 2&#x27;
  symmetry_plane = 2
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 12
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 5
      function = rampConstantUp
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]

   type = Transient
  # Two sets of linesearch options are for petsc 3.1 and 3.3 respectively
  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

#  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 1e-5
   nl_rel_tol = 1e-11
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./nl_its]
    type = NumNonlinearIterations
  [../]
  [./lin_its]
    type = NumLinearIterations
  [../]
  [./react_z]
    type = NodalSum
    variable = resid_z
    boundary = 5
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = j_int_surfbreak_ellip_crack_sym_mm_cfp_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fe9c7703-193b-4800-bddd-91f0c627a7ff"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/small_const.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function has a constant value,
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# This version of the test uses small deformation theory.  The results
# from the two models are identical.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 3
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ADComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain1]
    type = ADComputeMeanThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 0.5
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
  [./thermal_expansion_strain2]
    type = ADComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 2
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (t - tsf) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 1.0
               2 1.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = NEWTON
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b45ca734-b1a4-4d02-af35-7d6a08cc65d6"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/fric_constraint/2_block_common_cross.i</h4><pre class="moose-pre"><code class="language-text"># Test for LineElementAction on multiple blocks by placing parameters
# common to all blocks outside of the individual action blocks

# 2 beams of length 1m are fixed at one end and a force of 1e-4 N
# is applied at the other end of the beams. Beam 1 is in block 1
# and beam 2 is in block 2. All the material properties for the two
# beams are identical. The moment of inertia of beam 2 is twice that
# of beam 1.

# Since the end displacement of a cantilever beam is inversely proportional
# to the moment of inertia, the y displacement at the end of beam 1 should be twice
# that of beam 2.

[Mesh]
  type = FileMesh
  file = test_fric_cross.e
  #displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1 3&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = &#x27;1 2 3&#x27;
    value = 0.0
  [../]
  [./move_z4]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 2
    function = pull
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0  3.0  4.0  5.0  6.0  7.0   8.0  9.0 10.0 11.0 12.0 13.0&#x27;
    y = &#x27;0.0 0.0 -0.2 -0.4 -0.6 -0.8 -0.6 -0.4 -0.2  0.0 0.2 0.4  0.6 0.8&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 5e-5
  l_max_its = 10

  dt = 1
  dtmin = 1
  end_time = 13
[]

[Modules/TensorMechanics/LineElementMaster]
  # parameters common to all blocks

  add_variables = true
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  rotations = &#x27;rot_x rot_y rot_z&#x27;

  # Geometry parameters
  area = 0.5
  y_orientation = &#x27;0.0 1.0 0.0&#x27;

  [./block_1]
    Iy = 1e-5
    Iz = 1e-5
    block = 1
  [../]
  [./block_2]
    Iy = 8e-4
    Iz = 8e-4
    block = &#x27;2 3&#x27;
  [../]
[]

[Materials]
  [./stress]
    type = ComputeBeamResultants
    block = &#x27;1 2 3&#x27;
  [../]
  [./elasticity_1]
    type = ComputeElasticityBeam
    youngs_modulus = 2.0
    poissons_ratio = 0.3
    shear_coefficient = 1.0
    block = &#x27;1 2 3&#x27;
  [../]
[]

[Constraints]
  [./tie_z]
    type = NodalFrictionalConstraint
    normal_force = 0.006
    tangential_penalty = 100
    friction_coefficient = 0.5
    boundary = 6
    secondary = 4
    variable = disp_z
  [../]
  [./tie_z2]
    type = NodalFrictionalConstraint
    normal_force = 0.006
    tangential_penalty = 100
    friction_coefficient = 0.2
    boundary = 6
    secondary = 5
    variable = disp_z
  [../]
[]

[Postprocessors]
  [./disp_x_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_x
  [../]
  [./disp_x_2]
    type = NodalVariableValue
    nodeid = 2
    variable = disp_x
  [../]
  [./disp_z_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_z
  [../]
  [./disp_z_2]
    type = NodalVariableValue
    nodeid = 2
    variable = disp_z
  [../]
[]

[Outputs]
  #file_base = &#x27;2_block_out&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="68cf78b8-6ae0-4179-be05-628e3498b3cf"><div class="modal-content"><h4>modules/contact/test/tests/normalized_penalty/normalized_penalty_kin_Q8.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = normalized_penalty_Q8.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[AuxVariables]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
[]

[Functions]
  [./left_x]
    type = PiecewiseLinear
    x = &#x27;0 1 2&#x27;
    y = &#x27;0 0.02 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = FINITE
    generate_output = &#x27;stress_xx&#x27;
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  []
[]

[Contact]
  [./m3_s2]
    primary = 3
    secondary = 2
    penalty = 1e10
    normalize_penalty = true
    tangential_tolerance = 1e-3
  [../]
[]

[BCs]
  [./left_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 1
    function = left_x
  [../]

  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2 3 4&#x27;
    value = 0.0
  [../]

  [./right]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    value = 0
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2 3 4 1000&#x27;
    youngs_modulus = 3e8
    poissons_ratio = 0.0
  [../]
  [./stiffStuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2 3 4 1000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       101&#x27;

  line_search = &#x27;none&#x27;

  nl_rel_tol = 1e-12
  nl_abs_tol = 5e-8

  l_max_its = 100
  nl_max_its = 20
  dt = 0.5
  num_steps = 4
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5443fec4-471f-4fff-b9a9-db877277e27f"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_convex/gap_heat_transfer_convex.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  temperature = temp
[]

[Mesh]
  file = gap_heat_transfer_convex.e
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0 2.0&#x27;
    y = &#x27;0 1.0&#x27;
  [../]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0     1&#x27;
    y = &#x27;200 200&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]

  [./temp]
    initial_condition = 100
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 2
    secondary = 3
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Modules/TensorMechanics/Master/All]
  volumetric_locking_correction = true
  strain = FINITE
  eigenstrain_names = eigenstrain
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]

[BCs]
  [./move_right]
    type = FunctionDirichletBC
    boundary = &#x27;3&#x27;
    variable = disp_x
    function = disp
  [../]

  [./fixed_x]
    type = DirichletBC
    boundary = &#x27;1&#x27;
    variable = disp_x
    value = 0
  [../]
  [./fixed_y]
    type = DirichletBC
    boundary = &#x27;1 2 3 4&#x27;
    variable = disp_y
    value = 0
  [../]
  [./fixed_z]
    type = DirichletBC
    boundary = &#x27;1 2 3 4&#x27;
    variable = disp_z
    value = 0
  [../]

  [./temp_bottom]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_top]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    stress_free_temperature = 100
    thermal_expansion_coeff = 0
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

  [./heat1]
    type = HeatConductionMaterial
    block = 1

    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]
  [./heat2]
    type = HeatConductionMaterial
    block = 2

    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
    disp_x = disp_x
    disp_y = disp_y
    disp_z = disp_z
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  dt = 0.1
  end_time = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d6985f84-dd53-424a-be12-e110548c7d5e"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_hht_AD.i</h4><pre class="moose-pre"><code class="language-text"># Wave propogation in 1D using HHT time integration in the presence of Rayleigh damping
#
# The test is for an 1D bar element of length 4m  fixed on one end
# with a sinusoidal pulse dirichlet boundary condition applied to the other end.
# alpha, beta and gamma are HHT  time integration parameters
# eta and zeta are mass dependent and stiffness dependent Rayleigh damping
# coefficients, respectively.
# The equation of motion in terms of matrices is:
#
# M*accel + (eta*M+zeta*K)*((1+alpha)*vel-alpha*vel_old)
# +(1+alpha)*K*disp-alpha*K*disp_old = 0
#
# Here M is the mass matrix, K is the stiffness matrix
#
# The displacement at the first, second, third and fourth node at t = 0.1 are
# -7.787499960311491942e-02, 1.955566679096475483e-02 and -4.634888180231294501e-03, respectively.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 4
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 4.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    alpha = -0.3
    zeta = 0.1
    use_automatic_differentiation = true
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.422
    gamma = 0.8
    eta=0.1
    alpha = -0.3
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.422
    gamma = 0.8
    eta=0.1
    alpha = -0.3
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.422
    gamma = 0.8
    eta = 0.1
    alpha = -0.3
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.422
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.422
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.422
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.8
    execute_on = timestep_end
  [../]
[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
   type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value=0.0
  [../]
  [./right_z]
    type = DirichletBC
    variable = disp_z
    boundary = right
    value=0.0
  [../]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value=0.0
  [../]
  [./left_z]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value=0.0
  [../]
  [./front_x]
    type = DirichletBC
    variable = disp_x
    boundary = front
    value=0.0
  [../]
  [./front_z]
    type = DirichletBC
    variable = disp_z
    boundary = front
    value=0.0
  [../]
  [./back_x]
    type = DirichletBC
    variable = disp_x
    boundary = back
    value=0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = bottom
    function = displacement_bc
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ADComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;1 0&#x27;
  [../]

  [./strain]
    type = ADComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ADComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1&#x27;
  [../]

[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  start_time = 0
  end_time = 6.0
  l_tol = 1e-12
  nl_rel_tol = 1e-12
  dt = 0.1
[]


[Functions]
  [./displacement_bc]
    type = PiecewiseLinear
    data_file = &#x27;sine_wave.csv&#x27;
    format = columns
  [../]

[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_y
  [../]
  [./disp_2]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./disp_3]
    type = NodalVariableValue
    nodeid = 10
    variable = disp_y
  [../]
  [./disp_4]
    type = NodalVariableValue
    nodeid = 14
    variable = disp_y
  [../]
[]

[Outputs]
  file_base = &#x27;wave_rayleigh_hht_out&#x27;
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="87a358a1-fbcc-41c6-8041-5ffb133c12de"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymmetric_gps_finite.i</h4><pre class="moose-pre"><code class="language-text">#
# This test checks the generalized plane strain using finite strain formulation.
# since we constrain all the nodes against movement and the applied thermal strain
# is very small, the results are the same as small and incremental small strain formulations
#

[GlobalParams]
  displacements = disp_x
  scalar_out_of_plane_strain = scalar_strain_yy
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = lines.e
[]

[Variables]
  [./disp_x]
  [../]
  [./temp]
    initial_condition = 580.0
  [../]
  [./scalar_strain_yy]
    order = FIRST
    family = SCALAR
  [../]
[]

[Functions]
  [./temp100]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;580 680&#x27;
  [../]
  [./temp300]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;580 880&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = Diffusion
    variable = temp
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./gps]
        planar_formulation = GENERALIZED_PLANE_STRAIN
        scalar_out_of_plane_strain = scalar_strain_yy
        strain = FINITE
        generate_output = &#x27;strain_xx strain_yy strain_zz stress_xx stress_yy stress_zz&#x27;
        eigenstrain_names = eigenstrain
      [../]
    [../]
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1000
    value = 0
    variable = disp_x
  [../]
  [./temp100]
    type = FunctionDirichletBC
    variable = temp
    function = temp100
    boundary = 2
  [../]
  [./temp300]
    type = FunctionDirichletBC
    variable = temp
    function = temp300
    boundary = 3
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-8
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-08
  nl_max_its = 15
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 1
  num_steps = 1
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ecbf7065-3920-4094-b6c6-912163a951e4"><div class="modal-content"><h4>modules/combined/test/tests/reference_residual/reference_residual.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 4
  ny = 4
  nz = 4
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]

  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./saved_z]
  [../]
  [./saved_t]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = true
    incremental = true
    save_in = &#x27;saved_x saved_y saved_z&#x27;
    eigenstrain_names = thermal_expansion
    strain = FINITE
    decomposition_method = EigenSolution
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
    save_in = saved_t
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 1 2&#x27;
    y = &#x27;0 1 1&#x27;
    scale_factor = 0.1
  [../]
[]

[BCs]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value = 0.0
  [../]

  [./bottom_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]

  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value = 0.0
  [../]

  [./top_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]

  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value = 0.0
  [../]

  [./bottom_temp]
    type = DirichletBC
    variable = temp
    boundary = bottom
    value = 10.0
  [../]

  [./top_temp]
    type = DirichletBC
    variable = temp
    boundary = top
    value = 20.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 0
    youngs_modulus = 1.0
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]

  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    block = 0
    eigenstrain_name = thermal_expansion
    temperature = temp
    thermal_expansion_coeff = 1e-5
    stress_free_temperature = 0.0
  [../]

  [./heat1]
    type = HeatConductionMaterial
    block = 0
    specific_heat = 1.0
    thermal_conductivity = 1e-3 #Tuned to give temperature reference resid close to that of solidmech
  [../]

  [./density]
    type = Density
    block = 0
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10

  l_tol = 1e-3
  l_max_its = 100

  dt = 1.0
  end_time = 2.0
[]

[Postprocessors]
  [./ref_resid_x]
    type = NodalL2Norm
    execute_on = timestep_end
    variable = saved_x
  [../]
  [./ref_resid_y]
    type = NodalL2Norm
    execute_on = timestep_end
    variable = saved_y
  [../]
  [./ref_resid_z]
    type = NodalL2Norm
    execute_on = timestep_end
    variable = saved_z
  [../]
  [./ref_resid_t]
    type = NodalL2Norm
    execute_on = timestep_end
    variable = saved_t
  [../]
  [./nonlinear_its]
    type = NumNonlinearIterations
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="286d27ba-fbb5-4d42-bef1-f3a94b1db0cc"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/mandel.i</h4><pre class="moose-pre"><code class="language-text"># Mandel&#x27;s problem of consolodation of a drained medium
#
# A sample is in plane strain.
# -a &lt;= x &lt;= a
# -b &lt;= y &lt;= b
# It is squashed with constant force by impermeable, frictionless plattens on its top and bottom surfaces (at y=+/-b)
# Fluid is allowed to leak out from its sides (at x=+/-a)
# The porepressure within the sample is monitored.
#
# As is common in the literature, this is simulated by
# considering the quarter-sample, 0&lt;=x&lt;=a and 0&lt;=y&lt;=b, with
# impermeable, roller BCs at x=0 and y=0 and y=b.
# Porepressure is fixed at zero on x=a.
# Porepressure and displacement are initialised to zero.
# Then the top (y=b) is moved downwards with prescribed velocity,
# so that the total force that is inducing this downwards velocity
# is fixed.  The velocity is worked out by solving Mandel&#x27;s problem
# analytically, and the total force is monitored in the simulation
# to check that it indeed remains constant.
#
# Here are the problem&#x27;s parameters, and their values:
# Soil width.  a = 1
# Soil height.  b = 0.1
# Soil&#x27;s Lame lambda.  la = 0.5
# Soil&#x27;s Lame mu, which is also the Soil&#x27;s shear modulus.  mu = G = 0.75
# Soil bulk modulus.  K = la + 2*mu/3 = 1
# Drained Poisson ratio.  nu = (3K - 2G)/(6K + 2G) = 0.2
# Soil bulk compliance.  1/K = 1
# Fluid bulk modulus.  Kf = 8
# Fluid bulk compliance.  1/Kf = 0.125
# Soil initial porosity.  phi0 = 0.1
# Biot coefficient.  alpha = 0.6
# Biot modulus.  M = 1/(phi0/Kf + (alpha - phi0)(1 - alpha)/K) = 4.705882
# Undrained bulk modulus. Ku = K + alpha^2*M = 2.694118
# Undrained Poisson ratio.  nuu = (3Ku - 2G)/(6Ku + 2G) = 0.372627
# Skempton coefficient.  B = alpha*M/Ku = 1.048035
# Fluid mobility (soil permeability/fluid viscosity).  k = 1.5
# Consolidation coefficient.  c = 2*k*B^2*G*(1-nu)*(1+nuu)^2/9/(1-nuu)/(nuu-nu) = 3.821656
# Normal stress on top.  F = 1
#
# The solution for porepressure and displacements is given in
# AHD Cheng and E Detournay &quot;A direct boundary element method for plane strain poroelasticity&quot; International Journal of Numerical and Analytical Methods in Geomechanics 12 (1988) 551-572.
# The solution involves complicated infinite series, so I shall not write it here
#
# FINAL NOTE: The above solution assumes constant Biot Modulus.
# In porous_flow this is not true.  Therefore the solution is
# a little different than in the paper.  This test was therefore
# validated against MOOSE&#x27;s poromechanics, which can choose either
# a constant Biot Modulus (which has been shown to agree with
# the analytic solution), or a non-constant Biot Modulus (which
# gives the same results as porous_flow).

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
  ny = 1
  nz = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 0.1
  zmin = 0
  zmax = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.8
    alpha = 1e-5
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./roller_xmin]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left&#x27;
  [../]
  [./roller_ymin]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  [../]
  [./plane_strain]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
  [./xmax_drained]
    type = DirichletBC
    variable = porepressure
    value = 0
    boundary = right
  [../]
  [./top_velocity]
    type = FunctionDirichletBC
    variable = disp_y
    function = top_velocity
    boundary = top
  [../]
[]

[Functions]
  [./top_velocity]
    type = PiecewiseLinear
    x = &#x27;0 0.002 0.006   0.014   0.03    0.046   0.062   0.078   0.094   0.11    0.126   0.142   0.158   0.174   0.19 0.206 0.222 0.238 0.254 0.27 0.286 0.302 0.318 0.334 0.35 0.366 0.382 0.398 0.414 0.43 0.446 0.462 0.478 0.494 0.51 0.526 0.542 0.558 0.574 0.59 0.606 0.622 0.638 0.654 0.67 0.686 0.702&#x27;
    y = &#x27;-0.041824842    -0.042730269    -0.043412712    -0.04428867     -0.045509181    -0.04645965     -0.047268246 -0.047974749      -0.048597109     -0.0491467  -0.049632388     -0.050061697      -0.050441198     -0.050776675     -0.051073238      -0.0513354 -0.051567152      -0.051772022     -0.051953128 -0.052113227 -0.052254754 -0.052379865 -0.052490464 -0.052588233 -0.052674662 -0.052751065 -0.052818606 -0.052878312 -0.052931093 -0.052977751 -0.053018997 -0.053055459 -0.053087691 -0.053116185 -0.053141373 -0.05316364 -0.053183324 -0.053200724 -0.053216106 -0.053229704 -0.053241725 -0.053252351 -0.053261745 -0.053270049 -0.053277389 -0.053283879 -0.053289615&#x27;
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_force]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./tot_force]
    type = ParsedAux
    args = &#x27;stress_yy porepressure&#x27;
    execute_on = timestep_end
    variable = tot_force
    function = &#x27;-stress_yy+0.6*porepressure&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.6
    component = 2
    variable = disp_z
  [../]
  [./poro_vol_exp]
    type = PorousFlowMassVolumetricExpansion
    variable = porepressure
    fluid_component = 0
  [../]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = porepressure
  [../]
  [./flux]
    type = PorousFlowAdvectiveFlux
    variable = porepressure
    gravity = &#x27;0 0 0&#x27;
    fluid_component = 0
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 8
      density0 = 1
      thermal_expansion = 0
      viscosity = 1
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0.5 0.75&#x27;
    # bulk modulus is lambda + 2*mu/3 = 0.5 + 2*0.75/3 = 1
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = porepressure
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosity
    fluid = true
    mechanical = true
    ensure_positive = false
    porosity_zero = 0.1
    biot_coefficient = 0.6
    solid_bulk = 1
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1.5 0 0   0 1.5 0   0 0 1.5&#x27;
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityCorey
    n = 0 # unimportant in this fully-saturated situation
    phase = 0
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0.0 0 0&#x27;
    variable = porepressure
  [../]
  [./p1]
    type = PointValue
    outputs = csv
    point = &#x27;0.1 0 0&#x27;
    variable = porepressure
  [../]
  [./p2]
    type = PointValue
    outputs = csv
    point = &#x27;0.2 0 0&#x27;
    variable = porepressure
  [../]
  [./p3]
    type = PointValue
    outputs = csv
    point = &#x27;0.3 0 0&#x27;
    variable = porepressure
  [../]
  [./p4]
    type = PointValue
    outputs = csv
    point = &#x27;0.4 0 0&#x27;
    variable = porepressure
  [../]
  [./p5]
    type = PointValue
    outputs = csv
    point = &#x27;0.5 0 0&#x27;
    variable = porepressure
  [../]
  [./p6]
    type = PointValue
    outputs = csv
    point = &#x27;0.6 0 0&#x27;
    variable = porepressure
  [../]
  [./p7]
    type = PointValue
    outputs = csv
    point = &#x27;0.7 0 0&#x27;
    variable = porepressure
  [../]
  [./p8]
    type = PointValue
    outputs = csv
    point = &#x27;0.8 0 0&#x27;
    variable = porepressure
  [../]
  [./p9]
    type = PointValue
    outputs = csv
    point = &#x27;0.9 0 0&#x27;
    variable = porepressure
  [../]
  [./p99]
    type = PointValue
    outputs = csv
    point = &#x27;1 0 0&#x27;
    variable = porepressure
  [../]
  [./xdisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_x
  [../]
  [./ydisp]
    type = PointValue
    outputs = csv
    point = &#x27;1 0.1 0&#x27;
    variable = disp_y
  [../]
  [./total_downwards_force]
     type = ElementAverageValue
     outputs = csv
     variable = tot_force
  [../]
  [./dt]
    type = FunctionValuePostprocessor
    outputs = console
    function = if(0.15*t&lt;0.01,0.15*t,0.01)
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres asm lu 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 0.7
  [./TimeStepper]
    type = PostprocessorDT
    postprocessor = dt
    dt = 0.001
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = mandel
  [./csv]
    interval = 3
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="441803d4-b6d1-4a64-b4bd-a302cc2653ff"><div class="modal-content"><h4>modules/combined/test/tests/heat_conduction_xfem/heat.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 6
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  geometric_cut_userobjects = &#x27;line_seg_cut_uo&#x27;
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.5  1.0  0.5  0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
[]

[Variables]
  [./temp]
    initial_condition = 300.0     # set initial temp to ambient
  [../]
[]

[Functions]
  [./temp_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;0  0.1&#x27;
  [../]
[]

[Kernels]
  [./heat]         # gradient term in heat conduction equation
    type = HeatConduction
    variable = temp
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_temp]
    type = FunctionDirichletBC
    variable = temp
    boundary = 3
    function = temp_left
  [../]

  [./right_temp]
    type = DirichletBC
    variable = temp
    boundary = 1
    value = 0
  [../]
[]

[Materials]
  [./fuel_thermal]
    type = HeatConductionMaterial
    block = 0
    temp = temp
    thermal_conductivity = 5.0
    specific_heat = 1.0
  [../]
[]

[Executioner]

  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  l_tol = 8e-3

  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
  num_steps = 2
[]

[Outputs]
  # Define output file(s)

  file_base = heat_out
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e55b2b27-86c7-4de8-bd1a-31bf285dd60a"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test1q.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1q.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_abs_tol = 1e-7
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test1q_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="175b3ecc-26f0-45a8-bd63-a9f933c9c399"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/jacobian_damper/cube_load.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  # This test uses ElementalVariableValue postprocessors on specific
  # elements, so element numbering needs to stay unchanged
  allow_renumbering = false
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

  [./total_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1     2&#x27;
    y = &#x27;0 0.025 0.05&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]

  [./total_strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = total_strain_yy
    index_i = 1
    index_j = 1
  [../]
[]


[BCs]
  [./y_pull_function]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 3
    function = top_pull
  [../]

  [./x_bot]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]

  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]

  [./z_bot]
    type = DirichletBC
    variable = disp_z
    boundary = 0
    value = 0.0
  [../]
[]

[Postprocessors]
  [./stress_yy_el]
    type = ElementalVariableValue
    variable = stress_yy
    elementid = 0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 2e5
  [../]
  [./strain]
    type = ComputeFiniteStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Dampers]
  [./disp_x_damp]
    type = ElementJacobianDamper
    max_increment = 0.002
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10
  l_tol = 1e-9

  start_time = 0.0
  end_time = 2
  dt = 1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a31e2802-204d-45be-b857-fcdf71ef15d2"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/sphere2DRZ.i</h4><pre class="moose-pre"><code class="language-text">#
# 2DRZ Spherical Gap Heat Transfer Test.
#
# This test exercises 2D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid sphere of radius = 1 unit, and outer
# hollow sphere with an inner radius of 2. In other words, the gap between
# them is 1 radial unit in length.
#
# The conductivity of both spheres is set very large to achieve a uniform
# temperature in each sphere. The temperature of the center node of the
# inner sphere is ramped from 100 to 200 over one time unit. The
# temperature of the outside of the outer, hollow sphere is held fixed
# at 100.
#
# A simple analytical solution is possible for the integrated heat flux
# between the inner and outer spheres:
#
#  Integrated Flux = (T_left - T_right) * (gapK/(r^2*((1/r1)-(1/r2)))) * Area
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 4 * pi * 1^2 (4*pi*r^2)
#
# The integrated heat flux across the gap at time 1 is then:
#
# 4*pi*k*delta_T/((1/r1)-(1/r2))
# 4*pi*1*100/((1/1) - (1/2)) =  2513.3 watts
#
# For comparison, see results from the integrated flux post processors.
# This simulation makes use of symmetry, so only 1/2 of the spheres is meshed
# As such, the integrated flux from the post processors is 1/2 of the total,
# or 1256.6 watts... i.e. 400*pi.
# The value coming from the post processor is slightly less than this
# but converges as mesh refinement increases.
#
# Simulating contact is challenging. Regression tests that exercise
# contact features can be difficult to solve consistently across multiple
# platforms. While designing these tests, we felt it worth while to note
# some aspects of these tests. The following applies to:
# sphere3D.i, sphere2DRZ.i, cyl2D.i, and cyl3D.i.
# 1. We decided that to perform consistently across multiple platforms we
# would use very small convergence tolerance. In this test we chose an
# nl_rel_tol of 1e-12.
# 2. Due to such a high value for thermal conductivity (used here so that the
# domains come to a uniform temperature) the integrated flux at time = 0
# was relatively large (the value coming from SideIntegralFlux =
#  -_diffusion_coef[_qp]*_grad_u[_qp]*_normals[_qp] where the diffusion coefficient
# here is thermal conductivity).
# Even though _grad_u[_qp] is small, in this case the diffusion coefficient
# is large. The result is a number that isn&#x27;t exactly zero and tends to
# fail exodiff. For this reason the parameter execute_on = initial should not
# be used. That parameter is left to default settings in these regression tests.
#
[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = cyl2D.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]


[Variables]
  [./temp]
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]


[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]


[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = SPHERE
    sphere_origin = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
    order = fifth
    side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
  [./Console]
    type = Console
  [../]
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="762125c7-a1bd-4140-bb7a-1c56c3e06204"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_rz_exponential.i</h4><pre class="moose-pre"><code class="language-text">#
# Test to exercise the exponential stress release
#
# Stress vs. strain should show a linear relationship until cracking,
#   an exponential stress release, a linear relationship back to zero
#   strain, a linear relationship with the original stiffness in
#   compression and then back to zero strain, a linear relationship
#   back to the exponential curve, and finally further exponential
#   stress release.

[Mesh]
  file = cracking_rz_test.e
[]

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./disply]
    type = PiecewiseLinear
    x = &#x27;0 1       2  3      4 5       6&#x27;
    y = &#x27;0 0.00175 0 -0.0001 0 0.00175 0.0035&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pully]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = disply
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]

  [./sides]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 186.5e9
    poissons_ratio = 0.316
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 119.3e6
    softening_models = exponential_softening
  [../]
  [./exponential_softening]
    type = ExponentialSoftening
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type&#x27;
  petsc_options_value = &#x27;101                lu&#x27;

  line_search = &#x27;none&#x27;
  l_max_its = 100
  l_tol = 1e-5

  nl_max_its = 10
  nl_rel_tol = 1e-8

  nl_abs_tol = 1e-4

  start_time = 0.0
  end_time = 6.0
  dt = 0.005
  dtmin = 0.005
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="201fd15b-23b2-4871-b463-5c0c3c7efaa5"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh05.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated
# injection
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;500 500 1E1&#x27;
    x = &#x27;4000 5000 6500&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E8
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = 0
    point_file = bh03.bh
    SumQuantityUO = borehole_total_outflow_mass
    variable = pressure
    unit_weight = &#x27;0 0 0&#x27;
    character = -1
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
  [../]

  [./fluid_mass0]
    type = RichardsMass
    variable = pressure
    execute_on = timestep_begin
  [../]

  [./fluid_mass1]
    type = RichardsMass
    variable = pressure
    execute_on = timestep_end
  [../]

  [./zmass_error]
    type = FunctionValuePostprocessor
    function = mass_bal_fcn
    execute_on = timestep_end
  [../]

  [./p0]
    type = PointValue
    variable = pressure
    point = &#x27;1 1 1&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = -2E5
  [../]

  [./mass_bal_fcn]
    type = ParsedFunction
    value = abs((a-c+d)/2/(a+c))
    vars = &#x27;a c d&#x27;
    vals = &#x27;fluid_mass1 fluid_mass0 bh_report&#x27;
  [../]

[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 0
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-12 0 0  0 1E-12 0  0 0 1E-12&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    sat_UO = Saturation
    seff_UO = Seff1VG
    SUPG_UO = SUPGstandard
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 6500
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  file_base = bh05
  exodus = false
  csv = true
  execute_on = timestep_end
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="43aceb2c-49d5-4fa8-a9c0-7df0771db7ce"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_file.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped masses at the ends of the beam.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass = 0.01899772 at the cantilever end
# mass = 2.0 at the fixed end (just for file testing purposes does not alter result)

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first frequency of this beam is:
# f1 = 1/(2 pi) * sqrt(3EI/(mL^3)) = 0.25

# This implies that the corresponding time period of this beam is 4s.

# The FEM solution for this beam with 10 element gives time periods of 4s with time step of 0.01s.
# A higher time step of 0.1 s is used in the test to reduce computational time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y                vel_y                accel_y
# 0.0    0.0                   0.0                  0.0
# 0.1    0.0013076435060869    0.026152870121738    0.52305740243477
# 0.2    0.0051984378734383    0.051663017225289   -0.01285446036375
# 0.3    0.010269120909367     0.049750643493289   -0.02539301427625
# 0.4    0.015087433925158     0.046615616822532   -0.037307519138892
# 0.5    0.019534963888307     0.042334982440433   -0.048305168503101

[Mesh]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  nx = 10
  dim = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    boundary = &#x27;left right&#x27;
    beta = 0.25
    gamma = 0.5
  #  nodal_mass_file = nodal_mass.csv # commented out for testing error message
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    boundary = &#x27;left right&#x27;
    beta = 0.25
    gamma = 0.5
    nodal_mass_file = nodal_mass.csv
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    boundary = &#x27;left right&#x27;
    beta = 0.25
    gamma = 0.5
    nodal_mass_file = nodal_mass.csv
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  file_base = dyn_euler_small_added_mass_out
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9aea7b1c-9fc2-4c30-aee1-056e2752d55a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymmetric_gps_incremental.i</h4><pre class="moose-pre"><code class="language-text">#
# This test checks the generalized plane strain using incremental small strain formulation.
# The model consists of two sets of line elements. One undergoes a temperature rise of 100 with
# the other seeing a temperature rise of 300.  Young&#x27;s modulus is 3600, and
# Poisson&#x27;s ratio is 0.2.  The thermal expansion coefficient is 1e-8.  All
# nodes are constrained against movement.
#
# For plane strain case, i.e., without constraining the strain_yy to be uniform,
# the stress solution would be [-6e-3, -6e-3, -6e-3] and [-18e-3, -18e-3, -18e-3] (xx, yy, zz).
# The generalized plane strain kernels work to balance the force in y direction.
#
# With out of plane strain of 3e-6, the stress solution becomes
# [-3e-3, 6e-3, -3e-3] and [-15e-3, -6e-3, -15e-3] (xx, yy, zz).  This gives
# a domain integral of out-of-plane stress to be zero.
#

[GlobalParams]
  displacements = disp_x
  scalar_out_of_plane_strain = scalar_strain_yy
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = lines.e
[]

[Variables]
  [./disp_x]
  [../]
  [./temp]
    initial_condition = 580.0
  [../]
  [./scalar_strain_yy]
    order = FIRST
    family = SCALAR
  [../]
[]

[Functions]
  [./temp100]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;580 680&#x27;
  [../]
  [./temp300]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;580 880&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = Diffusion
    variable = temp
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./gps]
        planar_formulation = GENERALIZED_PLANE_STRAIN
        scalar_out_of_plane_strain = scalar_strain_yy
        strain = SMALL
        incremental = true
        generate_output = &#x27;strain_xx strain_yy strain_zz stress_xx stress_yy stress_zz&#x27;
        eigenstrain_names = eigenstrain
      [../]
    [../]
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1000
    value = 0
    variable = disp_x
  [../]
  [./temp100]
    type = FunctionDirichletBC
    variable = temp
    function = temp100
    boundary = 2
  [../]
  [./temp300]
    type = FunctionDirichletBC
    variable = temp
    function = temp300
    boundary = 3
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-8
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeStrainIncrementBasedStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-6
  nl_max_its = 15
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 1
  num_steps = 1
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0e340aa7-b673-433a-a107-7b7808d42f1d"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_3d_topo_q_func.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with 2 elements
#through the thickness, and calculates the J-Integrals using options
#to treat it as 3d.
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack3d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  q_function_type = Topology
  ring_first = 1
  ring_last = 3
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 500
    value = 0.0
  [../]
  [./no_z2]
    type = DirichletBC
    variable = disp_z
    boundary = 510
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]

[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]


[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = j_integral_3d_topo_q_func_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a8ed3cb2-9171-48b0-925b-ccc8a8b1a7bd"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test3qtt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3qtt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_abs_tol = 1e-7
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test3qtt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b4fbca17-9a9b-461a-a991-8546ad194c82"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/cyl3D.i</h4><pre class="moose-pre"><code class="language-text">#
# 3D Cylindrical Gap Heat Transfer Test.
#
# This test exercises 3D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid cylinder of radius = 1 unit, and outer
# hollow cylinder with an inner radius of 2. In other words, the gap between
# them is 1 radial unit in length.
#
# The conductivity of both cylinders is set very large to achieve a uniform
# temperature in each cylinder. The temperature of the center node of the
# inner cylinder is ramped from 100 to 200 over one time unit. The temperature
# of the outside of the outer, hollow cylinder is held fixed at 100.
#
# A simple analytical solution is possible for the integrated heat flux
# between the inner and outer cylinders:
#
#  Integrated Flux = (T_left - T_right) * (gapK/(r*ln(r2/r1))) * Area
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 2 * pi * h * r, where h is the height of the cylinder.
#
# The integrated heat flux across the gap at time 1 is then:
#
# 2*pi*h*k*delta_T/(ln(r2/r1))
# 2*pi*1*1*100/(ln(2/1)) = 906.5 watts
#
# For comparison, see results from the integrated flux post processors.
# This simulation makes use of symmetry, so only 1/4 of the cylinders is meshed
# As such, the integrated flux from the post processors is 1/4 of the total,
# or 226.6 watts.
# The value coming from the post processor is slightly less than this
# but converges as mesh refinement increases.
#
# Simulating contact is challenging. Regression tests that exercise
# contact features can be difficult to solve consistently across multiple
# platforms. While designing these tests, we felt it worth while to note
# some aspects of these tests. The following applies to:
# sphere3D.i, sphere2DRZ.i, cyl2D.i, and cyl3D.i.
# 1. We decided that to perform consistently across multiple platforms we
# would use very small convergence tolerance. In this test we chose an
# nl_rel_tol of 1e-12.
# 2. Due to such a high value for thermal conductivity (used here so that the
# domains come to a uniform temperature) the integrated flux at time = 0
# was relatively large (the value coming from SideIntegralFlux =
#  -_diffusion_coef[_qp]*_grad_u[_qp]*_normals[_qp] where the diffusion coefficient
# here is thermal conductivity).
# Even though _grad_u[_qp] is small, in this case the diffusion coefficient
# is large. The result is a number that isn&#x27;t exactly zero and tends to
# fail exodiff. For this reason the parameter execute_on = initial should not
# be used. That parameter is left to default settings in these regression tests.
#
 [GlobalParams]
  order = SECOND
  family = LAGRANGE
  []


[Mesh]
  file = cyl3D.e
[]

[Functions]

  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]

[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]


[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]

[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = CYLINDER
    cylinder_axis_point_1 = &#x27;0 0 0&#x27;
    cylinder_axis_point_2 = &#x27;0 1 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 5
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]

[]

[Outputs]
  exodus = true
   [./Console]
    type = Console
   [../]
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="72813bce-926f-454c-83d5-1e8f71b450c6"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_inertia_damping_ti.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam. The lumped
# mass also has a moment of inertia associated with it.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772
# Moment of inertia of lumped mass:
# Ixx = 0.2
# Iyy = 0.1
# Izz = 0.1
# mass proportional damping coefficient (eta) = 0.1

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y              vel_y               accel_y
# 0.0    0.0                 0.0                 0.0
# 0.1    0.001278249649738   0.025564992994761   0.51129985989521
# 0.2    0.0049813090917644  0.048496195845768  -0.052675802875074
# 0.3    0.0094704658873002  0.041286940064947  -0.091509312741339
# 0.4    0.013082280729802   0.03094935678508   -0.115242352856
# 0.5    0.015588313103503   0.019171290688959  -0.12031896906642

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x] # These auxkernels are only to check output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
  [./rot_accel_x]
    type = TestNewmarkTI
    displacement = rot_x
    variable = rot_accel_x
    first = false
  [../]
  [./rot_accel_y]
    type = TestNewmarkTI
    displacement = rot_y
    variable = rot_accel_y
    first = false
  [../]
  [./rot_accel_z]
    type = TestNewmarkTI
    displacement = rot_z
    variable = rot_accel_z
    first = false
  [../]
  [./rot_vel_x]
    type = TestNewmarkTI
    displacement = rot_x
    variable = rot_vel_x
  [../]
  [./rot_vel_y]
    type = TestNewmarkTI
    displacement = rot_y
    variable = rot_vel_y
  [../]
  [./rot_vel_z]
    type = TestNewmarkTI
    displacement = rot_z
    variable = rot_vel_z
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    boundary = right
    mass = 0.01899772
    eta = 0.1
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    boundary = right
    mass = 0.01899772
    eta = 0.1
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    boundary = right
    mass = 0.01899772
    eta = 0.1
  [../]
  [./rot_x_inertial]
    type = NodalRotationalInertia
    variable = rot_x
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    boundary = right
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 0
  [../]
  [./rot_y_inertial]
    type = NodalRotationalInertia
    variable = rot_y
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    boundary = right
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 1
  [../]
  [./rot_z_inertial]
    type = NodalRotationalInertia
    variable = rot_z
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    boundary = right
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 2
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  start_time = 0.0
  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6

  # Time integrator scheme
  scheme = &quot;newmark-beta&quot;
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  file_base = &quot;dyn_euler_small_added_mass_inertia_damping_out&quot;
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="044fe992-d884-4f10-a333-f1d16ce637bd"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/ghQ2P_pgas.i</h4><pre class="moose-pre"><code class="language-text"># quick two phase with Pgas and Swater being variables

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = Q2PRelPermPowerGas
    simm = 0.0
    n = 3
  [../]
[]

[Variables]
  [./pgas]
  [../]
  [./swater]
  [../]
[]

[ICs]
  [./pp_ic]
    type = ConstantIC
    value = 1
    variable = pgas
  [../]
  [./sat_ic]
    type = ConstantIC
    value = 0.5
    variable = swater
  [../]
[]

[Q2P]
  porepressure = pgas
  saturation = swater
  water_density = DensityWater
  water_relperm = RelPermWater
  water_viscosity = 1
  gas_density = DensityGas
  gas_relperm = RelPermGas
  gas_viscosity = 1
  diffusivity = 0
[]

[Postprocessors]
  [./pp_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
  [../]
  [./pp_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
  [../]

  [./sat_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = swater
  [../]
  [./sat_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = swater
  [../]
[]


[Materials]
  [./rock]
    type = Q2PMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    gravity = &#x27;-1 0 0&#x27;
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = ghQ2P_pgas
  csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3c0e4168-0584-48c4-af84-0f500928d951"><div class="modal-content"><h4>modules/combined/test/tests/evolving_mass_density/expand_compress_test_tensors.i</h4><pre class="moose-pre"><code class="language-text">#  Element mass tests

#  This series of tests is designed to compute the mass of elements based on
#  an evolving mass density calculation.  The tests consist of expansion and compression
#  of the elastic patch test model along each axis, uniform expansion and compression,
#  and shear in each direction.  The expansion and compression tests change the volume of
#  the elements.  The corresponding change in density should compensate for this so the
#  mass remains constant.  The shear tests should not result in a volume change, and this
#  is checked too.  The mass calculation is done with the post processor called Mass.

#  The tests/file names are as follows:

#  Expansion and compression along a single axis
#  expand_compress_x_test_out.e
#  expand_compress_y_test_out.e
#  expand_compress_z_test_out.e

#  Volumetric expansion and compression
#  uniform_expand_compress_test.i

#  Zero volume change shear along each axis
#  shear_x_test_out.e
#  shear_y_test_out.e
#  shear_z_test_out.e

#  The resulting mass calculation for these tests should always be = 1.

# This test is a duplicate of the uniform_expand_compress_test.i test for solid mechanics, and the
#   output of this tensor mechanics test is compared to the original
#   solid mechanics output.  The duplication is necessary to test the
#   migrated tensor mechanics version while maintaining tests for solid mechanics.

[Mesh]
  file = elastic_patch.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  order = FIRST
  family = LAGRANGE
[]

[Functions]
  [./rampConstant1]
    type = PiecewiseLinear
    x = &#x27;0.00 1.00  2.0   3.00&#x27;
    y = &#x27;0.00 0.25  0.0  -0.25&#x27;
    scale_factor = 1
  [../]
[] # Functions

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[Kernels]
  [./TensorMechanics]
  [../]
[]

[BCs]
  [./bot_x]
    type = DirichletBC
    variable = disp_x
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_y
    value = 0
  [../]
  [./bot_z]
    type = DirichletBC
    variable = disp_z
    value = 0
  [../]
  [./top]
    type = FunctionDirichletBC
    preset = false
    function = rampConstant1
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2 3 4 5 6 7&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./small_strain]
    type = ComputeSmallStrain
    block = &#x27; 1 2 3 4 5 6 7&#x27;
  [../]

  [./elastic_stress]
    type = ComputeLinearElasticStress
    block = &#x27;1 2 3 4 5 6 7&#x27;
  [../]
[]

[Executioner]

  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10
  l_max_its = 20
  start_time = 0.0
  dt = 1.0
  num_steps = 3
  end_time = 3.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]

[Postprocessors]
  [./Mass]
    type = Mass
    variable = disp_x
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="49bfa2e7-b20e-408b-9132-c95788319aca"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/truss/truss_3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = truss_3d.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
 [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
#    initial_condition = 1.0
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./x2]
    type = PiecewiseLinear
    x = &#x27;0  1 2 3&#x27;
    y = &#x27;0 .5 1 1&#x27;
  [../]
  [./y2]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3&#x27;
    y = &#x27;0 0 .5 1&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0.0
  [../]
  [./fixx2]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    function = x2
  [../]
  [./fixx3]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 3
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]
  [./fixy2]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = y2
  [../]
  [./fixy3]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 3
    value = 0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]
  [./fixz2]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
  [./fixz3]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 3
    value = 0
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    block = &#x27;1 2&#x27;
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    block = &#x27;1 2&#x27;
    property = e_over_l
    variable = e_over_l
  [../]
  [./area]
    type = ConstantAux
    block = &#x27;1 2&#x27;
    variable = area
    value = 1.0
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;jacobi   101&#x27;
  line_search = &#x27;none&#x27;

  nl_max_its = 15
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10

  dt = 1
  num_steps = 3
  end_time = 3
[]

[Kernels]
  [./solid_x]
    type = StressDivergenceTensorsTruss
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    component = 0
    variable = disp_x
    area = area
    save_in = react_x
  [../]
  [./solid_y]
    type = StressDivergenceTensorsTruss
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    component = 1
    variable = disp_y
    area = area
    save_in = react_y
  [../]
  [./solid_z]
    type = StressDivergenceTensorsTruss
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    component = 2
    variable = disp_z
    area = area
    save_in = react_z
  [../]
[]

[Materials]
  [./linelast]
    type = LinearElasticTruss
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="256bc751-dcc2-4fe8-9728-647ad70d1581"><div class="modal-content"><h4>modules/combined/test/tests/reference_residual/reference_residual_perfgraph.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 4
  ny = 4
  nz = 4
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]

  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./saved_z]
  [../]
  [./saved_t]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = true
    incremental = true
    save_in = &#x27;saved_x saved_y saved_z&#x27;
    eigenstrain_names = thermal_expansion
    strain = FINITE
    decomposition_method = EigenSolution
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
    save_in = saved_t
    extra_vector_tags = &#x27;ref&#x27;
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 1 2&#x27;
    y = &#x27;0 1 1&#x27;
    scale_factor = 0.1
  [../]
[]

[BCs]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value = 0.0
  [../]

  [./bottom_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]

  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value = 0.0
  [../]

  [./top_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]

  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value = 0.0
  [../]

  [./bottom_temp]
    type = DirichletBC
    variable = temp
    boundary = bottom
    value = 10.0
  [../]

  [./top_temp]
    type = DirichletBC
    variable = temp
    boundary = top
    value = 20.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 0
    youngs_modulus = 1.0
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]

  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    block = 0
    eigenstrain_name = thermal_expansion
    temperature = temp
    thermal_expansion_coeff = 1e-5
    stress_free_temperature = 0.0
  [../]

  [./heat1]
    type = HeatConductionMaterial
    block = 0
    specific_heat = 1.0
    thermal_conductivity = 1e-3 #Tuned to give temperature reference resid close to that of solidmech
  [../]

  [./density]
    type = Density
    block = 0
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10
  l_tol = 1e-3
  l_max_its = 100
  dt = 1.0
  end_time = 2.0
[]

[Postprocessors]
  [./res_calls]
    type = PerfGraphData
    section_name = &quot;ReferenceResidualProblem::computeResidualInternal&quot;
    data_type = calls
  [../]
  [./elapsed]
    type = PerfGraphData
    section_name = &quot;Root&quot;
    data_type = total
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="72267406-fae1-44f4-8f26-3eb3d7314816"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# density (rho) = 1.0

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first and third frequencies of this beam are:
# f1 = 1/(2 pi) * (3.5156/L^2) * sqrt(EI/rho)
# f2 = 6.268 f1

# This implies that the corresponding time period of this beam are 2.858 s and 0.455s

# The FEM solution for this beam with 10 element gives time periods of 2.856 s and 0.4505s with a time step of 0.01.
# A smaller time step is required to obtain a closer match for the lower time periods/higher frequencies.
# A higher time step of 0.05 is used in this test to reduce testing time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time       disp_y            vel_y            accel_y
# 0     0.0                  0.0                0.0
# 0.05  0.0016523559162602   0.066094236650407  2.6437694660163
# 0.1   0.0051691308901533   0.07457676230532  -2.3044684398197
# 0.15  0.0078956772343372   0.03448509146203   4.7008016060883
# 0.2   0.0096592517031463   0.03605788729033  -0.63788977295649
# 0.25  0.011069233444348    0.020341382357756  0.0092295756535376

[Mesh]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  dim = 1
  nx = 10
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux
    variable = rot_accel_x
    displacement = rot_x
    velocity = rot_vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux
    variable = rot_vel_x
    acceleration = rot_accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux
    variable = rot_accel_y
    displacement = rot_y
    velocity = rot_vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux
    variable = rot_vel_y
    acceleration = rot_accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux
    variable = rot_accel_z
    displacement = rot_z
    velocity = rot_vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux
    variable = rot_vel_z
    acceleration = rot_accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.05 0.1 10.0&#x27;
    y = &#x27;0.0 0.01  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  dt = 0.05
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
  [./inertial_force_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 0
    variable = disp_x
  [../]
  [./inertial_force_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 1
    variable = disp_y
  [../]
  [./inertial_force_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 2
    variable = disp_z
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 3
    variable = rot_x
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 4
    variable = rot_y
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    beta = 0.25
    gamma = 0.5
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ef9a2936-d006-48d2-b832-c95d6341bee6"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/domain_integral_thermal/j_integral_2d_inst_ctefunc.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./tempfunc]
    type = ParsedFunction
    value = 10.0*(2*x/504)
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;-10 -10
                10  10&#x27;
    scale_factor = 1e-6
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;60.0 80.0 100.0 120.0&#x27;
  radius_outer = &#x27;80.0 100.0 120.0 140.0&#x27;
  temperature = temp
  incremental = true
  eigenstrain_names = thermal_expansion
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
    eigenstrain_names = thermal_expansion
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    block = 1
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 400
    value = 0.0
  [../]

  [./no_x1]
    type = DirichletBC
    variable = disp_x
    boundary = 900
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = thermal_expansion
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm         31   preonly   lu      1&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 40

  nl_rel_step_tol= 1e-10
  nl_rel_tol = 1e-10

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  csv = true
  execute_on = &#x27;timestep_end&#x27;
[]

[Preconditioning]
  [./smp]
    type = SMP
    pc_side = left
    ksp_norm = preconditioned
    full = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="47d23d97-6fec-4f53-beac-3fa4da88fd3c"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/multiple_postprocessors.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test (Volume input as a vector of postprocessors)
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = - (0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# In this test the internal volume is calculated as the sum of two Postprocessors
# internalVolumeInterior and internalVolumeExterior.  This sum equals the value
# reported by the internalVolume postprocessor.
#
# The parameters combined at t = 1 gives p = 301.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 3d.e
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = ADDiffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = ADFunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      volume = &#x27;internalVolumeInterior internalVolumeExterior&#x27;
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e1
    poissons_ratio = 0
    block = 1
  [../]
  [./strain1]
    type = ADComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0
    block = 2
  [../]
  [./strain2]
    type = ADComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./internalVolumeInterior]
    type = InternalVolume
    boundary = &#x27;1 2 3 4 5 6&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./internalVolumeExterior]
    type = InternalVolume
    boundary = &#x27;13 14 15 16 17 18&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f95e669c-039f-481c-8d02-b688a8617d24"><div class="modal-content"><h4>modules/richards/test/tests/broadbridge_white/bw01.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 200
  ny = 1
  xmin = -10
  xmax = 10
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-5 1E-2 1E-2 1E-1&#x27;
    x = &#x27;0 1E-5 1 10&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 10
    bulk_mod = 2E9
  [../]
  [./SeffBW]
    type = RichardsSeff1BWsmall
    Sn = 0.0
    Ss = 1.0
    C = 1.5
    las = 2
  [../]
  [./RelPermBW]
    type = RichardsRelPermBW
    Sn = 0.0
    Ss = 1.0
    Kn = 0
    Ks = 1
    C = 1.5
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E2
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -9E2
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]


[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffBW
    pressure_vars = pressure
  [../]
[]


[BCs]
  active = &#x27;recharge&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pressure
    boundary = &#x27;right&#x27;
    pressures = &#x27;-1E10 1E10&#x27;
    bare_fluxes = &#x27;-1.25 -1.25&#x27; # corresponds to Rstar being 0.5 because i have to multiply by density*porosity
    use_mobility = false
    use_relperm = false
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.25
    mat_permeability = &#x27;1 0 0  0 1 0  0 0 1&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermBW
    SUPG_UO = SUPGstandard
    sat_UO = Saturation
    seff_UO = SeffBW
    viscosity = 4
    gravity = &#x27;-0.1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 2

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = bw01
  interval = 10000
  execute_on = &#x27;timestep_end final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1b188290-bcac-469e-b227-a0d1ec9b72ac"><div class="modal-content"><h4>modules/contact/test/tests/normalized_penalty/normalized_penalty_Q8.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = normalized_penalty_Q8.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Functions]
  [./left_x]
    type = PiecewiseLinear
    x = &#x27;0 1 2&#x27;
    y = &#x27;0 0.02 0&#x27;
  [../]
[]
[AuxVariables]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = FINITE
    generate_output = &#x27;stress_xx&#x27;
    save_in = &#x27;saved_x saved_y&#x27;
    extra_vector_tags = &#x27;ref&#x27;
  []
[]

[Contact]
  [./m3_s2]
    primary = 3
    secondary = 2
    penalty = 1e10
    normalize_penalty = true
    formulation = penalty
    tangential_tolerance = 1e-3
  [../]
[]

[BCs]
  [./left_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 1
    function = left_x
  [../]

  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2 3 4&#x27;
    value = 0.0
  [../]

  [./right]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    value = 0
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2 3 4 1000&#x27;
    youngs_modulus = 3e8
    poissons_ratio = 0.0
  [../]
  [./stiffStuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2 3 4 1000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       101&#x27;

  line_search = &#x27;none&#x27;

  nl_rel_tol = 1e-12
  nl_abs_tol = 5e-8

  l_max_its = 100
  nl_max_its = 10
  dt = 0.5
  num_steps = 4
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0cc318a8-9e21-4e44-b2d1-289ed300af48"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/restart.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 0.5
[]

[Outputs]
  exodus = true
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3880fda2-eecd-4836-93b9-0edbcf251bd1"><div class="modal-content"><h4>modules/geochemistry/test/tests/kinetics/quartz_dissolution.i</h4><pre class="moose-pre"><code class="language-text"># Example of quartz dissolution.
[TimeDependentReactionSolver]
  model_definition = definition
  geochemistry_reactor_name = reactor
  charge_balance_species = &quot;Cl-&quot;
  constraint_species = &quot;H2O              H+                 Cl-                SiO2(aq)&quot;
  constraint_value = &quot;  1.0              1E-10              1E-10              1E-9&quot;
  constraint_meaning = &quot;kg_solvent_water moles_bulk_species moles_bulk_species free_molality&quot;
  initial_temperature = 100.0
  temperature = 100.0
  kinetic_species_name = Quartz
  kinetic_species_initial_moles = 83.216414271 # Quartz has 60.0843g/mol
  ramp_max_ionic_strength_initial = 0 # max_ionic_strength in such a simple problem does not need ramping
  stoichiometric_ionic_str_using_Cl_only = true # for comparison with GWB
  execute_console_output_on = &#x27;&#x27; # only CSV output for this example
[]

[UserObjects]
  [./rate_quartz]
    type = GeochemistryKineticRate
    kinetic_species_name = Quartz
    intrinsic_rate_constant = 1.728E-10 # 2.0E-15mol/s/cm^2 = 1.728E-10mol/day/cm^2
    multiply_by_mass = true
    area_quantity = 1000
  [../]
  [./definition]
    type = GeochemicalModelDefinition
    database_file = &quot;../../../database/moose_geochemdb.json&quot;
    basis_species = &quot;H2O SiO2(aq) H+ Cl-&quot;
    kinetic_minerals = &quot;Quartz&quot;
    kinetic_rate_descriptions = &quot;rate_quartz&quot;
    piecewise_linear_interpolation = true # for comparison with GWB
  [../]
[]

[Functions]
  [./timestepper]
    type = PiecewiseLinear
    x = &#x27;0 0.5 3&#x27;
    y = &#x27;0.01 0.05 0.1&#x27;
  [../]
[]

[Executioner]
  type = Transient
  [./TimeStepper]
    type = FunctionDT
    function = timestepper
  [../]
  end_time = 5.0
[]

[AuxVariables]
  [./diss]
  [../]
[]
[AuxKernels]
  [./diss]
    type = ParsedAux
    args = moles_Quartz
    function = &#x27;83.216414271 - moles_Quartz&#x27;
    variable = diss
  [../]
[]
[Postprocessors]
  [./dissolved_moles]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = diss
  [../]
[]
[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ef572e7a-8443-458a-8d4a-2059162b7122"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_hht.i</h4><pre class="moose-pre"><code class="language-text"># Wave propogation in 1D using HHT time integration in the presence of Rayleigh damping
#
# The test is for an 1D bar element of length 4m  fixed on one end
# with a sinusoidal pulse dirichlet boundary condition applied to the other end.
# alpha, beta and gamma are HHT  time integration parameters
# eta and zeta are mass dependent and stiffness dependent Rayleigh damping
# coefficients, respectively.
# The equation of motion in terms of matrices is:
#
# M*accel + (eta*M+zeta*K)*((1+alpha)*vel-alpha*vel_old)
# +(1+alpha)*K*disp-alpha*K*disp_old = 0
#
# Here M is the mass matrix, K is the stiffness matrix
#
# The displacement at the first, second, third and fourth node at t = 0.1 are
# -7.787499960311491942e-02, 1.955566679096475483e-02 and -4.634888180231294501e-03, respectively.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 4
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 4.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    alpha = -0.3
    zeta = 0.1
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.422
    gamma = 0.8
    eta=0.1
    alpha = -0.3
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.422
    gamma = 0.8
    eta=0.1
    alpha = -0.3
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.422
    gamma = 0.8
    eta = 0.1
    alpha = -0.3
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.422
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.422
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.8
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.422
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.8
    execute_on = timestep_end
  [../]
[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
   type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value=0.0
  [../]
  [./right_z]
    type = DirichletBC
    variable = disp_z
    boundary = right
    value=0.0
  [../]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value=0.0
  [../]
  [./left_z]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value=0.0
  [../]
  [./front_x]
    type = DirichletBC
    variable = disp_x
    boundary = front
    value=0.0
  [../]
  [./front_z]
    type = DirichletBC
    variable = disp_z
    boundary = front
    value=0.0
  [../]
  [./back_x]
    type = DirichletBC
    variable = disp_x
    boundary = back
    value=0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = bottom
    function = displacement_bc
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;1 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 6.0
  l_tol = 1e-12
  nl_rel_tol = 1e-12
  dt = 0.1
[]


[Functions]
  [./displacement_bc]
    type = PiecewiseLinear
    data_file = &#x27;sine_wave.csv&#x27;
    format = columns
  [../]

[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_y
  [../]
  [./disp_2]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./disp_3]
    type = NodalVariableValue
    nodeid = 10
    variable = disp_y
  [../]
  [./disp_4]
    type = NodalVariableValue
    nodeid = 14
    variable = disp_y
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="244c486f-0853-4318-9466-9ce6529c1320"><div class="modal-content"><h4>test/tests/time_integrators/newmark-beta/newmark_beta_prescribed_parameters.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of the TimeIntegrator system.
#
# Testing that the first and second time derivatives
# are calculated correctly using the Newmark-Beta method
#
# @Requirement F1.30
###########################################################

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 1
  ny = 1
[]

[Variables]
  [u]
  []
[]

[Functions]
  [forcing_fn]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2    0.3  0.4    0.5  0.6&#x27;
    y = &#x27;0.0 0.0 0.0025 0.01 0.0175 0.02 0.02&#x27;
  []
[]

[Kernels]
  [ie]
    type = TimeDerivative
    variable = u
  []

  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  [left]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    function = forcing_fn
  []
  [right]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = forcing_fn
  []
[]

[Executioner]
  type = Transient
  start_time = 0.0
  num_steps = 6
  dt = 0.1
  [TimeIntegrator]
    type = NewmarkBeta
    beta = 0.4225
    gamma = 0.8
  []
[]

[Postprocessors]
  [udot]
    type = ElementAverageTimeDerivative
    variable = u
  []
  [udotdot]
    type = ElementAverageSecondTimeDerivative
    variable = u
  []
  [u]
    type = ElementAverageValue
    variable = u
  []
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f150f570-7f9b-49c1-b5ab-24f4fbd547af"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/multiple_postprocessors.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test (Volume input as a vector of postprocessors)
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = - (0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# In this test the internal volume is calculated as the sum of two Postprocessors
# internalVolumeInterior and internalVolumeExterior.  This sum equals the value
# reported by the internalVolume postprocessor.
#
# The parameters combined at t = 1 gives p = 301.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 3d.e
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = Diffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = FunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      volume = &#x27;internalVolumeInterior internalVolumeExterior&#x27;
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e1
    poissons_ratio = 0
    block = 1
  [../]
  [./strain1]
    type = ComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0
    block = 2
  [../]
  [./strain2]
    type = ComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./internalVolumeInterior]
    type = InternalVolume
    boundary = &#x27;1 2 3 4 5 6&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./internalVolumeExterior]
    type = InternalVolume
    boundary = &#x27;13 14 15 16 17 18&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4e3ba5f5-1f11-4b94-9a5b-b690a5d45fa0"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/recompute_radial_return/isotropic_plasticity_incremental_strain.i</h4><pre class="moose-pre"><code class="language-text"># This simulation uses the piece-wise linear strain hardening model
# with the incremental small strain formulation; incremental small strain
# is required to produce the strain_increment for the DiscreteRadialReturnStressIncrement
# class, which handles the calculation of the stress increment to return
# to the yield surface in a J2 (isotropic) plasticity problem.
#
#  This test assumes a Poissons ratio of zero and applies a displacement loading
# condition on the top in the y direction while fixing the displacement in the x
# and z directions; thus, only the normal stress and the normal strains in the
# y direction are compared in this problem.
#
# A similar problem was run in Abaqus on a similar 1 element mesh and was used
# to verify the SolidMechanics solution; this TensorMechanics code matches the
# SolidMechanics solution.
#
# Mechanical strain is the sum of the elastic and plastic strains but is different
# from total strain in cases with eigen strains, e.g. thermal strain.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./top_pull]
    type = ParsedFunction
    value = t*(0.01)
  [../]
  [./hf]
    type = PiecewiseLinear
    x = &#x27;0  0.00004 0.0001  0.1&#x27;
    y = &#x27;50   54    56       60&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy plastic_strain_xx plastic_strain_yy plastic_strain_zz&#x27;
  [../]
[]

[BCs]
  [./y_pull_function]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = top_pull
  [../]

  [./x_sides]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left right&#x27;
    value = 0.0
  [../]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./z_sides]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;back front&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.5e5
    poissons_ratio = 0.0
  [../]
  [./isotropic_plasticity]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 25.
    hardening_constant = 1000.0
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;isotropic_plasticity&#x27;
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12
  l_tol = 1e-9

  start_time = 0.0
  end_time = 0.01875
  dt = 0.00125
  dtmin = 0.0001
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a70e5387-03b2-41cd-bb90-6023dd057212"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4nstt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4tt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4nstt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8ee48e1c-e9df-48ff-a5ee-18da6fb28bd7"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/negative_volume.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute a negative number of moles
# to trigger an error check in the CavityPressureUserObject.
# The negative number of moles is achieved by supplying an
# open volume to the InternalVolume postprocessor, which
# calculates a negative volume.

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 2
[]

[Functions]
  [./temperature]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 2&#x27;
    scale_factor = 100
  [../]
[]

[Variables]
  [./temperature]
    initial_condition = 100
  [../]
[]

[Modules/TensorMechanics/Master]
  [./block]
    strain = FINITE
    add_variables = true
  [../]
[]

[Kernels]
  [./heat]
    type = Diffusion
    variable = temperature
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_r
    boundary = left
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 2
    function = temperature
    variable = temperature
  [../]
  [./CavityPressure]
    [./pressure]
      boundary = &#x27;top bottom right&#x27;
      initial_pressure = 10e5
      R = 8.3143
      output_initial_moles = initial_moles
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
    [../]
  [../]
[]

[Materials]
  [./elastic_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_abs_tol = 1e-10
  l_max_its = 20
  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = &#x27;top bottom right&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = AxisymmetricCenterlineAverageValue
    boundary = left
    variable = temperature
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="38e0b552-1bb1-4a71-9176-975cb80e827a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/plane_stress/ad_weak_plane_stress_finite.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
  out_of_plane_strain = strain_zz
[]

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./strain_zz]
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./nl_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./react_z]
    type = ADMaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
  [./min_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = min
  [../]
  [./max_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = max
  [../]
[]

[Modules/TensorMechanics/Master]
  [./plane_stress]
    planar_formulation = WEAK_PLANE_STRESS
    strain = FINITE
    generate_output = &#x27;stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy&#x27;
    eigenstrain_names = eigenstrain
    use_automatic_differentiation = true
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    use_displaced_mesh = false
  [../]
  [./strain_zz]
    type = ADRankTwoAux
    rank_two_tensor = total_strain
    variable = nl_strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0     1   100&#x27;
    y=&#x27;0  0.00  0.00&#x27;
  [../]
  [./tempfunc]
    type = ParsedFunction
    value = &#x27;(1 - x) * t&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./thermal_strain]
    type = ADComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 0.02
    stress_free_temperature = 0.5
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ADComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  # controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-12

  # time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
[]

[Outputs]
  file_base = &#x27;weak_plane_stress_finite_out&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5247eb70-4805-4441-a901-fd6b36d156fe"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4ns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4ns_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9688ab36-4d31-4ded-86c0-0f05207302a3"><div class="modal-content"><h4>modules/richards/test/tests/recharge_discharge/rd01.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  # very little mesh dependence here
  nx = 120
  ny = 1
  xmin = 0
  xmax = 6
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1 10 500 5000 5000&#x27;
    x = &#x27;0 10 100 1000 10000 100000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1E3
    bulk_mod = 2E7
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.336
    al = 1.43E-4
  [../]
  [./RelPermPower]
    type = RichardsRelPermVG1
    scut = 0.99
    simm = 0.0
    m = 0.336
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E+2
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -72620.4
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]


[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]


[BCs]
  active = &#x27;recharge&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pressure
    boundary = &#x27;right&#x27;
    pressures = &#x27;0 1E9&#x27;
    bare_fluxes = &#x27;-2.315E-3 -2.315E-3&#x27;
    use_relperm = false
    use_mobility = false
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.33
    mat_permeability = &#x27;0.295E-12 0 0  0 0.295E-12 0  0 0 0.295E-12&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    SUPG_UO = SUPGstandard
    sat_UO = Saturation
    seff_UO = SeffVG
    viscosity = 1.01E-3
    gravity = &#x27;-10 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-13 1E-15 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 359424

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = rd01
  interval = 100000
  execute_on = &#x27;initial final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="74feaaeb-e58f-4360-bdd6-2a492fb74609"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/strain_energy_density/rate_incr_model_elas_plas.i</h4><pre class="moose-pre"><code class="language-text"># Single element test to check the strain energy density calculation

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 2
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
  [./ramp_disp_y]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 6.8e-6 1.36e-5&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = SMALL
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress elastic_strain_xx elastic_strain_yy elastic_strain_zz plastic_strain_xx plastic_strain_yy plastic_strain_zz strain_xx strain_yy strain_zz&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./top_disp]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = &#x27;top&#x27;
    function = ramp_disp_y
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 30e+6
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;isoplas&#x27;
  [../]
  [./isoplas]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 1e2
    hardening_constant = 0.0
  [../]
  [./strain_energy_density]
    type = StrainEnergyDensity
    incremental = true
  [../]
[]

[Executioner]
   type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 2
   num_steps = 2
[]

[Postprocessors]
  [./epxx]
    type = ElementalVariableValue
    variable = elastic_strain_xx
    elementid = 0
  [../]
  [./epyy]
    type = ElementalVariableValue
    variable = elastic_strain_yy
    elementid = 0
  [../]
  [./epzz]
    type = ElementalVariableValue
    variable = elastic_strain_zz
    elementid = 0
  [../]
  [./eplxx]
    type = ElementalVariableValue
    variable = plastic_strain_xx
    elementid = 0
  [../]
  [./eplyy]
    type = ElementalVariableValue
    variable = plastic_strain_yy
    elementid = 0
  [../]
  [./eplzz]
    type = ElementalVariableValue
    variable = plastic_strain_zz
    elementid = 0
  [../]
  [./etxx]
    type = ElementalVariableValue
    variable = strain_xx
    elementid = 0
  [../]
  [./etyy]
    type = ElementalVariableValue
    variable = strain_yy
    elementid = 0
  [../]
  [./etzz]
    type = ElementalVariableValue
    variable = strain_zz
    elementid = 0
  [../]
  [./sigxx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./sigyy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./sigzz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./SED]
    type = ElementAverageValue
    variable = SED
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7662ccb4-47c4-441e-9dd2-f39458ecbf9b"><div class="modal-content"><h4>modules/combined/test/tests/internal_volume/rz.i</h4><pre class="moose-pre"><code class="language-text">#
# Internal Volume Test
#
# This test is designed to compute the internal volume of a space considering
#   an embedded volume inside.
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total volume
#   is 7.
#
[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = meshes/rz.e
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = 1e4
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]

  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = true
    incremental = true
    strain = FINITE
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]

  [./Pressure]
    [./fred]
      boundary = 3
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK

  start_time = 0.0
  dt = 1.0
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5d413680-2980-447e-aec4-7b944e7614df"><div class="modal-content"><h4>modules/porous_flow/test/tests/infiltration_and_drainage/rsc02.i</h4><pre class="moose-pre"><code class="language-text"># RSC test with low-res time and spatial resolution
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 200
  ny = 1
  xmin = 0
  xmax = 10 # x is the depth variable, called zeta in RSC
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  PorousFlowDictator = dictator
  gravity = &#x27;0 0 0&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;3E-2 5E-1 8E-1&#x27;
    x = &#x27;0 1 5&#x27;
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;pwater poil&#x27;
    number_fluid_phases = 2
    number_fluid_components = 2
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
[]

[Modules]
  [./FluidProperties]
    [./water]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      density0 = 10
      thermal_expansion = 0
      viscosity = 1e-3
    [../]
    [./oil]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      density0 = 20
      thermal_expansion = 0
      viscosity = 2e-3
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow2PhasePP
    phase0_porepressure = pwater
    phase1_porepressure = poil
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
    mass_fraction_vars = &#x27;massfrac_ph0_sp0 massfrac_ph1_sp0&#x27;
  [../]
  [./water]
    type = PorousFlowSingleComponentFluid
    fp = water
    phase = 0
    compute_enthalpy = false
    compute_internal_energy = false
  [../]
  [./oil]
    type = PorousFlowSingleComponentFluid
    fp = oil
    phase = 1
    compute_enthalpy = false
    compute_internal_energy = false
  [../]
  [./relperm_water]
    type = PorousFlowRelativePermeabilityCorey
    n = 1
    phase = 0
  [../]
  [./relperm_oil]
    type = PorousFlowRelativePermeabilityCorey
    n = 1
    phase = 1
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.25
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
  [../]
[]

[Variables]
  [./pwater]
  [../]
  [./poil]
  [../]
[]

[ICs]
  [./water_init]
    type = ConstantIC
    variable = pwater
    value = 0
  [../]
  [./oil_init]
    type = ConstantIC
    variable = poil
    value = 15
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pwater
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pwater
  [../]
  [./mass1]
    type = PorousFlowMassTimeDerivative
    fluid_component = 1
    variable = poil
  [../]
  [./flux1]
    type = PorousFlowAdvectiveFlux
    fluid_component = 1
    variable = poil
  [../]
[]


[AuxVariables]
  [./SWater]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./SOil]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./massfrac_ph0_sp0]
    initial_condition = 1
  [../]
  [./massfrac_ph1_sp0]
    initial_condition = 0
  [../]
[]


[AuxKernels]
  [./SWater]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 0
    variable = SWater
  [../]
  [./SOil]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 1
    variable = SOil
  [../]
[]


[BCs]
# we are pumping water into a system that has virtually incompressible fluids, hence the pressures rise enormously.  this adversely affects convergence because of almost-overflows and precision-loss problems.  The fixed things help keep pressures low and so prevent these awful behaviours.   the movement of the saturation front is the same regardless of the fixed things.
  active = &#x27;recharge fixedoil fixedwater&#x27;
  [./recharge]
    type = PorousFlowSink
    variable = pwater
    boundary = &#x27;left&#x27;
    flux_function = -1.0
  [../]
  [./fixedwater]
    type = DirichletBC
    variable = pwater
    boundary = &#x27;right&#x27;
    value = 0
  [../]
  [./fixedoil]
    type = DirichletBC
    variable = poil
    boundary = &#x27;right&#x27;
    value = 15
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10      1E-10      10000&#x27;
  [../]
[]

[VectorPostprocessors]
  [./swater]
    type = LineValueSampler
    variable = SWater
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;7 0 0&#x27;
    sort_by = x
    num_points = 21
    execute_on = timestep_end
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 5
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = rsc02
  [./along_line]
    type = CSV
    execute_vector_postprocessors_on = final
  [../]
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial final&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="230732f5-c0c8-4ee7-a8f1-7a9bc3cc3197"><div class="modal-content"><h4>modules/xfem/test/tests/pressure_bc/inclined_edge_2d_pressure.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = False
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 9
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;0.0 0.33 0.5 0.67&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    generate_output = &#x27;stress_xx stress_yy&#x27;
  [../]
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0 1.0 2.0&#x27;
    y = &#x27;0 500 1000&#x27;
  [../]
[]

[BCs]
  [./bottom_y]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
  [./top_y]
    type = DirichletBC
    boundary = 2
    variable = disp_y
    value = 0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
[]

[DiracKernels]
  [./pressure_x]
    type = XFEMPressure
    variable = disp_x
    component = 0
    function = pressure
  [../]

  [./pressure_y]
    type = XFEMPressure
    variable = disp_y
    component = 1
    function = pressure
  [../]
[]


[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12

# time control
  start_time = 0.0
  dt = 1
  end_time = 2
[]

[Outputs]
  file_base = inclined_edge_2d_pressure_out
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c5b1e981-1af7-4d7e-a82e-96e1a9a51ac9"><div class="modal-content"><h4>modules/porous_flow/test/tests/infiltration_and_drainage/rd02.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 120
  ny = 1
  xmin = 0
  xmax = 6
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1 10 500 5000 50000&#x27;
    x = &#x27;0 10 100 1000 10000 500000&#x27;
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = pressure
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.336
    alpha = 1.43e-4
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e7
      viscosity = 1.01e-3
      density0 = 1000
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pressure
    capillary_pressure = pc
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityVG
    m = 0.336
    seff_turnover = 0.99
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.33
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;0.295E-12 0 0  0 0.295E-12 0  0 0 0.295E-12&#x27;
  [../]
[]

[Variables]
  [./pressure]
    initial_condition = 0.0
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pressure
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pressure
    gravity = &#x27;-10 0 0&#x27;
  [../]
[]

[AuxVariables]
  [./SWater]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./SWater]
    type = MaterialStdVectorAux
    property = PorousFlow_saturation_qp
    index = 0
    variable = SWater
  [../]
[]

[BCs]
  [./base]
    type = DirichletBC
    boundary = left
    value = 0.0
    variable = pressure
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason -ksp_diagonal_scale -ksp_diagonal_scale_fix -ksp_gmres_modifiedgramschmidt -snes_linesearch_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres      asm      lu           NONZERO                   2               1E-10      1E-10      10&#x27;
  [../]
[]

[VectorPostprocessors]
  [./swater]
    type = LineValueSampler
    variable = SWater
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;6 0 0&#x27;
    sort_by = x
    num_points = 121
    execute_on = timestep_end
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 345600

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = rd02
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial final&#x27;
  [../]
  [./along_line]
    type = CSV
    execute_on = final
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="61841c84-2edc-4c13-9fbf-f7971980e1cc"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/anisotropic_patch/anisotropic_patch_test.i</h4><pre class="moose-pre"><code class="language-text"># Patch Test

# This test is designed to compute constant xx, yy, zz, xy, yz, and zx
#  stress on a set of irregular hexes.  The mesh is composed of one
#  block with seven elements.  The elements form a unit cube with one
#  internal element.  There is a nodeset for each exterior node.

# The cube is displaced by 1e-6 units in x, 2e-6 in y, and 3e-6 in z.
#  The faces are sheared as well (1e-6, 2e-6, and 3e-6 for xy, yz, and
#  zx).  This gives a uniform strain/stress state for all six unique
#  tensor components.

# With Young&#x27;s modulus at 1e6 and Poisson&#x27;s ratio at 0, the shear
#  modulus is 5e5 (G=E/2/(1+nu)).  Therefore,
#
#  stress xx = 1e6 * 1e-6 = 1
#  stress yy = 1e6 * 2e-6 = 2
#  stress zz = 1e6 * 3e-6 = 3
#  stress xy = 2 * 5e5 * 1e-6 / 2 = 0.5
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 5e5 * 2e-6 / 2 = 1
#  stress zx = 2 * 5e5 * 3e-6 / 2 = 1.5

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  block = &#x27;1 2 3 4 5 6 7&#x27;
[]

[Mesh]#Comment
  file = anisotropic_patch_test.e
[] # Mesh

[Functions]
  [./rampConstant1]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 1e-6
  [../]
  [./rampConstant2]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 2e-6
  [../]
  [./rampConstant3]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 3e-6
  [../]
  [./rampConstant4]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 4e-6
  [../]
  [./rampConstant6]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 6e-6
  [../]
[] # Functions

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[] # Variables

[AuxVariables]
  [./elastic_energy]
    order = CONSTANT
    family = MONOMIAL
  [../]
[] # AuxVariables

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx vonmises_stress hydrostatic_stress firstinv_stress secondinv_stress thirdinv_stress&#x27;
  [../]
[]

[AuxKernels]
  [./elastic_energy]
    type = ElasticEnergyAux
    variable = elastic_energy
  [../]
[] # AuxKernels

[BCs]
  [./node1_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./node1_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = rampConstant2
  [../]
  [./node1_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 1
    function = rampConstant3
  [../]

  [./node2_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = rampConstant1
  [../]
  [./node2_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = rampConstant2
  [../]
  [./node2_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 2
    function = rampConstant6
  [../]

  [./node3_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 3
    function = rampConstant1
  [../]
  [./node3_y]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
  [./node3_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 3
    function = rampConstant3
  [../]

  [./node4_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./node4_y]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
  [./node4_z]
    type = DirichletBC
    variable = disp_z
    boundary = 4
    value = 0.0
  [../]

  [./node5_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 5
    function = rampConstant1
  [../]
  [./node5_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = rampConstant4
  [../]
  [./node5_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 5
    function = rampConstant3
  [../]

  [./node6_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 6
    function = rampConstant2
  [../]
  [./node6_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 6
    function = rampConstant4
  [../]
  [./node6_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 6
    function = rampConstant6
  [../]

  [./node7_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 7
    function = rampConstant2
  [../]
  [./node7_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 7
    function = rampConstant2
  [../]
  [./node7_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 7
    function = rampConstant3
  [../]

  [./node8_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 8
    function = rampConstant1
  [../]
  [./node8_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 8
    function = rampConstant2
  [../]
  [./node8_z]
    type = DirichletBC
    variable = disp_z
    boundary = 8
    value = 0.0
  [../]
[] # BCs

[Materials]
  [./elastic_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1e6 0.0 0.0 1e6 0.0 1e6 0.5e6 0.5e6 0.5e6&#x27;
    fill_method = symmetric9
    euler_angle_1 = 18.0
    euler_angle_2 = 43.0
    euler_angle_3 = 177.0
#    Isotropic material constants
#    The three euler angles do not matter
#    youngs_modulus = 1e6
#    poissons_ratio = 0.0
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[] # Materials

[Executioner]
  type = Transient

  nl_abs_tol = 1e-10
  l_max_its = 20

  start_time = 0.0
  dt = 1.0
  num_steps = 2
  end_time = 2.0
[] # Executioner

[Outputs]
  file_base = anisotropic_patch_test_out
  [./exodus]
    type = Exodus
    elemental_as_nodal = true
  [../]
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="59554c2d-da1c-478f-84a9-589d18e7fc91"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/domain_integral_thermal/c_integral_2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
[]

[AuxVariables]
  [./SERD]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 0.1 100.0&#x27;
    y = &#x27;0. 1 1&#x27;
    scale_factor = -68.95 #MPa
  [../]
[]


[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SERD]
    type = MaterialRealAux
    variable = SERD
    property = strain_energy_rate_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 400
    value = 0.0
  [../]

  [./no_x1]
    type = DirichletBC
    variable = disp_x
    boundary = 900
    value = 0.0
  [../]
  [./Pressure]
    [./crack_pressure]
      boundary = 700
      function = rampConstantUp
    [../]
  [../]
[]

[Materials]
    [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206800
    poissons_ratio = 0.0
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
  [./powerlawcrp]
    type = PowerLawCreepStressUpdate
    coefficient = 3.125e-21 # 7.04e-17 #
    n_exponent = 2.0
    m_exponent = 0.0
    activation_energy = 0.0
  [../]
[]


[DomainIntegral]
  integrals = CIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;60.0 80.0 100.0 120.0&#x27;
  radius_outer = &#x27;80.0 100.0 120.0 140.0&#x27;
  incremental = true
  inelastic_models = &#x27;powerlawcrp&#x27;
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm         31   preonly   lu      1&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 40

  nl_rel_step_tol= 1e-10
  nl_rel_tol = 1e-10

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  exodus = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    pc_side = left
    ksp_norm = preconditioned
    full = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="080bbdef-9a16-4976-9ff6-cd535f52b389"><div class="modal-content"><h4>modules/contact/test/tests/glued/glued_contact_mechanical_constraint_test.i</h4><pre class="moose-pre"><code class="language-text"># This is a mechanical constraint (contact formulation) version of glued_contact_mechanical_constraint.i
[Mesh]
  file = glued_contact_test.e
[]

[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./up]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.5001&#x27;
  [../]

  [./lateral]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3&#x27;
    y = &#x27;0 0 1 0&#x27;
    scale_factor = 0.5
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
[]

[Contact]
  [./dummy_name]
    primary = 2
    secondary = 3
    penalty = 1e6
    model = glued
    formulation = kinematic
  [../]
[]

[BCs]

  [./bottom_lateral]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 1
    function = lateral
  [../]

  [./bottom_up]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = up
  [../]

  [./bottom_out]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]

  [./top]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
[]

[Materials]
  [./stiffStuff1]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stiffStuff1_strain]
    type= ComputeFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./stiffStuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]

  [./stiffStuff2]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stiffStuff2_strain]
    type= ComputeFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./stiffStuff2_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  #petsc_options_iname = &#x27;-pc_type -pc_hypre_type -snes_type -snes_ls -snes_linesearch_type -ksp_gmres_restart&#x27;
  #petsc_options_value = &#x27;hypre    boomeramg      ls         basic    basic                    101&#x27;
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;ilu      101&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-8
  l_tol = 1e-4

  l_max_its = 100
  nl_max_its = 10
  dt = 0.1
  num_steps = 30

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]
[]

[Postprocessors]
  active = &#x27;&#x27;
  [./resid]
    type = Residual
  [../]
  [./iters]
    type = NumNonlinearIterations
  [../]
[]

[Outputs]
  file_base = mechanical_constraint_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b36fee62-2eb1-46f0-9c24-8f9eebcf0e3d"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_hht_ti.i</h4><pre class="moose-pre"><code class="language-text"># Wave propogation in 1D using HHT time integration in the presence of Rayleigh damping
#
# The test is for an 1D bar element of length 4m  fixed on one end
# with a sinusoidal pulse dirichlet boundary condition applied to the other end.
# alpha, beta and gamma are HHT  time integration parameters
# eta and zeta are mass dependent and stiffness dependent Rayleigh damping
# coefficients, respectively.
# The equation of motion in terms of matrices is:
#
# M*accel + (eta*M+zeta*K)*((1+alpha)*vel-alpha*vel_old)
# +(1+alpha)*K*disp-alpha*K*disp_old = 0
#
# Here M is the mass matrix, K is the stiffness matrix
#
# The displacement at the first, second, third and fourth node at t = 0.1 are
# -7.787499960311491942e-02, 1.955566679096475483e-02 and -4.634888180231294501e-03, respectively.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 4
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 4.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    alpha = -0.3
    zeta = 0.1
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    eta=0.1
    alpha = -0.3
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    eta=0.1
    alpha = -0.3
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    eta = 0.1
    alpha = -0.3
  [../]

[]

[AuxKernels]
  [./accel_x] # These auxkernels are only to check output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
   type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value=0.0
  [../]
  [./right_z]
    type = DirichletBC
    variable = disp_z
    boundary = right
    value=0.0
  [../]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value=0.0
  [../]
  [./left_z]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value=0.0
  [../]
  [./front_x]
    type = DirichletBC
    variable = disp_x
    boundary = front
    value=0.0
  [../]
  [./front_z]
    type = DirichletBC
    variable = disp_z
    boundary = front
    value=0.0
  [../]
  [./back_x]
    type = DirichletBC
    variable = disp_x
    boundary = back
    value=0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = bottom
    function = displacement_bc
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;1 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 6.0
  l_tol = 1e-12
  nl_rel_tol = 1e-12
  dt = 0.1

  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.422
    gamma = 0.8
  [../]
[]


[Functions]
  [./displacement_bc]
    type = PiecewiseLinear
    data_file = &#x27;sine_wave.csv&#x27;
    format = columns
  [../]

[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_y
  [../]
  [./disp_2]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./disp_3]
    type = NodalVariableValue
    nodeid = 10
    variable = disp_y
  [../]
  [./disp_4]
    type = NodalVariableValue
    nodeid = 14
    variable = disp_y
  [../]
[]

[Outputs]
  file_base = &#x27;wave_rayleigh_hht_out&#x27;
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2226f0b2-7db4-4401-8f3e-01b85159ef92"><div class="modal-content"><h4>modules/combined/test/tests/adaptive_timestepping/adapt_tstep_function_change_restart2.i</h4><pre class="moose-pre"><code class="language-text"># This is a test designed to evaluate the cabability of the
# IterationAdaptiveDT TimeStepper to adjust time step size according to
# a function.  For example, if the power input function for a BISON
# simulation rapidly increases or decreases, the IterationAdaptiveDT
# TimeStepper should take time steps small enough to capture the
# oscillation.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  order = FIRST
  family = LAGRANGE
  block = 1
[]

[Mesh]
  file = 1hex8_10mm_cube.e
[]

[Functions]
  [./Fiss_Function]
    type = PiecewiseLinear
    x = &#x27;0 1e6  2e6  2.001e6 2.002e6&#x27;
    y = &#x27;0 3e8  3e8  12e8    0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]

  [./disp_y]
  [../]

  [./disp_z]
  [../]

  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    volumetric_locking_correction = true
    incremental = true
    eigenstrain_names = thermal_expansion
    decomposition_method = EigenSolution
    add_variables  = true
    generate_output = &#x27;vonmises_stress&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]

  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]

  [./heat_source]
     type = HeatSource
     variable = temp
     value = 1.0
     function = Fiss_Function
  [../]
[]

[BCs]
 [./bottom_temp]
   type = DirichletBC
   variable = temp
   boundary = 1
   value = 300
 [../]
 [./top_bottom_disp_x]
   type = DirichletBC
   variable = disp_x
   boundary = &#x27;1&#x27;
   value = 0
 [../]
 [./top_bottom_disp_y]
   type = DirichletBC
   variable = disp_y
   boundary = &#x27;1&#x27;
   value = 0
 [../]
 [./top_bottom_disp_z]
   type = DirichletBC
   variable = disp_z
   boundary = &#x27;1&#x27;
   value = 0
 [../]
[]

[Materials]
 [./thermal]
    type = HeatConductionMaterial
    temp = temp
    specific_heat = 1.0
    thermal_conductivity = 1.0
  [../]

  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 300e6
    poissons_ratio = .3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]

  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 5e-6
    stress_free_temperature = 300.0
    temperature = temp
    eigenstrain_name = thermal_expansion
  [../]

  [./density]
    type = Density
    density = 10963.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  verbose = true
  nl_abs_tol = 1e-10
  num_steps = 50000
  end_time = 2.002e6
  [./TimeStepper]
    type = IterationAdaptiveDT
    timestep_limiting_function = Fiss_Function
    max_function_change = 3e7
    dt = 1e6
  [../]
[]

[Postprocessors]
  [./Temperature_of_Block]
    type = ElementAverageValue
    variable = temp
    execute_on = &#x27;timestep_end&#x27;
  [../]

  [./vonMises]
    type = ElementAverageValue
    variable = vonmises_stress
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 10
  [../]
[]

[Problem]
  restart_file_base = adapt_tstep_function_change_restart1_checkpoint_cp/0065
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="56ebda8c-274b-4127-906e-d8778119f879"><div class="modal-content"><h4>modules/navier_stokes/test/tests/ins/jeffery_hamel/wedge_natural.i</h4><pre class="moose-pre"><code class="language-text"># This input file solves the Jeffery-Hamel problem with the exact
# solution&#x27;s outlet BC replaced by a natural BC.  This problem does
# not converge to the analytical solution, although the flow at the
# outlet still &quot;looks&quot; reasonable.
[GlobalParams]
  gravity = &#x27;0 0 0&#x27;

  # Params used by the WedgeFunction for computing the exact solution.
  # The value of K is only required for comparing the pressure to the
  # exact solution, and is computed by the associated jeffery_hamel.py
  # script.
  alpha_degrees = 15
  Re = 30
  K = -9.78221333616
  f = f_theta
[]

[Mesh]
  file = wedge_8x12.e
[]

[Variables]
  [./vel_x]
    order = SECOND
    family = LAGRANGE
  [../]
  [./vel_y]
    order = SECOND
    family = LAGRANGE
  [../]
  [./p]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./mass]
    type = INSMass
    variable = p
    u = vel_x
    v = vel_y
    p = p
  [../]
  [./x_momentum_time]
    type = INSMomentumTimeDerivative
    variable = vel_x
  [../]
  [./x_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_x
    u = vel_x
    v = vel_y
    p = p
    component = 0
  [../]
  [./y_momentum_time]
    type = INSMomentumTimeDerivative
    variable = vel_y
  [../]
  [./y_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_y
    u = vel_x
    v = vel_y
    p = p
    component = 1
  [../]
[]

[BCs]
  [./vel_x_no_slip]
    type = DirichletBC
    variable = vel_x
    boundary = &#x27;top_wall bottom_wall&#x27;
    value = 0.0
  [../]
  [./vel_y_no_slip]
    type = DirichletBC
    variable = vel_y
    boundary = &#x27;top_wall bottom_wall&#x27;
    value = 0.0
  [../]
  [./vel_x_inlet]
    type = FunctionDirichletBC
    variable = vel_x
    boundary = &#x27;inlet&#x27;
    function = &#x27;vel_x_exact&#x27;
  [../]
  [./vel_y_inlet]
    type = FunctionDirichletBC
    variable = vel_y
    boundary = &#x27;inlet&#x27;
    function = &#x27;vel_y_exact&#x27;
  [../]
[]

[Materials]
  [./const]
    type = GenericConstantMaterial
    block = 1
    prop_names = &#x27;rho mu&#x27;
    prop_values = &#x27;1  1&#x27;
  [../]
[]

[Preconditioning]
  [./SMP_NEWTON]
    type = SMP
    full = true
    solve_type = NEWTON
  [../]
[]

[Executioner]
  type = Transient
  dt = 1.e-2
  dtmin = 1.e-2
  num_steps = 5
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type -sub_pc_factor_levels&#x27;
  petsc_options_value = &#x27;300                bjacobi  ilu          4&#x27;
  line_search = none
  nl_rel_tol = 1e-13
  nl_abs_tol = 1e-11
  nl_max_its = 10
  l_tol = 1e-6
  l_max_its = 300
[]

[Outputs]
  exodus = true
[]

[Functions]
  [./f_theta]
    # Non-dimensional solution values f(eta), 0 &lt;= eta &lt;= 1 for
    # alpha=15deg, Re=30.  Note: this introduces an input file
    # ordering dependency: this Function must appear *before* the two
    # function below which use it since apparently proper dependency
    # resolution is not done in this scenario.
    type = PiecewiseLinear
    data_file = &#x27;f.csv&#x27;
    format = &#x27;columns&#x27;
  [../]
  [./vel_x_exact]
    type = WedgeFunction
    var_num = 0
    mu = 1
    rho = 1
  [../]
  [./vel_y_exact]
    type = WedgeFunction
    var_num = 1
    mu = 1
    rho = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dfc51758-d4ee-472e-a194-2369816d8f6a"><div class="modal-content"><h4>modules/combined/test/tests/ad_power_law_creep/power_law_creep_smallstrain.i</h4><pre class="moose-pre"><code class="language-text"># 1x1x1 unit cube with uniform pressure on top face for the case of small strain.
#  This test does not have a solid mechanics analog because there is not an equvialent
#  small strain with rotations strain calculator material in solid mechanics

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1000.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy&#x27;
    use_automatic_differentiation = true
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = ADHeatConduction
    variable = temp
  [../]
  [./heat_ie]
    type = ADHeatConductionTimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./u_top_pull]
    type = ADPressure
    variable = disp_y
    component = 1
    boundary = top
    constant = -10.0e6
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = ADDirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp_fix]
    type = DirichletBC
    variable = temp
    boundary = &#x27;bottom top&#x27;
    value = 1000.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 2e11
    poissons_ratio = 0.3
    constant_on = SUBDOMAIN
  [../]
  [./radial_return_stress]
    type = ADComputeMultipleInelasticStress
    inelastic_models = &#x27;power_law_creep&#x27;
  [../]
  [./power_law_creep]
    type = ADPowerLawCreepStressUpdate
    coefficient = 1.0e-15
    n_exponent = 4
    activation_energy = 3.0e5
    temperature = temp
  [../]

  [./thermal]
    type = ADHeatConductionMaterial
    specific_heat = 1.0
    thermal_conductivity = 100.
  [../]
  [./density]
    type = ADDensity
    density = 1.0
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.0
  end_time = 1.0
  num_steps = 10
  dt = 0.1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e99e86b9-97b6-4a62-95c3-66ddd6104978"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh16.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = true
# supg = true
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 0.1
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 0.01
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 2
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    output = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    output = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    output = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    output = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh16
  execute_on = &#x27;timestep_end final&#x27;
  interval = 100000
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5350903c-0f23-4ad8-b35d-7295869e4fba"><div class="modal-content"><h4>modules/xfem/test/tests/solid_mechanics_basic/crack_propagation_2d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
  use_crack_growth_increment = true
  crack_growth_increment = 0.2
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 11
  ny = 11
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;1.0  0.5  0.7  0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 0.0
  [../]
  [./xfem_marker_uo]
    type = XFEMRankTwoTensorMarkerUserObject
    execute_on = timestep_end
    tensor = stress
    scalar_type = MaxPrincipal
    threshold = 5e+1
    average = true
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    planar_formulation = plane_strain
    add_variables = true
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0  50   100&#x27;
    y=&#x27;0  0.02 0.1&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = bottom
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
  [./topx]
    type = DirichletBC
    boundary = top
    variable = disp_x
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    boundary = top
    variable = disp_y
    function = pull
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 0
  [../]

  [./_elastic_strain]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-9

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 2.0
  num_steps = 5000

  max_xfem_update = 1
[]

[Outputs]
  file_base = crack_propagation_2d_out
  exodus = true
  execute_on = timestep_end
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6717f7b7-2ede-4152-b184-b270148ebfd2"><div class="modal-content"><h4>modules/richards/test/tests/recharge_discharge/rd03.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = gold/rd02.e
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;2E4 1E6&#x27;
    x = &#x27;0 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1E3
    bulk_mod = 2E7
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.336
    al = 1.43E-4
  [../]
  [./RelPermPower]
    type = RichardsRelPermVG1
    scut = 0.99
    simm = 0.0
    m = 0.336
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E+0
  [../]
[]



[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_from_file_timestep = 2
    initial_from_file_var = pressure
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]


[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]




[BCs]
  active = &#x27;fix_bot&#x27;
  [./fix_bot]
    type = DirichletBC
    variable = pressure
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.33
    mat_permeability = &#x27;0.295E-12 0 0  0 0.295E-12 0  0 0 0.295E-12&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    SUPG_UO = SUPGstandard
    sat_UO = Saturation
    seff_UO = SeffVG
    viscosity = 1.01E-3
    gravity = &#x27;-10 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;

    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-13 1E-15 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 8.2944E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = rd03
  interval = 100000
  execute_on = &#x27;initial timestep_end final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="297aff57-9810-43c1-8885-df82a65ac48b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/material_limit_time_step/damage/scalar_material_damage_timestep_limit.i</h4><pre class="moose-pre"><code class="language-text"># This is a basic test of the system for continuum damage mechanics
# materials. It uses ScalarMaterialDamage for the damage model,
# which simply gets its damage index from another material. In this
# case, we prescribe the evolution of the damage index using a
# function. A single element has a fixed prescribed displacement
# on one side that puts the element in tension, and then the
# damage index evolves from 0 to 1 over time, and this verifies
# that the stress correspondingly drops to 0.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX8
[]

[AuxVariables]
  [damage_index]
    order = CONSTANT
    family = MONOMIAL
  []
[]

[Modules/TensorMechanics/Master]
  [all]
    strain = SMALL
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_xx strain_xx&#x27;
  []
[]

[AuxKernels]
  [damage_index]
    type = MaterialRealAux
    variable = damage_index
    property = damage_index_prop
    execute_on = timestep_end
  []
[]

[BCs]
  [symmy]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0
  []
  [symmx]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0
  []
  [symmz]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0
  []
  [axial_load]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0.01
  []
[]

[Functions]
  [damage_evolution]
    type = PiecewiseLinear
    xy_data = &#x27;0.0   0.0
               0.1   0.0
               2.1   2.0&#x27;
  []
[]

[Materials]
  [damage_index]
    type = GenericFunctionMaterial
    prop_names = damage_index_prop
    prop_values = damage_evolution
  []
  [damage]
    type = ScalarMaterialDamage
    damage_index = damage_index_prop
  []
  [stress]
    type = ComputeDamageStress
    damage_model = damage
  []
  [elasticity]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.2
    youngs_modulus = 10e9
  []
[]

[Postprocessors]
  [stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  []
  [strain_xx]
    type = ElementAverageValue
    variable = strain_xx
  []
  [damage_index]
    type = ElementAverageValue
    variable = damage_index
  []
  [time_step_limit]
    type = MaterialTimeStepPostprocessor
  []
[]

[Executioner]
  type = Transient

  l_max_its  = 50
  l_tol      = 1e-8
  nl_max_its = 20
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-8

  dt = 0.1
  dtmin = 0.001
  end_time = 1.1
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.1
    growth_factor = 2.0
    cutback_factor = 0.5
    timestep_limiting_postprocessor = time_step_limit
  []
[]

[Outputs]
  csv=true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="790a2c23-4760-4e2d-a4c3-b7e44a30205c"><div class="modal-content"><h4>modules/contact/test/tests/nodal_area/nodal_area_Hex27.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = nodal_area_Hex27.e
[]

[GlobalParams]
  order = SECOND
  displacements = &#x27;displ_x displ_y displ_z&#x27;
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0     1&#x27;
    y = &#x27;0  20e-6&#x27;
  [../]
[]

[Variables]
  [./displ_x]
  [../]
  [./displ_y]
  [../]
  [./displ_z]
  [../]
[]

[AuxVariables]
  [./react_x]
  [../]
  [./react_y]
  [../]
  [./react_z]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    incremental = true
    save_in = &#x27;react_x react_y react_z&#x27;
    add_variables = true
    strain = FINITE
    generate_output = &#x27;stress_xx&#x27;
  [../]
[]

[BCs]
  [./move_right]
    type = FunctionDirichletBC
    boundary = &#x27;1&#x27;
    variable = displ_x
    function = disp
  [../]

  [./fixed_x]
    type = DirichletBC
    boundary = &#x27;3 4&#x27;
    variable = displ_x
    value = 0
  [../]

  [./fixed_y]
    type = DirichletBC
    boundary = 10
    variable = displ_y
    value = 0
  [../]

  [./fixed_z]
    type = DirichletBC
    boundary = 11
    variable = displ_z
    value = 0
  [../]
[]

[Contact]
  [./dummy_name]
    primary = 3
    secondary = 2
    penalty = 1e8
    tangential_tolerance = 1e-4
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  #petsc_options_iname = &#x27;-snes_type -snes_ls -snes_linesearch_type -ksp_gmres_restart -pc_type&#x27;
  #petsc_options_value = &#x27;ls         basic    basic                    201                lu&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-7
  nl_rel_tol = 1e-6

  l_tol = 1e-4
  l_max_its = 40

  start_time = 0.0
  dt = 1.0
  end_time = 1.0
  num_steps = 100

  [./Quadrature]
    order = THIRD
  [../]
[]

[Postprocessors]
  [./react_x]
    type = NodalSum
    variable = react_x
    boundary = 1
  [../]
  [./total_area]
    type = NodalSum
    variable = nodal_area_dummy_name
    boundary = 2
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7dac3a9e-1371-4443-a8c4-b9954ad7062c"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test4qns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test4qns_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="da7866b4-ce39-4520-bf3e-52d1c0851dd8"><div class="modal-content"><h4>modules/contact/test/tests/hertz_spherical/hertz_contact_hex20.i</h4><pre class="moose-pre"><code class="language-text"># Hertz Contact: Sphere on sphere

# Spheres have the same radius, Young&#x27;s modulus, and Poisson&#x27;s ratio.

# Define E:
# 1/E = (1-nu1^2)/E1 + (1-nu2^2)/E2
#
# Effective radius R:
# 1/R = 1/R1 + 1/R2
#
# F is the applied compressive load.
#
# Area of contact a::
# a^3 = 3FR/4E
#
# Depth of indentation d:
# d = a^2/R
#
#
# Let R1 = R2 = 2.  Then R = 1.
#
# Let nu1 = nu2 = 0.25, E1 = E2 = 1.40625e7.  Then E = 7.5e6.
#
# Let F = 10000.  Then a = 0.1, d = 0.01.
#

[GlobalParams]
  volumetric_locking_correction = false
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  order = SECOND
[]

[Mesh]#Comment
  file = hertz_contact_hex20.e
[] # Mesh

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 795.77471545947674 # 10000/pi/2^2
  [../]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.  1.    2.&#x27;
    y = &#x27;0. -0.01 -0.01&#x27;
  [../]
[] # Functions

[Variables]

  [./disp_x]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_y]
    order = SECOND
    family = LAGRANGE
  [../]

  [./disp_z]
    order = SECOND
    family = LAGRANGE
  [../]

[] # Variables

[AuxVariables]

  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./hydrostatic]
    order = CONSTANT
    family = MONOMIAL
  [../]

  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./saved_z]
  [../]

[] # AuxVariables

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = SMALL
    extra_vector_tags = &#x27;ref&#x27;
    save_in = &#x27;saved_x saved_y saved_z&#x27;
  [../]
[]
[AuxKernels]

  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
#  [./vonmises]
#    type = RankTwoScalarAux
#    rank_two_tensor = stress
#    variable = vonmises
#    scalar_type = VonMisesStress
#  [../]

[] # AuxKernels

[BCs]

  [./base_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1000
    value = 0.0
  [../]
  [./base_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1000
    value = 0.0
  [../]
  [./base_z]
    type = DirichletBC
    variable = disp_z
    boundary = 1000
    value = 0.0
  [../]

  [./symm_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./symm_z]
    type = DirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
  [./disp_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

[] # BCs

[Contact]
  [./dummy_name]
    primary = 1000
    secondary = 100

    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+10
  [../]
[]

#[Dampers]
#  [./contact_slip]
#    type = ContactSlipDamper
#    primary = 1000
#    secondary = 100
#  [../]
#[]

[Materials]
  [./tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1.40625e7
    poissons_ratio = 0.25
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = &#x27;1&#x27;
  [../]

  [./tensor_1000]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1000&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]
  [./stress_1000]
    type = ComputeLinearElasticStress
    block = &#x27;1000&#x27;
  [../]

[] # Materials

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  []
[]

[Executioner]

  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;


  nl_abs_tol = 1e-7

  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 2.0

  [./Quadrature]
    order = THIRD
  [../]

[] # Executioner

[Postprocessors]
  [./maxdisp]
    type = NodalVariableValue
    nodeid = 386 # 387-1 where 387 is the exodus node number of the top-center node
    variable = disp_y
  [../]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 2
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 2
  [../]

  [./bot_react_z]
    type = NodalSum
    variable = saved_z
    boundary = 2
  [../]

[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[] # Outputs
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8c661e97-1a14-456c-bd45-bbb1265ccf37"><div class="modal-content"><h4>test/tests/time_integrators/newmark-beta/newmark_beta_default_parameters.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of the TimeIntegrator system.
#
# Testing that the first and second time derivatives
# are calculated correctly using the Newmark-Beta method
#
# @Requirement F1.30
###########################################################

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 1
  ny = 1
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2    0.3  0.4    0.5  0.6&#x27;
    y = &#x27;0.0 0.0 0.0025 0.01 0.0175 0.02 0.02&#x27;
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;left&#x27;
    function = forcing_fn
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;right&#x27;
    function = forcing_fn
  [../]
[]

[Executioner]
  type = Transient

  # Time integrator scheme
  scheme = &quot;newmark-beta&quot;

  start_time = 0.0
  num_steps = 6
  dt = 0.1
[]

[Postprocessors]
  [./udot]
    type = ElementAverageTimeDerivative
    variable = u
  [../]
  [./udotdot]
    type = ElementAverageSecondTimeDerivative
    variable = u
  [../]
  [./u]
    type = ElementAverageValue
    variable = u
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aec4a637-a381-4ec7-bc70-fc02e5837a63"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh_lumped_07.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = false
# supg = true
# transient = true
# lumped = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
  viscosity = &#x27;1E-3 0.5E-3&#x27;
  gravity = &#x27;0 0 0&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-3
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-3
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = RandomIC
    min = 0.2
    max = 0.8
    variable = pwater
  [../]
  [./gas_ic]
    type = RandomIC
    min = 1.2
    max = 1.8
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((p0-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((p0-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-13 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh_lumped_07
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fdc6cd2f-f4c5-45e1-94fb-73f8b071482e"><div class="modal-content"><h4>modules/richards/test/tests/broadbridge_white/bw_lumped_02.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 200
  ny = 1
  xmin = -10
  xmax = 10
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermBW
  SUPG_UO = SUPGstandard
  sat_UO = Saturation
  seff_UO = SeffBW
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-1 5E-1 5E-1&#x27;
    x = &#x27;0 1 10&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 10
    bulk_mod = 2E9
  [../]
  [./SeffBW]
    type = RichardsSeff1BWsmall
    Sn = 0.0
    Ss = 1.0
    C = 1.5
    las = 2
  [../]
  [./RelPermBW]
    type = RichardsRelPermBW
    Sn = 0.0
    Ss = 1.0
    Kn = 0
    Ks = 1
    C = 1.5
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E2
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -9E2
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsLumpedMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]


[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffBW
    pressure_vars = pressure
  [../]
[]


[BCs]
  active = &#x27;recharge&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pressure
    boundary = &#x27;right&#x27;
    pressures = &#x27;-1E10 1E10&#x27;
    bare_fluxes = &#x27;-1.25 -1.25&#x27; # corresponds to Rstar being 0.5 because i have to multiply by density*porosity
    use_mobility = false
    use_relperm = false
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.25
    mat_permeability = &#x27;1 0 0  0 1 0  0 0 1&#x27;
    viscosity = 4
    gravity = &#x27;-0.1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 2

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = bw_lumped_02
  interval = 10000
  execute_on = &#x27;timestep_end final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5b929a99-d298-4263-a3ac-313567bb28fc"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/time_integration/hht_test.i</h4><pre class="moose-pre"><code class="language-text"># Test for  HHT time integration

# The test is for an 1D bar element of  unit length fixed on one end
# with a ramped pressure boundary condition applied to the other end.
# alpha, beta and gamma are HHT time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel + alpha*(K*disp - K*disp_old) + K*disp = P(t+alpha dt)*Area
#
# Here M is the mass matrix, K is the stiffness matrix, P is the applied pressure
#
# This equation is equivalent to:
#
# density*accel + alpha*(Div stress - Div stress_old) +Div Stress= P(t+alpha dt)
#
# The first term on the left is evaluated using the Inertial force kernel
# The next two terms on the left involving alpha are evaluated using the
# DynamicStressDivergenceTensors Kernel
# The residual due to Pressure is evaluated using Pressure boundary condition
#
# The system will come to steady state slowly after the pressure becomes constant.
# Alpha equal to zero will result in Newmark integration.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    alpha = 0.11
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.25
    gamma = 0.5
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.25
    gamma = 0.5
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    gamma = 0.5
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = bottom
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
      disp_z = disp_z
      factor = 1
      alpha = 0.11
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 2
  dt = 0.1
[]


[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 1.0 2.0 5.0&#x27;
    y = &#x27;0.0 0.1 0.2 1.0 1.0 1.0&#x27;
    scale_factor = 1e9
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalMaxValue
    variable = disp_y
    boundary = bottom
  [../]
  [./vel]
    type = NodalMaxValue
    variable = vel_y
    boundary = bottom
  [../]
  [./accel]
    type = NodalMaxValue
    variable = accel_y
    boundary = bottom
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./strain_yy]
    type = ElementAverageValue
    variable = strain_yy
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7b337c88-13b4-44c1-a89a-f065baf08b6b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_deprecated.i</h4><pre class="moose-pre"><code class="language-text">#
# Simple pull test for cracking.
# The stress increases for two steps and then drops to zero.

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3  4&#x27;
    y = &#x27;0 1 0 -1 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pull]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displ
  [../]
  [./left]
    type = ADDirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./bottom]
    type = ADDirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
  [./back]
    type = ADDirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 1.68e6
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.1
  dt = 0.025
[]

[Outputs]
  exodus = true
  file_base = cracking_out
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bd3b5d7b-2dcd-479f-a60c-8e4193caddaf"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test2tt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test2.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.1
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test2tt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e096a369-cd9e-46cb-937c-868f1aab73e8"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh_fu_04.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated
# production
# fullyupwind
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  sat_UO = Saturation
  seff_UO = Seff1VG
  SUPG_UO = SUPGstandard
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1 1E1 1E2 1E3&#x27;
    x = &#x27;0 1E-1 1 1E1 1E2 1E3&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E8
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = -1E6
    point_file = bh02.bh
    SumQuantityUO = borehole_total_outflow_mass
    variable = pressure
    unit_weight = &#x27;0 0 0&#x27;
    character = 1
    fully_upwind = true
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
  [../]

  [./fluid_mass0]
    type = RichardsMass
    variable = pressure
    execute_on = timestep_begin
  [../]

  [./fluid_mass1]
    type = RichardsMass
    variable = pressure
    execute_on = timestep_end
  [../]

  [./zmass_error]
    type = FunctionValuePostprocessor
    function = mass_bal_fcn
    execute_on = timestep_end
  [../]

  [./p0]
    type = PointValue
    variable = pressure
    point = &#x27;1 1 1&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 0
  [../]

  [./mass_bal_fcn]
    type = ParsedFunction
    value = abs((a-c+d)/2/(a+c))
    vars = &#x27;a c d&#x27;
    vals = &#x27;fluid_mass1 fluid_mass0 bh_report&#x27;
  [../]

[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 0
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-12 0 0  0 1E-12 0  0 0 1E-12&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 1E3
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  file_base = bh_fu_04
  exodus = false
  execute_on = timestep_end
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="499f7b40-0d99-4ec8-8a3c-868a406b4862"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/smeared_cracking/cracking_rz.i</h4><pre class="moose-pre"><code class="language-text">#

[Mesh]
  file = cracking_rz_test.e
[]

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3  4&#x27;
    y = &#x27;0 1 0 -1 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
  [../]
[]

[BCs]
  [./pull]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = displ
  [../]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 4.0e7
    poissons_ratio = 0.0
  [../]
  [./elastic_stress]
    type = ComputeSmearedCrackingStress
    cracking_stress = 1.68e6
    softening_models = abrupt_softening
  [../]
  [./abrupt_softening]
    type = AbruptSoftening
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK


  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101               &#x27;


  line_search = &#x27;none&#x27;


  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-2
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.1
  dt = 0.025
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b3ee2585-0198-4581-b4d3-eb7d27ae7421"><div class="modal-content"><h4>modules/combined/test/tests/thermo_mech/ad-youngs_modulus_function_temp.i</h4><pre class="moose-pre"><code class="language-text"># ---------------------------------------------------------------------------
# This test is designed to verify the variable elasticity tensor functionality in the
# ADComputeFiniteStrainElasticStress class with the elasticity_tensor_has_changed flag
# by varying the young&#x27;s modulus with temperature. A constant strain is applied
# to the mesh in this case, and the stress varies with the changing elastic constants.
#
# Geometry: A single element cube in symmetry boundary conditions and pulled
#           at a constant displacement to create a constant strain in the x-direction.
#
# Temperature:  The temperature varies from 400K to 700K in this simulation by
#           100K each time step. The temperature is held constant in the last
#           timestep to ensure that the elasticity tensor components are constant
#           under constant temperature.
#
# Results: Because Poisson&#x27;s ratio is set to zero, only the stress along the x
#          axis is non-zero.  The stress changes with temperature.
#
#    Temperature(K)   strain_{xx}(m/m)     Young&#x27;s Modulus(Pa)   stress_{xx}(Pa)
#          400              0.001             10.0e6               1.0e4
#          500              0.001             10.0e6               1.0e4
#          600              0.001              9.94e6              9.94e3
#          700              0.001              9.93e6              9.93e3
#
#    The tensor mechanics results align exactly with the analytical results above
#    when this test is run with ComputeIncrementalSmallStrain.  When the test is
#    run with ComputeFiniteStrain, a 0.05% discrepancy between the analytical
#    strains and the simulation strain results is observed, and this discrepancy
#    is carried over into the calculation of the elastic stress.
#-------------------------------------------------------------------------

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 400
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./temperature_function]
    type = PiecewiseLinear
    x = &#x27;1       4&#x27;
    y = &#x27;400   700&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = ADDiffusion
    variable = temp
  [../]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
[]


[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]

 [./elastic_strain_xx]
    type = ADRankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./u_left_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_back_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./u_pull_right]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0.001
  [../]

  [./temp_bc_1]
    type = ADFunctionDirichletBC
    variable = temp
    preset = false
    boundary = &#x27;1 2 3 4&#x27;
    function = temperature_function
  [../]
[]

[Materials]
  [./youngs_modulus]
    type = ADPiecewiseLinearInterpolationMaterial
    xy_data = &#x27;0          10e+6
               599.9999   10e+6
               600        9.94e+6
               99900      10e3&#x27;
    property = youngs_modulus
    variable = temp
  [../]

  [./elasticity_tensor]
    type = ADComputeVariableIsotropicElasticityTensor
    youngs_modulus = youngs_modulus
    poissons_ratio = 0.0
  [../]
  [./strain]
    type = ADComputeIncrementalSmallStrain
  [../]
  [./stress]
    type = ADComputeFiniteStrainElasticStress
  [../]
[]

[Preconditioning]
  [./full]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  end_time = 5
[]

[Postprocessors]
  [./elastic_strain_xx]
    type = ElementAverageValue
    variable = elastic_strain_xx
  [../]
  [./elastic_stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./temp]
    type = AverageNodalVariableValue
    variable = temp
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fddaab35-3097-4c07-9f87-58eaf388fc10"><div class="modal-content"><h4>test/tests/time_integrators/central-difference/central_difference.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of the TimeIntegrator system.
#
# Testing that the first and second time derivatives
# are calculated correctly using the Newmark-Beta method
#
# @Requirement F1.30
###########################################################

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 1
  ny = 1
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2    0.3  0.4    0.5  0.6&#x27;
    y = &#x27;0.0 0.0 0.0025 0.01 0.0175 0.02 0.02&#x27;
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    function = forcing_fn
    preset = false
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = forcing_fn
    preset = false
  [../]
[]

[Executioner]
  type = Transient

  [./TimeIntegrator]
    type = CentralDifference
  []

  start_time = 0.0
  num_steps = 6
  dt = 0.1
[]

[Postprocessors]
  [./udot]
    type = ElementAverageTimeDerivative
    variable = u
  [../]
  [./udotdot]
    type = ElementAverageSecondTimeDerivative
    variable = u
  [../]
  [./u]
    type = ElementAverageValue
    variable = u
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a1ff818c-f176-4fb8-8d8b-d5bbdf0cfa05"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_plastic/power_law_creep.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  second_order = true
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = false
[]

[AuxVariables]
  [./hydrostatic_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./hydrostatic_stress]
    type = ADRankTwoScalarAux
    variable = hydrostatic_stress
    rank_two_tensor = stress
    scalar_type = Hydrostatic
  [../]
[]

[Variables]
  [./disp_x]
    order = SECOND
    scaling = 1e-10
  [../]
  [./disp_y]
    order = SECOND
    scaling = 1e-10
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 10&#x27;
    y = &#x27;0 1e-3&#x27;
  [../]
[]

[Kernels]
  [./stress_x]
    type = ADStressDivergenceTensors
    component = 0
    variable = disp_x
  [../]
  [./stress_y]
    type = ADStressDivergenceTensors
    component = 1
    variable = disp_y
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
  [../]
  [./strain]
    type = ADComputeIncrementalSmallStrain
  [../]
  [./elastic_strain]
    type = ADComputeMultipleInelasticStress
  [../]

  [./creep_ten]
    type = ADPowerLawCreepStressUpdate
    coefficient = 10e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_ten
  [../]
  [./creep_ten2]
    type = ADPowerLawCreepStressUpdate
    coefficient = 10e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_ten2
  [../]
  [./creep_one]
    type = ADPowerLawCreepStressUpdate
    coefficient = 1e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_one
  [../]
  [./creep_nine]
    type = ADPowerLawCreepStressUpdate
    coefficient = 9e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_nine
  [../]
  [./creep_zero]
    type = ADPowerLawCreepStressUpdate
    coefficient = 0e-24
    n_exponent = 4
    activation_energy = 0
    base_name = creep_zero
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = -pc_hypre_type
  petsc_options_value = boomeramg

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-5

  num_steps = 5
  dt = 1e-1
[]

[Postprocessors]
  [./max_disp_x]
    type = ElementExtremeValue
    variable = disp_x
  [../]
  [./max_disp_y]
    type = ElementExtremeValue
    variable = disp_y
  [../]
  [./max_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="db72e7a0-1727-4656-9310-ec0fc813e574"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh_fu_06.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = true
# supg = false
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGnone
  [../]
  [./SUPGgas]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 2
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFullyUpwindFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-13 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh_fu_06
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="06ac3d78-036e-4682-967a-9d3888e761a5"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4nns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_method = nodal_normal_based
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4nns_out
  exodus = true
[]

[NodalNormals]
  boundary = 11
  corner_boundary = 20
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3f2c160d-7244-4eb3-b24a-33ea31c29871"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/static_vm/ansys_vm2.i</h4><pre class="moose-pre"><code class="language-text"># This is a reproduction of test number 2 of ANSYS apdl verification manual.

# This test checks for the deformation at the center of a beam with simply
# supported boundary conditions and a uniform load w = 10,000 lb/ft.

#    |||||||||      def.      ||||||||
#    *---*---*---*---*---*---*---*---*
#            /\              /\
#           ///              oo
#        a           l            a
#     &lt;-----&gt; &lt;--------------&gt; &lt;-----&gt;
#

# l = 240 in, a = 120 in, A = 50.65 in^2, Iz = 7892 in^2
# E = 30e6 psi
# Solution deflection: 0.182 in. (dispz_5: -1.824633e-01)

[Mesh]
  [generated_mesh]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 8
    xmin = 0.0
    xmax = 480.0
  []
  [cnode]
    type = ExtraNodesetGenerator
    coord = &#x27;0.0&#x27;
    new_boundary = &#x27;one&#x27;
    input = generated_mesh
  []
  [cnode1]
    type = ExtraNodesetGenerator
    coord = &#x27;60.0&#x27;
    new_boundary = &#x27;two&#x27;
    input = cnode
  []
  [cnode2]
    type = ExtraNodesetGenerator
    coord = &#x27;420.0&#x27;
    new_boundary = &#x27;eight&#x27;
    input = cnode1
  []
  [cnode3]
    type = ExtraNodesetGenerator
    coord = &#x27;480.0&#x27;
    new_boundary = &#x27;nine&#x27;
    input = cnode2
  []

  [cnode4]
    type = ExtraNodesetGenerator
    coord = &#x27;120.0&#x27;
    new_boundary = &#x27;BC1&#x27;
    input = cnode3
  []

  [cnode5]
    type = ExtraNodesetGenerator
    coord = &#x27;360.0&#x27;
    new_boundary = &#x27;BC2&#x27;
    input = cnode4
  []
[]

[Modules/TensorMechanics/LineElementMaster]
  [./all]
    add_variables = true
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    # Geometry parameters
    area = 50.65
    Ay = 0.0
    Az = 0.0
    Iy = 7892.0
    Iz = 7892.0
    y_orientation = &#x27;0 1.0 0.0&#x27;
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 30.0e6
    # poissons_ratio = -0.9998699638
      poissons_ratio = 0.33
    # poissons_ratio = 0.3
    shear_coefficient = 0.85
    block = 0
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;BC1&#x27;
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;BC1&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;BC1&#x27;
    value = 0.0
  [../]

  [./fixy2]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;BC2&#x27;
    value = 0.0
  [../]
  [./fixz2]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;BC2&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_50e3]
    type = PiecewiseLinear
    x = &#x27;0.0 10.0&#x27;
    y = &#x27;0.0 50000.0&#x27;
  [../]
  [./force_25e3]
    type = PiecewiseLinear
    x = &#x27;0.0 10.0&#x27;
    y = &#x27;0.0 25000.0&#x27;
  [../]
[]

[NodalKernels]
  [./force_z2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;two&#x27;
    function = force_50e3
  [../]
  [./force_z8]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;eight&#x27;
    function = force_50e3
  [../]

  [./force_z1]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;one&#x27;
    function = force_25e3
  [../]
  [./force_z9]
    type =  UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;nine&#x27;
    function = force_25e3
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]
[Executioner]
  type = Transient
  solve_type = JFNK
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-06
  nl_abs_tol = 1e-06

  dt = 1.0
  dtmin = 0.001
  end_time = 10
[]

[Postprocessors]
  [./disp_z1]
    type = PointValue
    point = &#x27;0.0 0.0 0.0&#x27;
    variable = disp_z
  [../]
  [./disp_x1]
    type = PointValue
    point = &#x27;0.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_z2]
    type = PointValue
    point = &#x27;60.0 0.0 0.0&#x27;
    variable = disp_z
  [../]
  [./disp_zBC1]
    type = PointValue
    point = &#x27;120.0 0.0 0.0&#x27;
    variable = disp_z
  [../]
  [./disp_z5]
    type = PointValue
    point = &#x27;240.0 0.0 0.0&#x27;
    variable = disp_z
  [../]
  [./disp_zBC2]
    type = PointValue
    point = &#x27;360.0 0.0 0.0&#x27;
    variable = disp_z
  [../]
  [./disp_xBC2]
    type = PointValue
    point = &#x27;360.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_z8]
    type = PointValue
    point = &#x27;420.0 0.0 0.0&#x27;
    variable = disp_z
  [../]
  [./disp_z9]
    type = PointValue
    point = &#x27;480.0 0.0 0.0&#x27;
    variable = disp_z
  [../]
[]
[Debug]
 show_var_residual_norms = true
[]

[Outputs]
  csv = true
  exodus = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="49cfea83-795a-4818-b75a-8e61d605a9d3"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_2d_mouth_dir.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 2d plane strain model
#Crack direction is defined using the crack mouth coordinates.
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackMouth
  crack_mouth_boundary = 900
  2d = true
  axis_2d = 2
  radius_inner = &#x27;4.0 4.5 5.0 5.5 6.0&#x27;
  radius_outer = &#x27;4.5 5.0 5.5 6.0 6.5&#x27;
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = j_integral_2d_mouth_dir_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="158c58d6-f2db-43a7-9cb4-1d4f5212dc61"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/prescribed_displacement/3D_QStatic_1_Ramped_Displacement_ti.i</h4><pre class="moose-pre"><code class="language-text"># One 3D element under ramped displacement loading.
#
# loading:
# time : 0.0 0.1  0.2  0.3
# disp : 0.0 0.0 -0.01 -0.01

# This displacement loading is applied using the PresetDisplacement boundary condition.

# Here, the given displacement time history is converted to an acceleration
# time history using Backward Euler time differentiation. Then, the resulting
# acceleration is integrated using Newmark time integration to obtain a
# displacement time history which is then applied to the boundary.

# This is done because if the displacement is applied using Dirichlet BC, the
# resulting acceleration is very noisy.

# Boundaries:
# x = 0 left
# x = 1 right
# y = 0 bottom
# y = 1 top
# z = 0 back
# z = 1 front

# Result: The displacement at the top node in the z direction should match
# the prescribed displacement. Also, the z acceleration should
# be two triangular pulses, one peaking at 0.1 and another peaking at
# 0.2.


[Mesh]
  type = GeneratedMesh
  dim = 3 # Dimension of the mesh
  nx = 1 # Number of elements in the x direction
  ny = 1 # Number of elements in the y direction
  nz = 1 # Number of elements in the z direction
  xmin = 0.0
  xmax = 1
  ymin = 0.0
  ymax = 1
  zmin = 0.0
  zmax = 1
  allow_renumbering = false # So NodalVariableValue can index by id
[]

[Variables] # variables that are solved
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables] # variables that are calculated for output
  [./accel_x]
  [../]
  [./vel_x]
  [../]
  [./accel_y]
  [../]
  [./vel_y]
  [../]
  [./accel_z]
  [../]
  [./vel_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics] # zeta*K*vel + K * disp
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    zeta = 0.000025
  [../]
  [./inertia_x] # M*accel + eta*M*vel
    type = InertialForce
    variable = disp_x
    eta = 19.63
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    eta = 19.63
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    eta = 19.63
  [../]
[]

[AuxKernels]
  [./accel_x] # These auxkernels are only to check output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./displacement_front]
    type = PiecewiseLinear
    data_file = &#x27;displacement.csv&#x27;
    format = columns
  [../]
[]

[BCs]
  [./Preset_displacement]
    type = PresetDisplacement
    variable = disp_z
    function = displacement_front
    boundary = front
    beta = 0.25
    velocity = vel_z
    acceleration = accel_z
  [../]
  [./anchor_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./anchor_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./anchor_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    youngs_modulus = 325e6 #Pa
    poissons_ratio = 0.3
    type = ComputeIsotropicElasticityTensor
    block = 0
  [../]
  [./strain]
    #Computes the strain, assuming small strains
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    #Computes the stress, using linear elasticity
    type = ComputeLinearElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 2000 #kg/m3
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 3.0
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  dt = 0.1
  timestep_tolerance = 1e-6

  # Time integrator scheme
  scheme = &quot;newmark-beta&quot;
[]

[Postprocessors] # These quantites are printed to a csv file at every time step
  [./_dt]
    type = TimestepSize
  [../]
  [./accel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_x
  [../]
  [./accel_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_y
  [../]
  [./accel_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_z
  [../]
  [./vel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_x
  [../]
  [./vel_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_y
  [../]
  [./vel_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = vel_z
  [../]
  [./disp_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_x
  [../]
  [./disp_6y]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_y
  [../]
  [./disp_6z]
    type = NodalVariableValue
    nodeid = 6
    variable = disp_z
  [../]
[]

[Outputs]
  file_base = &quot;3D_QStatic_1_Ramped_Displacement_out&quot;
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c925ab1f-b6b2-4fa8-8803-334d439b310c"><div class="modal-content"><h4>modules/porous_flow/test/tests/dirackernels/bh07.i</h4><pre class="moose-pre"><code class="language-text"># Comparison with analytical solution for cylindrically-symmetric situation
[Mesh]
  type = FileMesh
  file = bh07_input.e
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1000 10000&#x27;
    x = &#x27;100 1000&#x27;
  [../]
[]

[Variables]
  [./pp]
    initial_condition = 1E7
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pp
  [../]
  [./fflux]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = pp
    gravity = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./fix_outer]
    type = DirichletBC
    boundary = perimeter
    variable = pp
    value = 1E7
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;pp&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./borehole_total_outflow_mass]
    type = PorousFlowSumQuantity
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.8
    alpha = 1e-5
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      viscosity = 1e-3
      density0 = 1000
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pp
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.1
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-11 0 0 0 1E-11 0 0 0 1E-11&#x27;
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityFLAC
    m = 2
    phase = 0
  [../]
[]

[DiracKernels]
  [./bh]
    type = PorousFlowPeacemanBorehole
    variable = pp
    SumQuantityUO = borehole_total_outflow_mass
    point_file = bh07.bh
    fluid_phase = 0
    bottom_p_or_t = 0
    unit_weight = &#x27;0 0 0&#x27;
    use_mobility = true
    re_constant = 0.1594  # use Chen and Zhang version
    character = 2 # double the strength because bh07.bh only fills half the mesh
  [../]
[]

[Postprocessors]
  [./bh_report]
    type = PorousFlowPlotQuantity
    uo = borehole_total_outflow_mass
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./fluid_mass]
    type = PorousFlowFluidMass
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[VectorPostprocessors]
  [./pp]
    type = LineValueSampler
    variable = pp
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;300 0 0&#x27;
    sort_by = x
    num_points = 300
    execute_on = timestep_end
  [../]
[]

[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 1E3
  solve_type = NEWTON
  [./TimeStepper]
    # get only marginally better results for smaller time steps
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = bh07
  [./along_line]
    type = CSV
    execute_on = final
  [../]
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial final&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="80115afa-0150-48b8-9af7-27d2a0f979d3"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test4.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.0125
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test4_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="eafbb0e3-3091-4988-acb2-bba6a5c3f9bc"><div class="modal-content"><h4>modules/porous_flow/test/tests/functions/mpf1.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  xmin = 0
  xmax = 10
  ymin = 0
  ymax = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./dummy]
    type = TimeDerivative
    variable = u
  [../]
[]

[Functions]
  [./dist]
    type = PiecewiseLinear
    x = &#x27;1 10&#x27;  # time
    y = &#x27;0 9&#x27;   # distance
  [../]
  [./moving_planar_front]
    type = MovingPlanarFront
    start_posn = &#x27;1 1 0&#x27;
    end_posn = &#x27;2 2 0&#x27; # it does not matter that dist exceeds this
    active_length = 5
    activation_time = 1
    deactivation_time = 9
    distance = dist
  [../]
[]

[AuxVariables]
  [./mpf]
  [../]
[]

[AuxKernels]
  [./mpf]
    type = FunctionAux
    variable = mpf
    function = moving_planar_front
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.5
  end_time = 10
[]

[Outputs]
  file_base = mpf1
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1391cce4-2bcc-4cd2-8a65-5e6de270437b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/3D/3d_nodalmass_explicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for the CentralDifference time integrator

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 1
    ny = 1
    nz = 2
    xmin = 0.0
    xmax = 1
    ymin = 0.0
    ymax = 1
    zmin = 0.0
    zmax = 2
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;1 1 2&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
  [./accel_z]
    type = TestNewmarkTI
    variable = accel_z
    displacement = disp_z
    first = false
  [../]
  [./vel_z]
    type = TestNewmarkTI
    variable = vel_z
    displacement = disp_z
  [../]
[]

[BCs]
  [./x_bot]
    type = FunctionDirichletBC
    boundary = &#x27;back&#x27;
    variable = disp_x
    function = dispx
    preset = false
  [../]
  [./y_bot]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = back
    function = dispy
    preset = false
  [../]
  [./z_bot]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = back
    function = dispz
    preset = false
  [../]
[]

[Functions]
  [./dispx]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
  [./dispy]
    type = ParsedFunction
    value = 0.1*t*t*sin(10*t)
  [../]
  [./dispz]
    type = ParsedFunction
    value = 0.1*t*t*sin(20*t)
  [../]
[]

[NodalKernels]
  [./nodal_mass_x]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_x&#x27;
  [../]
  [./nodal_mass_y]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_y&#x27;
  [../]
  [./nodal_mass_z]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_z&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = CentralDifference
  [../]
[]

[Postprocessors]
  [./accel_10x]
    type = NodalVariableValue
    nodeid = 10
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="75c04fff-0399-46b1-991e-6e466eae49c3"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/truss/truss_hex.i</h4><pre class="moose-pre"><code class="language-text"># This test is designed to check
# whether truss element works well with other multi-dimensional element
# e.g. the hex element in this case, by assigning different brock number
# to different types of elements.
[Mesh]
  type = FileMesh
  file = truss_hex.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
#    initial_condition = 1.0
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./x2]
    type = PiecewiseLinear
    x = &#x27;0  1 2 3&#x27;
    y = &#x27;0 .5 1 1&#x27;
  [../]
  [./y2]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3&#x27;
    y = &#x27;0 0 .5 1&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./fixx2]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]
  [./fixz2]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]

  [./fixDummyHex_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1000
    value = 0
  [../]

  [./fixDummyHex_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1000
    value = 0
  [../]

  [./fixDummyHex_z]
    type = DirichletBC
    variable = disp_z
    boundary = 1000
    value = 0
  [../]
[]

[DiracKernels]
  [./pull]
    type = ConstantPointSource
    value = -25
    point = &#x27;0 -2 0&#x27;
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    block = &#x27;1 2&#x27;
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    block = &#x27;1 2&#x27;
    property = e_over_l
    variable = e_over_l
  [../]
  [./area1]
    type = ConstantAux
    block = 1
    variable = area
    value = 1.0
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
  [./area2]
    type = ConstantAux
    block = 2
    variable = area
    value = 0.25
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;jacobi   101&#x27;

  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10

  dt = 1
  num_steps = 1
  end_time = 1
[]

[Kernels]
  [./truss_x]
    type = StressDivergenceTensorsTruss
    block = &#x27;1 2&#x27;
    variable = disp_x
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    component = 0
    area = area
    save_in = react_x
  [../]
  [./truss_y]
    type = StressDivergenceTensorsTruss
    block = &#x27;1 2&#x27;
    variable = disp_y
    component = 1
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    area = area
    save_in = react_y
  [../]
  [./truss_z]
    type = StressDivergenceTensorsTruss
    block = &#x27;1 2&#x27;
    variable = disp_z
    component = 2
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    area = area
    save_in = react_z
  [../]
  [./TensorMechanics]
    block = 1000
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
#  [./hex_x]
#    type = StressDivergenceTensors
#    block = 1000
#    variable = disp_x
#    component = 0
#    displacements = &#x27;disp_x disp_y disp_z&#x27;
#  [../]
#  [./hex_y]
#    type = StressDivergenceTensors
#    block = 1000
#    variable = disp_y
#    component = 1
#    displacements = &#x27;disp_x disp_y disp_z&#x27;
#  [../]
#  [./hex_z]
#    type = StressDivergenceTensors
#    block = 1000
#    variable = disp_z
#    component = 2
#    displacements = &#x27;disp_x disp_y disp_z&#x27;
#  [../]
[]

[Materials]
   [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 1000
    youngs_modulus = 1e6
    poissons_ratio = 0
  [../]
  [./strain]
    type = ComputeSmallStrain
    block = 1000
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = 1000
  [../]
  [./linelast]
    type = LinearElasticTruss
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    youngs_modulus = 1e6
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2ac4b22d-3310-4cf2-988f-48a3fc0c7b94"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/strain_energy_density/incr_model.i</h4><pre class="moose-pre"><code class="language-text"># Single element test to check the strain energy density calculation

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 2
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -100
  [../]
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress strain_xx strain_yy strain_zz&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./Pressure]
    [./top]
      boundary = &#x27;top&#x27;
      function = rampConstantUp
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 30e+6
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./strain_energy_density]
    type = StrainEnergyDensity
    incremental = true
  [../]
[]

[Executioner]
   type = Transient

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 3e-7
   nl_rel_tol = 1e-12
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Postprocessors]
  [./epxx]
    type = ElementalVariableValue
    variable = strain_xx
    elementid = 0
  [../]
  [./epyy]
    type = ElementalVariableValue
    variable = strain_yy
    elementid = 0
  [../]
  [./epzz]
    type = ElementalVariableValue
    variable = strain_zz
    elementid = 0
  [../]
  [./sigxx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./sigyy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./sigzz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./SED]
    type = ElementAverageValue
    variable = SED
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5c342816-084a-48fd-a5c7-454cc08f5d80"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_3d_rot.i</h4><pre class="moose-pre"><code class="language-text">#This tests the Interaction-Integral evaluation capability.
#This is a 3d extrusion of a 2d plane strain model with 2 elements
#through the thickness, and calculates the Interaction-Integrals using options
#to treat it as 3d.

[GlobalParams]
  order = FIRST
#  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack3d_rot.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = &#x27;InteractionIntegralKI InteractionIntegralKII InteractionIntegralKIII&#x27;
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;0 0 -1&#x27;
  radius_inner = &#x27;4.0 5.5&#x27;
  radius_outer = &#x27;5.5 7.0&#x27;
  block = 1
  youngs_modulus = 207000
  poissons_ratio = 0.3
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_x
    boundary = 500
    value = 0.0
  [../]
  [./no_z2]
    type = DirichletBC
    variable = disp_x
    boundary = 510
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_z
    boundary = 700
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;


  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = interaction_integral_3d_rot_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="65d8b779-bde1-4d18-829e-c50632c73492"><div class="modal-content"><h4>modules/xfem/test/tests/diffusion_xfem/levelsetcut2d_aux.i</h4><pre class="moose-pre"><code class="language-text"># 2D: Mesh is cut by level set based cutter
# The level set is a MOOSE auxvariable

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 3
  ny = 3
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;3   5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;x-0.5&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 3
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]

[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 1
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="84e4bf84-db80-44da-b43f-69b369c79af2"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/moving_level_set.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 5
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutSetUserObject
    cut_data = &#x27;0.3 1.0 0.3 0.2 0 3&#x27;
    heal_always = false
  [../]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Functions]
  [./u_left]
    type = PiecewiseLinear
    x = &#x27;0   2&#x27;
    y = &#x27;3   5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;x-0.7-0.07*(t-1)&#x27;
  [../]
[]

[Constraints]
  [./u_constraint]
    type = XFEMSingleVariableConstraint
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_displaced_mesh = false
    variable = u
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 3
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]

[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  # petsc_options_value = &#x27;hypre boomeramg&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-9

  start_time = 0.0
  dt = 1
  end_time = 3.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = timestep_end
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="21ff8b29-6759-4d33-b084-3d50bd186380"><div class="modal-content"><h4>modules/combined/test/tests/power_law_creep/power_law_creep.i</h4><pre class="moose-pre"><code class="language-text"># 1x1x1 unit cube with uniform pressure on top face

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1000.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy&#x27;
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./u_top_pull]
    type = Pressure
    variable = disp_y
    component = 1
    boundary = top
    factor = -10.0e6
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp_fix]
    type = DirichletBC
    variable = temp
    boundary = &#x27;bottom top&#x27;
    value = 1000.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2e11
    poissons_ratio = 0.3
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;power_law_creep&#x27;
    tangent_operator = elastic
  [../]
  [./power_law_creep]
    type = PowerLawCreepStressUpdate
    coefficient = 1.0e-15
    n_exponent = 4
    activation_energy = 3.0e5
    temperature = temp
  [../]

  [./thermal]
    type = HeatConductionMaterial
    specific_heat = 1.0
    thermal_conductivity = 100.
  [../]
  [./density]
    type = Density
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.0
  end_time = 1.0
  num_steps = 10
  dt = 0.1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="44ab44fa-f7aa-4ce5-93d3-edf56cde2d4d"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh07.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated = true
# gravity = false
# supg = true
# transient = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 1E1 1E3 1E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.0
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-3
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-3
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = RandomIC
    min = 0.2
    max = 0.8
    variable = pwater
  [../]
  [./gas_ic]
    type = RandomIC
    min = 1.2
    max = 1.8
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((p0-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((p0-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    density_UO = &#x27;DensityWater DensityGas&#x27;
    relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
    SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
    sat_UO = &#x27;SatWater SatGas&#x27;
    seff_UO = &#x27;SeffWater SeffGas&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-13 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = gh07
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ef8218d3-18ed-4d10-9a2c-16a0bc9441a3"><div class="modal-content"><h4>modules/porous_flow/test/tests/dirackernels/bh05.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated
# injection
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;500 500 1E1&#x27;
    x = &#x27;4000 5000 6500&#x27;
  [../]
[]

[Variables]
  [./pp]
    initial_condition = -2E5
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pp
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;pp&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./borehole_total_outflow_mass]
    type = PorousFlowSumQuantity
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.8
    alpha = 1e-5
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 2e9
      viscosity = 1e-3
      density0 = 1000
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pp
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.1
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-12 0 0 0 1E-12 0 0 0 1E-12&#x27;
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityFLAC
    m = 2
    phase = 0
  [../]
[]

[DiracKernels]
  [./bh]
    type = PorousFlowPeacemanBorehole
    variable = pp
    SumQuantityUO = borehole_total_outflow_mass
    point_file = bh03.bh
    fluid_phase = 0
    bottom_p_or_t = 0
    unit_weight = &#x27;0 0 0&#x27;
    use_mobility = true
    character = -1
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = PorousFlowPlotQuantity
    uo = borehole_total_outflow_mass
  [../]

  [./fluid_mass0]
    type = PorousFlowFluidMass
    execute_on = timestep_begin
  [../]

  [./fluid_mass1]
    type = PorousFlowFluidMass
    execute_on = timestep_end
  [../]

  [./zmass_error]
    type = FunctionValuePostprocessor
    function = mass_bal_fcn
    execute_on = timestep_end
  [../]

  [./p0]
    type = PointValue
    variable = pp
    point = &#x27;0 0 0&#x27;
    execute_on = timestep_end
  [../]
[]


[Functions]
  [./mass_bal_fcn]
    type = ParsedFunction
    value = abs((a-c+d)/2/(a+c))
    vars = &#x27;a c d&#x27;
    vals = &#x27;fluid_mass1 fluid_mass0 bh_report&#x27;
  [../]
[]

[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 6500
  solve_type = NEWTON
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = bh05
  exodus = false
  csv = true
  execute_on = timestep_end
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cefb3243-efff-4f15-84a8-875dc53820ff"><div class="modal-content"><h4>modules/richards/test/tests/rogers_stallybrass_clements/rsc_fu_01.i</h4><pre class="moose-pre"><code class="language-text"># RSC test with high-res time and spatial resolution
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 600
  ny = 1
  xmin = 0
  xmax = 10 # x is the depth variable, called zeta in RSC
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityOil&#x27;
  relperm_UO = &#x27;RelPerm RelPerm&#x27;
  SUPG_UO = &#x27;SUPGstandard SUPGstandard&#x27;
  sat_UO = &#x27;Saturation Saturation&#x27;
  seff_UO = &#x27;SeffWater SeffOil&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;3E-3 3E-2 0.05&#x27;
    x = &#x27;0 1 5&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater poil&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 10
    bulk_mod = 2E9
  [../]
  [./DensityOil]
    type = RichardsDensityConstBulk
    dens0 = 20
    bulk_mod = 2E9
  [../]
  [./SeffWater]
    type = RichardsSeff2waterRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./SeffOil]
    type = RichardsSeff2gasRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./RelPerm]
    type = RichardsRelPermMonomial
    simm = 0
    n = 1
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E-2
  [../]
[]


[Variables]
  [./pwater]
  [../]
  [./poil]
  [../]
[]

[ICs]
  [./water_init]
    type = ConstantIC
    variable = pwater
    value = 0
  [../]
  [./oil_init]
    type = ConstantIC
    variable = poil
    value = 15
  [../]
[]

[Kernels]
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstoil]
    type = RichardsMassChange
    variable = poil
  [../]
  [./richardsfoil]
    type = RichardsFullyUpwindFlux
    variable = poil
  [../]
[]


[AuxVariables]
  [./SWater]
  [../]
  [./SOil]
  [../]
[]


[AuxKernels]
  [./Seff1VGwater_AuxK]
    type = RichardsSeffAux
    variable = SWater
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
  [./Seff1VGoil_AuxK]
    type = RichardsSeffAux
    variable = SOil
    seff_UO = SeffOil
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
[]


[BCs]
# we are pumping water into a system that has virtually incompressible fluids, hence the pressures rise enormously.  this adversely affects convergence because of almost-overflows and precision-loss problems.  The fixed things help keep pressures low and so prevent these awful behaviours.   the movement of the saturation front is the same regardless of the fixed things.
  active = &#x27;recharge fixedoil fixedwater&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pwater
    boundary = &#x27;left&#x27;
    pressures = &#x27;-1E10 1E10&#x27;
    bare_fluxes = &#x27;-1 -1&#x27;
    use_mobility = false
    use_relperm = false
  [../]
  [./fixedwater]
    type = DirichletBC
    variable = pwater
    boundary = &#x27;right&#x27;
    value = 0
  [../]
  [./fixedoil]
    type = DirichletBC
    variable = poil
    boundary = &#x27;right&#x27;
    value = 15
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.25
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = &#x27;1E-3 2E-3&#x27;
    gravity = &#x27;0E-0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = rsc_fu_01
  interval = 100000
  execute_on = &#x27;initial timestep_end final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="30ff01e7-7714-4552-ba79-29f8b9bed6c5"><div class="modal-content"><h4>modules/combined/test/tests/ad_power_law_creep/power_law_creep_restart2.i</h4><pre class="moose-pre"><code class="language-text"># 1x1x1 unit cube with uniform pressure on top face

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1000.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy&#x27;
    use_automatic_differentiation = true
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = ADHeatConduction
    variable = temp
  [../]
  [./heat_ie]
    type = ADHeatConductionTimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./u_top_pull]
    type = ADPressure
    variable = disp_y
    component = 1
    boundary = top
    constant = -10.0e6
    function = top_pull
  [../]
  [./u_bottom_fix]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./u_yz_fix]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./u_xy_fix]
    type = ADDirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp_fix]
    type = DirichletBC
    variable = temp
    boundary = &#x27;bottom top&#x27;
    value = 1000.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 2e11
    poissons_ratio = 0.3
    constant_on = SUBDOMAIN
  [../]
  [./radial_return_stress]
    type = ADComputeMultipleInelasticStress
    inelastic_models = &#x27;power_law_creep&#x27;
  [../]
  [./power_law_creep]
    type = ADPowerLawCreepStressUpdate
    coefficient = 1.0e-15
    n_exponent = 4
    activation_energy = 3.0e5
    temperature = temp
  [../]

  [./thermal]
    type = ADHeatConductionMaterial
    specific_heat = 1.0
    thermal_conductivity = 100.
  [../]
  [./density]
    type = ADDensity
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 20
  nl_max_its = 20
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-6
  l_tol = 1e-5
  start_time = 0.6
  end_time = 1.0
  num_steps = 12
  dt = 0.1
[]

[Outputs]
  file_base = power_law_creep_out
  exodus = true
[]

[Problem]
  restart_file_base = power_law_creep_restart1_out_cp/0006
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1541eab3-16ca-4c2e-8c88-09e0e7e149fa"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/3D/3d_consistent_explicit.i</h4><pre class="moose-pre"><code class="language-text"># One element test to test the central difference time integrator in 3D.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 2
  xmin = 0.0
  xmax = 1
  ymin = 0.0
  ymax = 1
  zmin = 0.0
  zmax = 2
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_x
  [../]
  [./accel_z]
    type = TestNewmarkTI
    variable = accel_z
    displacement = disp_z
    first = false
  [../]
  [./vel_z]
    type = TestNewmarkTI
    variable = vel_z
    displacement = disp_z
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
  [../]
[]

[BCs]
  [./x_bot]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = &#x27;back&#x27;
    function = dispx
    preset = false
  [../]
  [./y_bot]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = &#x27;back&#x27;
    function = dispy
    preset = false
  [../]
  [./z_bot]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = &#x27;back&#x27;
    function = dispz
    preset = false
  [../]
  [./Periodic]
    [./x_dir]
      variable = &#x27;disp_x disp_y disp_z&#x27;
      primary = &#x27;left&#x27;
      secondary = &#x27;right&#x27;
      translation = &#x27;1.0 0.0 0.0&#x27;
    [../]
    [./y_dir]
      variable = &#x27;disp_x disp_y disp_z&#x27;
      primary = &#x27;bottom&#x27;
      secondary = &#x27;top&#x27;
      translation = &#x27;0.0 1.0 0.0&#x27;
    [../]
  [../]
[]

[Functions]
  [./dispx]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
  [./dispy]
    type = ParsedFunction
    value = 0.1*t*t*sin(10*t)
  [../]
  [./dispz]
    type = ParsedFunction
    value = 0.1*t*t*sin(20*t)
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 1e4
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = CentralDifference
  [../]
[]

[Postprocessors]
  [./accel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4963c3d5-d0b7-40fb-aaea-27ca603b6d01"><div class="modal-content"><h4>modules/contact/test/tests/catch_release/catch_release.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = catch_release.e
[]

[Functions]
  [./up]
    type = PiecewiseLinear
    x = &#x27;0 1 2.00 3 4&#x27;
    y = &#x27;0 1 1.01 1 0&#x27;
    scale_factor = 0.5
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    strain = FINITE
    generate_output = &#x27;stress_yy&#x27;
  []
[]

[Contact]
  [./dummy_name]
    primary = 2
    secondary = 3
    penalty = 1e6
    model = frictionless
  [../]
[]

[BCs]
  [./lateral]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 4&#x27;
    value = 0.0
  [../]

  [./bottom_up]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    function = up
  [../]

  [./out]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1 4&#x27;
    value = 0.0
  [../]

  [./top]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
[]

[Materials]
  [./stiffStuff]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stiffStuffStress]
    type = ComputeFiniteStrainElasticStress
  []
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  #petsc_options_iname = &#x27;-pc_type -snes_type -snes_ls -snes_linesearch_type -ksp_gmres_restart&#x27;
  #petsc_options_value = &#x27;ilu      ls         basic    basic                    101&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      101&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-4
  l_tol = 1e-4

  l_max_its = 100
  nl_max_its = 20
  dt = 1.0
  end_time = 4.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e662aabe-289b-41b5-913e-82d7892298da"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test4qns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test4q.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_distance = 0.2
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.025
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test4qns_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8e22278b-fae7-4aa5-8b48-32403775feb3"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/plane_stress/ad_weak_plane_stress_incremental.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
  out_of_plane_strain = strain_zz
[]

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./strain_zz]
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./nl_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./react_z]
    type = ADMaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
  [./min_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = min
  [../]
  [./max_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = max
  [../]
[]

[Modules/TensorMechanics/Master]
  [./plane_stress]
    planar_formulation = WEAK_PLANE_STRESS
    strain = SMALL
    incremental = true
    generate_output = &#x27;stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy&#x27;
    eigenstrain_names = eigenstrain
    use_automatic_differentiation = true
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    use_displaced_mesh = false
  [../]
  [./strain_zz]
    type = ADRankTwoAux
    rank_two_tensor = total_strain
    variable = nl_strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0     1   100&#x27;
    y=&#x27;0  0.00  0.00&#x27;
  [../]
  [./tempfunc]
    type = ParsedFunction
    value = &#x27;(1 - x) * t&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./thermal_strain]
    type = ADComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 0.02
    stress_free_temperature = 0.5
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ADComputeStrainIncrementBasedStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-12

# time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
[]

[Outputs]
  file_base = &#x27;weak_plane_stress_incremental_out&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="158b6e2d-cd0d-4cce-a8d7-4d42de428edd"><div class="modal-content"><h4>modules/richards/test/tests/rogers_stallybrass_clements/rsc_lumped_01.i</h4><pre class="moose-pre"><code class="language-text"># RSC test with high-res time and spatial resolution
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 600
  ny = 1
  xmin = 0
  xmax = 10 # x is the depth variable, called zeta in RSC
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityOil&#x27;
  relperm_UO = &#x27;RelPerm RelPerm&#x27;
  SUPG_UO = &#x27;SUPGstandard SUPGstandard&#x27;
  sat_UO = &#x27;Saturation Saturation&#x27;
  seff_UO = &#x27;SeffWater SeffOil&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;3E-3 3E-2 0.05&#x27;
    x = &#x27;0 1 5&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater poil&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 10
    bulk_mod = 2E9
  [../]
  [./DensityOil]
    type = RichardsDensityConstBulk
    dens0 = 20
    bulk_mod = 2E9
  [../]
  [./SeffWater]
    type = RichardsSeff2waterRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./SeffOil]
    type = RichardsSeff2gasRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./RelPerm]
    type = RichardsRelPermMonomial
    simm = 0
    n = 1
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E-2
  [../]
[]


[Variables]
  [./pwater]
  [../]
  [./poil]
  [../]
[]

[ICs]
  [./water_init]
    type = ConstantIC
    variable = pwater
    value = 0
  [../]
  [./oil_init]
    type = ConstantIC
    variable = poil
    value = 15
  [../]
[]

[Kernels]
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstoil]
    type = RichardsLumpedMassChange
    variable = poil
  [../]
  [./richardsfoil]
    type = RichardsFlux
    variable = poil
  [../]
[]


[AuxVariables]
  [./SWater]
  [../]
  [./SOil]
  [../]
[]


[AuxKernels]
  [./Seff1VGwater_AuxK]
    type = RichardsSeffAux
    variable = SWater
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
  [./Seff1VGoil_AuxK]
    type = RichardsSeffAux
    variable = SOil
    seff_UO = SeffOil
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
[]


[BCs]
# we are pumping water into a system that has virtually incompressible fluids, hence the pressures rise enormously.  this adversely affects convergence because of almost-overflows and precision-loss problems.  The fixed things help keep pressures low and so prevent these awful behaviours.   the movement of the saturation front is the same regardless of the fixed things.
  active = &#x27;recharge fixedoil fixedwater&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pwater
    boundary = &#x27;left&#x27;
    pressures = &#x27;-1E10 1E10&#x27;
    bare_fluxes = &#x27;-1 -1&#x27;
    use_mobility = false
    use_relperm = false
  [../]
  [./fixedwater]
    type = DirichletBC
    variable = pwater
    boundary = &#x27;right&#x27;
    value = 0
  [../]
  [./fixedoil]
    type = DirichletBC
    variable = poil
    boundary = &#x27;right&#x27;
    value = 15
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.25
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = &#x27;1E-3 2E-3&#x27;
    gravity = &#x27;0E-0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = rsc_lumped_01
  interval = 100000
  execute_on = &#x27;initial final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dc11c838-141c-4834-9a43-2b9cca0ef47a"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3nns.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
#  [./element_id]
#  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    normal_smoothing_method = nodal_normal_based
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

#  [./penetrate17]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 11
#    paired_boundary = 12
#    quantity = element_id
#  [../]
#
#  [./penetrate18]
#    type = PenetrationAux
#    variable = element_id
#    boundary = 12
#    paired_boundary = 11
#    quantity = element_id
#  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3nns_out
  exodus = true
[]

[NodalNormals]
  boundary = 11
  corner_boundary = 20
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1dec4166-17ca-4f24-98ef-f20141769a26"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/plane_stress/weak_plane_stress_incremental.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
  out_of_plane_strain = strain_zz
[]

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./strain_zz]
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./nl_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./react_z]
    type = MaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
  [./min_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = min
  [../]
  [./max_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = max
  [../]
[]

[Modules/TensorMechanics/Master]
  [plane_stress]
    planar_formulation = WEAK_PLANE_STRESS
    strain = SMALL
    incremental = true
    generate_output = &#x27;stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy&#x27;
    eigenstrain_names = eigenstrain
  []
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    use_displaced_mesh = false
  [../]
  [./strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = nl_strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0     1   100&#x27;
    y=&#x27;0  0.00  0.00&#x27;
  [../]
  [./tempfunc]
    type = ParsedFunction
    value = &#x27;(1 - x) * t&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 0.02
    stress_free_temperature = 0.5
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ComputeStrainIncrementBasedStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  line_search = none

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-06

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-12

# time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="73328e76-9748-4ef9-8bef-5a37032e6614"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test13.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    data_file = piecewise_linear_columns_more_data.csv
    format = columns
    xy_in_file_only = false
    x_index_in_file = 3 #Will generate error because data does not contain 4 columns
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3d48afc3-9d42-4068-9344-2fd8d21ca18d"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test3qtt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test3qtt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="58e042e1-00d0-4359-b3a4-5be16fba5964"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_dyn_variable_action.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction
# The velocity and acceleration AuxVariables and the corresponding AuxKernels
# are set up using the LineElementAction using add_dynamic_variables. The action
# also creates the displacement variables, stress divergence kernels and
# beam strain. NodalTranslationalInertia is not created by the action.

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The theoretical first frequency of this beam is:
# f1 = 1/(2 pi) * sqrt(3EI/(mL^3)) = 0.25

# This implies that the corresponding time period of this beam is 4s.

# The FEM solution for this beam with 10 element gives time periods of 4s with time step of 0.01s.
# A higher time step of 0.1 s is used in the test to reduce computational time.

# The time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y                vel_y                accel_y
# 0.0    0.0                   0.0                  0.0
# 0.1    0.0013076435060869    0.026152870121738    0.52305740243477
# 0.2    0.0051984378734383    0.051663017225289   -0.01285446036375
# 0.3    0.010269120909367     0.049750643493289   -0.02539301427625
# 0.4    0.015087433925158     0.046615616822532   -0.037307519138892
# 0.5    0.019534963888307     0.042334982440433   -0.048305168503101

[Mesh]
  type = GeneratedMesh
  xmin = 0.0
  xmax = 4.0
  nx = 10
  dim = 1
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Modules/TensorMechanics/LineElementMaster]
  [./all]
    add_variables = true
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;

    # Geometry parameters
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;

    # Add AuxVariables and AuxKernels for dynamic simulation
    add_dynamic_variables = true

    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;

    beta = 0.25 # Newmark time integration parameter
    gamma = 0.5 # Newmark time integration parameter
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  file_base = &#x27;dyn_euler_small_added_mass_out&#x27;
  hide = &#x27;rot_vel_x rot_vel_y rot_vel_z rot_accel_x rot_accel_y rot_accel_z&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="702c4531-877a-4ba2-93ba-30da14a04373"><div class="modal-content"><h4>modules/combined/test/tests/evolving_mass_density/shear_test_tensors.i</h4><pre class="moose-pre"><code class="language-text">#  Element mass tests

#  This series of tests is designed to compute the mass of elements based on
#  an evolving mass density calculation.  The tests consist of expansion and compression
#  of the elastic patch test model along each axis, uniform expansion and compression,
#  and shear in each direction.  The expansion and compression tests change the volume of
#  the elements.  The corresponding change in density should compensate for this so the
#  mass remains constant.  The shear tests should not result in a volume change, and this
#  is checked too.  The mass calculation is done with the post processor called Mass.

#  The tests/file names are as follows:

#  Expansion and compression along a single axis
#  expand_compress_x_test_out.e
#  expand_compress_y_test_out.e
#  expand_compress_z_test_out.e

#  Volumetric expansion and compression
#  uniform_expand_compress_test.i

#  Zero volume change shear along each axis
#  shear_x_test_out.e
#  shear_y_test_out.e
#  shear_z_test_out.e

#  The resulting mass calculation for these tests should always be = 1.

# This test is a duplicate of the uniform_expand_compress_test.i test for solid mechanics, and the
#   output of this tensor mechanics test is compared to the original
#   solid mechanics output.  The duplication is necessary to test the
#   migrated tensor mechanics version while maintaining tests for solid mechanics.


[Mesh]
  file = elastic_patch.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./rampConstant1]
    type = PiecewiseLinear
    x = &#x27;0.00 1.00  2.0   3.00&#x27;
    y = &#x27;0.00 0.25  0.0  -0.25&#x27;
    scale_factor = 1
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./TensorMechanics]
  [../]
[]

[BCs]
  [./bot_x]
    type = DirichletBC
    variable = disp_x
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_y
    value = 0
  [../]
  [./bot_z]
    type = DirichletBC
    variable = disp_z
    value = 0
  [../]

  [./top_x]
    variable = disp_x
    preset = false
  [../]
  [./top_y]
    variable = disp_y
    preset = false
  [../]
  [./top_z]
    variable = disp_z
    preset = false
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2 3 4 5 6 7&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.0
  [../]

  [./small_strain]
    type = ComputeSmallStrain
    block = &#x27; 1 2 3 4 5 6 7&#x27;
  [../]

  [./elastic_stress]
    type = ComputeLinearElasticStress
    block = &#x27;1 2 3 4 5 6 7&#x27;
  [../]
[]

[Executioner]

  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10
  l_max_its = 20
  start_time = 0.0
  dt = 1.0
  num_steps = 3
  end_time = 3.0
[] # Executioner

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[] # Outputs

[Postprocessors]
  [./Mass]
    type = Mass
    variable = disp_x
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4320a252-6ead-44e1-a944-f5a13c0358fe"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_added_mass_inertia_damping.i</h4><pre class="moose-pre"><code class="language-text"># Test for small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The beam is massless with a lumped mass at the end of the beam. The lumped
# mass also has a moment of inertia associated with it.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# mass (m) = 0.01899772
# Moment of inertia of lumped mass:
# Ixx = 0.2
# Iyy = 0.1
# Izz = 0.1
# mass proportional damping coefficient (eta) = 0.1

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the beam behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time   disp_y              vel_y               accel_y
# 0.0    0.0                 0.0                 0.0
# 0.1    0.001278249649738   0.025564992994761   0.51129985989521
# 0.2    0.0049813090917644  0.048496195845768  -0.052675802875074
# 0.3    0.0094704658873002  0.041286940064947  -0.091509312741339
# 0.4    0.013082280729802   0.03094935678508   -0.115242352856
# 0.5    0.015588313103503   0.019171290688959  -0.12031896906642

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_x]
    type = NewmarkAccelAux
    variable = rot_accel_x
    displacement = rot_x
    velocity = rot_vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_x]
    type = NewmarkVelAux
    variable = rot_vel_x
    acceleration = rot_accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_y]
    type = NewmarkAccelAux
    variable = rot_accel_y
    displacement = rot_y
    velocity = rot_vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_y]
    type = NewmarkVelAux
    variable = rot_vel_y
    acceleration = rot_accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./rot_accel_z]
    type = NewmarkAccelAux
    variable = rot_accel_z
    displacement = rot_z
    velocity = rot_vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./rot_vel_z]
    type = NewmarkVelAux
    variable = rot_vel_z
    acceleration = rot_accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
  [./x_inertial]
    type = NodalTranslationalInertia
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
    eta = 0.1
  [../]
  [./y_inertial]
    type = NodalTranslationalInertia
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
    eta = 0.1
  [../]
  [./z_inertial]
    type = NodalTranslationalInertia
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    boundary = right
    beta = 0.25
    gamma = 0.5
    mass = 0.01899772
    eta = 0.1
  [../]
  [./rot_x_inertial]
    type = NodalRotationalInertia
    variable = rot_x
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary = right
    beta = 0.25
    gamma = 0.5
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 0
  [../]
  [./rot_y_inertial]
    type = NodalRotationalInertia
    variable = rot_y
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary = right
    beta = 0.25
    gamma = 0.5
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 1
  [../]
  [./rot_z_inertial]
    type = NodalRotationalInertia
    variable = rot_z
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y rot_vel_z&#x27;
    rotational_accelerations= &#x27;rot_accel_x rot_accel_y rot_accel_z&#x27;
    boundary = right
    beta = 0.25
    gamma = 0.5
    Ixx = 2e-1
    Iyy = 1e-1
    Izz = 1e-1
    eta = 0.1
    component = 2
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 10.0&#x27;
    y = &#x27;0.0 1e-2  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-ksp_type -pc_type&#x27;
  petsc_options_value = &#x27;preonly   lu&#x27;

  dt = 0.1
  end_time = 5.0
  timestep_tolerance = 1e-6
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1ae839eb-17d9-4b20-a049-5c3a875d85f2"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/torque_reaction/disp_about_axis_errors.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = 1.
  [../]
[]

[Modules/TensorMechanics/Master]
  [master]
    strain = FINITE
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    add_variables = true
  []
[]

[BCs]

  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value = 0.0
  [../]

  [./bottom_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]

  [./top_x]
    type = DisplacementAboutAxis
    boundary = top
    function = rampConstant
    angle_units = degrees
    axis_origin = &#x27;0. 0. 0.&#x27;
    axis_direction = &#x27;0. 0. 1.&#x27;
    component = 0
    variable = disp_x
  [../]

  [./top_y]
    type = DisplacementAboutAxis
    boundary = top
    function = rampConstant
    angle_units = degrees
    axis_origin = &#x27;0. 0. 0.&#x27;
    variable = disp_y
  [../]

[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 0
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]


[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 30
  nl_max_its = 20
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12
  l_tol = 1e-8

  start_time = 0.0
  dt = 0.1
  dtmin = 0.1 # die instead of cutting the timestep

  end_time = 0.5
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="75be278c-e939-42ec-aa94-3ccd5b6ce29b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/t_stress/t_stress_ellip_crack_3d.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = ellip_crack_4sym_norad_mm.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  partitioner = centroid
  centroid_partitioner_direction = z
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstantUp]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -689.5 #MPa
  [../]
[]

[DomainIntegral]
  integrals = &#x27;JIntegral InteractionIntegralKI InteractionIntegralT&#x27;
  boundary = 1001
  crack_direction_method = CurvedCrackFront
  crack_end_direction_method = CrackDirectionVector
  crack_direction_vector_end_1 = &#x27;0.0 1.0 0.0&#x27;
  crack_direction_vector_end_2 = &#x27;1.0 0.0 0.0&#x27;
  radius_inner = &#x27;12.5 25.0 37.5&#x27;
  radius_outer = &#x27;25.0 37.5 50.0&#x27;
  intersecting_boundary = &#x27;1 2&#x27;
  symmetry_plane = 2
  youngs_modulus = 206.8e+3 #MPa
  poissons_ratio = 0.3
  block = 1
  disp_x = disp_x
  disp_y = disp_y
  disp_z = disp_z
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 12
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 5
      function = rampConstantUp
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 206.8e+3
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
   type = Transient
  #petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

   l_max_its = 50
   nl_max_its = 20
   nl_abs_tol = 1e-5
   nl_rel_tol = 1e-11
   l_tol = 1e-2

   start_time = 0.0
   dt = 1

   end_time = 1
   num_steps = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = t_stress_ellip_crack_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="98222419-93a5-4e2e-a4d6-e61188292a23"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/rz.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (2) with an interior cavity of volume 8.
#   Block 1 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts T in the following way:
#   T =&gt; T0 + beta * t
# with
#   beta = T0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# At t = 1, p = 200.

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Mesh]
  file = rz.e
[]

[Functions]
  [./temperature]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 2&#x27;
    scale_factor = 240.54443866068704
  [../]
[]

[Variables]
  [./disp_r]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_r
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 2
    function = temperature
    variable = temp
  [../]
  [./CavityPressure]
    [./1]
      boundary = 2
      initial_pressure = 100
      R = 8.314472
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
    [../]
  [../]
[]

[Materials]
  [./elastic_tensor1]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 1
  [../]
  [./strain1]
    type = ComputeAxisymmetricRZFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elastic_tensor2]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 2
  [../]
  [./strain2]
    type = ComputeAxisymmetricRZFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_abs_tol = 1e-10

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 2
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = true
  [./checkpoint]
    type = Checkpoint
    num_files = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0c3bc44c-6677-41dd-83e3-8306f58c7a82"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/acceleration_bc/AccelerationBC_test.i</h4><pre class="moose-pre"><code class="language-text"># Test for  Acceleration boundary condition

# This test contains one brick element which is fixed in the y and z direction.
# Base acceleration is applied in the x direction to all nodes on the bottom surface (y=0).

# The PresetAcceleration converts the given acceleration to a displacement
# using Newmark time integration. This displacement is then prescribed on the boundary.
#
# Result: The acceleration at the bottom node should be same as the input acceleration
# which is a triangular function with peak at t = 0.2 in this case. Width of the triangular function
# is 0.2 s.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./TensorMechanics]
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.25
    gamma = 0.5
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.25
    gamma = 0.5
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    gamma = 0.5
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]

[Functions]
  [./acceleration_bottom]
    type = PiecewiseLinear
    data_file = acceleration.csv
    format = columns
  [../]
[]

[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./preset_accelertion]
    type = PresetAcceleration
    boundary = bottom
    function = acceleration_bottom
    variable = disp_x
    beta = 0.25
    acceleration = accel_x
    velocity = vel_x
   [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
  [../]

  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./density]
    type = GenericConstantMaterial
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]

[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      101&#x27;
  start_time = 0
  end_time = 2.0
  dt = 0.01
  dtmin = 0.01
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-8
  l_tol = 1e-8
  timestep_tolerance = 1e-8
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalVariableValue
    variable = disp_x
    nodeid = 1
  [../]
  [./vel]
    type = NodalVariableValue
    variable = vel_x
    nodeid = 1
  [../]
  [./accel]
    type = NodalVariableValue
    variable = accel_x
    nodeid = 1
  [../]
[]

[Outputs]
  csv = true
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0d624219-2a35-4b55-96b3-d82ed806a767"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/constraints/frictional_constraint.i</h4><pre class="moose-pre"><code class="language-text"># Test for frictional beam constraint.
#
# Using a simple L-shaped geometry with a frictional constraint at the
# corner between the two beams. The longer beam properties and loading is
# taken from an earlier beam regression test for static loading. The maximum
# applied load of 50000 lb should result in a displacement of 3.537e-3. Since
# the constraint is frictional with a low normal force (1.0) and coefficient
# of friction (0.05) and the short beam is much less stiff, the
# y-dir displacement of the long beam is still 3.537e-3. However, the y-dir
# displacement of the short beam increases until the force exceeds the
# frictional capacity which in this case is 0.05 and then remains constant
# after that point.

[Mesh]
  file = beam_cons_patch.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = &#x27;1001 1003&#x27;
    value = 0.0
  [../]
[]

[Constraints]
  [./tie_y_fuel]
    type = NodalFrictionalConstraint
    normal_force = 1.0
    tangential_penalty = 1.2e5
    friction_coefficient = 0.05
    boundary = 1005
    secondary = 1004
    variable = disp_y
  [../]
  [./tie_x_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = disp_x
  [../]
  [./tie_z_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = disp_z
  [../]
  [./tie_rot_y_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_y
  [../]
  [./tie_rot_x_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_x
  [../]
  [./tie_rot_z_fuel]
    type = NodalStickConstraint
    penalty = 1.2e14
    boundary = 1005
    secondary = 1004
    variable = rot_z
  [../]
[]

[Functions]
  [./force_loading]
    type = PiecewiseLinear
    x = &#x27;0.0 5.0&#x27;
    y = &#x27;0.0 50000.0&#x27;
  [../]
[]

[NodalKernels]
  [./force_x2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = &#x27;1004&#x27;
    function = force_loading
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]
[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-8

  dt = 1
  dtmin = 1
  end_time = 5
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
  [../]
[]

[Materials]
  [./elasticity_pipe]
    type = ComputeElasticityBeam
    shear_coefficient = 1.0
    youngs_modulus = 30e6
    poissons_ratio = 0.3
    block = 1
    outputs = exodus
    output_properties = &#x27;material_stiffness material_flexure&#x27;
  [../]
  [./strain_pipe]
    type = ComputeIncrementalBeamStrain
    block = &#x27;1&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 28.274
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 0.0 1.0&#x27;
  [../]
  [./stress_pipe]
    type = ComputeBeamResultants
    block = 1
    outputs = exodus
    output_properties = &#x27;forces moments&#x27;
  [../]
  [./elasticity_cons]
    type = ComputeElasticityBeam
    shear_coefficient = 1.0
    youngs_modulus = 10e2
    poissons_ratio = 0.3
    block = 2
    outputs = exodus
    output_properties = &#x27;material_stiffness material_flexure&#x27;
  [../]
  [./strain_cons]
    type = ComputeIncrementalBeamStrain
    block = &#x27;2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 1.0
    Ay = 0.0
    Az = 0.0
    Iy = 1.0
    Iz = 1.0
    y_orientation = &#x27;0.0 0.0 1.0&#x27;
  [../]
  [./stress_cons]
    type = ComputeBeamResultants
    block = 2
    outputs = exodus
    output_properties = &#x27;forces moments&#x27;
  [../]
[]

[Postprocessors]
  [./disp_y_n4]
    type = NodalVariableValue
    variable = disp_y
    nodeid = 3
  [../]
  [./disp_y_n2]
    type = NodalVariableValue
    variable = disp_y
    nodeid = 1
  [../]
  [./horz_forces_y]
    type = PointValue
    point = &#x27;9.9 60.0 0.0&#x27;
    variable = forces_y
  [../]
  [./forces_y]
    type = PointValue
    point = &#x27;10.0 59.9 0.0&#x27;
    variable = forces_y
  [../]
[]

[Outputs]
  csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="40d72645-b381-453d-a137-3eb5c65e85e4"><div class="modal-content"><h4>modules/porous_flow/test/tests/gravity/grav02c.i</h4><pre class="moose-pre"><code class="language-text"># Checking that gravity head is established in the transient situation when 0&lt;=saturation&lt;=1 (note the less-than-or-equal-to).
# 2phase (PP), 2components, vanGenuchten, constant fluid bulk-moduli for each phase, constant viscosity, constant permeability, Corey relative perm
# For better agreement with the analytical solution (ana_pp), just increase nx

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
  xmin = -1
  xmax = 0
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-3 1E-2 1E-1&#x27;
    x = &#x27;1E-3 1E-2 1E-1&#x27;
  [../]
[]

[Variables]
  [./ppwater]
    initial_condition = -0.1
  [../]
  [./ppgas]
    initial_condition = 0
  [../]
[]

[AuxVariables]
  [./massfrac_ph0_sp0]
    initial_condition = 1
  [../]
  [./massfrac_ph1_sp0]
    initial_condition = 0
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = ppwater
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    fluid_component = 0
    variable = ppwater
    gravity = &#x27;-1 0 0&#x27;
  [../]
  [./mass1]
    type = PorousFlowMassTimeDerivative
    fluid_component = 1
    variable = ppgas
  [../]
  [./flux1]
    type = PorousFlowAdvectiveFlux
    fluid_component = 1
    variable = ppgas
    gravity = &#x27;-1 0 0&#x27;
  [../]
[]

[Functions]
  [./ana_ppwater]
    type = ParsedFunction
    vars = &#x27;g B p0 rho0&#x27;
    vals = &#x27;1 2 pp_water_top 1&#x27;
    value = &#x27;-B*log(exp(-p0/B)+g*rho0*x/B)&#x27; # expected pp at base
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;ppwater ppgas&#x27;
    number_fluid_phases = 2
    number_fluid_components = 2
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.5
    alpha = 1
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid0]
      type = SimpleFluidProperties
      bulk_modulus = 2
      density0 = 1
      viscosity = 1
      thermal_expansion = 0
    [../]
    [./simple_fluid1]
      type = SimpleFluidProperties
      bulk_modulus = 1
      density0 = 0.1
      viscosity = 0.5
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow2PhasePP
    phase0_porepressure = ppwater
    phase1_porepressure = ppgas
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
    mass_fraction_vars = &#x27;massfrac_ph0_sp0 massfrac_ph1_sp0&#x27;
  [../]
  [./simple_fluid0]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid0
    phase = 0
  [../]
  [./simple_fluid1]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid1
    phase = 1
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.1
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0  0 2 0  0 0 3&#x27;
  [../]
  [./relperm_water]
    type = PorousFlowRelativePermeabilityCorey
    n = 1
    phase = 0
  [../]
  [./relperm_gas]
    type = PorousFlowRelativePermeabilityCorey
    n = 1
    phase = 1
  [../]
[]

[Postprocessors]
  [./pp_water_top]
    type = PointValue
    variable = ppwater
    point = &#x27;0 0 0&#x27;
  [../]
  [./pp_water_base]
    type = PointValue
    variable = ppwater
    point = &#x27;-1 0 0&#x27;
  [../]
  [./pp_water_analytical]
    type = FunctionValuePostprocessor
    function = ana_ppwater
    point = &#x27;-1 0 0&#x27;
  [../]
  [./mass_ph0]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./mass_ph1]
    type = PorousFlowFluidMass
    fluid_component = 1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

[]

[Preconditioning]
  active = andy
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-12 1E-10 10000&#x27;
  [../]
  [./check]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -snes_type&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-12 1E-10 10000 test&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
  end_time = 1.0
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  file_base = grav02c
  [./csv]
    type = CSV
  [../]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f0d94607-3df7-4045-bf27-9194e6ffb569"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/truss/truss_hex_action.i</h4><pre class="moose-pre"><code class="language-text"># This test is designed to check
# whether truss element works well with other multi-dimensional element
# e.g. the hex element in this case, by assigning different block number
# to different types of elements.
[Mesh]
  type = FileMesh
  file = truss_hex.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./x2]
    type = PiecewiseLinear
    x = &#x27;0  1 2 3&#x27;
    y = &#x27;0 .5 1 1&#x27;
  [../]
  [./y2]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3&#x27;
    y = &#x27;0 0 .5 1&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./fixx2]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]
  [./fixz2]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]

  [./fixDummyHex_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1000
    value = 0
  [../]

  [./fixDummyHex_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1000
    value = 0
  [../]

  [./fixDummyHex_z]
    type = DirichletBC
    variable = disp_z
    boundary = 1000
    value = 0
  [../]
[]

[DiracKernels]
  [./pull]
    type = ConstantPointSource
    value = -25
    point = &#x27;0 -2 0&#x27;
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    block = &#x27;1 2&#x27;
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    block = &#x27;1 2&#x27;
    property = e_over_l
    variable = e_over_l
  [../]
  [./area1]
    type = ConstantAux
    block = 1
    variable = area
    value = 1.0
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
  [./area2]
    type = ConstantAux
    block = 2
    variable = area
    value = 0.25
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;jacobi   101&#x27;

  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10

  dt = 1
  num_steps = 1
  end_time = 1
[]

[Kernels]
  [./TensorMechanics]
    block = 1000
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[Modules/TensorMechanics/LineElementMaster]
   [./block]
     truss = true
     displacements = &#x27;disp_x disp_y disp_z&#x27;

     area = area

     block = &#x27;1 2&#x27;
     save_in = &#x27;react_x react_y react_z&#x27;
   [../]
[]

[Materials]
   [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 1000
    youngs_modulus = 1e6
    poissons_ratio = 0
  [../]
  [./strain]
    type = ComputeSmallStrain
    block = 1000
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = 1000
  [../]
  [./linelast]
    type = LinearElasticTruss
    block = &#x27;1 2&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    youngs_modulus = 1e6
  [../]
[]

[Outputs]
  file_base = &#x27;truss_hex_out&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f3b90773-81d7-429c-98b4-d032a8362622"><div class="modal-content"><h4>modules/combined/examples/xfem/xfem_mechanics_prescribed_growth.i</h4><pre class="moose-pre"><code class="language-text"># This is a demonstration of a simple mechanics simulation using XFEM
# to represent a single crack that is prescribed to propagate along
# a line over time.

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 11
  ny = 11
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  geometric_cut_userobjects = &#x27;line_seg_cut_uo&#x27;
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./line_seg_cut_uo]
    type = LineSegmentCutUserObject
    cut_data = &#x27;1.0  0.5  0.1  0.5&#x27;
    time_start_cut = 0.0
    time_end_cut = 8.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    planar_formulation = plane_strain
    add_variables = true
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0  50&#x27;
    y=&#x27;0  0.02&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = bottom
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
  [./topx]
    type = DirichletBC
    boundary = top
    variable = disp_x
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    boundary = top
    variable = disp_y
    function = pull
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]

  [./_elastic_strain]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  line_search = &#x27;none&#x27;

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

# controls for linear iterations
  l_max_its = 100
  l_tol = 1e-2

# controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-9

# time control
  start_time = 0.0
  dt = 1.0
  end_time = 10.0

  max_xfem_update = 5
[]

[Outputs]
  exodus = true
  execute_on = timestep_end
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1634cf7f-c8f4-45c1-a300-b0d29ff761a7"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/j_integral/j_integral_2d_topo_q_func.i</h4><pre class="moose-pre"><code class="language-text">#This tests the J-Integral evaluation capability.
#This is a 2d plane strain model
#The analytic solution for J1 is 2.434.  This model
#converges to that solution with a refined mesh.
#Reference: National Agency for Finite Element Methods and Standards (U.K.):
#Test 1.1 from NAFEMS publication &quot;Test Cases in Linear Elastic Fracture
#Mechanics&quot; R0020.

[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
[]

[AuxVariables]
  [./SED]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = JIntegral
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  q_function_type = Topology
  ring_first = 1
  ring_last = 4
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[AuxKernels]
  [./SED]
    type = MaterialRealAux
    variable = SED
    property = strain_energy_density
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]

  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]

  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = j_integral_2d_topo_q_func_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5dcad217-4f5e-4dae-80ab-55897e74195c"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/plane_stress/ad_weak_plane_stress_small.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
  out_of_plane_strain = strain_zz
[]

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./strain_zz]
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./nl_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./react_z]
    type = ADMaterialTensorIntegral
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
  [../]
  [./min_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = min
  [../]
  [./max_strain_zz]
    type = NodalExtremeValue
    variable = strain_zz
    value_type = max
  [../]
[]

[Modules/TensorMechanics/Master]
  [./plane_stress]
    planar_formulation = WEAK_PLANE_STRESS
    strain = SMALL
    generate_output = &#x27;stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy&#x27;
    eigenstrain_names = eigenstrain
    use_automatic_differentiation = true
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    use_displaced_mesh = false
  [../]
  [./strain_zz]
    type = ADRankTwoAux
    rank_two_tensor = total_strain
    variable = nl_strain_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x=&#x27;0     1   100&#x27;
    y=&#x27;0  0.00  0.00&#x27;
  [../]
  [./tempfunc]
    type = ParsedFunction
    value = &#x27;(1 - x) * t&#x27;
  [../]
[]

[BCs]
  [./bottomx]
    type = DirichletBC
    boundary = 0
    variable = disp_x
    value = 0.0
  [../]
  [./bottomy]
    type = DirichletBC
    boundary = 0
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]
  [./thermal_strain]
    type = ADComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 0.02
    stress_free_temperature = 0.5
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ADComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  # controls for nonlinear iterations
  nl_max_its = 15
  nl_rel_tol = 1e-14
  nl_abs_tol = 1e-12

  # time control
  start_time = 0.0
  dt = 1.0
  dtmin = 1.0
  end_time = 2.0
[]

[Outputs]
  file_base = &#x27;weak_plane_stress_small_out&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5c9cf51f-4f16-46c3-891c-4904fa4bad86"><div class="modal-content"><h4>test/tests/utils/mathutils/clamp.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
[]

[Problem]
  solve = false
[]

[Functions]
  [./clamp]
    type = ClampTestFunction
  [../]
  [./exact]
    type = PiecewiseLinear
    x = &#x27;0   0.2 0.8 1.0&#x27;
    y = &#x27;0.2 0.2 0.8 0.8&#x27;
    axis = x
  [../]
[]

[VectorPostprocessors]
  [./functions]
    type = LineFunctionSampler
    functions = &#x27;clamp exact&#x27;
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;1 0 0&#x27;
    num_points = 10
    sort_by = x
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7940c67b-fdde-42b8-bced-baae6ec558ee"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/2D/2d_lumped_explicit.i</h4><pre class="moose-pre"><code class="language-text"># Tests for the central difference time integrator for 2D elements

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = 0
    ymax = 2
    nx = 1
    ny = 2
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
  [./accel_y]
  [../]
  [./vel_y]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
[]

[BCs]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./x_bot]
    type = FunctionDirichletBC
    boundary = bottom
    variable = disp_x
    function = disp
    preset = false
  [../]
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y&#x27;
    implicit = false
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 1e4
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = CentralDifference
    solve_type = lumped
  [../]
[]

[Postprocessors]
  [./accel_2x]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="64db5113-4382-45ba-90b6-bf6091c39ae2"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test2.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test2.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test2_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d1865a05-e6e4-4358-b858-875cb87b890c"><div class="modal-content"><h4>modules/peridynamics/test/tests/simple_tests/2D_regularD_constH_BPD.i</h4><pre class="moose-pre"><code class="language-text"># Test for bond-based peridynamic formulation
# for regular grid from generated mesh with const bond constants

# Square plate with Dirichlet boundary conditions applied
# at the left, top and bottom edges

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = PeridynamicsMesh
  horizon_number = 3

  [./gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 4
    ny = 4
  [../]
  [./gpd]
    type = MeshGeneratorPD
    input = gmg
    retain_fe_mesh = false
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[BCs]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1003
    value = 0.0
  [../]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = 1002
    value = 0.0
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1000
    function = &#x27;-0.001*t&#x27;
  [../]
[]

[Modules/Peridynamics/Mechanics/Master]
  [./all]
    formulation = BOND
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2e5
    poissons_ratio = 0.33
  [../]

  [./force_density]
    type = ComputeSmallStrainConstantHorizonMaterialBPD
  [../]
[]

[Functions]
  [./disp_x_anal]
    type = PiecewiseLinear
    axis = x
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.00033&#x27;
  [../]
  [./disp_y_anal]
    type = PiecewiseLinear
    axis = y
    x = &#x27;0 1&#x27;
    y = &#x27;-0.001 0&#x27;
  [../]
[]

[Postprocessors]
  [./anal_disp_L2]
    type = NodalFunctionsL2NormPD
    functions = &#x27;disp_x_anal disp_y_anal&#x27;
  [../]
  [./disp_diff_L2]
    type = NodalDisplacementDifferenceL2NormPD
    analytic_functions = &#x27;disp_x_anal disp_y_anal&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = none
  start_time = 0
  end_time = 1
[]

[Outputs]
  file_base = 2D_regularD_constH_BPD
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4b4ec11e-f433-4b2a-9e8b-161e13a6a545"><div class="modal-content"><h4>test/tests/geomsearch/3d_moving_penetration/pl_test3tt.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3tt.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./normal_z]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./closest_point_z]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
  [./diff_z]
    type = Diffusion
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
    tangential_tolerance = 0.09
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = normal_z
    boundary = 11
    paired_boundary = 12
    quantity = normal_z
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = normal_z
    boundary = 12
    paired_boundary = 11
    quantity = normal_z
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_z
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = closest_point_z
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_z
  [../]

  [./penetrate17]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate18]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate19]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate20]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b1z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 2
    function = disp_y
  [../]

  [./b2z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = 2
    value = 0
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
[]

[Outputs]
  file_base = pl_test3tt_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dc1c875f-762e-48c9-a629-5f2b4b244b12"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/static/euler_finite_rot_y_action.i</h4><pre class="moose-pre"><code class="language-text"># Large strain/large rotation cantilever beam tese

# A 300 N point load is applied at the end of a 4 m long cantilever beam.
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 1e8
# shear coefficient (k) = 1.0
# Area (A) = 1.0
# Iy = Iz = 0.16

# The non-dimensionless parameter alpha = kAGL^2/EI = 1e6
# Since the value of alpha is quite high, the beam behaves like
# a thin beam where shear effects are not significant.

# Beam deflection:
# small strain+rot = 3.998 m (exact 4.0)
# large strain + small rotation = -0.05 m in x and 3.74 m in y
# large rotations + small strain = -0.92 m in x and 2.38 m in y
# large rotations + large strain = -0.954 m in x and 2.37 m in y (exact -1.0 m in x and 2.4 m in y)

# References:
# K. E. Bisshopp and D.C. Drucker, Quaterly of Applied Mathematics, Vol 3, No. 3, 1945.

[Mesh]
  type = FileMesh
  file = beam_finite_rot_test_2.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = 1
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = 1
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = 1
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = 2
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 2.0  8.0&#x27;
    y = &#x27;0.0 300.0 300.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  line_search = &#x27;none&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre     boomeramg     4&#x27;
  nl_max_its = 50
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-7
  l_max_its = 50
  dt = 0.05
  end_time = 2.1
[]

[Modules/TensorMechanics/LineElementMaster]
  [./all]
  add_variables = true
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  rotations = &#x27;rot_x rot_y rot_z&#x27;
  strain_type = FINITE
  rotation_type = FINITE

  # Geometry parameters
  area = 1.0
  Iy = 0.16
  Iz = 0.16
  y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1e4
    poissons_ratio = -0.99995
    shear_coefficient = 1.0
    block = 1
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 1
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./rot_z]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = rot_z
  [../]
[]

[Outputs]
  file_base = &#x27;euler_finite_rot_y_out&#x27;
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="40292187-b24e-4120-bb11-ec66239a56e4"><div class="modal-content"><h4>modules/richards/test/tests/rogers_stallybrass_clements/rsc_fu_02.i</h4><pre class="moose-pre"><code class="language-text"># RSC test with low-res time and spatial resolution
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 200
  ny = 1
  xmin = 0
  xmax = 10 # x is the depth variable, called zeta in RSC
  ymin = 0
  ymax = 0.05
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityOil&#x27;
  relperm_UO = &#x27;RelPerm RelPerm&#x27;
  SUPG_UO = &#x27;SUPGstandard SUPGstandard&#x27;
  sat_UO = &#x27;Saturation Saturation&#x27;
  seff_UO = &#x27;SeffWater SeffOil&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;3E-2 5E-1 8E-1&#x27;
    x = &#x27;0 1 5&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater poil&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 10
    bulk_mod = 2E9
  [../]
  [./DensityOil]
    type = RichardsDensityConstBulk
    dens0 = 20
    bulk_mod = 2E9
  [../]
  [./SeffWater]
    type = RichardsSeff2waterRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./SeffOil]
    type = RichardsSeff2gasRSC
    oil_viscosity = 2E-3
    scale_ratio = 2E3
    shift = 10
  [../]
  [./RelPerm]
    type = RichardsRelPermMonomial
    simm = 0
    n = 1
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.0
    sum_s_res = 0.0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1.0E-2
  [../]
[]


[Variables]
  [./pwater]
  [../]
  [./poil]
  [../]
[]

[ICs]
  [./water_init]
    type = ConstantIC
    variable = pwater
    value = 0
  [../]
  [./oil_init]
    type = ConstantIC
    variable = poil
    value = 15
  [../]
[]

[Kernels]
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstoil]
    type = RichardsMassChange
    variable = poil
  [../]
  [./richardsfoil]
    type = RichardsFullyUpwindFlux
    variable = poil
  [../]
[]


[AuxVariables]
  [./SWater]
  [../]
  [./SOil]
  [../]
[]


[AuxKernels]
  [./Seff1VGwater_AuxK]
    type = RichardsSeffAux
    variable = SWater
    seff_UO = SeffWater
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
  [./Seff1VGoil_AuxK]
    type = RichardsSeffAux
    variable = SOil
    seff_UO = SeffOil
    pressure_vars = &#x27;pwater poil&#x27;
  [../]
[]


[BCs]
# we are pumping water into a system that has virtually incompressible fluids, hence the pressures rise enormously.  this adversely affects convergence because of almost-overflows and precision-loss problems.  The fixed things help keep pressures low and so prevent these awful behaviours.   the movement of the saturation front is the same regardless of the fixed things.
  active = &#x27;recharge fixedoil fixedwater&#x27;
  [./recharge]
    type = RichardsPiecewiseLinearSink
    variable = pwater
    boundary = &#x27;left&#x27;
    pressures = &#x27;-1E10 1E10&#x27;
    bare_fluxes = &#x27;-1 -1&#x27;
    use_mobility = false
    use_relperm = false
  [../]
  [./fixedwater]
    type = DirichletBC
    variable = pwater
    boundary = &#x27;right&#x27;
    value = 0
  [../]
  [./fixedoil]
    type = DirichletBC
    variable = poil
    boundary = &#x27;right&#x27;
    value = 15
  [../]
[]


[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.25
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = &#x27;1E-3 2E-3&#x27;
    gravity = &#x27;0E-0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  active = &#x27;andy&#x27;

  [./andy]
    type = SMP
    full = true
    petsc_options = &#x27;&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000&#x27;
  [../]
[]


[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options = &#x27;-snes_converged_reason&#x27;
  end_time = 5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]


[Outputs]
  file_base = rsc_fu_02
  interval = 100000
  execute_on = &#x27;initial timestep_end final&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="39a14ce8-e3dc-49ea-8e2c-e4d491277b48"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/truss/truss_2d.i</h4><pre class="moose-pre"><code class="language-text">#
# Truss in two dimensional space
#
# The truss is made of five equilateral triangles supported at each end.
# The truss starts at (0,0).  At (1,0), there is a point load of 25.
# The reactions are therefore
#  Ryleft  = 2/3 * 25 = 16.7
#  Ryright = 1/3 * 25 = 8.33
# The area of each member is 0.8.
# Statics gives the stress in each member.  For example, for element 6 (from
#   (0,0) to (1/2,sqrt(3)/2)), the force is
#   f = 2/3 * 25 * 2/sqrt(3) = 100/3/sqrt(3) (compressive)
#   and the stress is
#   s = -100/3/sqrt(3)/0.8 = -24.06
#

[Mesh]
  type = FileMesh
  file = truss_2d.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
#    initial_condition = 1.0
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./x2]
    type = PiecewiseLinear
    x = &#x27;0  1 2 3&#x27;
    y = &#x27;0 .5 1 1&#x27;
  [../]
  [./y2]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3&#x27;
    y = &#x27;0 0 .5 1&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./fixy4]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0
  [../]
[]

[DiracKernels]
  [./pull]
    type = ConstantPointSource
    value = -25
    point = &#x27;1 0 0&#x27;
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    block = 1
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    block = 1
    property = e_over_l
    variable = e_over_l
  [../]
  [./area]
    type = ConstantAux
    block = 1
    variable = area
    value = 0.8
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;jacobi   101&#x27;

  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10

  dt = 1
  num_steps = 1
  end_time = 1
[]

[Kernels]
  [./solid_x]
    type = StressDivergenceTensorsTruss
    block = 1
    displacements = &#x27;disp_x disp_y&#x27;
    component = 0
    variable = disp_x
    area = area
    save_in = react_x
  [../]
  [./solid_y]
    type = StressDivergenceTensorsTruss
    block = 1
    displacements = &#x27;disp_x disp_y&#x27;
    component = 1
    variable = disp_y
    area = area
    save_in = react_y
  [../]
[]

[Materials]
  [./linelast]
    type = LinearElasticTruss
    block = 1
    youngs_modulus = 1e6
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d7ff43dd-a75d-464c-9d7d-37160ee8f00e"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking_exponential.i</h4><pre class="moose-pre"><code class="language-text">#
# Test to exercise the exponential stress release
#
# Stress vs. strain should show a linear relationship until cracking,
#   an exponential stress release, a linear relationship back to zero
#   strain, a linear relationship with the original stiffness in
#   compression and then back to zero strain, a linear relationship
#   back to the exponential curve, and finally further exponential
#   stress release.
#

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displx]
    type = PiecewiseLinear
    x = &#x27;0 1       2  3      4 5       6&#x27;
    y = &#x27;0 0.00175 0 -0.0001 0 0.00175 0.0035&#x27;
  [../]
  [./disply]
    type = PiecewiseLinear
    x = &#x27;0 5 6&#x27;
    y = &#x27;0 0 .00175&#x27;
  [../]
  [./displz]
    type = PiecewiseLinear
    x = &#x27;0 2 3&#x27;
    y = &#x27;0 0 .0035&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pullx]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displx
  [../]
  [./left]
    type = ADDirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./fix_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./move_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    function = disply
  [../]
  [./back]
    type = ADDirichletBC
    variable = disp_z
    boundary = &#x27;3&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 186.5e9
    poissons_ratio = .316
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 119.3e6
    softening_models = exponential_softening
  [../]
  [./exponential_softening]
    type = ADExponentialSoftening
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type&#x27;
  petsc_options_value = &#x27;101                lu&#x27;

  line_search = &#x27;none&#x27;
  l_max_its = 100
  l_tol = 1e-6

  nl_max_its = 10
  nl_rel_tol = 1e-12
  nl_abs_tol = 1.e-4

  start_time = 0.0
  dt = 0.02
  dtmin = 0.02
  num_steps = 300
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0ae6bc22-9838-4231-9e2f-19c1ab4bc1a2"><div class="modal-content"><h4>modules/combined/test/tests/thermal_elastic/thermal_elastic.i</h4><pre class="moose-pre"><code class="language-text"># Patch Test

# This test is designed to compute constant xx, yy, zz, xy, yz, and xz
#  stress on a set of irregular hexes.  The mesh is composed of one
#  block with seven elements.  The elements form a unit cube with one
#  internal element.  There is a nodeset for each exterior node.

# The cube is displaced by 1e-6 units in x, 2e-6 in y, and 3e-6 in z.
#  The faces are sheared as well (1e-6, 2e-6, and 3e-6 for xy, yz, and
#  zx).  This gives a uniform strain/stress state for all six unique
#  tensor components.  This displacement is again applied in the second
#  step.

# With Young&#x27;s modulus at 1e6 and Poisson&#x27;s ratio at 0, the shear
#  modulus is 5e5 (G=E/2/(1+nu)).  Therefore, for the mechanical strain,
#
#  stress xx = 1e6 * 1e-6 = 1
#  stress yy = 1e6 * 2e-6 = 2
#  stress zz = 1e6 * 3e-6 = 3
#  stress xy = 2 * 5e5 * 1e-6 / 2 = 0.5
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 5e5 * 2e-6 / 2 = 1
#  stress zx = 2 * 5e5 * 3e-6 / 2 = 1.5

# Young&#x27;s modulus is a function of temperature for this test.  The
#  temperature changes from 100 to 500.  The Young&#x27;s modulus drops
#  due to that temperature change from 1e6 to 6e5.

# Poisson&#x27;s ratio also is a function of temperature and changes from
#  0 to 0.25.

# At the end of the temperature ramp, E=6e5 and nu=0.25.  This gives
#  G=2.4e=5.  lambda=E*nu/(1+nu)/(1-2*nu)=2.4E5.  The final stress
#  is therefore

#  stress xx = 2.4e5 * 12e-6 + 2*2.4e5*2e-6 = 3.84
#  stress yy = 2.4e5 * 12e-6 + 2*2.4e5*4e-6 = 4.80
#  stress zz = 2.4e5 * 12e-6 + 2*2.4e5*6e-6 = 5.76
#  stress xy = 2 * 2.4e5 * 2e-6 / 2 = 0.48
#             (2 * G   * gamma_xy / 2 = 2 * G * epsilon_xy)
#  stress yz = 2 * 2.4e5 * 4e-6 / 2 = 0.96
#  stress xz = 2 * 2.4e5 * 6e-6 / 2 = 1.44

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = thermal_elastic.e
[]

[Functions]
  [./ramp1]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 1e-6
  [../]
  [./ramp2]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 2e-6
  [../]
  [./ramp3]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 3e-6
  [../]
  [./ramp4]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 4e-6
  [../]
  [./ramp6]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 2.&#x27;
    scale_factor = 6e-6
  [../]
  [./tempFunc]
    type = PiecewiseLinear
    x = &#x27;0     1     2&#x27;
    y = &#x27;100.0 100.0 500.0&#x27;
  [../]
[]

[Variables]
  [./temp]
    initial_condition = 100.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_xz stress_yz&#x27;
    strain = FINITE
  [../]
[]

[Kernels]
  [./heat]
    type = Diffusion
    variable = temp
  [../]
[]

[BCs]
  [./node1_x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./node1_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = ramp2
  [../]
  [./node1_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 1
    function = ramp3
  [../]

  [./node2_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 2
    function = ramp1
  [../]
  [./node2_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = ramp2
  [../]
  [./node2_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 2
    function = ramp6
  [../]

  [./node3_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 3
    function = ramp1
  [../]
  [./node3_y]
    type = DirichletBC
    variable = disp_y
    boundary = 3
    value = 0.0
  [../]
  [./node3_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 3
    function = ramp3
  [../]

  [./node4_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./node4_y]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0.0
  [../]
  [./node4_z]
    type = DirichletBC
    variable = disp_z
    boundary = 4
    value = 0.0
  [../]

  [./node5_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 5
    function = ramp1
  [../]
  [./node5_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 5
    function = ramp4
  [../]
  [./node5_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 5
    function = ramp3
  [../]

  [./node6_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 6
    function = ramp2
  [../]
  [./node6_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 6
    function = ramp4
  [../]
  [./node6_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 6
    function = ramp6
  [../]

  [./node7_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 7
    function = ramp2
  [../]
  [./node7_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 7
    function = ramp2
  [../]
  [./node7_z]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = 7
    function = ramp3
  [../]

  [./node8_x]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 8
    function = ramp1
  [../]
  [./node8_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 8
    function = ramp2
  [../]
  [./node8_z]
    type = DirichletBC
    variable = disp_z
    boundary = 8
    value = 0.0
  [../]

  [./temp]
    type = FunctionDirichletBC
    variable = temp
    boundary = &#x27;10 12&#x27;
    function = tempFunc
  [../]
[]

[Materials]
  [./youngs_modulus]
    type = PiecewiseLinearInterpolationMaterial
    x = &#x27;100 500&#x27;
    y = &#x27;1e6 6e5&#x27;
    property = youngs_modulus
    variable = temp
  [../]
  [./poissons_ratio]
    type = PiecewiseLinearInterpolationMaterial
    x = &#x27;100 500&#x27;
    y = &#x27;0   0.25&#x27;
    property = poissons_ratio
    variable = temp
  [../]

  [./elasticity_tensor]
    type = ComputeVariableIsotropicElasticityTensor
    args = temp
    youngs_modulus = youngs_modulus
    poissons_ratio = poissons_ratio
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-9

  l_max_its = 20

  start_time = 0.0
  dt = 1.0
  end_time = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e39a44a4-4be9-4761-ae7b-d23cee2c1996"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/interaction_integral/interaction_integral_2d.i</h4><pre class="moose-pre"><code class="language-text">#This tests the Interaction Integral evaluation capability.
#This is a 2d nonlinear plane strain model

[GlobalParams]
  order = FIRST
#  order = SECOND
  family = LAGRANGE
  displacements = &#x27;disp_x disp_y&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = crack2d.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1.&#x27;
    y = &#x27;0. 1.&#x27;
    scale_factor = -1e2
  [../]
[]

[DomainIntegral]
  integrals = &#x27;InteractionIntegralKI InteractionIntegralKII InteractionIntegralKIII&#x27;
  boundary = 800
  crack_direction_method = CrackDirectionVector
  crack_direction_vector = &#x27;1 0 0&#x27;
  2d = true
  axis_2d = 2
  radius_inner = &#x27;4.0 4.5 5.0 5.5 6.0&#x27;
  radius_outer = &#x27;4.5 5.0 5.5 6.0 6.5&#x27;
  block = 1
  youngs_modulus = 207000
  poissons_ratio = 0.3
  output_q = false
  incremental = true
[]

[Modules/TensorMechanics/Master]
  [./master]
    strain = FINITE
    add_variables = true
    incremental = true
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress&#x27;
    planar_formulation = PLANE_STRAIN
  [../]
[]

[BCs]
  [./crack_y]
    type = DirichletBC
    variable = disp_y
    boundary = 100
    value = 0.0
  [../]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 700
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 400
      function = rampConstant
    [../]
  [../]
[] # BCs

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 207000
    poissons_ratio = 0.3
  [../]
  [./elastic_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]


[Executioner]
  type = Transient

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;101&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 20
  nl_abs_tol = 1e-5
  l_tol = 1e-2

  start_time = 0.0
  dt = 1

  end_time = 1
  num_steps = 1
[]

[Outputs]
  file_base = interaction_integral_2d_out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4e981835-3f9a-4e26-8074-d8d4fe606867"><div class="modal-content"><h4>modules/contact/test/tests/verification/hertz_cyl/half_symm_q4/hertz_cyl_half_1deg_template3.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = hertz_cyl_half_1deg.e
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./saved_x]
  [../]
  [./saved_y]
  [../]
  [./diag_saved_x]
  [../]
  [./diag_saved_y]
  [../]
  [./inc_slip_x]
  [../]
  [./inc_slip_y]
  [../]
  [./accum_slip_x]
  [../]
  [./accum_slip_y]
  [../]
  [./tang_force_x]
  [../]
  [./tang_force_y]
  [../]
[]

[Functions]
  [./disp_ramp_vert]
    type = PiecewiseLinear
    x = &#x27;0. 1. 11.&#x27;
    y = &#x27;0. -0.0020 -0.0020&#x27;
  [../]
  [./disp_ramp_horz]
    type = PiecewiseLinear
    x = &#x27;0. 1. 11.&#x27;
    y = &#x27;0. 0.0 0.0014&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    extra_vector_tags = &#x27;ref&#x27;
    save_in = &#x27;saved_x saved_y&#x27;
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./inc_slip_x]
    type = PenetrationAux
    variable = inc_slip_x
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./inc_slip_y]
    type = PenetrationAux
    variable = inc_slip_y
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_x]
    type = PenetrationAux
    variable = accum_slip_x
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./accum_slip_y]
    type = PenetrationAux
    variable = accum_slip_y
    execute_on = timestep_end
    boundary = 3
    paired_boundary = 2
  [../]
  [./tang_force_x]
    type = PenetrationAux
    variable = tang_force_x
    quantity = tangential_force_x
    boundary = 3
    paired_boundary = 2
  [../]
  [./tang_force_y]
    type = PenetrationAux
    variable = tang_force_y
    quantity = tangential_force_y
    boundary = 3
    paired_boundary = 2
  [../]
  [./penetration]
    type = PenetrationAux
    variable = penetration
    boundary = 3
    paired_boundary = 2
  [../]
[]

[Postprocessors]
  [./bot_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 1
  [../]
  [./bot_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 1
  [../]
  [./top_react_x]
    type = NodalSum
    variable = saved_x
    boundary = 4
  [../]
  [./top_react_y]
    type = NodalSum
    variable = saved_y
    boundary = 4
  [../]
  [./disp_x226]
    type = NodalVariableValue
    nodeid = 225
    variable = disp_x
  [../]
  [./disp_y226]
    type = NodalVariableValue
    nodeid = 225
    variable = disp_y
  [../]
  [./_dt]
    type = TimestepSize
  [../]
  [./num_lin_it]
    type = NumLinearIterations
  [../]
  [./num_nonlin_it]
    type = NumNonlinearIterations
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./top_y_disp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 4
    function = disp_ramp_vert
  [../]
  [./top_x_disp]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = disp_ramp_horz
  [../]
[]

[Materials]
  [./stuff1_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1&#x27;
    youngs_modulus = 1e10
    poissons_ratio = 0.0
  [../]
  [./stuff1_strain]
    type = ComputeFiniteStrain
    block = &#x27;1&#x27;
  [../]
  [./stuff1_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1&#x27;
  [../]
  [./stuff2_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;2&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff2_strain]
    type = ComputeFiniteStrain
    block = &#x27;2&#x27;
  [../]
  [./stuff2_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;2&#x27;
  [../]
  [./stuff3_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;3&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff3_strain]
    type = ComputeFiniteStrain
    block = &#x27;3&#x27;
  [../]
  [./stuff3_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;3&#x27;
  [../]
  [./stuff4_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;4&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff4_strain]
    type = ComputeFiniteStrain
    block = &#x27;4&#x27;
  [../]
  [./stuff4_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;4&#x27;
  [../]
  [./stuff5_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;5&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff5_strain]
    type = ComputeFiniteStrain
    block = &#x27;5&#x27;
  [../]
  [./stuff5_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;5&#x27;
  [../]
  [./stuff6_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;6&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff6_strain]
    type = ComputeFiniteStrain
    block = &#x27;6&#x27;
  [../]
  [./stuff6_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;6&#x27;
  [../]
  [./stuff7_elas_tens]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;7&#x27;
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./stuff7_strain]
    type = ComputeFiniteStrain
    block = &#x27;7&#x27;
  [../]
  [./stuff7_stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;7&#x27;
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu     superlu_dist&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-7
  nl_rel_tol = 1e-6
  l_max_its = 100
  nl_max_its = 200

  start_time = 0.0
  end_time = 2.0
  l_tol = 5e-4
  dt = 0.1
  dtmin = 0.1
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[VectorPostprocessors]
  [./x_disp]
    type = NodalValueSampler
    variable = disp_x
    boundary = &#x27;3 4&#x27;
    sort_by = id
  [../]
  [./y_disp]
    type = NodalValueSampler
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    sort_by = id
  [../]
  [./cont_press]
    type = NodalValueSampler
    variable = contact_pressure
    boundary = &#x27;3&#x27;
    sort_by = id
  [../]
[]

[Outputs]
  print_linear_residuals = true
  perf_graph = true
  [./exodus]
    type = Exodus
    elemental_as_nodal = true
  [../]
  [./console]
    type = Console
    max_rows = 5
  [../]
  [./chkfile]
    type = CSV
    show = &#x27;x_disp y_disp cont_press&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./chkfile2]
    type = CSV
    show = &#x27;bot_react_x bot_react_y disp_x226 disp_y226 top_react_x top_react_y&#x27;
    start_time = 0.9
    execute_vector_postprocessors_on = timestep_end
  [../]
  [./outfile]
    type = CSV
    delimiter = &#x27; &#x27;
    execute_vector_postprocessors_on = none
  [../]
[]

[Contact]
  [./interface]
    primary = 2
    secondary = 3
    disp_x = disp_x
    disp_y = disp_y
    model = coulomb
    friction_coefficient = 0.0
    formulation = penalty
    normalize_penalty = true
    tangential_tolerance = 1e-3
    penalty = 1e+9
  [../]
[]

[Dampers]
  [./contact_slip]
    type = ContactSlipDamper
    primary = &#x27;2&#x27;
    secondary = &#x27;3&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="435cd628-80e1-4bd4-80c9-c5abba422e27"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_1/gh_fu_20.i</h4><pre class="moose-pre"><code class="language-text"># investigating validity of immobile saturation
# 5 elements, full upwinding

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 5
  xmin = -1
  xmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = DensityConstBulk
  relperm_UO = RelPermPower
  SUPG_UO = SUPGnone
  sat_UO = Saturation
  seff_UO = SeffVG
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1 10 100 1000 10000&#x27;
    x = &#x27;0 10 100 1000 10000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E3
  [../]
  [./SeffVG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.1
  [../]
  [./SUPGnone]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pressure]
    order = FIRST
    family = LAGRANGE
    initial_condition = -1.0
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFullyUpwindFlux
    variable = pressure
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = SeffVG
    pressure_vars = pressure
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = 1E-3
    gravity = &#x27;-1 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1E0
  end_time = 1E5

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh_fu_20
  execute_on = &#x27;timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c30ae724-c401-493f-868f-7ce5cb208207"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free_orientation_inclined.i</h4><pre class="moose-pre"><code class="language-text"># Test to verify the fundamental natural frequency of a one element ADComputeShellStress
# BCs: Clamped on one end, free on others.
# Initial perturbation applied to edge of the beam. After that, the shell vibrates freely.
#
# Results have been compared for various thicknesses with the following approximate Results
# (Moose results were obtained with 8 elements along the length)
# Thickness = 0.1. Reference freq: 10.785 Hz, Moose freq: 10.612 Hz
# Thickness = 0.05. Reference freq: 5.393 Hz, Moose freq: 5.335 Hz
# Thickness = 0.025. Reference freq: 2.696 Hz, Moose freq: 2.660 Hz
#
# Reference values have been obtained from Robert Blevins, &quot;Formulas for Dynamics, Acoustics and Vibration&quot;,
# Table 5.3 case 11. Formula looks like: f = lambda^2/(2*pi*a^2) * sqrt(E*h^2/(12*(1-nu*nu))), where lambda
# changes as a function of shell dimensions.

# This test uses one single element for speed reasons.

# Here, the shell, instead of being on the XY plane, is oriented at a 45 deg. angle
# with respect to the Y axis.

[Mesh]
  type = FileMesh
  file = shell_inclined.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./rot_x]
  [../]
  [./rot_y]
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  # aux variables for dynamics
  [./vel_x]
  [../]
  [./vel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_x]
  [../]
  [./accel_y]
  [../]
  [./accel_z]
  [../]
  [./rot_vel_x]
  [../]
  [./rot_vel_y]
  [../]
  [./rot_accel_x]
  [../]
  [./rot_accel_y]
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    variable = stress_yy
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    variable = stress_yz
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 2
  [../]

# Kernels for dynamics
[./accel_x]
  type = NewmarkAccelAux
  variable = accel_x
  displacement = disp_x
  velocity = vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_x]
  type = NewmarkVelAux
  variable = vel_x
  acceleration = accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_y]
  type = NewmarkAccelAux
  variable = accel_y
  displacement = disp_y
  velocity = vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_y]
  type = NewmarkVelAux
  variable = vel_y
  acceleration = accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_z]
  type = NewmarkAccelAux
  variable = accel_z
  displacement = disp_z
  velocity = vel_z
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_z]
  type = NewmarkVelAux
  variable = vel_z
  acceleration = accel_z
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_x]
  type = NewmarkAccelAux
  variable = rot_accel_x
  displacement = rot_x
  velocity = rot_vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_x]
  type = NewmarkVelAux
  variable = rot_vel_x
  acceleration = rot_accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_y]
  type = NewmarkAccelAux
  variable = rot_accel_y
  displacement = rot_y
  velocity = rot_vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_y]
  type = NewmarkVelAux
  variable = rot_vel_y
  acceleration = rot_accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_function]
    type = PiecewiseLinear
    x = &#x27;0.0 0.01 0.15 10.0&#x27;
    y = &#x27;0.0 0.01 0.0 0.0&#x27;
  [../]
[]
[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;2&#x27;
    function = force_function
  [../]
[]
[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
  [../]

  [./inertial_force_x]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 0
    variable = disp_x
    thickness = 0.1
  [../]

  [./inertial_force_y]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 1
    variable = disp_y
    thickness = 0.1

  [../]

  [./inertial_force_z]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 2
    variable = disp_z
    thickness = 0.1

  [../]

  [./inertial_force_rot_x]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 3
    variable = rot_x
    thickness = 0.1
  [../]

  [./inertial_force_rot_y]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 4
    variable = rot_y
    thickness = 0.1
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 2100000
    poissons_ratio = 0.3
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeIncrementalShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 0.1
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_z_tip]
    type = PointValue
    point = &#x27;0.0 1.06 1.06&#x27;
    variable = disp_z
  [../]
  [./rot_x_tip]
    type = PointValue
    point = &#x27;0.0 1.06 1.06&#x27;
    variable = rot_x
  [../]
  [./stress_yy_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yy
  [../]
  [./stress_yy_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yy
  [../]
  [./stress_yy_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yy
  [../]
  [./stress_yy_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yy
  [../]
  [./stress_yz_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yz
  [../]
  [./stress_yz_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yz
  [../]
  [./stress_yz_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yz
  [../]
  [./stress_yz_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yz
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-10
  l_max_its = 20
  dt = 0.005
  dtmin = 0.005
  timestep_tolerance = 2e-13
  end_time = 0.5

  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]

[]

[Outputs]
  perf_graph = true
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bc010d63-9286-4f2a-9ae8-f22124f5e681"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/coupled_pressure/coupled_pressure_test.i</h4><pre class="moose-pre"><code class="language-text">#
# Pressure Test
#
# This test is designed to compute pressure loads on three faces of a unit cube.
# The pressure is computed as an auxiliary variable. It should give the same result
# as pressure_test.i
#
# The mesh is composed of one block with a single element.  Symmetry bcs are
# applied to the faces opposite the pressures.  Poisson&#x27;s ratio is zero,
# which makes it trivial to check displacements.
#


[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  type = FileMesh
  file = pressure_test.e
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 1.0
  [../]
  [./zeroRamp]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 0. 1.&#x27;
    scale_factor = 2.0
  [../]
  [./rampUnramp]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 0.&#x27;
    scale_factor = 10.0
  [../]
[]

[AuxVariables]
  [./pressure_1]
  [../]
  [./pressure_2]
  [../]
  [./pressure_3]
  [../]
[]

[AuxKernels]
  [./side1_pressure_ak]
    type = FunctionAux
    variable = pressure_1
    boundary = 1
    function = rampConstant
  [../]
  [./side2_pressure_ak]
    type = FunctionAux
    variable = pressure_2
    boundary = 2
    function = zeroRamp
  [../]
  [./side3_pressure_ak]
    type = FunctionAux
    variable = pressure_3
    boundary = 3
    function = rampUnramp
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./all]
        strain = SMALL
        add_variables = true
      [../]
    [../]
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 5
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./CoupledPressure]
    [./Side1]
      boundary = &#x27;1&#x27;
      pressure = pressure_1
      displacements = &#x27;disp_x disp_y disp_z&#x27;
    [../]
    [./Side2]
      boundary = &#x27;2&#x27;
      pressure = pressure_2
      displacements = &#x27;disp_x disp_y disp_z&#x27;
    [../]
  [../]

  [./side3_x]
    type = CoupledPressureBC
    variable = &#x27;disp_x&#x27;
    boundary = &#x27;3&#x27;
    pressure = pressure_3
    component = 0
  [../]
  [./side3_y]
    type = CoupledPressureBC
    variable = &#x27;disp_y&#x27;
    boundary = &#x27;3&#x27;
    pressure = pressure_3
    component = 1
  [../]
  [./side3_z]
    type = CoupledPressureBC
    variable = &#x27;disp_z&#x27;
    boundary = &#x27;3&#x27;
    pressure = pressure_3
    component = 2
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;0 0.5e6&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  nl_abs_tol = 1e-10
  l_max_its = 20
  start_time = 0.0
  dt = 1.0
  num_steps = 2
  end_time = 2.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="820cc8b4-0990-4987-a404-bf359d196dd4"><div class="modal-content"><h4>modules/richards/test/tests/gravity_head_2/gh_lumped_18.i</h4><pre class="moose-pre"><code class="language-text"># with immobile saturation
# unsaturated = true
# gravity = true
# supg = true
# transient = true
# lumped = true

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 20
  xmin = 0
  xmax = 1
[]


[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
  viscosity = &#x27;1E-3 0.5E-3&#x27;
  gravity = &#x27;-1 0 0&#x27;
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1E0 0.5E1 0.5E2 0.4E4 1E5 1E6 1E7&#x27;
    x = &#x27;0 1E-1 1E0 1E1 1E2 1E3 1E4 1E5 1E6&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0E2
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5E2
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.4
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.3
    n = 2
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
  [./SUPGgas]
    type = RichardsSUPGstandard
    p_SUPG = 1E-5
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./water_ic]
    type = ConstantIC
    value = 1
    variable = pwater
  [../]
  [./gas_ic]
    type = ConstantIC
    value = 2
    variable = pgas
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardstwater richardsfgas richardstgas&#x27;
  [./richardstwater]
    type = RichardsLumpedMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsLumpedMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFlux
    variable = pgas
  [../]
[]


[AuxVariables]
  [./seffgas]
  [../]
  [./seffwater]
  [../]
[]

[AuxKernels]
  [./seffgas_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffGas
    variable = seffgas
  [../]
  [./seffwater_kernel]
    type = RichardsSeffAux
    pressure_vars = &#x27;pwater pgas&#x27;
    seff_UO = SeffWater
    variable = seffwater
  [../]
[]

[Postprocessors]
  [./mwater_init]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mgas_init]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_begin
    outputs = none
  [../]
  [./mwater_fin]
    type = RichardsMass
    variable = pwater
    execute_on = timestep_end
    outputs = none
  [../]
  [./mgas_fin]
    type = RichardsMass
    variable = pgas
    execute_on = timestep_end
    outputs = none
  [../]

  [./mass_error_water]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_w
  [../]
  [./mass_error_gas]
    type = FunctionValuePostprocessor
    function = fcn_mass_error_g
  [../]

  [./pw_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./pw_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pwater
    outputs = none
  [../]
  [./error_water]
    type = FunctionValuePostprocessor
    function = fcn_error_water
  [../]

  [./pg_left]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./pg_right]
    type = PointValue
    point = &#x27;1 0 0&#x27;
    variable = pgas
    outputs = none
  [../]
  [./error_gas]
    type = FunctionValuePostprocessor
    function = fcn_error_gas
  [../]
[]

[Functions]
  [./fcn_mass_error_w]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mwater_init mwater_fin&#x27;
  [../]
  [./fcn_mass_error_g]
    type = ParsedFunction
    value = &#x27;abs(0.5*(mi-mf)/(mi+mf))&#x27;
    vars = &#x27;mi mf&#x27;
    vals = &#x27;mgas_init mgas_fin&#x27;
  [../]
  [./fcn_error_water]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;1E2 -1 pw_left 1 pw_right&#x27;
  [../]
  [./fcn_error_gas]
    type = ParsedFunction
    value = &#x27;abs((-b*log(-(gdens0*xval+(-b*exp(-p0/b)))/b)-p1)/p1)&#x27;
    vars = &#x27;b gdens0 p0 xval p1&#x27;
    vals = &#x27;0.5E2 -0.5 pg_left 1 pg_right&#x27;
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    linear_shape_fcns = true
  [../]
[]



[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  file_base = gh_lumped_18
  execute_on = &#x27;timestep_end final&#x27;
  interval = 100000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5e0709a3-1418-45fb-97e9-e4e8d37f815d"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/1D_axisymmetric/axisymm_plane_strain_finite.i</h4><pre class="moose-pre"><code class="language-text">#
# This test checks elastic stress calculations with mechanical and thermal
# strain using finite strain formulation. Young&#x27;s modulus is 3600, and Poisson&#x27;s ratio is 0.2.
# The axisymmetric, plane strain 1D mesh is pulled with displacement of 2e-3.
# Thus, the strain is [log(1+1e-3)=9.995e-4, 0, log(1+1e-3)=9.995e-4] (xx, yy, zz). This gives stress of
# [4.9975, 1.999, 4.9975].  After a temperature increase of 100 with alpha of
# 1e-6, the stress becomes [4.3975, 1.399, 4.3975].
#

[GlobalParams]
  displacements = disp_x
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = line.e
[]

[Variables]
  [./disp_x]
  [../]
[]

[AuxVariables]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;580 580 680&#x27;
  [../]
  [./disp_x]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 2e-3&#x27;
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./ps]
        planar_formulation = PLANE_STRAIN
        strain = FINITE
        generate_output = &#x27;strain_xx strain_zz stress_xx stress_yy stress_zz&#x27;
        eigenstrain_names = eigenstrain
      [../]
    [../]
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = temp
    execute_on = &#x27;timestep_begin&#x27;
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    boundary = 1
    value = 0
    variable = disp_x
  [../]
  [./disp_x]
    type = FunctionDirichletBC
    boundary = 2
    function = disp_x
    variable = disp_x
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 3600
    poissons_ratio = 0.2
  [../]

  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-6
    temperature = temp
    stress_free_temperature = 580
    eigenstrain_name = eigenstrain
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_max_its = 50
  l_tol = 1e-6
  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10
  start_time = 0
  end_time = 2
  num_steps = 2
[]

[Outputs]
  exodus = true
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="186ab161-8a9f-4881-9796-5b73550c8d65"><div class="modal-content"><h4>modules/geochemistry/test/tests/time_dependent_reactions/mixing.i</h4><pre class="moose-pre"><code class="language-text"># Seawater at temperature=4degC is slowly mixed with this fluid initially at temperature=273degC until a 10:1 ratio is achieved
[TimeDependentReactionSolver]
  model_definition = definition
  geochemistry_reactor_name = reactor
  swap_into_basis = &quot;H2S(aq)&quot;
  swap_out_of_basis = &quot;O2(aq)&quot;
  charge_balance_species = &quot;Cl-&quot;
  constraint_species = &quot;H2O              H+           Cl-    Na+    Mg++    SO4--   Ca++    K+      HCO3-  Ba++  SiO2(aq) Sr++     Zn++  Cu+     Al+++  Fe++   Mn++    H2S(aq)&quot;
  constraint_value = &quot;1.0                6.309573E-5  600E-3 529E-3 0.01E-6 0.01E-6 21.6E-3 26.7E-3 2.0E-3 15E-6 20.2E-3  100.5E-6 41E-6 0.02E-6 4.1E-6 903E-6 1039E-6 6.81E-3&quot;
  constraint_meaning = &quot;kg_solvent_water activity moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species moles_bulk_species&quot;
  close_system_at_time = -0.01
  remove_fixed_activity_name = &#x27;H+&#x27;
  remove_fixed_activity_time = -0.01
  initial_temperature = 273
  temperature = T
  # The following source species and rates are taken from the Geochemists Workbench (see output from mixing.rea)
  # An alternative is to run the seawater_mixing MOOSE input files and extract the source species and rates
  source_species_names = &quot;H2O Al+++ Ba++ Ca++ Cl- Cu+ Fe++ H+ HCO3- K+ Mg++ Mn++ Na+ O2(aq) SO4-- SiO2(aq) Sr++ Zn++&quot;
  source_species_rates = &quot;H2O_rate Al+++_rate Ba++_rate Ca++_rate Cl-_rate Cu+_rate Fe++_rate H+_rate HCO3-_rate K+_rate Mg++_rate Mn++_rate Na+_rate O2aq_rate SO4--_rate SiO2aq_rate Sr++_rate Zn++_rate&quot;
  mode = mode
  execute_console_output_on = &#x27;&#x27; # only CSV output needed for this example
  stoichiometric_ionic_str_using_Cl_only = true # for comparison with GWB
[]

[AuxVariables]
  [./T]
  [../]
  [./mode]
  [../]
  [./H2O_rate]
  [../]
  [./Al+++_rate]
  [../]
  [./Ba++_rate]
  [../]
  [./Ca++_rate]
  [../]
  [./Cl-_rate]
  [../]
  [./Cu+_rate]
  [../]
  [./Fe++_rate]
  [../]
  [./H+_rate]
  [../]
  [./HCO3-_rate]
  [../]
  [./K+_rate]
  [../]
  [./Mg++_rate]
  [../]
  [./Mn++_rate]
  [../]
  [./Na+_rate]
  [../]
  [./O2aq_rate]
  [../]
  [./SO4--_rate]
  [../]
  [./SiO2aq_rate]
  [../]
  [./Sr++_rate]
  [../]
  [./Zn++_rate]
  [../]
[]
[AuxKernels]
  [./mode_auxk]
    type = FunctionAux
    variable = mode
    function = &#x27;if(t&lt;=0, 1, 0)&#x27; # dump at start of first timestep
    execute_on = timestep_begin
  [../]
  [./T_auxk]
    type = FunctionAux
    variable = T
    function = &#x27;if(t&lt;=0, 273, 4)&#x27; # during initialisation and dumping, T=273, while during adding T=temperature of reactants
    execute_on = timestep_begin
  [../]
  [./H2O_rate_auxk]
    type = FunctionAux
    variable = H2O_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 55.510000000000005)&#x27;
  [../]
  [./Al+++_rate]
    type = FunctionAux
    variable = Al+++_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 3.643e-10)&#x27;
  [../]
  [./Ba++_rate]
    type = FunctionAux
    variable = Ba++_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 8.831e-08)&#x27;
  [../]
  [./Ca++_rate]
    type = FunctionAux
    variable = Ca++_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.0104)&#x27;
  [../]
  [./Cl-_rate]
    type = FunctionAux
    variable = Cl-_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.559)&#x27;
  [../]
  [./Cu+_rate]
    type = FunctionAux
    variable = Cu+_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 7.000000000000001e-09)&#x27;
  [../]
  [./Fe++_rate]
    type = FunctionAux
    variable = Fe++_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 4.746e-15)&#x27;
  [../]
  [./H+_rate]
    type = FunctionAux
    variable = H+_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.0002005)&#x27;
  [../]
  [./HCO3-_rate]
    type = FunctionAux
    variable = HCO3-_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.002153)&#x27;
  [../]
  [./K+_rate]
    type = FunctionAux
    variable = K+_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.010100000000000001)&#x27;
  [../]
  [./Mg++_rate]
    type = FunctionAux
    variable = Mg++_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.054400000000000004)&#x27;
  [../]
  [./Mn++_rate]
    type = FunctionAux
    variable = Mn++_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 6.79e-14)&#x27;
  [../]
  [./Na+_rate]
    type = FunctionAux
    variable = Na+_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.48019999999999996)&#x27;
  [../]
  [./O2aq_rate]
    type = FunctionAux
    variable = O2aq_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.000123)&#x27;
  [../]
  [./SO4--_rate]
    type = FunctionAux
    variable = SO4--_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.0295)&#x27;
  [../]
  [./SiO2aq_rate]
    type = FunctionAux
    variable = SiO2aq_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 0.00017)&#x27;
  [../]
  [./Sr++_rate]
    type = FunctionAux
    variable = Sr++_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 3.8350000000000004e-05)&#x27;
  [../]
  [./Zn++_rate]
    type = FunctionAux
    variable = Zn++_rate
    execute_on = timestep_begin
    function = &#x27;if(t&lt;=0, 0, 1e-08)&#x27;
  [../]
[]

[Postprocessors]
  [./temperature]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;solution_temperature&quot;
  [../]
  [./fugactity_O2]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;activity_O2(g)&quot;
  [../]
  [./molal_SO4--]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;molal_SO4--&quot;
  [../]
  [./molal_NaSO4]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;molal_NaSO4-&quot;
  [../]
  [./molal_H2Saq]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;molal_H2S(aq)&quot;
  [../]
  [./molal_HSO4-]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;molal_HSO4-&quot;
  [../]
  [./cm3_Anhydrite]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;free_cm3_Anhydrite&quot;
  [../]
  [./cm3_Pyrite]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;free_cm3_Pyrite&quot;
  [../]
  [./cm3_Talc]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;free_cm3_Talc&quot;
  [../]
  [./cm3_AmSil]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = &quot;free_cm3_Amrph^silica&quot;
  [../]
[]

[Functions]
  [./timestepper]
    type = PiecewiseLinear
    x = &#x27;0    0.1  1   10&#x27;
    y = &#x27;0.01 0.01 0.5 10&#x27;
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.01 # to allow initial dump to occur
  [./TimeStepper]
    type = FunctionDT
    function = timestepper
  [../]
  end_time = 10
[]

[UserObjects]
  [./definition]
    type = GeochemicalModelDefinition
    database_file = &quot;../../../database/moose_geochemdb.json&quot;
    basis_species = &quot;H2O H+ Cl- Na+ Mg++ SO4-- Ca++ K+ HCO3- Ba++ SiO2(aq) Sr++ Zn++ Cu+ Al+++ Fe++ Mn++ O2(aq)&quot;
    equilibrium_minerals = &quot;Anhydrite Pyrite Talc Amrph^silica Barite Dolomite-ord Muscovite Nontronit-Na Pyrolusite Strontianite&quot;
    equilibrium_gases = &quot;O2(g)&quot;
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a52ded63-bdde-40b3-b7d6-08bfb7a8f7aa"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_pressure/pressure_test.i</h4><pre class="moose-pre"><code class="language-text">#
# Pressure Test
#
# This test is designed to compute pressure loads on three faces of a unit cube.
#
# The mesh is composed of one block with a single element.  Symmetry bcs are
# applied to the faces opposite the pressures.  Poisson&#x27;s ratio is zero,
# which makes it trivial to check displacements.
#


[Mesh]
  type = FileMesh
  file = pressure_test.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./rampConstant]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 1.&#x27;
    scale_factor = 1.0
  [../]
  [./zeroRamp]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 0. 1.&#x27;
    scale_factor = 1.0
  [../]
  [./rampUnramp]
    type = PiecewiseLinear
    x = &#x27;0. 1. 2.&#x27;
    y = &#x27;0. 1. 0.&#x27;
    scale_factor = 10.0
  [../]
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = 4
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = 5
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = 6
    value = 0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = 1
      function = rampConstant
      displacements = &#x27;disp_x disp_y disp_z&#x27;
      use_automatic_differentiation = true
    [../]
    [./Side2]
      boundary = 2
      function = zeroRamp
      displacements = &#x27;disp_x disp_y disp_z&#x27;
      use_automatic_differentiation = true
      factor = 2.0
    [../]
    [./Side3]
      boundary = 3
      function = rampUnramp
      displacements = &#x27;disp_x disp_y disp_z&#x27;
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ADComputeElasticityTensor
    block = 1
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;0 0.5e6&#x27;
  [../]
  [./strain]
    type = ADComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    block = 1
  [../]
  [./stress]
    type = ADComputeLinearElasticStress
    block = 1
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  nl_abs_tol = 1e-10
  l_max_its = 20
  start_time = 0.0
  dt = 1.0
  num_steps = 2
  end_time = 2.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e23a1b6d-4229-4078-ba05-f309b563caf8"><div class="modal-content"><h4>modules/peridynamics/test/tests/generalized_plane_strain/planestrain_prescribed_OSPD.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  scalar_out_of_plane_strain = scalar_strain_zz
[]

[Mesh]
  type = PeridynamicsMesh
  horizon_number = 3

  [./gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 4
    ny = 4
  [../]
  [./gpd]
    type = MeshGeneratorPD
    input = gmg
    retain_fe_mesh = false
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./scalar_strain_zz]
    order = FIRST
    family = SCALAR
  [../]

  [./strain_zz]
  [../]
[]

[Modules/Peridynamics/Mechanics/Master]
  [./all]
    formulation = ORDINARY_STATE
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = tempfunc
    use_displaced_mesh = false
  [../]

  [./strain_zz]
    type = NodalRankTwoPD
    variable = strain_zz
    rank_two_tensor = total_strain
    output_type = component
    index_i = 2
    index_j = 2
  [../]
[]

[AuxScalarKernels]
  [./scalar_strain_zz]
    type = FunctionScalarAux
    variable = scalar_strain_zz
    function = scalar_strain_zz_func
  [../]
[]

[Functions]
  [./tempfunc]
    type = ParsedFunction
    value = &#x27;(1 - x) * t&#x27;
  [../]
  [./scalar_strain_zz_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 0
               1 7.901e-5
               2 1.103021e-2&#x27;
  [../]
[]

[BCs]
  [./bottom_x]
    type = DirichletBC
    boundary = 1000
    variable = disp_x
    value = 0.0
  [../]
  [./bottom_y]
    type = DirichletBC
    boundary = 1000
    variable = disp_y
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    poissons_ratio = 0.3
    youngs_modulus = 1e6
  [../]

  [./force_density]
    type = ComputeSmallStrainConstantHorizonMaterialOSPD
    temperature = temp
    thermal_expansion_coeff = 0.02
    stress_free_temperature = 0.5
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  line_search = none

  start_time = 0.0
  end_time = 2.0
[]

[Outputs]
  exodus = true
  file_base = planestrain_prescribed_OSPD
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a1a4d425-cbc2-4127-a3d6-84f70e78e4f5"><div class="modal-content"><h4>modules/combined/test/tests/inelastic_strain/creep/creep_nl1.i</h4><pre class="moose-pre"><code class="language-text">#
# Test for effective strain calculation.
# Boundary conditions from NAFEMS test NL1
#
# This is not a verification test. This is the creep analog of the same test
# in the elas_plas directory. Instead of using the IsotropicPlasticity
# material model this test uses the PowerLawCreep material model.
#
[GlobalParams]
  temperature = temp
  order = FIRST
  family = LAGRANGE
  volumetric_locking_correction = true
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  file = one_elem2.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./temp]
    initial_condition = 600.0
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./vonmises]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./pressure]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./elastic_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./creep_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./creep_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./creep_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./tot_strain_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./eff_creep_strain]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    decomposition_method = EigenSolution
  [../]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat_ie]
    type = HeatConductionTimeDerivative
    variable = temp
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
    execute_on = timestep_end
  [../]
  [./vonmises]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = vonmises
    scalar_type = VonMisesStress
    execute_on = timestep_end
  [../]
  [./pressure]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = pressure
    scalar_type = Hydrostatic
    execute_on = timestep_end
  [../]
  [./elastic_strain_xx]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./elastic_strain_yy]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./elastic_strain_zz]
    type = RankTwoAux
    rank_two_tensor = elastic_strain
    variable = elastic_strain_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./creep_strain_xx]
    type = RankTwoAux
    rank_two_tensor = creep_strain
    variable = creep_strain_xx
    index_i = 0
    index_j = 0
    execute_on = timestep_end
  [../]
  [./creep_strain_yy]
    type = RankTwoAux
    rank_two_tensor = creep_strain
    variable = creep_strain_yy
    index_i = 1
    index_j = 1
    execute_on = timestep_end
  [../]
  [./creep_strain_zz]
    type = RankTwoAux
    rank_two_tensor = creep_strain
    variable = creep_strain_zz
    index_i = 2
    index_j = 2
    execute_on = timestep_end
  [../]
  [./tot_strain_xx]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_xx
    index_i = 0
    index_j = 0
  [../]
  [./tot_strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_yy
    index_i = 1
    index_j = 1
  [../]
  [./tot_strain_zz]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = tot_strain_zz
    index_i = 2
    index_j = 2
  [../]
  [./eff_creep_strain]
    type = MaterialRealAux
    property = effective_creep_strain
    variable = eff_creep_strain
  [../]
[]

[Functions]
  [./appl_dispy]
    type = PiecewiseLinear
    x = &#x27;0     1.0     2.0&#x27;
    y = &#x27;0.0 0.25e-4 0.50e-4&#x27;
  [../]
[]

[BCs]
  [./side_x]
    type = DirichletBC
    variable = disp_x
    boundary = 101
    value = 0.0
  [../]
  [./origin_x]
    type = DirichletBC
    variable = disp_x
    boundary = 103
    value = 0.0
  [../]
  [./bot_y]
    type = DirichletBC
    variable = disp_y
    boundary = 102
    value = 0.0
  [../]
  [./origin_y]
    type = DirichletBC
    variable = disp_y
    boundary = 103
    value = 0.0
  [../]
  [./top_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 1
    function = appl_dispy
  [../]
  [./temp_fix]
    type = DirichletBC
    variable = temp
    boundary = &#x27;1 2&#x27;
    value = 600.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = 1
    youngs_modulus = 250e9
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputePlaneFiniteStrain
    block = 1
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    block = 1
    inelastic_models = &#x27;powerlawcrp&#x27;
  [../]
  [./powerlawcrp]
    type = PowerLawCreepStressUpdate
    block = 1
    coefficient = 3.125e-14
    n_exponent = 5.0
    m_exponent = 0.0
    activation_energy = 0.0
  [../]
  [./thermal]
    type = HeatConductionMaterial
    block = 1
    specific_heat = 1.0
    thermal_conductivity = 100.
  [../]
  [./density]
    type = Density
    block = 1
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-12
  l_tol = 1e-6
  l_max_its = 100
  nl_max_its = 20

  dt = 1.0
  start_time = 0.0
  num_steps = 100
  end_time = 2.0
[]

[Postprocessors]
  [./stress_xx]
    type = ElementAverageValue
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ElementAverageValue
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ElementAverageValue
    variable = stress_xy
  [../]
  [./vonmises]
    type = ElementAverageValue
    variable = vonmises
  [../]
  [./pressure]
    type = ElementAverageValue
    variable = pressure
  [../]
  [./el_strain_xx]
    type = ElementAverageValue
    variable = elastic_strain_xx
  [../]
  [./el_strain_yy]
    type = ElementAverageValue
    variable = elastic_strain_yy
  [../]
  [./el_strain_zz]
    type = ElementAverageValue
    variable = elastic_strain_zz
  [../]
  [./crp_strain_xx]
    type = ElementAverageValue
    variable = creep_strain_xx
  [../]
  [./crp_strain_yy]
    type = ElementAverageValue
    variable = creep_strain_yy
  [../]
  [./crp_strain_zz]
    type = ElementAverageValue
    variable = creep_strain_zz
  [../]
  [./eff_creep_strain]
    type = ElementAverageValue
    variable = eff_creep_strain
  [../]
  [./tot_strain_xx]
    type = ElementAverageValue
    variable = tot_strain_xx
  [../]
  [./tot_strain_yy]
    type = ElementAverageValue
    variable = tot_strain_yy
  [../]
  [./tot_strain_zz]
    type = ElementAverageValue
    variable = tot_strain_zz
  [../]
  [./disp_x1]
    type = NodalVariableValue
    nodeid = 0
    variable = disp_x
  [../]
  [./disp_x4]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_x
  [../]
  [./disp_y1]
    type = NodalVariableValue
    nodeid = 0
    variable = disp_y
  [../]
  [./disp_y4]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./_dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="84286a1a-8e32-474a-8fb4-8e8d6b759f56"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test3q.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test3q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 2.0 -2.0  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-10
  l_max_its = 10

  start_time = 0.0
  dt = 0.02
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test3q_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0d286563-798b-4996-a9a8-b2f0c547bb42"><div class="modal-content"><h4>test/tests/misc/check_error/function_file_test8.i</h4><pre class="moose-pre"><code class="language-text"># Test for usage of missing function
[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = ic_function
    [../]
  [../]

[]

[Functions]
  [./ic_function]
    type = PiecewiseLinear
    xy_data = &#x27;1 2 3&#x27;
    scale_factor = 1.0
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a84c8d2e-8677-4347-8701-6f285b3ef78a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/2D/2d_consistent_implicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for the central difference time integrator for a 2D mesh

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 2.0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
[]

[BCs]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./x_bot]
    type = PresetDisplacement
    boundary = bottom
    variable = disp_x
    beta = 0.25
    velocity = vel_x
    acceleration = accel_x
    function = disp
  [../]
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 1e4
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_abs_tol = 1e-11
  nl_rel_tol = 1e-11
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./accel_2x]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_x
  [../]
  [./accel_2y]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9c5c6658-119d-4d5f-97e6-a32318413b53"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/small_linear.i</h4><pre class="moose-pre"><code class="language-text"># This tests the thermal expansion coefficient function using both
# options to specify that function: mean and instantaneous.  There
# two blocks, each containing a single element, and these use the
# two variants of the function.

# In this test, the instantaneous CTE function is a linear function
# while the mean CTE function is an analytic function designed to
# give the same response.  If \bar{alpha}(T) is the mean CTE function,
# and \alpha(T) is the instantaneous CTE function,

# \bar{\alpha}(T) = 1/(T-Tref) \intA^{T}_{Tsf} \alpha(T) dT

# where Tref is the reference temperature used to define the mean CTE
# function, and Tsf is the stress-free temperature.

# This version of the test uses small deformation theory.  The results
# from the two models are identical.

[Mesh]
  file = &#x27;blocks.e&#x27;
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = 3
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = 1
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = temp_func
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ADComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain1]
    type = ADComputeMeanThermalExpansionFunctionEigenstrain
    block = 1
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 0.5
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
  [./thermal_expansion_strain2]
    type = ADComputeInstantaneousThermalExpansionFunctionEigenstrain
    block = 2
    thermal_expansion_function = cte_func_inst
    stress_free_temperature = 0.0
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;tsf tref scale&#x27; #stress free temp, reference temp, scale factor
    vals = &#x27;0.0 0.5  1e-4&#x27;
    value = &#x27;scale * (0.5 * t^2 - 0.5 * tsf^2) / (t - tref)&#x27;
  [../]
  [./cte_func_inst]
    type = PiecewiseLinear
    xy_data = &#x27;0 0.0
               2 2.0&#x27;
    scale_factor = 1e-4
  [../]

  [./temp_func]
    type = PiecewiseLinear
    xy_data = &#x27;0 1
               1 2&#x27;
  [../]
[]

[Postprocessors]
  [./disp_1]
    type = NodalMaxValue
    variable = disp_x
    boundary = 101
  [../]

  [./disp_2]
    type = NodalMaxValue
    variable = disp_x
    boundary = 102
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  l_max_its = 100
  l_tol = 1e-4
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  start_time = 0.0
  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5ff6185b-271d-4599-807a-8b0333e319fe"><div class="modal-content"><h4>modules/richards/test/tests/dirac/bh07.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = bh07_input.e
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1000 10000&#x27;
    x = &#x27;100 1000&#x27;
  [../]
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E9
  [../]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-5
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.0
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0
    sum_s_res = 0
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E8
  [../]

  [./borehole_total_outflow_mass]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  active = &#x27;pressure&#x27;
  [./pressure]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./p_ic]
    type = FunctionIC
    variable = pressure
    function = initial_pressure
  [../]
[]

[BCs]
  [./fix_outer]
    type = DirichletBC
    boundary = perimeter
    variable = pressure
    value = 1E7
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
[]


[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    variable = pressure
  [../]
[]

[DiracKernels]
  [./bh]
    type = RichardsBorehole
    bottom_pressure = 0
    point_file = bh07.bh
    SumQuantityUO = borehole_total_outflow_mass
    variable = pressure
    unit_weight = &#x27;0 0 0&#x27;
    re_constant = 0.1594
    character = 2
  [../]
[]


[Postprocessors]
  [./bh_report]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_mass
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./fluid_mass]
    type = RichardsMass
    variable = pressure
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]


[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = 1E7
  [../]
[]


[Materials]
  [./all]
    type = RichardsMaterial
    block = 1
    viscosity = 1E-3
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-11 0 0  0 1E-11 0  0 0 1E-11&#x27;
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    sat_UO = Saturation
    seff_UO = Seff1VG
    SUPG_UO = SUPGstandard
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 1000
  solve_type = NEWTON

  [./TimeStepper]
    # get only marginally better results for smaller time steps
    type = FunctionDT
    function = dts
  [../]

[]

[Outputs]
  file_base = bh07
  execute_on = &#x27;initial timestep_end final&#x27;
  interval = 10000
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6591a1af-8879-44d0-8bf5-9ae187b8c6bc"><div class="modal-content"><h4>test/tests/multiapps/picard/function_dt_sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 10
[]

[Functions]
  [./u_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]

  [./dts]
    type = PiecewiseLinear
    x = &#x27;0.1  10&#x27;
    y = &#x27;0.1  10&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = u_fn
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10
  start_time = 0
  num_steps = 3
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d539d47e-88d0-4ed5-af7c-7e60356e2d70"><div class="modal-content"><h4>modules/combined/test/tests/combined_plasticity_temperature/ad_plasticity_temperature_dep_yield.i</h4><pre class="moose-pre"><code class="language-text">#
# This is a test of the piece-wise linear strain hardening model using the
# small strain formulation.  This test exercises the temperature-dependent
# yield stress.
#
# Test procedure:
# 1. The element is pulled to and then beyond the yield stress for a given
# temperature.
# 2. The displacement is then constant while the temperature increases and
# the yield stress decreases.  This results in a lower stress with more
# plastic strain.
# 3. The temperature decreases beyond its original value giving a higher
# yield stress.  The displacement increases, causing increases stress to
# the new yield stress.
# 4. The temperature and yield stress are constant with increasing
# displacement giving a constant stress and more plastic strain.
#
# Plotting total_strain_yy on the x axis and stress_yy on the y axis shows
# the stress history in a clear way.
#
#  s |
#  t |            *****
#  r |           *
#  e |   *****  *
#  s |  *    * *
#  s | *     *
#    |*
#    +------------------
#           total strain
#

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    incremental = true
    add_variables = true
    generate_output = &#x27;stress_yy plastic_strain_xx plastic_strain_yy plastic_strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./top_pull]
    type = PiecewiseLinear
    x = &#x27;0 1     2    4    5    6&#x27;
    y = &#x27;0 0.025 0.05 0.05 0.06 0.085&#x27;
  [../]
  [./yield]
    type = PiecewiseLinear
    x = &#x27;400 500 600&#x27;
    y = &#x27;6e3 5e3 4e3&#x27;
  [../]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2   3   4&#x27;
    y = &#x27;500 500 500 600 400&#x27;
  [../]
[]

[Kernels]
  [./heat]
    type = ADHeatConduction
    variable = temp
  [../]
[]

[BCs]
  [./y_pull_function]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = top_pull
  [../]
  [./x_bot]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./z_bot]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
  [./temp]
    type = FunctionDirichletBC
    variable = temp
    function = temp
    boundary = left
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    block = 0
    youngs_modulus = 2.0e5
    poissons_ratio = 0.3
  [../]
  [./creep_plas]
    type = ADComputeMultipleInelasticStress
    block = 0
    inelastic_models = &#x27;plasticity&#x27;
    max_iterations = 50
    absolute_tolerance = 1e-05
  [../]
  [./plasticity]
    type = ADIsotropicPlasticityStressUpdate
    block = 0
    hardening_constant = 0
    yield_stress_function = yield
    temperature = temp
  [../]
  [./heat_conduction]
    type = ADHeatConductionMaterial
    block = 0
    specific_heat = 1
    thermal_conductivity = 1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10
  l_tol = 1e-9

  start_time = 0.0
  end_time = 6
  dt = 0.1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1205ff51-8ade-4a29-b550-3c0c5bda8448"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/truss/truss_plastic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  elem_type = EDGE
  nx = 1
[]

[GlobalParams]
  displacements = &#x27;disp_x&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
 [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./hf]
    type = PiecewiseLinear
    x = &#x27;0    0.0001  0.0003  0.0023&#x27;
    y = &#x27;50e6 52e6    54e6    56e6&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./load]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = right
    function = &#x27;t&#x27;
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    property = e_over_l
    variable = e_over_l
  [../]
  [./area]
    type = ConstantAux
    variable = area
    value = 1.0
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Postprocessors]
  [./s_xx]
    type = ElementIntegralMaterialProperty
    mat_prop = axial_stress
  [../]
  [./e_xx]
    type = ElementIntegralMaterialProperty
    mat_prop = total_stretch
  [../]
  [./ee_xx]
    type = ElementIntegralMaterialProperty
    mat_prop = elastic_stretch
  [../]
  [./ep_xx]
    type = ElementIntegralMaterialProperty
    mat_prop = plastic_stretch
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  nl_abs_tol = 1e-11
  l_max_its = 20
  dt = 5e-5
  num_steps = 10
[]

[Kernels]
  [./solid]
    type = StressDivergenceTensorsTruss
    component = 0
    variable = disp_x
    area = area
    save_in = react_x
  [../]
[]

[Materials]
  [./truss]
    type = PlasticTruss
    youngs_modulus = 2.0e11
    yield_stress = 500e5
    outputs = exodus
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9b4d52f9-efd5-4b11-ae1a-1ed0bcc4b44c"><div class="modal-content"><h4>modules/richards/test/tests/dirac/q2p01.i</h4><pre class="moose-pre"><code class="language-text"># unsaturated
# production
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    y = &#x27;1E-2 1E-1 1 1E1 1E2 1E3&#x27;
    x = &#x27;0 1E-1 1 1E1 1E2 1E3&#x27;
  [../]
[]


[UserObjects]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 0.5
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.3
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.2
    n = 2
  [../]
  [./RelPermGas]
    type = Q2PRelPermPowerGas
    simm = 0.1
    n = 3
  [../]

  [./borehole_total_outflow_water]
    type = RichardsSumQuantity
  [../]
  [./borehole_total_outflow_gas]
    type = RichardsSumQuantity
  [../]
[]


[Variables]
  [./pp]
  [../]
  [./sat]
  [../]
[]

[ICs]
  [./p_ic]
    type = ConstantIC
    variable = pp
    value = 1
  [../]
  [./s_ic]
    type = ConstantIC
    variable = sat
    value = 0.5
  [../]
[]


[Q2P]
  porepressure = pp
  saturation = sat
  water_density = DensityWater
  water_relperm = RelPermWater
  water_viscosity = 0.8
  gas_density = DensityGas
  gas_relperm = RelPermGas
  gas_viscosity = 0.5
  diffusivity = 0.0
  output_total_masses_to = &#x27;CSV&#x27;
[]

[DiracKernels]
  [./bh_water]
    type = Q2PBorehole
    bottom_pressure = 0
    point_file = bh02.bh
    SumQuantityUO = borehole_total_outflow_water
    variable = sat
    unit_weight = &#x27;0 0 0&#x27;
    character = 8E9
    fluid_density = DensityWater
    fluid_relperm = RelPermWater
    other_var = pp
    var_is_porepressure = false
    fluid_viscosity = 0.8
  [../]
  [./bh_gas]
    type = Q2PBorehole
    bottom_pressure = 0
    point_file = bh02.bh
    SumQuantityUO = borehole_total_outflow_gas
    variable = pp
    unit_weight = &#x27;0 0 0&#x27;
    character = 1E10
    fluid_density = DensityGas
    fluid_relperm = RelPermGas
    other_var = sat
    var_is_porepressure = true
    fluid_viscosity = 0.5
  [../]
[]



[Postprocessors]
  [./bh_report_water]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_water
  [../]
  [./bh_report_gas]
    type = RichardsPlotQuantity
    uo = borehole_total_outflow_gas
  [../]

  [./p0]
    type = PointValue
    variable = pp
    point = &#x27;1 1 1&#x27;
    execute_on = timestep_end
  [../]
  [./sat0]
    type = PointValue
    variable = sat
    point = &#x27;1 1 1&#x27;
    execute_on = timestep_end
  [../]
[]




[Materials]
  [./rock]
    type = Q2PMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-12 0 0  0 1E-12 0  0 0 1E-12&#x27;
    gravity = &#x27;0 0 0&#x27;
  [../]
[]


[Preconditioning]
  [./usual]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -ksp_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-10 1E-10 10000 30&#x27;
  [../]
[]


[Executioner]
  type = Transient
  end_time = 1E3
  solve_type = NEWTON

  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]


[]

[Outputs]
  file_base = q2p01
  execute_on = timestep_end
  [./CSV]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c48b0aba-dabb-43a7-846c-c15b0befd76b"><div class="modal-content"><h4>test/tests/geomsearch/2d_moving_penetration/pl_test1q.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = pl_test1q.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./distance]
  [../]
  [./tangential_distance]
  [../]
  [./normal_x]
  [../]
  [./normal_y]
  [../]
  [./closest_point_x]
  [../]
  [./closest_point_y]
  [../]
  [./element_id]
  [../]
  [./side]
  [../]
[]

[Kernels]
  [./diff_x]
    type = Diffusion
    variable = disp_x
  [../]
  [./diff_y]
    type = Diffusion
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./penetrate]
    type = PenetrationAux
    variable = distance
    boundary = 11            #secondary
    paired_boundary = 12     #primary
  [../]

  [./penetrate2]
    type = PenetrationAux
    variable = distance
    boundary = 12            #secondary
    paired_boundary = 11     #primary
  [../]

  [./penetrate3]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 11
    paired_boundary = 12
    quantity = tangential_distance
  [../]

  [./penetrate4]
    type = PenetrationAux
    variable = tangential_distance
    boundary = 12
    paired_boundary = 11
    quantity = tangential_distance
  [../]

  [./penetrate5]
    type = PenetrationAux
    variable = normal_x
    boundary = 11
    paired_boundary = 12
    quantity = normal_x
  [../]

  [./penetrate6]
    type = PenetrationAux
    variable = normal_x
    boundary = 12
    paired_boundary = 11
    quantity = normal_x
  [../]

  [./penetrate7]
    type = PenetrationAux
    variable = normal_y
    boundary = 11
    paired_boundary = 12
    quantity = normal_y
  [../]

  [./penetrate8]
    type = PenetrationAux
    variable = normal_y
    boundary = 12
    paired_boundary = 11
    quantity = normal_y
  [../]

  [./penetrate9]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_x
  [../]

  [./penetrate10]
    type = PenetrationAux
    variable = closest_point_x
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_x
  [../]

  [./penetrate11]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 11
    paired_boundary = 12
    quantity = closest_point_y
  [../]

  [./penetrate12]
    type = PenetrationAux
    variable = closest_point_y
    boundary = 12
    paired_boundary = 11
    quantity = closest_point_y
  [../]

  [./penetrate13]
    type = PenetrationAux
    variable = element_id
    boundary = 11
    paired_boundary = 12
    quantity = element_id
  [../]

  [./penetrate14]
    type = PenetrationAux
    variable = element_id
    boundary = 12
    paired_boundary = 11
    quantity = element_id
  [../]

  [./penetrate15]
    type = PenetrationAux
    variable = side
    boundary = 11
    paired_boundary = 12
    quantity = side
  [../]

  [./penetrate16]
    type = PenetrationAux
    variable = side
    boundary = 12
    paired_boundary = 11
    quantity = side
  [../]
[]

[BCs]
  [./b1x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]

  [./b1y]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./b2x]
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]

  [./b2y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 2
    function = disp_y
  [../]
[]

[Functions]
  [./disp_y]
    type = PiecewiseLinear
    x = &#x27;0.0 0.25 0.75 1.0&#x27;
    y = &#x27;0.0 0.7 -0.7  0.0&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_ksp_ew&#x27;

  nl_rel_tol = 1.e-9
  l_max_its = 10

  start_time = 0.0
  dt = 0.05
  end_time = 1.0
  [./Quadrature]
    order = THIRD
  [../]
[]

[Outputs]
  file_base = pl_test1q_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3d398e3f-510d-40d7-8188-4609326ab58d"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_smeared_cracking/cracking.i</h4><pre class="moose-pre"><code class="language-text">#
# Simple pull test for cracking.
# The stress increases for two steps and then drops to zero.

[Mesh]
  file = cracking_test.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Functions]
  [./displ]
    type = PiecewiseLinear
    x = &#x27;0 1 2 3  4&#x27;
    y = &#x27;0 1 0 -1 0&#x27;
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./pull]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 4
    function = displ
  [../]
  [./left]
    type = ADDirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./bottom]
    type = ADDirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
  [./back]
    type = ADDirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 2.8e7
    poissons_ratio = 0
  [../]
  [./elastic_stress]
    type = ADComputeSmearedCrackingStress
    cracking_stress = 1.68e6
    softening_models = abrupt_softening
  [../]
  [./abrupt_softening]
    type = ADAbruptSoftening
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;101                asm      lu&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 100
  nl_max_its = 100
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  l_tol = 1e-5
  start_time = 0.0
  end_time = 0.1
  dt = 0.025
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1ae9de4a-3a12-45dd-91b0-48490e65454a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/rayleigh_damping/rayleigh_newmark.i</h4><pre class="moose-pre"><code class="language-text"># Test for rayleigh damping implemented using Newmark time integration

# The test is for an 1D bar element of  unit length fixed on one end
# with a ramped pressure boundary condition applied to the other end.
# zeta and eta correspond to the stiffness and mass proportional rayleigh damping
# beta and gamma are Newmark time integration parameters
# The equation of motion in terms of matrices is:
#
# M*accel + eta*M*vel + zeta*K*vel + K*disp = P*Area
#
# Here M is the mass matrix, K is the stiffness matrix, P is the applied pressure
#
# This equation is equivalent to:
#
# density*accel + eta*density*vel + zeta*d/dt(Div stress) + Div stress = P
#
# The first two terms on the left are evaluated using the Inertial force kernel
# The next two terms on the left involving zeta are evaluated using the
# DynamicStressDivergenceTensors Kernel
# The residual due to Pressure is evaluated using Pressure boundary condition
#
# The system will come to steady state slowly after the pressure becomes constant.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 1.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./strain_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]

[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    zeta = 0.1
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    velocity = vel_x
    acceleration = accel_x
    beta = 0.25
    gamma = 0.5
    eta=0.1
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    velocity = vel_y
    acceleration = accel_y
    beta = 0.25
    gamma = 0.5
    eta=0.1
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    velocity = vel_z
    acceleration = accel_z
    beta = 0.25
    gamma = 0.5
    eta = 0.1
  [../]

[]

[AuxKernels]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    beta = 0.25
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    gamma = 0.5
    execute_on = timestep_end
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 0
    index_j = 1
  [../]
  [./strain_yy]
    type = RankTwoAux
    rank_two_tensor = total_strain
    variable = strain_yy
    index_i = 0
    index_j = 1
  [../]

[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
    type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./Pressure]
    [./Side1]
      boundary = bottom
      function = pressure
      disp_x = disp_x
      disp_y = disp_y
      disp_z = disp_z
      factor = 1
    [../]
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;210e9 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;7750&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 2
  dt = 0.1
[]


[Functions]
  [./pressure]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2 1.0 2.0 5.0&#x27;
    y = &#x27;0.0 0.1 0.2 1.0 1.0 1.0&#x27;
    scale_factor = 1e9
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp]
    type = NodalMaxValue
    variable = disp_y
    boundary = bottom
  [../]
  [./vel]
    type = NodalMaxValue
    variable = vel_y
    boundary = bottom
  [../]
  [./accel]
    type = NodalMaxValue
    variable = accel_y
    boundary = bottom
  [../]
  [./stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./strain_yy]
    type = ElementAverageValue
    variable = strain_yy
  [../]

[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6baf2a47-d04b-443c-912c-47df544b4184"><div class="modal-content"><h4>modules/richards/test/tests/user_objects/uo3.i</h4><pre class="moose-pre"><code class="language-text"># Seff User objects give the correct value
# Sat User objects give the correct value
#
# If you want to add another test for another UserObject
# then add the UserObject, add a Function defining the expected result,
# add an AuxVariable and AuxKernel that will record the UserObjects value
# and finally add a NodalL2Error that compares this with the Function
#
# Here pressure is x where x runs between -5E6 and 5E6

[UserObjects]
  [./Seff1VG]
    type = RichardsSeff1VG
    m = 0.8
    al = 1E-6
  [../]
  [./Seff1BWsmall]
    type = RichardsSeff1BWsmall
    Sn = 0.0
    Ss = 1.0
    C = 1.01
    las = 1E5
  [../]
  [./Seff1RSC]
    type = RichardsSeff1RSC
    oil_viscosity = 4.0
    scale_ratio = 1E6
    shift = -2E6
  [../]
  [./Seff1VGcut]
    type = RichardsSeff1VGcut
    m = 0.8
    al = 1E-6
    p_cut = -1E6
  [../]

  # following are unimportant in this test
  [./PPNames]
    type = RichardsVarNames
    richards_vars = pressure
  [../]
  [./DensityConstBulk]
    type = RichardsDensityConstBulk
    dens0 = 1000
    bulk_mod = 2E6
  [../]
  [./RelPermPower]
    type = RichardsRelPermPower
    simm = 0.10101
    n = 2
  [../]
  [./Saturation]
    type = RichardsSat
    s_res = 0.054321
    sum_s_res = 0.054321
  [../]
  [./SUPGstandard]
    type = RichardsSUPGstandard
    p_SUPG = 1E5
  [../]
[]

[Functions]
  [./initial_pressure]
    type = ParsedFunction
    value = x
  [../]

  [./answer_Seff1VG]
    type = ParsedFunction
    value = (1+max((-x)*al,0)^(1/(1-m)))^(-m)
    vars = &#x27;al m&#x27;
    vals = &#x27;1E-6 0.8&#x27;
  [../]
  [./answer_dSeff1VG]
    type = GradParsedFunction
    direction = &#x27;1 0 0&#x27;
    value = (1+max((-x)*al,0)^(1/(1-m)))^(-m)
    vars = &#x27;al m&#x27;
    vals = &#x27;1E-6 0.8&#x27;
  [../]
  [./answer_d2Seff1VG]
    type = Grad2ParsedFunction
    direction = &#x27;1 0 0&#x27;
    value = (1+max((-x)*al,0)^(1/(1-m)))^(-m)
    vars = &#x27;al m&#x27;
    vals = &#x27;1E-6 0.8&#x27;
  [../]

  [./answer_Seff1BW]
    type = PiecewiseLinear
    format = columns
    data_file = satBW.csv
    axis = x
  [../]
  [./answer_Seff1BWprime]
    type = PiecewiseLinear
    format = columns
    data_file = satBWprime.csv
    axis = x
  [../]
  [./answer_Seff1BW2prime]
    type = PiecewiseLinear
    format = columns
    data_file = satBW2prime.csv
    axis = x
  [../]

  [./answer_Seff1RSC]
    type = ParsedFunction
    value = (1+exp((-x-shift)/scale))^(-0.5)
    vars = &#x27;shift scale&#x27;
    vals = &#x27;-2E6 1E6&#x27;
  [../]
  [./answer_dSeff1RSC]
    type = GradParsedFunction
    direction = &#x27;1 0 0&#x27;
    value = (1+exp((-x-shift)/scale))^(-0.5)
    vars = &#x27;shift scale&#x27;
    vals = &#x27;-2E6 1E6&#x27;
  [../]
  [./answer_d2Seff1RSC]
    type = Grad2ParsedFunction
    direction = &#x27;1 0 0&#x27;
    value = (1+exp((-x-shift)/scale))^(-0.5)
    vars = &#x27;shift scale&#x27;
    vals = &#x27;-2E6 1E6&#x27;
  [../]

  [./answer_Seff1VGcut]
    type = ParsedFunction
    value = if(x&lt;pcut,scut+dscut*(x-pcut),(1+max((-x)*al,0)^(1/(1-m)))^(-m))
    vars = &#x27;al m pcut scut dscut&#x27;
    vals = &#x27;1E-6 0.8 -1E6 0.574349177498517 1.14869835499703e-06&#x27;
  [../]
  [./answer_dSeff1VGcut]
    type = GradParsedFunction
    direction = &#x27;1 0 0&#x27;
    value = if(x&lt;pcut,scut+dscut*(x-pcut),(1+max((-x)*al,0)^(1/(1-m)))^(-m))
    vars = &#x27;al m pcut scut dscut&#x27;
    vals = &#x27;1E-6 0.8 -1E6 0.574349177498517 1.14869835499703e-06&#x27;
  [../]
  [./answer_d2Seff1VGcut]
    type = Grad2ParsedFunction
    direction = &#x27;1 0 0&#x27;
    value = if(x&lt;pcut,scut+dscut*(x-pcut),(1+max((-x)*al,0)^(1/(1-m)))^(-m))
    vars = &#x27;al m pcut scut dscut&#x27;
    vals = &#x27;1E-6 0.8 -1E6 0.574349177498517 1.14869835499703e-06&#x27;
  [../]

  [./answer_Sat]
    type = ParsedFunction
    value = sres+((1-sumsres)*((1+max((-x)*al,0)^(1/(1-m)))^(-m)))
    vars = &#x27;al m sres sumsres&#x27;
    vals = &#x27;1E-6 0.8 0.054321 0.054321&#x27;
  [../]
  [./answer_dSat]
    type = ParsedFunction
    value = 1-sumsres
    vars = &#x27;sumsres&#x27;
    vals = &#x27;0.054321&#x27;
  [../]
[]

[AuxVariables]
  [./Seff1VG_Aux]
  [../]
  [./dSeff1VG_Aux]
  [../]
  [./d2Seff1VG_Aux]
  [../]

  [./Seff1BWsmall_Aux]
  [../]
  [./dSeff1BWsmall_Aux]
  [../]
  [./d2Seff1BWsmall_Aux]
  [../]

  [./Seff1RSC_Aux]
  [../]
  [./dSeff1RSC_Aux]
  [../]
  [./d2Seff1RSC_Aux]
  [../]

  [./Seff1VGcut_Aux]
  [../]
  [./dSeff1VGcut_Aux]
  [../]
  [./d2Seff1VGcut_Aux]
  [../]

  [./Sat_Aux]
  [../]
  [./dSat_Aux]
  [../]

  [./check_Aux]
  [../]
[]

[AuxKernels]
  [./Seff1VG_AuxK]
    type = RichardsSeffAux
    variable = Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
  [../]
  [./dSeff1VG_AuxK]
    type = RichardsSeffPrimeAux
    variable = dSeff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
    wrtnum = 0
  [../]
  [./d2Seff1VG_AuxK]
    type = RichardsSeffPrimePrimeAux
    variable = d2Seff1VG_Aux
    seff_UO = Seff1VG
    pressure_vars = pressure
    wrtnum1 = 0
    wrtnum2 = 0
  [../]

  [./Seff1BWsmall_AuxK]
    type = RichardsSeffAux
    variable = Seff1BWsmall_Aux
    seff_UO = Seff1BWsmall
    pressure_vars = pressure
  [../]
  [./dSeff1BWsmall_AuxK]
    type = RichardsSeffPrimeAux
    variable = dSeff1BWsmall_Aux
    seff_UO = Seff1BWsmall
    pressure_vars = pressure
    wrtnum = 0
  [../]
  [./d2Seff1BWsmall_AuxK]
    type = RichardsSeffPrimePrimeAux
    variable = d2Seff1BWsmall_Aux
    seff_UO = Seff1BWsmall
    pressure_vars = pressure
    wrtnum1 = 0
    wrtnum2 = 0
  [../]

  [./Seff1RSC_AuxK]
    type = RichardsSeffAux
    variable = Seff1RSC_Aux
    seff_UO = Seff1RSC
    pressure_vars = pressure
  [../]
  [./dSeff1RSC_AuxK]
    type = RichardsSeffPrimeAux
    variable = dSeff1RSC_Aux
    seff_UO = Seff1RSC
    pressure_vars = pressure
    wrtnum = 0
  [../]
  [./d2Seff1RSC_AuxK]
    type = RichardsSeffPrimePrimeAux
    variable = d2Seff1RSC_Aux
    seff_UO = Seff1RSC
    pressure_vars = pressure
    wrtnum1 = 0
    wrtnum2 = 0
  [../]

  [./Seff1VGcut_AuxK]
    type = RichardsSeffAux
    variable = Seff1VGcut_Aux
    seff_UO = Seff1VGcut
    pressure_vars = pressure
  [../]
  [./dSeff1VGcut_AuxK]
    type = RichardsSeffPrimeAux
    variable = dSeff1VGcut_Aux
    seff_UO = Seff1VGcut
    pressure_vars = pressure
    wrtnum = 0
  [../]
  [./d2Seff1VGcut_AuxK]
    type = RichardsSeffPrimePrimeAux
    variable = d2Seff1VGcut_Aux
    seff_UO = Seff1VGcut
    pressure_vars = pressure
    wrtnum1 = 0
    wrtnum2 = 0
  [../]

  [./Sat_AuxK]
    type = RichardsSatAux
    sat_UO = Saturation
    seff_var = Seff1VG_Aux
    variable = Sat_Aux
  [../]
  [./dSat_AuxK]
    type = RichardsSatPrimeAux
    sat_UO = Saturation
    seff_var = Seff1VG_Aux
    variable = dSat_Aux
  [../]

  [./check_AuxK]
    type = FunctionAux
    variable = check_Aux
    function = answer_Seff1VGcut
  [../]
[]

[Postprocessors]
  [./cf_Seff1VG]
    type = NodalL2Error
    function = answer_Seff1VG
    variable = Seff1VG_Aux
  [../]
  [./cf_dSeff1VG]
    type = NodalL2Error
    function = answer_dSeff1VG
    variable = dSeff1VG_Aux
  [../]
  [./cf_d2Seff1VG]
    type = NodalL2Error
    function = answer_d2Seff1VG
    variable = d2Seff1VG_Aux
  [../]

  [./cf_Seff1BW]
    type = NodalL2Error
    function = answer_Seff1BW
    variable = Seff1BWsmall_Aux
  [../]
  [./cf_Seff1BWprime]
    type = NodalL2Error
    function = answer_Seff1BWprime
    variable = dSeff1BWsmall_Aux
  [../]
  [./cf_Seff1BW2prime]
    type = NodalL2Error
    function = answer_Seff1BW2prime
    variable = d2Seff1BWsmall_Aux
  [../]

  [./cf_Seff1RSC]
    type = NodalL2Error
    function = answer_Seff1RSC
    variable = Seff1RSC_Aux
  [../]
  [./cf_dSeff1RSC]
    type = NodalL2Error
    function = answer_dSeff1RSC
    variable = dSeff1RSC_Aux
  [../]
  [./cf_d2Seff1RSC]
    type = NodalL2Error
    function = answer_d2Seff1RSC
    variable = d2Seff1RSC_Aux
  [../]

  [./cf_Seff1VGcut]
    type = NodalL2Error
    function = answer_Seff1VGcut
    variable = Seff1VGcut_Aux
  [../]
  [./cf_dSeff1VGcut]
    type = NodalL2Error
    function = answer_dSeff1VGcut
    variable = dSeff1VGcut_Aux
  [../]
  [./cf_d2Seff1VGcut]
    type = NodalL2Error
    function = answer_d2Seff1VGcut
    variable = d2Seff1VGcut_Aux
  [../]

  [./cf_Sat]
    type = NodalL2Error
    function = answer_Sat
    variable = Sat_Aux
  [../]
  [./cf_dSat]
    type = NodalL2Error
    function = answer_dSat
    variable = dSat_Aux
  [../]
[]



#############################################################################
#
# Following is largely unimportant as we are not running an actual similation
#
#############################################################################
[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmin = -5E6
  xmax = 5E6
[]

[Variables]
  [./pressure]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = initial_pressure
    [../]
  [../]
[]

[Kernels]
  active = &#x27;richardsf richardst&#x27;
  [./richardst]
    type = RichardsMassChange
    richardsVarNames_UO = PPNames
    variable = pressure
  [../]
  [./richardsf]
    type = RichardsFlux
    richardsVarNames_UO = PPNames
    variable = pressure
  [../]
[]

[Materials]
  [./unimportant_material]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-20 0 0  0 1E-20 0  0 0 1E-20&#x27;
    richardsVarNames_UO = PPNames
    density_UO = DensityConstBulk
    relperm_UO = RelPermPower
    sat_UO = Saturation
    seff_UO = Seff1VG
    SUPG_UO = SUPGstandard
    viscosity = 1E-3
    gravity = &#x27;0 0 -10&#x27;
    linear_shape_fcns = true
  [../]
[]

[Preconditioning]
  [./does_nothing]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_converged_reason&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E50 1E50 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  num_steps = 1
  dt = 1E-100
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  active = &#x27;csv&#x27;
  file_base = uo3
  [./csv]
    type = CSV
  [../]
  [./exodus]
    type = Exodus
    hide = pressure
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#a8ee1579-0398-4b94-987d-63f2c0783b51" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#fce241fb-29f0-43f8-bd18-67e5f95b41ab" class="tooltipped" data-position="left" data-tooltip="Example Input Syntax">Example Input Syntax</a></li><li><a href="#8bb355cc-675b-4341-82e6-7d20b0562295" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#8ab9018f-04b2-4b3b-a9b9-2908a3ca1459" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>