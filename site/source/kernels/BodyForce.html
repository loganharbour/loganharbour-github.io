<!DOCTYPE html><head><meta charset="UTF-8"><title>BodyForce.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="076a5e79-afe3-48d9-bf13-0c691052e3ad"><i class="material-icons">menu</i></a><ul class="sidenav" id="076a5e79-afe3-48d9-bf13-0c691052e3ad"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">kernels</span><a href="#" class="breadcrumb">BodyForce</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="ad10fa6f-31de-4e21-9dbe-cb926c493235" data-section-level="1" data-section-text="BodyForce"><h1 id="bodyforce">BodyForce</h1><section class="scrollspy" id="adca0a63-3ca7-4159-93db-b2156dbd54a2" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p><code>BodyForce</code> implements a force term in momentum transport or structural mechanics or a source term in species/mass transport. The strong form, given a domain <span tex="\Omega" bookmark="moose-equation-d520b04a-e617-474c-8dee-de3a8449058b" recursive="True" class="moose-katex-inline-equation" id="moose-equation-d520b04a-e617-474c-8dee-de3a8449058b"><script>var element = document.getElementById("moose-equation-d520b04a-e617-474c-8dee-de3a8449058b");katex.render("\\Omega", element, {displayMode:false,throwOnError:false});</script></span> is defined as</p><p><span class="moose-katex-block-equation"><span tex="\underbrace{-f}_{\textrm{BodyForce}} + \sum_{i=1}^n \beta_i = 0 \in \Omega" bookmark="moose-equation-634d828f-b770-482d-bea7-843b5b48d936" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-634d828f-b770-482d-bea7-843b5b48d936"></span><script>var element = document.getElementById("moose-equation-634d828f-b770-482d-bea7-843b5b48d936");katex.render("\\underbrace{-f}_{\\textrm{BodyForce}} + \\sum_{i=1}^n \\beta_i = 0 \\in \\Omega", element, {displayMode:true,throwOnError:false});</script></span> where <span tex="f" bookmark="moose-equation-354a2c08-f66b-4d71-9992-e97bb123404d" recursive="True" class="moose-katex-inline-equation" id="moose-equation-354a2c08-f66b-4d71-9992-e97bb123404d"><script>var element = document.getElementById("moose-equation-354a2c08-f66b-4d71-9992-e97bb123404d");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span> is the source term (negative if a sink) and the second term on the left hand side represents the strong forms of other kernels. The <code>BodyForce</code> weak form, in inner-product notation, is defined as</p><p><span class="moose-katex-block-equation"><span tex="R_i(u_h) = (\psi_i, -f) \quad \forall \psi_i," bookmark="moose-equation-c3ccb336-92bf-4f40-b276-0a7ae9b4c61e" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-c3ccb336-92bf-4f40-b276-0a7ae9b4c61e"></span><script>var element = document.getElementById("moose-equation-c3ccb336-92bf-4f40-b276-0a7ae9b4c61e");katex.render("R_i(u_h) = (\\psi_i, -f) \\quad \\forall \\psi_i,", element, {displayMode:true,throwOnError:false});</script></span> where the <span tex="\psi_i" bookmark="moose-equation-70d5841b-dd57-4517-8234-c6cce07f5cbc" recursive="True" class="moose-katex-inline-equation" id="moose-equation-70d5841b-dd57-4517-8234-c6cce07f5cbc"><script>var element = document.getElementById("moose-equation-70d5841b-dd57-4517-8234-c6cce07f5cbc");katex.render("\\psi_i", element, {displayMode:false,throwOnError:false});</script></span> are the test functions, and <span tex="u_h" bookmark="moose-equation-e187033d-4142-4555-b587-7b8244093979" recursive="True" class="moose-katex-inline-equation" id="moose-equation-e187033d-4142-4555-b587-7b8244093979"><script>var element = document.getElementById("moose-equation-e187033d-4142-4555-b587-7b8244093979");katex.render("u_h", element, {displayMode:false,throwOnError:false});</script></span> are the trial solutions in the finite dimensional space <span tex="\mathcal{S}^h" bookmark="moose-equation-09a2dd98-7d47-4988-a5ef-6ede9d6ce8b9" recursive="True" class="moose-katex-inline-equation" id="moose-equation-09a2dd98-7d47-4988-a5ef-6ede9d6ce8b9"><script>var element = document.getElementById("moose-equation-09a2dd98-7d47-4988-a5ef-6ede9d6ce8b9");katex.render("\\mathcal{S}^h", element, {displayMode:false,throwOnError:false});</script></span> for the unknown (<span tex="u" bookmark="moose-equation-a5747831-3d9b-46b5-9d02-99c2317431e4" recursive="True" class="moose-katex-inline-equation" id="moose-equation-a5747831-3d9b-46b5-9d02-99c2317431e4"><script>var element = document.getElementById("moose-equation-a5747831-3d9b-46b5-9d02-99c2317431e4");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span>).</p><p>The Jacobian term for this kernel is zero: <span tex="\frac{\partial R_i(u_h)}{\partial u_j} = 0" bookmark="moose-equation-80851487-2501-4ac5-bdd9-2d00e3708563" recursive="True" class="moose-katex-inline-equation" id="moose-equation-80851487-2501-4ac5-bdd9-2d00e3708563"><script>var element = document.getElementById("moose-equation-80851487-2501-4ac5-bdd9-2d00e3708563");katex.render("\\frac{\\partial R_i(u_h)}{\\partial u_j} = 0", element, {displayMode:false,throwOnError:false});</script></span>, since it is assumed that <span tex="f" bookmark="moose-equation-875aae6b-85c5-498e-9ce2-caee3d01665c" recursive="True" class="moose-katex-inline-equation" id="moose-equation-875aae6b-85c5-498e-9ce2-caee3d01665c"><script>var element = document.getElementById("moose-equation-875aae6b-85c5-498e-9ce2-caee3d01665c");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span> <em></em>is not** a function of the unknown <span tex="u" bookmark="moose-equation-c1523080-1b23-4b6a-8ad6-8325f36e987e" recursive="True" class="moose-katex-inline-equation" id="moose-equation-c1523080-1b23-4b6a-8ad6-8325f36e987e"><script>var element = document.getElementById("moose-equation-c1523080-1b23-4b6a-8ad6-8325f36e987e");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span>.</p><p>The force is constructed through a user supplied constant <span tex="c" bookmark="moose-equation-3c6871e9-6832-4eff-b633-0246aa872398" recursive="True" class="moose-katex-inline-equation" id="moose-equation-3c6871e9-6832-4eff-b633-0246aa872398"><script>var element = document.getElementById("moose-equation-3c6871e9-6832-4eff-b633-0246aa872398");katex.render("c", element, {displayMode:false,throwOnError:false});</script></span>, <a href="../../syntax/Functions/index.html">function</a> value evaluated at the current time and quadrature point <span tex="f" bookmark="moose-equation-7fc9f5f6-4d84-483c-894d-f5d376fd544f" recursive="True" class="moose-katex-inline-equation" id="moose-equation-7fc9f5f6-4d84-483c-894d-f5d376fd544f"><script>var element = document.getElementById("moose-equation-7fc9f5f6-4d84-483c-894d-f5d376fd544f");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span>, and/or <a href="../../syntax/Postprocessors/index.html">postprocessor</a> value <span tex="p" bookmark="moose-equation-3c207671-5292-47bf-bd2b-d57e774a7123" recursive="True" class="moose-katex-inline-equation" id="moose-equation-3c207671-5292-47bf-bd2b-d57e774a7123"><script>var element = document.getElementById("moose-equation-3c207671-5292-47bf-bd2b-d57e774a7123");katex.render("p", element, {displayMode:false,throwOnError:false});</script></span>. The constant <span tex="c" bookmark="moose-equation-0d129341-cf3a-4571-bf70-a5923c7b4daf" recursive="True" class="moose-katex-inline-equation" id="moose-equation-0d129341-cf3a-4571-bf70-a5923c7b4daf"><script>var element = document.getElementById("moose-equation-0d129341-cf3a-4571-bf70-a5923c7b4daf");katex.render("c", element, {displayMode:false,throwOnError:false});</script></span>, supplied through the parameter <code>value</code>, may also be controlled over the course of a transient simulation with a <a href="../../syntax/Controls/index.html"><code>Controls</code></a> block.  <span tex="c" bookmark="moose-equation-157b9102-724a-4aef-9e23-3577fbf28cb4" recursive="True" class="moose-katex-inline-equation" id="moose-equation-157b9102-724a-4aef-9e23-3577fbf28cb4"><script>var element = document.getElementById("moose-equation-157b9102-724a-4aef-9e23-3577fbf28cb4");katex.render("c", element, {displayMode:false,throwOnError:false});</script></span>, <span tex="f" bookmark="moose-equation-f570e8f4-7039-4966-a3f5-68e0b2329387" recursive="True" class="moose-katex-inline-equation" id="moose-equation-f570e8f4-7039-4966-a3f5-68e0b2329387"><script>var element = document.getElementById("moose-equation-f570e8f4-7039-4966-a3f5-68e0b2329387");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span>, <span tex="p" bookmark="moose-equation-3c71a36e-6a60-450a-947f-982df7d797bc" recursive="True" class="moose-katex-inline-equation" id="moose-equation-3c71a36e-6a60-450a-947f-982df7d797bc"><script>var element = document.getElementById("moose-equation-3c71a36e-6a60-450a-947f-982df7d797bc");katex.render("p", element, {displayMode:false,throwOnError:false});</script></span> are supplied through the input parameters <code>value</code>, <code>function</code>, and <code>postprocessor</code> respectively. Not supplying <span tex="c" bookmark="moose-equation-619aecaf-b33f-414f-b26b-0768f216ca1f" recursive="True" class="moose-katex-inline-equation" id="moose-equation-619aecaf-b33f-414f-b26b-0768f216ca1f"><script>var element = document.getElementById("moose-equation-619aecaf-b33f-414f-b26b-0768f216ca1f");katex.render("c", element, {displayMode:false,throwOnError:false});</script></span>, <span tex="f" bookmark="moose-equation-6e52184a-4476-4c30-ae78-ea55d3ae358b" recursive="True" class="moose-katex-inline-equation" id="moose-equation-6e52184a-4476-4c30-ae78-ea55d3ae358b"><script>var element = document.getElementById("moose-equation-6e52184a-4476-4c30-ae78-ea55d3ae358b");katex.render("f", element, {displayMode:false,throwOnError:false});</script></span>, or <span tex="p" bookmark="moose-equation-50c4a69d-d7da-42f0-a0c4-7fe94939d5a5" recursive="True" class="moose-katex-inline-equation" id="moose-equation-50c4a69d-d7da-42f0-a0c4-7fe94939d5a5"><script>var element = document.getElementById("moose-equation-50c4a69d-d7da-42f0-a0c4-7fe94939d5a5");katex.render("p", element, {displayMode:false,throwOnError:false});</script></span> through its corresponding parameter is equivalent to setting its value to unity.</p></section><section class="scrollspy" id="1d872378-7f4e-434f-839a-6fb054cabbc5" data-section-level="2" data-section-text="Example Syntax"><h2 id="example-syntax">Example Syntax</h2><p>The case below demonstrates the use of <code>BodyForce</code> where the force term is supplied based upon a function form:</p><pre class="moose-pre"><code class="language-text">[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
    function = &#x27;x+y&#x27;
  [../]

  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]
</code></pre><a href="#933c427c-c2c9-47d7-981f-44edc654622d" class="modal-trigger">(test/tests/kernels/block_kernel/block_kernel_test.i)</a><div class="modal moose-modal" id="933c427c-c2c9-47d7-981f-44edc654622d"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/test/tests/kernels/block_kernel/block_kernel_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
  uniform_refine = 1
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1.0
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
    function = &#x27;x+y&#x27;
  [../]

  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  dt = 0.1
  num_steps = 10
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="3379b3b6-04fa-4891-b719-23e26c01c8ce" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="ed42b9d7-8473-4794-9c39-5279b7a0e857" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">The name of the variable that this Kernel operates on</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>NonlinearVariableName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the variable that this Kernel operates on</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="d2135659-695c-4cfb-a73c-b77df74025a7" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of block ids (SubdomainID) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<SubdomainName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The list of block ids (SubdomainID) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">displacements</span><span class="moose-parameter-header-description">The displacements</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<VariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The displacements</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">function</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">A function that describes the body force</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FunctionName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>A function that describes the body force</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">postprocessor</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">A postprocessor whose value is multiplied by the body force</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>PostprocessorName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>A postprocessor whose value is multiplied by the body force</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">value</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Coefficient to multiply by the body force term</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Coefficient to multiply by the body force term</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="a66e0d03-47d3-44cc-b0d0-4b1a3e45bd5c" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">diag_save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this Kernel's diagonal Jacobian contributions to. Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<AuxVariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this Kernel's diagonal Jacobian contributions to. Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this Kernel's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<AuxVariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this Kernel's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation. Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation. Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="78b53005-6f6a-4232-afb3-7f11cdc27b51" data-section-level="3" data-section-text="Tagging Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">extra_matrix_tags</span><span class="moose-parameter-header-description">The extra tags for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<TagName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_vector_tags</span><span class="moose-parameter-header-description">The extra tags for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<TagName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the vectors this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_tags</span><span class="moose-parameter-header-default">system</span><span class="moose-parameter-header-description">The tag for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>system</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime system</p><p class="moose-parameter-description"><span>Description:</span>The tag for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">vector_tags</span><span class="moose-parameter-header-default">nontime</span><span class="moose-parameter-header-description">The tag for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nontime</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime time</p><p class="moose-parameter-description"><span>Description:</span>The tag for the vectors this Kernel should fill</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Tagging Parameters</h3></summary></details></section></section><section class="scrollspy" id="5dcf1408-d321-46f0-96aa-ccfb61b4a5a5" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#26f673ef-63f9-4552-8140-cbd1ee6ccdd4" class="modal-trigger">test/tests/materials/boundary_material/bnd_coupling_vol.i</a></li><li><a href="#4af018df-920c-466e-a7f8-48a3e9541c08" class="modal-trigger">test/tests/functions/constant_function/constant_function_test.i</a></li><li><a href="#cf0eb4f8-3441-431d-8678-3da7797a2a97" class="modal-trigger">test/tests/time_steppers/function_dt/function_dt_no_interpolation.i</a></li><li><a href="#dc5eef3f-0af0-4e80-8ed5-98f3c8b5c197" class="modal-trigger">test/tests/postprocessors/element_time_derivative/el_time_deriv_1d_test.i</a></li><li><a href="#1c8ef1f5-3c88-4bf8-b5f7-789a1b8bf116" class="modal-trigger">test/tests/utils/spline_interpolation/bicubic_spline_interpolation_x_normal.i</a></li><li><a href="#b620ab60-ed31-4589-9809-e299e9f75b2b" class="modal-trigger">test/tests/kernels/scalar_constraint/scalar_constraint_kernel.i</a></li><li><a href="#68e4ab80-ef64-49f0-b99a-188a0fe5cc56" class="modal-trigger">modules/richards/test/tests/jacobian_2/jn_fu_01.i</a></li><li><a href="#fa2dc504-a3a3-43a5-8b4c-90d3a6bc01c5" class="modal-trigger">test/tests/problems/no_kernel_coverage_check/no_coverage_check.i</a></li><li><a href="#cf799a32-237f-4e01-829b-4be0b23b6769" class="modal-trigger">test/tests/restart/restart_add_variable/add_variable_restart.i</a></li><li><a href="#7eced0b2-652c-47f7-8aa4-504d2968470a" class="modal-trigger">modules/tensor_mechanics/test/tests/initial_stress/gravity_with_aux.i</a></li><li><a href="#d92de933-765b-44e9-bd77-46b9e41ea2d5" class="modal-trigger">test/tests/postprocessors/element_average_value/elem_pps_multi_block_test.i</a></li><li><a href="#8f76d882-904e-4226-88f1-5d784e342624" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_homog1mat.i</a></li><li><a href="#1344af3b-803f-4a67-9686-2e940e9935e8" class="modal-trigger">test/tests/bcs/function_neumann_bc/test.i</a></li><li><a href="#0d4081db-f288-4dee-9c64-8eb8a179f30a" class="modal-trigger">test/tests/time_integrators/explicit-euler/ee-1d-linear.i</a></li><li><a href="#c3033b2f-3db2-4088-b93e-f7c06c27558f" class="modal-trigger">test/tests/adaptivity/interval/adapt_interval.i</a></li><li><a href="#6d8c12c9-07de-4e18-8ace-945a2d83316a" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/pp_generation_fullysat_action.i</a></li><li><a href="#3bad934c-7f8a-414f-87e1-432277aab040" class="modal-trigger">modules/heat_conduction/test/tests/sideset_heat_transfer/gap_thermal_ktemp_1D.i</a></li><li><a href="#e7ff65a5-5307-4622-af6c-bb7d743d12be" class="modal-trigger">test/tests/misc/check_error/missing_req_par_mesh_block_test.i</a></li><li><a href="#f42dd33b-1817-41b3-a610-17731513e227" class="modal-trigger">test/tests/kernels/vector_fe/coupled_scalar_vector_jacobian.i</a></li><li><a href="#0da04291-1965-4394-8eb6-646baf3def75" class="modal-trigger">test/tests/restart/restart_transient_from_transient/restart_trans_with_2subs.i</a></li><li><a href="#650950b5-f6e0-40c2-ab94-adcf3043d017" class="modal-trigger">test/tests/mortar/cant-do-3d/periodic.i</a></li><li><a href="#389b0768-a9af-4a11-b5ee-3f00b6a56421" class="modal-trigger">test/tests/bcs/penalty_dirichlet_bc/penalty_dirichlet_bc_test.i</a></li><li><a href="#e6b35a12-4b1e-4aa1-ad93-de5e0e72d1b5" class="modal-trigger">test/tests/restart/restart_transient_from_steady/restart_trans_with_2subs.i</a></li><li><a href="#0158a0ca-c603-4c90-8e67-1411e3bde040" class="modal-trigger">test/tests/kernels/coupled_time_derivative/coupled_time_derivative_test.i</a></li><li><a href="#f79d4f80-acd3-4d3b-979d-e9378f0c90ed" class="modal-trigger">test/tests/time_integrators/explicit-euler/ee-1d-quadratic-neumann.i</a></li><li><a href="#30a55306-ae15-4351-8b0c-ec21910d788d" class="modal-trigger">test/tests/time_integrators/abort/abort.i</a></li><li><a href="#1d76496c-a5be-43a4-b75d-2fb5231ba59d" class="modal-trigger">test/tests/time_steppers/timesequence_stepper/timesequence.i</a></li><li><a href="#9a904d81-8556-49fc-85ad-cad712887998" class="modal-trigger">test/tests/postprocessors/element_integral_var_pps/initial_pps.i</a></li><li><a href="#aae9bbc4-b59b-47e3-8313-82617099f4fd" class="modal-trigger">test/tests/variables/fe_hermite/hermite-3-2d.i</a></li><li><a href="#3b6917de-85a7-43b8-b924-dd801b0b2fc8" class="modal-trigger">test/tests/time_integrators/actually_explicit_euler_verification/ee-1d-quadratic.i</a></li><li><a href="#df8c2aec-a462-4742-abfa-052a041108ef" class="modal-trigger">test/tests/transfers/multiapp_userobject_transfer/tosub_sub.i</a></li><li><a href="#9aeffac2-9ee8-46ea-aa1c-e0816641c47a" class="modal-trigger">test/tests/dgkernels/2d_diffusion_dg/2d_diffusion_dg_test.i</a></li><li><a href="#f1a5c86e-d361-4e36-9098-e9fecd64fd31" class="modal-trigger">test/tests/postprocessors/relative_solution_difference_norm/test.i</a></li><li><a href="#56f29187-39c5-41cc-be8b-75889603c85e" class="modal-trigger">test/tests/dampers/bounding_value_element_damper/bounding_value_max_test.i</a></li><li><a href="#f35f3d63-2604-4266-a74d-deb7fd4799ab" class="modal-trigger">modules/functional_expansion_tools/examples/3D_volumetric_Cartesian_direct/main.i</a></li><li><a href="#fb54dbe1-839e-4878-b36e-3cbf7f86e38c" class="modal-trigger">test/tests/interfacekernels/1d_interface/mixed_shapes.i</a></li><li><a href="#3ed0df5c-b4c0-4417-a462-84b329a80546" class="modal-trigger">test/tests/time_integrators/tvdrk2/1d-linear.i</a></li><li><a href="#fdd6b6f0-7e3c-4c1b-9e49-3bebe8563e52" class="modal-trigger">modules/porous_flow/test/tests/energy_conservation/heat04_action_KT.i</a></li><li><a href="#1f34c4d2-88e1-4285-9d3c-b77d964e3ecc" class="modal-trigger">modules/heat_conduction/test/tests/heat_conduction/coupled_convective_heat_flux/coupled_convective_heat_flux.i</a></li><li><a href="#b471f080-d8e3-4b60-bbe0-f7ef84da3df9" class="modal-trigger">test/tests/ics/from_exodus_solution/elem_part1.i</a></li><li><a href="#d5e396bc-8fc9-4b1d-bdf4-ea8a3a73a927" class="modal-trigger">test/tests/postprocessors/element_time_derivative/element_time_derivative_test.i</a></li><li><a href="#03222d76-9148-4dd7-8eb8-168b7a535bc9" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined_fully_saturated_volume.i</a></li><li><a href="#52fbb204-cd25-4426-b7b3-fc682b3dbf33" class="modal-trigger">test/tests/restart/restart_add_variable/transient_with_stateful.i</a></li><li><a href="#bc959889-ae52-4b6a-ba54-ef1b35712c4e" class="modal-trigger">test/tests/preconditioners/smp/smp_single_adapt_test.i</a></li><li><a href="#ab273171-6a28-4e59-8b3a-ac1b9f69d5c3" class="modal-trigger">test/tests/variables/fe_monomial_const/monomial-const-3d.i</a></li><li><a href="#d90fd71a-4949-40d5-9104-cc8ff40911d0" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_lsdep1mat.i</a></li><li><a href="#4f2ffb83-d9b6-4fb2-80f1-cf1972f78780" class="modal-trigger">test/tests/time_integrators/bdf2/bdf2_adapt.i</a></li><li><a href="#25119aca-7165-4b05-a846-925d310973e5" class="modal-trigger">python/peacock/tests/common/oversample.i</a></li><li><a href="#5bf5de66-b8ce-4004-9dc1-842973354f03" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/poly_chaos/sub.i</a></li><li><a href="#fdb13c00-a8ca-4502-847e-821abe91d164" class="modal-trigger">test/tests/postprocessors/num_dofs/num_dofs.i</a></li><li><a href="#465e503d-6800-42ce-a18f-921d95d7adc7" class="modal-trigger">test/tests/mortar/continuity-2d-non-conforming/soln-continuity.i</a></li><li><a href="#2f68c534-1401-4d07-80e6-02ec2b5dd69b" class="modal-trigger">test/tests/variables/fe_hermite/hermite-3-3d.i</a></li><li><a href="#9c784b9a-255b-4d50-8e56-85521bb66a38" class="modal-trigger">test/tests/variables/mixed_order_variables/mixed_order_variables_test.i</a></li><li><a href="#68898b3b-582d-4dae-96b2-7ca8d9cb0152" class="modal-trigger">test/tests/tag/2d_diffusion_dg_tag.i</a></li><li><a href="#aee9e86f-f8a8-4762-8388-07a6e7b68fc7" class="modal-trigger">modules/porous_flow/test/tests/energy_conservation/heat04.i</a></li><li><a href="#e597aeae-de7f-49a0-8a62-a9a15dee92e1" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/pod_rb/boundary/sub.i</a></li><li><a href="#2c351e83-bfab-47c1-9e5b-c0f3d00dae98" class="modal-trigger">test/tests/postprocessors/postprocessor_dependency/element_side_pp.i</a></li><li><a href="#b484f7f4-21d8-4e30-b3d2-eb6f66711aa7" class="modal-trigger">test/tests/kernels/forcing_function/forcing_function_error_check.i</a></li><li><a href="#15ccfee0-13a9-4cd5-a2ba-8871daef7f0e" class="modal-trigger">test/tests/restart/restart_steady_from_transient/steady_from_transient_restart.i</a></li><li><a href="#53e4bc6a-dbc4-465b-ad90-895324814367" class="modal-trigger">test/tests/userobjects/postprocessor_spatial_user_object/master.i</a></li><li><a href="#11a04395-0ba9-4f06-a543-da6b851c5b51" class="modal-trigger">test/tests/transfers/multiapp_conservative_transfer/master_power_density.i</a></li><li><a href="#a6d3931d-6165-41c4-b949-e1ced790c64d" class="modal-trigger">test/tests/materials/ad_material/ad_stateful_material.i</a></li><li><a href="#a8eb8b37-37de-4104-a78e-e966f7756225" class="modal-trigger">examples/ex14_pps/ex14_compare_solutions_1.i</a></li><li><a href="#f99b7b2d-6e8e-4df1-b306-d7f088445b47" class="modal-trigger">modules/functional_expansion_tools/examples/2D_interface/main.i</a></li><li><a href="#a1b99c9d-f148-4792-b356-fa9341c6f36e" class="modal-trigger">modules/level_set/test/tests/verification/1d_level_set_mms/level_set_mms.i</a></li><li><a href="#26982bc5-002e-40c7-86e7-fdec3ecfe7aa" class="modal-trigger">test/tests/outputs/oversample/over_sampling_second_file.i</a></li><li><a href="#c7af8432-cdad-4b4a-b4f4-5daac33a3482" class="modal-trigger">test/tests/variables/get_elemental_value/get_elemental_value.i</a></li><li><a href="#c74b1929-9b46-45bc-bd20-8c297ba00fad" class="modal-trigger">modules/combined/test/tests/poro_mechanics/pp_generation_unconfined_action.i</a></li><li><a href="#0b7da2af-218d-4a73-8b3a-6abb0d4d5215" class="modal-trigger">test/tests/outputs/console/console_final.i</a></li><li><a href="#e9c4f6be-a775-4bb4-a044-c7ab518f94db" class="modal-trigger">test/tests/userobjects/interface_user_object/interface_mp_real_user_object_QP.i</a></li><li><a href="#697d2cc4-f8db-423e-ae33-5b24f2c5fd0f" class="modal-trigger">test/tests/time_integrators/tvdrk2/2d-quadratic.i</a></li><li><a href="#dbf4ef11-a2ef-453f-9b73-8f035ac6c44b" class="modal-trigger">test/tests/variables/fe_hier/hier-2-1d.i</a></li><li><a href="#c9b79feb-2276-4b9f-a99d-2a8cbc4dda4a" class="modal-trigger">test/tests/executioners/time_period/time_period_test.i</a></li><li><a href="#07e08915-6e92-4318-b410-7903cafdd732" class="modal-trigger">test/tests/restart/restart_diffusion/exodus_refined_refined_restart_2_test.i</a></li><li><a href="#0bf48c88-3c5f-4a60-8d5c-a1509d6f2483" class="modal-trigger">test/tests/mortar/periodic-value/periodic.i</a></li><li><a href="#b5481eae-8473-4f4e-8799-568b6c0f4eae" class="modal-trigger">test/tests/restart/restart_transient_from_transient/pseudo_trans_with_2subs.i</a></li><li><a href="#6a2ea040-84e0-4b89-953d-404974422c7f" class="modal-trigger">test/tests/bcs/vectorpostprocessor/vectorpostprocessor.i</a></li><li><a href="#1738876f-9dc7-4e31-83a6-b929b545dc9b" class="modal-trigger">test/tests/multiapps/restart_subapp_ic/master2.i</a></li><li><a href="#ce69c69f-a3b9-4d98-9805-b16c21e1fc85" class="modal-trigger">test/tests/multiapps/grid-sequencing/vi-fine-alone.i</a></li><li><a href="#291b459d-e872-424c-ac36-fb7e6f53b01a" class="modal-trigger">test/tests/variables/fe_monomial_const/monomial-const-1d.i</a></li><li><a href="#77adafc8-0e4c-4775-9359-5da8823601f2" class="modal-trigger">test/tests/adaptivity/max_h_level/max_h_level.i</a></li><li><a href="#85a939a4-f4e5-46a8-850b-478cdc46f662" class="modal-trigger">test/tests/variables/fe_hier/hier-2-3d.i</a></li><li><a href="#7c1bf371-0659-40a3-97dc-1d75848d4ab0" class="modal-trigger">test/tests/postprocessors/element_h1_error_pps/element_h1_error_pp_test.i</a></li><li><a href="#0fe18848-f124-45da-b335-55614284e6fe" class="modal-trigger">test/tests/nodalkernels/constraint_enforcement/lower-bound.i</a></li><li><a href="#fa4ca32c-f9f1-4378-b4ab-757da725941c" class="modal-trigger">test/tests/misc/check_error/missing_coupled_mat_prop_test.i</a></li><li><a href="#8fa8d915-7251-48b1-852f-1139e0aaa1e1" class="modal-trigger">test/tests/postprocessors/num_elems/num_elems.i</a></li><li><a href="#bf9e36f1-6652-4277-bba6-fb24b07f36dd" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/pod_rb/errors/sub.i</a></li><li><a href="#934a9fc8-59a4-4bf7-945a-2e17ff39bfd4" class="modal-trigger">test/tests/transfers/multiapp_conservative_transfer/sub_power_density.i</a></li><li><a href="#896b8698-d065-45cf-aeac-813a1d90d22e" class="modal-trigger">test/tests/bcs/nodal_normals/cylinder_hexes_1st_2nd.i</a></li><li><a href="#3fc54b8a-7b27-4439-924d-633929bd86e9" class="modal-trigger">test/tests/restart/restart_transient_from_steady/steady_with_2subs.i</a></li><li><a href="#d405a6e0-a717-4afd-8d15-e2d5dd22614c" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined.i</a></li><li><a href="#886a04a7-bdc9-4892-9b97-a8932fdc24c4" class="modal-trigger">test/tests/mortar/continuity-2d-non-conforming/sequencing-stateful-soln-continuity.i</a></li><li><a href="#ffc454a1-54e8-4d2b-910c-7c3ea8e63c5c" class="modal-trigger">test/tests/dampers/bounding_value_nodal_damper/bounding_value_max_test.i</a></li><li><a href="#6dbc8d97-053d-4f42-b4de-152810605c81" class="modal-trigger">test/tests/time_integrators/rk-2/1d-linear.i</a></li><li><a href="#5043520e-593c-481a-84e7-cad1570ff6dc" class="modal-trigger">test/tests/misc/check_error/incomplete_kernel_variable_coverage_test.i</a></li><li><a href="#02e893f6-9dd9-4f0a-8c8c-11caa3faf9a1" class="modal-trigger">test/tests/variables/fe_hier/hier-1-1d.i</a></li><li><a href="#124d719a-a32f-4a94-a619-dad1b3535e9f" class="modal-trigger">modules/heat_conduction/test/tests/sideset_heat_transfer/cfem_gap.i</a></li><li><a href="#312f0ecb-fde7-45c9-857a-06e86cb75eb6" class="modal-trigger">test/tests/dgkernels/dg_block_restrict/2d_dg_diffusion_block_restrict.i</a></li><li><a href="#44ba9f16-396f-4b32-b507-3eb717b3a4c4" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined_basicthm.i</a></li><li><a href="#a8d98bdd-89aa-46be-ac2b-bdcb9104f654" class="modal-trigger">test/tests/restart/restart_steady_from_transient/transient.i</a></li><li><a href="#aaaa32f8-90bf-4d81-9bfb-430aadc40486" class="modal-trigger">modules/level_set/test/tests/kernels/advection/advection_mms.i</a></li><li><a href="#b0dddc8a-6fb9-4d71-b164-22c5ea519212" class="modal-trigger">test/tests/executioners/transient_sync_time/transient_sync_time_test.i</a></li><li><a href="#45554c19-6fd8-4410-b718-3253a380e9e9" class="modal-trigger">test/tests/userobjects/interface_user_object/interface_value_user_object_QP.i</a></li><li><a href="#9286fa5e-4eee-4b65-ad49-e4360919f502" class="modal-trigger">test/tests/userobjects/internal_side_user_object/internal_side_user_object.i</a></li><li><a href="#491f3fc3-7221-4933-8d48-daed06b03e51" class="modal-trigger">test/tests/variables/fe_hermite_convergence/hermite_converge_dirichlet.i</a></li><li><a href="#2b548409-76f5-46b0-b119-2255de85aeea" class="modal-trigger">test/tests/kernels/ode/parsedode_sys_impl_test.i</a></li><li><a href="#45761604-3f52-4124-a3c4-2f16aab8d002" class="modal-trigger">test/tests/restart/restart_diffusion/exodus_refined_restart_2_test.i</a></li><li><a href="#b6a32f74-d9bd-4d60-9c36-c20d3b519d53" class="modal-trigger">test/tests/restart/restart_subapp_not_master/complete_solve_no_subapp.i</a></li><li><a href="#106115a7-7c4f-4f17-9f0b-95b63452c5df" class="modal-trigger">test/tests/postprocessors/num_vars/num_vars.i</a></li><li><a href="#05d1efb6-0b57-41a1-8f02-90a3f0079e23" class="modal-trigger">test/tests/transfers/multiapp_userobject_transfer/tosub_displaced_sub.i</a></li><li><a href="#26ff0c18-8f2f-40ad-99ed-c3e319f899d1" class="modal-trigger">test/tests/variables/fe_hermite_convergence/hermite_converge_periodic.i</a></li><li><a href="#b5b188c3-8f67-4381-9e63-65343a802da4" class="modal-trigger">modules/stochastic_tools/examples/surrogates/sub.i</a></li><li><a href="#4baf5559-2dd8-46af-a413-92e103e2bfa3" class="modal-trigger">test/tests/mesh_modifiers/lower_d_block/lower_d.i</a></li><li><a href="#8dae77c4-4dbe-40e0-b01b-8ed94037c00a" class="modal-trigger">test/tests/userobjects/interface_user_object/interface_userobject_material_value.i</a></li><li><a href="#d9128350-72d1-4b80-82f5-dd20c7f3ce31" class="modal-trigger">test/tests/multiapps/restart_multilevel/master.i</a></li><li><a href="#ca41cec2-d2a6-4e23-b395-172463930f46" class="modal-trigger">test/tests/outputs/debug/show_var_residual_norms.i</a></li><li><a href="#56d262f1-58ba-4876-bfd6-e950bd37e488" class="modal-trigger">test/tests/adaptivity/initial_marker/initial_marker.i</a></li><li><a href="#1919fa76-4a43-4a3f-b460-6cd33e68532c" class="modal-trigger">test/tests/time_integrators/convergence/implicit_convergence.i</a></li><li><a href="#07c1b8df-c0b2-4c81-a5bb-b86b01917a85" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_xy_homog1mat.i</a></li><li><a href="#629684f1-8ffb-40fb-aeff-32d54cc14343" class="modal-trigger">modules/functional_expansion_tools/test/tests/standard_use/interface_coupled.i</a></li><li><a href="#0b96f307-7292-47a1-a9e9-e5f129ba5dd5" class="modal-trigger">test/tests/multiapps/restart_subapp_ic/master.i</a></li><li><a href="#fd0e8208-e116-4621-9dea-6c5eb8479d09" class="modal-trigger">test/tests/mortar/continuity-2d-conforming/conforming-2nd-order.i</a></li><li><a href="#97ab8eeb-d8df-437e-8c1b-d815e5f6e253" class="modal-trigger">test/tests/time_integrators/implicit-euler/ie.i</a></li><li><a href="#c1cb0954-db08-4ef9-be52-136c8c90767d" class="modal-trigger">test/tests/auxkernels/constant_scalar_aux/constant_scalar_aux.i</a></li><li><a href="#528e22f2-e729-4cee-a390-89e8e052714a" class="modal-trigger">test/tests/interfacekernels/2d_interface/coupled_value_coupled_flux_with_jump_material.i</a></li><li><a href="#9245df2b-885f-407d-9108-f02cd691eb26" class="modal-trigger">test/tests/kernels/vector_fe/coupled_scalar_default_vector_value.i</a></li><li><a href="#cc061018-6338-42fe-9ce0-e507e3004e6a" class="modal-trigger">test/tests/misc/save_in/dg_save_in_test.i</a></li><li><a href="#847c7fff-e813-4e5f-bbba-4cb9a8c23315" class="modal-trigger">test/tests/time_integrators/actually_explicit_euler_verification/ee-2d-quadratic.i</a></li><li><a href="#010b06bc-b2eb-47fc-bc53-6bb9ba11efaf" class="modal-trigger">test/tests/postprocessors/num_adaptivity_cycles/num_adaptivity_cycles_toggle_adaptivity.i</a></li><li><a href="#7bdd6048-1296-46fd-a7aa-979a0c1ee620" class="modal-trigger">test/tests/postprocessors/side_pps/side_pps_multi_bnd_test.i</a></li><li><a href="#44d93675-250f-45ea-99b9-9af407a58caa" class="modal-trigger">python/peacock/tests/input_tab/InputTree/gold/transient.i</a></li><li><a href="#36d2ca24-2d89-446a-aa01-6ef3858b256e" class="modal-trigger">test/tests/outputs/oversample/over_sampling_test_file.i</a></li><li><a href="#0af75b07-0118-41a3-aaa9-2bced103a60b" class="modal-trigger">test/tests/dgkernels/2d_diffusion_dg/no_functor_additions.i</a></li><li><a href="#2d7cd73a-ab0e-43c6-8786-d1a8c65ac3b4" class="modal-trigger">test/tests/misc/initial_solution_copy/solutions_equal.i</a></li><li><a href="#24be86fc-196b-4fae-a126-ab069f2a00af" class="modal-trigger">modules/combined/test/tests/elastic_thermal_patch/elastic_thermal_patch_rz.i</a></li><li><a href="#2c499340-a493-4699-bf3c-617d955ea269" class="modal-trigger">test/tests/restart/restart_transient_from_steady/steady_with_sub.i</a></li><li><a href="#44484c51-95b0-465f-9c75-76d55371aed9" class="modal-trigger">test/tests/ics/from_exodus_solution/nodal_part2.i</a></li><li><a href="#419c729a-9264-4732-bbbe-cafd56caf306" class="modal-trigger">test/tests/time_integrators/implicit-euler/ie_adapt.i</a></li><li><a href="#540c4ce2-17c8-4acc-a079-65506ed766bb" class="modal-trigger">test/tests/variables/fe_hier/hier-1-2d.i</a></li><li><a href="#c55d3101-c0ce-411e-be32-868c7e02f5a4" class="modal-trigger">test/tests/misc/check_error/subdomain_restricted_kernel_mismatch.i</a></li><li><a href="#f5a7f0b3-337a-4bf1-a62a-698da82985b3" class="modal-trigger">test/tests/indicators/laplacian_jump_indicator/biharmonic.i</a></li><li><a href="#5332017e-3214-4dd6-8c26-a71a094c5e93" class="modal-trigger">test/tests/multiapps/restart/sub.i</a></li><li><a href="#442b7afc-4304-444b-bd12-88c6daa3c6c9" class="modal-trigger">test/tests/problems/no_material_coverage_check/no_material_coverage_check.i</a></li><li><a href="#211be852-0967-4f61-aa0c-0cbae2814545" class="modal-trigger">python/peacock/tests/common/transient_with_date.i</a></li><li><a href="#3db46cda-d66d-4fbe-be08-65c4982c99ea" class="modal-trigger">test/tests/dampers/min_damping/min_nodal_damping.i</a></li><li><a href="#f96d815d-ae3a-4597-8c8f-accc6ca230df" class="modal-trigger">test/tests/dgkernels/advection_diffusion_mixed_bcs_test_resid_jac/dg_advection_diffusion_test.i</a></li><li><a href="#3791d55c-39e8-46b6-9d3c-390c031fb1a8" class="modal-trigger">test/tests/postprocessors/mms_slope/mms_slope_test.i</a></li><li><a href="#aa552e0f-7245-469b-a046-a6b8835680e9" class="modal-trigger">test/tests/multiapps/restart/master.i</a></li><li><a href="#733885a0-8056-40e0-b3eb-4c08bb2d9d46" class="modal-trigger">test/tests/actions/meta_action_multiple_tasks/circle_quads.i</a></li><li><a href="#c49b0b85-b6dc-4a9e-b1fa-8b3f6a757c91" class="modal-trigger">test/tests/kernels/vector_fe/coupled_scalar_vector.i</a></li><li><a href="#552deddd-deac-4557-9762-937e89e10d1a" class="modal-trigger">modules/stochastic_tools/examples/surrogates/pod_rb/2d_multireg/sub.i</a></li><li><a href="#0f1c9597-aec4-4592-8c97-45bac9ff113a" class="modal-trigger">test/tests/restart/restart_diffusion/restart_diffusion_test_transient.i</a></li><li><a href="#7620c4ca-ce3d-44bd-9d36-7d8bb2002a86" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/load_store/sub.i</a></li><li><a href="#55093b77-496e-476e-8b02-b3dec4d379ed" class="modal-trigger">test/tests/misc/line_source/line_source.i</a></li><li><a href="#eefcca91-1db6-497d-8259-a9c2bd35ce86" class="modal-trigger">test/tests/executioners/solve_type_linear/linear_with_full_smp.i</a></li><li><a href="#6b8dfa61-e733-4ced-8288-51dd5b8835b1" class="modal-trigger">modules/functional_expansion_tools/examples/2D_interface_different_submesh/main.i</a></li><li><a href="#97eda157-f41b-4264-bb98-d30761b4d57e" class="modal-trigger">test/tests/mesh/named_entities/named_entities_test_xda.i</a></li><li><a href="#3a10296d-c7ab-4c9d-89e7-28ef64684ec0" class="modal-trigger">modules/ray_tracing/test/tests/coord_type/rspherical_line_integral.i</a></li><li><a href="#293c6d8d-a5d1-4fe3-8e17-0a1f81ee10cf" class="modal-trigger">python/mms/test/mms_temporal.i</a></li><li><a href="#75cad589-2e5c-49bc-ab06-101521297ecf" class="modal-trigger">test/tests/transfers/multiapp_conservative_transfer/master_nearest_point.i</a></li><li><a href="#9004d1a1-bf20-4edb-a4d5-60beeaed3d98" class="modal-trigger">test/tests/time_integrators/multi_stage_time_integrator/unconverged_1st_stage.i</a></li><li><a href="#bbe9d707-bf3e-4e65-a5ab-27c32e29fef2" class="modal-trigger">test/tests/ics/from_exodus_solution/nodal_part1.i</a></li><li><a href="#c477ed0e-072b-4c9b-a1aa-0b1886960dda" class="modal-trigger">modules/combined/examples/publications/rapid_dev/fig6.i</a></li><li><a href="#deea3d80-885f-40bf-a7ee-eac6c624d423" class="modal-trigger">test/tests/meshgenerators/lower_d_block_generator/ids.i</a></li><li><a href="#41788fdd-427b-44ee-b88d-0d273fa7dddc" class="modal-trigger">test/tests/functions/pps_function/pp_function.i</a></li><li><a href="#bd827111-26dc-42c5-ae79-4b1436361713" class="modal-trigger">test/tests/interfacekernels/ik_displaced/displaced.i</a></li><li><a href="#f89b0290-140e-4d8f-ade3-30357787a6b8" class="modal-trigger">test/tests/auxkernels/time_integration/time_integration.i</a></li><li><a href="#fd29d25e-c6cd-4d84-a121-2d047ae58c46" class="modal-trigger">test/tests/mesh/named_entities/named_entities_test.i</a></li><li><a href="#e6e8625f-c728-4acc-9c81-7a757150d895" class="modal-trigger">modules/combined/test/tests/poro_mechanics/pp_generation_unconfined.i</a></li><li><a href="#54f69e4f-a3eb-462a-a408-0562ba0c4af9" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined_fully_saturated.i</a></li><li><a href="#2a457218-5fe3-4be8-93c4-9f57e4efe70e" class="modal-trigger">test/tests/outputs/variables/show_single_vars.i</a></li><li><a href="#14e21561-7345-40e0-8428-754a24e9cabb" class="modal-trigger">test/tests/bcs/function_dirichlet_bc/test.i</a></li><li><a href="#2fb6f089-e9ff-46cc-b7e3-ae48ed635b2f" class="modal-trigger">test/tests/postprocessors/element_l2_difference/element_l2_difference.i</a></li><li><a href="#909d4b94-6864-47c3-9f81-c2f3ec97b0f5" class="modal-trigger">test/tests/bcs/second_deriv/test_lap_bc.i</a></li><li><a href="#61a952a1-71af-4a13-b3cd-0431d57bcd72" class="modal-trigger">test/tests/transfers/multiapp_high_order_variable_transfer/master_L2_Lagrange_conservative.i</a></li><li><a href="#68f03de9-c057-48df-a58a-7548fb2dd2bd" class="modal-trigger">test/tests/restart/restart_subapp_not_master/two_step_solve_sub.i</a></li><li><a href="#35324e41-51e7-41fa-a29c-6d772b712b8f" class="modal-trigger">test/tests/time_integrators/dirk/dirk-2d-heat-adap.i</a></li><li><a href="#e50802f2-cd8d-4605-bf60-27d6a3583048" class="modal-trigger">test/tests/variables/fe_hermite/hermite-3-1d.i</a></li><li><a href="#980e1b31-765a-416e-9fc3-9ef05016e551" class="modal-trigger">modules/stochastic_tools/examples/parameter_study/nonlin_diff_react/nonlin_diff_react_sub.i</a></li><li><a href="#02642170-cffd-4d52-b8d0-dec38f8d19c5" class="modal-trigger">test/tests/mortar/gap-conductance-2d-non-conforming/gap-conductance.i</a></li><li><a href="#fe3ee967-40d9-49e2-95f0-7b35f17c915e" class="modal-trigger">python/mms/test/mms_spatial.i</a></li><li><a href="#b5b7a4bf-3990-4212-b2b8-b6c60c953fee" class="modal-trigger">test/tests/dgkernels/3d_diffusion_dg/3d_diffusion_dg_test.i</a></li><li><a href="#23ff0e0d-08ba-4ac2-a482-dc668717805f" class="modal-trigger">test/tests/transfers/multiapp_userobject_transfer/sub.i</a></li><li><a href="#6352bc93-c837-42a7-be14-792eacc7417e" class="modal-trigger">test/tests/postprocessors/nodal_var_value/nodal_var_value.i</a></li><li><a href="#d6a18f0d-8a9b-4937-804c-a2c099d439e4" class="modal-trigger">test/tests/kernels/ode/ode_expl_test.i</a></li><li><a href="#a93f904c-2024-437c-8896-e2c46a2ebb2b" class="modal-trigger">modules/combined/test/tests/elastic_patch/elastic_patch_rz.i</a></li><li><a href="#00b9932f-59e8-4443-af78-0f0c68e544e0" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/gaussian_process/sub.i</a></li><li><a href="#d110fa92-66c7-4e6f-ac98-cd627a3c7cc9" class="modal-trigger">test/tests/misc/check_error/incomplete_kernel_block_coverage_test.i</a></li><li><a href="#0cbef84f-8647-4d51-a2f8-099fa2c14e7a" class="modal-trigger">test/tests/userobjects/postprocessor_spatial_user_object/sub.i</a></li><li><a href="#2893a190-2a4e-4c88-bca4-77749573d750" class="modal-trigger">test/tests/multiapps/restart_multilevel/master2.i</a></li><li><a href="#e1b6760e-2d8c-4bf3-b0d3-8f9f7a3df7c0" class="modal-trigger">test/tests/multiapps/restart/master2.i</a></li><li><a href="#3307a079-6cfc-49ca-938f-77b712772e4c" class="modal-trigger">test/tests/misc/check_error/missing_material_prop_test2.i</a></li><li><a href="#f7a96031-682e-4192-9c36-07e2f94c1ce3" class="modal-trigger">test/tests/auxkernels/error_function_aux/error_function_aux.i</a></li><li><a href="#57c1d3e2-c3b4-4bd9-8316-e0ddcb4a967f" class="modal-trigger">test/tests/bcs/ad_function_neumann_bc/test.i</a></li><li><a href="#237fa828-f1a6-4f3c-9c0c-83a2bcb6e924" class="modal-trigger">modules/porous_flow/test/tests/energy_conservation/heat04_action.i</a></li><li><a href="#b30d1bf1-fd9a-4400-bcc5-f3a3202e5c81" class="modal-trigger">test/tests/transfers/multiapp_high_order_variable_transfer/master_L2_Lagrange.i</a></li><li><a href="#125bc462-ccb6-4645-8fd6-a4e4a64724dc" class="modal-trigger">test/tests/nodalkernels/constraint_enforcement/upper-and-lower-bound.i</a></li><li><a href="#412bec33-e772-49ba-9de0-96c91a83fea3" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/pp_generation_action.i</a></li><li><a href="#d14484ae-3372-435b-95ff-d32d53d31a08" class="modal-trigger">test/tests/multiapps/restart_multilevel/sub.i</a></li><li><a href="#0a42c0b4-e795-4e1f-8844-423a9c76d5fe" class="modal-trigger">modules/heat_conduction/test/tests/convective_heat_flux/coupled.i</a></li><li><a href="#8acd67c0-ee47-4344-9305-4de57335f122" class="modal-trigger">test/tests/variables/fe_hier/hier-3-3d.i</a></li><li><a href="#3e5f9b53-185e-4ef3-a559-bafa4bcf6c82" class="modal-trigger">test/tests/misc/check_error/missing_material_prop_test.i</a></li><li><a href="#8cdf9f6c-422e-43b7-b7ee-3e47f2b7c930" class="modal-trigger">test/tests/kernels/coupled_time_derivative/ad_coupled_time_derivative_test.i</a></li><li><a href="#8ffbcbf3-ec7c-45d8-a453-09c4b893d9e4" class="modal-trigger">test/tests/time_steppers/function_dt/function_dt_min.i</a></li><li><a href="#879661b4-f560-4e01-b4d6-f7b040ad5e17" class="modal-trigger">test/tests/outputs/oversample/over_sampling_test_gen.i</a></li><li><a href="#cd2b4ac6-9676-40ff-af6a-c2f9fad6dcc0" class="modal-trigger">test/tests/postprocessors/nodal_var_value/screen_output_test.i</a></li><li><a href="#fc966b2b-2d48-4f99-bd45-f8e66ee620d4" class="modal-trigger">test/tests/problems/no_material_dependency_check/no_material_coverage_check.i</a></li><li><a href="#3072e26a-ff4e-44f0-83e9-13fb2307d5d0" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_rz_homog1mat.i</a></li><li><a href="#3c7cbd76-9089-47cc-ae48-f31c6ca003c2" class="modal-trigger">modules/stochastic_tools/examples/surrogates/combined/trans_diff_2d/trans_diff_sub.i</a></li><li><a href="#5ebe5e18-b9f8-4229-8c48-4ac7240623ea" class="modal-trigger">test/tests/nodalkernels/constraint_enforcement/upper-bound.i</a></li><li><a href="#1af0023c-fa76-4f9b-bf75-48e4c287dfa9" class="modal-trigger">modules/heat_conduction/test/tests/sideset_heat_transfer/gap_thermal_1D.i</a></li><li><a href="#b3648a9b-d94b-4417-8e59-193c131d7476" class="modal-trigger">test/tests/postprocessors/pps_interval/pps_out_interval.i</a></li><li><a href="#a10200ab-16ca-4455-afd1-cdce7a2850a2" class="modal-trigger">test/tests/time_integrators/crank-nicolson/cranic.i</a></li><li><a href="#537e7678-6777-43e2-9167-77365ac88f4e" class="modal-trigger">test/tests/misc/check_error/coupled_grad_without_declare.i</a></li><li><a href="#760dd380-da4d-4260-b798-ee2767e6f00a" class="modal-trigger">modules/fluid_properties/test/tests/ideal_gas/test.i</a></li><li><a href="#e2ec372e-7c11-4413-b9a8-d19df9cc0887" class="modal-trigger">test/tests/misc/check_error/subdomain_restricted_auxkernel_mismatch.i</a></li><li><a href="#e8497b36-a337-417b-a769-d19aff5c3bd5" class="modal-trigger">test/tests/restart/start_time_override/start_time_override.i</a></li><li><a href="#9b12f8d3-9ad2-4662-b743-4873aaa4694c" class="modal-trigger">modules/heat_conduction/test/tests/convective_heat_flux/t_inf.i</a></li><li><a href="#196c0227-8053-4872-b849-29d11e1725a1" class="modal-trigger">modules/navier_stokes/test/tests/ins/mms/pspg/pspg_mms_test.i</a></li><li><a href="#807bf51b-7e8b-46c7-8846-6724e3e3bffd" class="modal-trigger">test/tests/executioners/steady_time/steady_time.i</a></li><li><a href="#99da9e0b-0600-47a8-909f-13260dbddace" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_rz_homog1mat.i</a></li><li><a href="#1941a41d-cee2-48f8-80a5-a9cc9d8f316e" class="modal-trigger">test/tests/transfers/multiapp_high_order_variable_transfer/master_L2_Lagrange_userobject.i</a></li><li><a href="#3574b3cf-562f-4bc1-8b04-67f1bbbff847" class="modal-trigger">test/tests/dgkernels/dg_displacement/dg_displacement.i</a></li><li><a href="#fad46f4a-a1bf-42a6-b4c4-1e83de532490" class="modal-trigger">test/tests/nodalkernels/constraint_enforcement/vi-bounding.i</a></li><li><a href="#81ed60f4-77ff-4e90-8d47-88dc38f64bbb" class="modal-trigger">test/tests/time_integrators/explicit-euler/ee-2d-quadratic.i</a></li><li><a href="#b8f4d11c-8dbd-44d8-bb8f-89536e34fe41" class="modal-trigger">modules/porous_flow/test/tests/energy_conservation/heat04_fullysat_action.i</a></li><li><a href="#fbb1b5f5-68af-43be-a3ff-833451dc3447" class="modal-trigger">test/tests/time_integrators/dirk/dirk-2d-heat.i</a></li><li><a href="#aa2268fa-0407-4926-bc6f-f3175e1dec3c" class="modal-trigger">test/tests/misc/save_in/block-restricted-save-in.i</a></li><li><a href="#5443cbb9-0b0a-435d-839d-7f00df43d9b7" class="modal-trigger">test/tests/variables/fe_hier/hier-3-2d.i</a></li><li><a href="#9ac7f9f1-1843-4c79-8c97-70c64cb964bd" class="modal-trigger">modules/navier_stokes/test/tests/ins/mms/supg/supg_mms_test.i</a></li><li><a href="#0f22a726-9ce4-485c-8cb8-661ac9d3d633" class="modal-trigger">modules/combined/test/tests/elastic_patch/ad_elastic_patch_rz.i</a></li><li><a href="#ae6d646f-f019-4dc0-9216-5300dd5bda89" class="modal-trigger">test/tests/ics/from_exodus_solution/elem_part2.i</a></li><li><a href="#16866cab-3bd4-4069-af67-66d7f096521a" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_rz_lsdep1mat.i</a></li><li><a href="#54ac29bc-a7d6-4a84-a52a-c7320972c543" class="modal-trigger">test/tests/controls/bool_function_control/bool_function_control.i</a></li><li><a href="#6707e26e-a89d-4552-9396-2515f340c6d6" class="modal-trigger">test/tests/userobjects/interface_user_object/interface_value_rate_increment_user_object_QP.i</a></li><li><a href="#ab3a2d16-35db-49d4-8f13-7432bc669f21" class="modal-trigger">test/tests/bcs/nodal_normals/cylinder_hexes_2nd.i</a></li><li><a href="#02ef947c-a2cf-4fbe-9b9e-7b433ef74f39" class="modal-trigger">test/tests/postprocessors/pps_interval/pps_bad_interval2.i</a></li><li><a href="#b71b541b-a2fd-4aec-afb3-52451e45e0ee" class="modal-trigger">test/tests/preconditioners/pbp/pbp_adapt_test.i</a></li><li><a href="#63482b33-3bd7-45e6-ba5e-83e681f196a5" class="modal-trigger">test/tests/dampers/min_damping/min_general_damping.i</a></li><li><a href="#666f6b4a-83c9-4135-8a69-3f6979f6f950" class="modal-trigger">test/tests/auxkernels/function_scalar_aux/function_scalar_aux.i</a></li><li><a href="#af5bebbe-38e0-4ac8-b078-7fadd459e955" class="modal-trigger">test/tests/bcs/nodal_normals/circle_quads.i</a></li><li><a href="#50d4f9a1-e7e6-4347-84f6-392a31a083ad" class="modal-trigger">test/tests/executioners/executioner/transient.i</a></li><li><a href="#a17365fe-18d7-4958-b5ac-972f706e4802" class="modal-trigger">test/tests/time_integrators/explicit-euler/ee-1d-quadratic.i</a></li><li><a href="#48c90c5d-29f6-42b2-860f-2fb33a079940" class="modal-trigger">test/tests/outputs/exodus/variable_output_test.i</a></li><li><a href="#6b9c5e2a-1bfe-490f-9909-3775e994c03d" class="modal-trigger">test/tests/postprocessors/interface_value/interface_average_variable_value_postprocessor.i</a></li><li><a href="#40115f40-c099-49e7-b77c-d2e0544541f1" class="modal-trigger">examples/ex14_pps/ex14_compare_solutions_2.i</a></li><li><a href="#1e8b31c4-d8c4-4d89-954d-7c2bd9bf1fdd" class="modal-trigger">test/tests/postprocessors/num_adaptivity_cycles/num_adaptivity_cycles.i</a></li><li><a href="#7a7b3467-eeb3-4022-ac96-8373c1fa5240" class="modal-trigger">test/tests/postprocessors/nodal_var_value/pps_output_test.i</a></li><li><a href="#67d41022-6468-45bf-abcb-82f585412005" class="modal-trigger">test/tests/utils/spline_interpolation/bicubic_spline_interpolation.i</a></li><li><a href="#9ae85d23-abe9-4390-92a9-8ac18341c58b" class="modal-trigger">examples/ex13_functions/ex13.i</a></li><li><a href="#41606cb6-8646-4e47-8d79-1543fd6dbd9c" class="modal-trigger">modules/phase_field/test/tests/KKS_system/kks_multiphase.i</a></li><li><a href="#1f2df51c-a080-47ec-bd63-320a077194e4" class="modal-trigger">modules/heat_conduction/test/tests/recover/recover.i</a></li><li><a href="#fa994588-394f-43c6-8814-d9b09d806646" class="modal-trigger">test/tests/adaptivity/initial_adapt/initial_adapt.i</a></li><li><a href="#a74b5ee9-9dde-4e3e-87a7-b9462f8c74ab" class="modal-trigger">test/tests/time_steppers/timesequence_stepper/timesequence_restart3.i</a></li><li><a href="#164e21b4-6198-4587-b588-a6d7d7610f11" class="modal-trigger">test/tests/multiapps/restart_multilevel/subsub.i</a></li><li><a href="#ea2d198f-5aba-49a0-b6f7-1dedfd6bbb52" class="modal-trigger">test/tests/dgkernels/ad_dg_diffusion/2d_diffusion_ad_dg_test.i</a></li><li><a href="#01de52fb-1eaa-4887-82fa-81770cd97d73" class="modal-trigger">test/tests/multiapps/picard/function_dt_sub.i</a></li><li><a href="#31d7bdc7-3aea-428b-8bcf-e320ab693ff3" class="modal-trigger">test/tests/meshgenerators/lower_d_block_generator/names.i</a></li><li><a href="#77408f8a-0583-4ed0-9e03-65242936c930" class="modal-trigger">test/tests/time_steppers/timesequence_stepper/timesequence_restart_failure.i</a></li><li><a href="#3ea62aeb-ac1c-4438-87f2-7bfdca07f91f" class="modal-trigger">test/tests/interfacekernels/gmsh_sidesets/coupled_value_coupled_flux.i</a></li><li><a href="#02c8c8a9-7cd9-4359-a2b5-6a12a96f005f" class="modal-trigger">test/tests/outputs/residual/output_residual_test.i</a></li><li><a href="#35dedd52-d878-4444-b336-3201d541cea8" class="modal-trigger">test/tests/variables/fe_hier/hier-3-1d.i</a></li><li><a href="#c0f45bca-ca7e-4c12-a8f1-bdd85a399fd1" class="modal-trigger">modules/heat_conduction/test/tests/heat_conduction/coupled_convective_heat_flux/const_hw.i</a></li><li><a href="#9fe93da6-9111-4e76-ae9e-600766356dd4" class="modal-trigger">test/tests/multiapps/restart_subapp_ic/sub2.i</a></li><li><a href="#f2031ba1-5aba-4600-8841-31c07b6ae8dc" class="modal-trigger">test/tests/kernels/ode/ode_sys_impl_test.i</a></li><li><a href="#39e78bd5-0396-4151-abe6-a7d2c3c7fdbc" class="modal-trigger">modules/heat_conduction/test/tests/heat_conduction/coupled_convective_heat_flux/coupled_convective_heat_flux_two_phase.i</a></li><li><a href="#3d002eeb-5d2d-4fff-b480-d57310251908" class="modal-trigger">test/tests/utils/spline_interpolation/bicubic_spline_interpolation_y_normal.i</a></li><li><a href="#5b2bf978-fde5-4504-bbb6-057c8a9441ee" class="modal-trigger">test/tests/variables/fe_monomial_const/monomial-const-2d.i</a></li><li><a href="#b935c6b5-76d3-4562-bed4-c013fd27133f" class="modal-trigger">test/tests/kernels/scalar_constraint/scalar_constraint_kernel_disp.i</a></li><li><a href="#0d862a69-0628-4cdf-9974-43afc4598e50" class="modal-trigger">test/tests/mortar/continuity-2d-non-conforming/dual-soln-continuity.i</a></li><li><a href="#f3b43cf9-28cf-4328-a061-6761c08b7147" class="modal-trigger">modules/fluid_properties/test/tests/stiffened_gas/test.i</a></li><li><a href="#706e33d7-f83f-45ae-8f03-2604e0aec1bf" class="modal-trigger">test/tests/restart/restart_subapp_not_master/two_step_solve_sub_restart.i</a></li><li><a href="#0b603a29-2c26-41b0-975c-4b332a9858ae" class="modal-trigger">test/tests/outputs/debug/show_var_residual_norms_debug.i</a></li><li><a href="#abd4a44b-1f14-4170-8642-519ee956e5db" class="modal-trigger">modules/heat_conduction/test/tests/heat_conduction/coupled_convective_heat_flux/on_off.i</a></li><li><a href="#852887a9-dc40-4efa-a55a-67f587f2e37c" class="modal-trigger">test/tests/multiapps/restart_subapp_ic/sub.i</a></li><li><a href="#1d503a40-298a-4b7c-a20c-1eeb411f3f8b" class="modal-trigger">test/tests/kernels/block_kernel/block_kernel_test.i</a></li><li><a href="#d39f2319-44a8-4349-b97b-31520dfc4f42" class="modal-trigger">test/tests/transfers/multiapp_conservative_transfer/sub_userobject.i</a></li><li><a href="#69a8222d-2ced-4649-9bbd-187d821941b1" class="modal-trigger">test/tests/interfacekernels/2d_interface/coupled_value_coupled_flux_dot.i</a></li><li><a href="#0f9be7b0-5b9c-4893-b3e6-d9562fb5ab82" class="modal-trigger">test/tests/postprocessors/avg_nodal_var_value/avg_nodal_var_value.i</a></li><li><a href="#b8008e06-c99a-467f-b0f3-04e39762339e" class="modal-trigger">test/tests/vectorpostprocessors/element_variables_difference_max/element_variables_difference_max.i</a></li><li><a href="#2f732fe4-b133-4a17-90dc-1e3fa4660dd1" class="modal-trigger">test/tests/bcs/nodal_normals/cylinder_hexes.i</a></li><li><a href="#61b45f9f-a5d5-4e4e-a481-daf2822c9c89" class="modal-trigger">test/tests/restart/restart_subapp_not_master/two_step_solve_master.i</a></li><li><a href="#130d808a-3c7b-4e2a-9b60-ea7ce40584ea" class="modal-trigger">test/tests/mortar/continuity-2d-conforming/conforming_two_var.i</a></li><li><a href="#22df9a46-e1e4-4ed6-b69f-bbfed1f6161e" class="modal-trigger">test/tests/time_integrators/actually_explicit_euler_verification/ee-2d-linear-adapt.i</a></li><li><a href="#6a493b2c-3849-4b25-85ca-cf10cbfe19df" class="modal-trigger">test/tests/mortar/continuity-2d-conforming/conforming.i</a></li><li><a href="#a92ce018-b289-4bd3-86a9-8bc0fc5b442f" class="modal-trigger">test/tests/postprocessors/pps_interval/pps_interval_mismatch.i</a></li><li><a href="#267c31b8-c96e-40f4-8e0c-ece9d30583fd" class="modal-trigger">test/tests/preconditioners/pbp/pbp_dg_test.i</a></li><li><a href="#15af39a9-049d-4bad-adb5-8c225176cd24" class="modal-trigger">test/tests/postprocessors/num_nodes/num_nodes.i</a></li><li><a href="#eb8f05dc-131e-4b49-b486-c0ffd83ed435" class="modal-trigger">test/tests/auxkernels/element_aux_var/block_global_depend_elem_aux.i</a></li><li><a href="#b32c7c4f-e0f1-4089-8465-d6f7c5a03472" class="modal-trigger">modules/richards/test/tests/jacobian_2/jnQ2P.i</a></li><li><a href="#ee17f4d6-db8e-4181-a472-98c843ae34c1" class="modal-trigger">test/tests/materials/material/material_test_dg.i</a></li><li><a href="#73364374-2d9d-4e99-a0f9-6bd1eb93d397" class="modal-trigger">test/tests/multiapps/picard/function_dt_master.i</a></li><li><a href="#dccd91f7-6658-49dc-b921-bf8bbd7a4d08" class="modal-trigger">test/tests/materials/material/exception_material.i</a></li><li><a href="#4c7e96c4-18ba-4d82-b974-6ca1adac14a5" class="modal-trigger">test/tests/interfacekernels/3d_interface/coupled_value_coupled_flux.i</a></li><li><a href="#b508e250-b768-4ab6-a600-8584a41726a7" class="modal-trigger">test/tests/multiapps/grid-sequencing/vi-coarse.i</a></li><li><a href="#ff94fb96-156e-44cf-b596-41ead7ba20a5" class="modal-trigger">test/tests/variables/fe_hier/hier-1-3d.i</a></li><li><a href="#017cfffb-177d-4b76-9152-066958809f88" class="modal-trigger">test/tests/multiapps/grid-sequencing/vi-coarser.i</a></li><li><a href="#c6e9f8df-5c8e-4dab-a1f7-51f8a095bfee" class="modal-trigger">test/tests/mesh/custom_partitioner/custom_linear_partitioner_restart_test.i</a></li><li><a href="#165e27d2-9794-4994-95d4-13f8bc03d7e0" class="modal-trigger">test/tests/variables/fe_hier/hier-2-2d.i</a></li><li><a href="#2df4047d-83ef-476b-9bf2-9f603430736b" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/pod_rb/internal/sub.i</a></li><li><a href="#52603590-559e-4898-ad3f-77bc73cf60ec" class="modal-trigger">test/tests/multiapps/restart/sub2.i</a></li><li><a href="#3c7f6404-ae24-4d7e-b779-47ff2b9c68f2" class="modal-trigger">test/tests/problems/reference_residual_problem/reference_residual.i</a></li><li><a href="#9976fd03-49bf-4dd1-b9ac-38a0cf3e8f5a" class="modal-trigger">modules/porous_flow/test/tests/mass_conservation/mass03.i</a></li><li><a href="#24e213e2-308a-4cea-962e-189bec874e86" class="modal-trigger">test/tests/executioners/executioner/steady.i</a></li><li><a href="#be5ff980-aa79-4e06-b56a-d786aca152d7" class="modal-trigger">modules/combined/examples/thermomechanics/circle_thermal_expansion_stress.i</a></li><li><a href="#7a8ee3e6-e35b-4ef9-b619-a6a14a424628" class="modal-trigger">test/tests/interfacekernels/adaptivity/adaptivity.i</a></li><li><a href="#e161bd6f-56b8-48d5-92e9-93cd98458c94" class="modal-trigger">test/tests/vectorpostprocessors/dynamic_point_sampler/dynamic_point_sampler.i</a></li><li><a href="#c141ee76-0f43-4b4c-b30f-ee8914c6806c" class="modal-trigger">test/tests/postprocessors/avg_nodal_var_value/avg_nodal_var_value_ts_begin.i</a></li><li><a href="#4d68d5e0-0d55-4581-8573-20f8abe6302f" class="modal-trigger">modules/stochastic_tools/examples/surrogates/polynomial_regression/sub.i</a></li><li><a href="#00f2f0be-e07a-403a-8492-a77bda481cd2" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_rz_lsdep1mat.i</a></li><li><a href="#749d1885-437d-4a0a-82ba-852abfeb5467" class="modal-trigger">modules/level_set/test/tests/verification/1d_level_set_supg_mms/1d_level_set_supg_mms.i</a></li><li><a href="#378b2f6f-20d8-4f27-857b-170448ccf8ce" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_discrete2mat.i</a></li><li><a href="#d7440d0a-9f70-4c22-b743-5f79d2899ddc" class="modal-trigger">test/tests/time_integrators/rk-2/2d-quadratic.i</a></li><li><a href="#f250280e-060d-4c7c-a418-ab5bc7076c5e" class="modal-trigger">test/tests/interfacekernels/3d_interface/coupled_value_coupled_flux_with_jump_material.i</a></li><li><a href="#bf1ed327-5da7-44ca-abf5-b09a70deb1d8" class="modal-trigger">test/tests/outputs/residual/output_residual_elem.i</a></li><li><a href="#ee016b0a-0fb2-407e-be3b-a66a979f1a73" class="modal-trigger">test/tests/kernels/2d_diffusion/2d_diffusion_bodyforce_test.i</a></li><li><a href="#cc776563-3366-49f6-b9b0-e24527565290" class="modal-trigger">test/tests/time_integrators/convergence/explicit_convergence.i</a></li><li><a href="#afb4a858-de87-40cb-8487-6c1e9f4946d5" class="modal-trigger">test/tests/outputs/oversample/adapt.i</a></li><li><a href="#58412743-7a5f-4e56-b8c3-bc363edb1a41" class="modal-trigger">test/tests/executioners/executioner/steady_state_check_test.i</a></li><li><a href="#d16d1d3e-6b33-4950-b22d-1960dbda0531" class="modal-trigger">python/peacock/tests/common/transient_big.i</a></li><li><a href="#26d5613e-b9fa-4601-a299-92686746415c" class="modal-trigger">modules/geochemistry/test/tests/kernels/time_deriv_1.i</a></li><li><a href="#a0b5aefc-012a-4105-8d01-b3f6c6f323e5" class="modal-trigger">test/tests/dampers/min_damping/min_elem_damping.i</a></li><li><a href="#e5b0205f-e8cc-4994-92e4-694cc6000630" class="modal-trigger">test/tests/time_integrators/implicit-euler/ie-monomials.i</a></li><li><a href="#7d5270bf-7cc2-46ac-87e1-58aa2efee11f" class="modal-trigger">test/tests/time_integrators/actually_explicit_euler_verification/ee-2d-linear.i</a></li><li><a href="#656b6610-0fd2-4905-a2ee-44baec4ff3ce" class="modal-trigger">test/tests/nodalkernels/penalty_dirichlet/nodal_penalty_dirichlet.i</a></li><li><a href="#3e3fafa9-43f5-4d4d-87f0-d291eb87b6c0" class="modal-trigger">test/tests/time_integrators/crank-nicolson/cranic_adapt.i</a></li><li><a href="#8b6c7ee5-196f-4341-bbf1-e17095b490ae" class="modal-trigger">test/tests/executioners/transient_sync_time/transient_time_interval_output_test.i</a></li><li><a href="#d86a7adc-8631-438c-b03b-6ee1eaf96b6d" class="modal-trigger">test/tests/time_integrators/bdf2/bdf2.i</a></li><li><a href="#84cbf912-d5fd-4bec-9a05-e142da82320b" class="modal-trigger">test/tests/time_integrators/explicit-euler/ee-2d-linear-adapt.i</a></li><li><a href="#838664a0-a6b9-4623-a97d-32903fda9c86" class="modal-trigger">test/tests/auxkernels/mesh_integer/mesh_integer.i</a></li><li><a href="#b6bed4fc-c09b-42f7-b528-6c2dd137d90c" class="modal-trigger">test/tests/mesh/adapt/initial_adaptivity_test.i</a></li><li><a href="#af4c60a5-333f-442b-8b70-146a3aa01b73" class="modal-trigger">test/tests/kernels/vector_fe/electromagnetic_coulomb_gauge.i</a></li><li><a href="#2e96f6d5-6534-488f-9944-c9a4f8c995de" class="modal-trigger">test/tests/userobjects/internal_side_user_object/internal_side_user_object_two_materials.i</a></li><li><a href="#c66ac292-4a9f-4916-903e-044b21ae55ca" class="modal-trigger">test/tests/materials/stateful_internal_side_uo/internal_side_uo_stateful.i</a></li><li><a href="#7d03b2eb-f85f-46b1-a658-b403374fc53c" class="modal-trigger">test/tests/tag/tag_interface_kernels.i</a></li><li><a href="#6a3a5fca-7192-49bb-83f8-d85a135427d0" class="modal-trigger">test/tests/indicators/laplacian_jump_indicator/biharmonic_transient.i</a></li><li><a href="#2b960944-6000-474c-960d-df3122abcc99" class="modal-trigger">test/tests/restart/restart_diffusion/restart_diffusion_test_transient_new_name.i</a></li><li><a href="#19e024f5-590a-4e4c-bc5c-3be1fa88a9e2" class="modal-trigger">test/tests/dgkernels/adaptivity/adaptivity.i</a></li><li><a href="#4942156a-76fe-4677-8cbb-7f8e02401b80" class="modal-trigger">test/tests/time_steppers/timesequence_stepper/exodustimesequence.i</a></li><li><a href="#e87ad266-7614-4573-9cc5-4f686b5233ee" class="modal-trigger">test/tests/restart/restart_transient_from_steady/restart_trans_with_sub.i</a></li><li><a href="#beb6f548-2c24-44bb-93b8-d1baf56f5d91" class="modal-trigger">test/tests/interfacekernels/1d_interface/reaction_1D_transient.i</a></li><li><a href="#e6ca5f92-984e-4b57-a4d0-8943cc203351" class="modal-trigger">modules/functional_expansion_tools/examples/2D_interface_no_material/main.i</a></li><li><a href="#52e64c45-0d0c-4e1d-853a-3444f8f715a1" class="modal-trigger">modules/navier_stokes/test/tests/ins/mms/supg/supg_adv_dominated_mms.i</a></li><li><a href="#6c0d00ef-351f-4e5c-a1c3-d3d1e80496b5" class="modal-trigger">modules/combined/test/tests/poro_mechanics/pp_generation.i</a></li><li><a href="#7fbe3659-a621-46b3-88c9-cbdc992e63ae" class="modal-trigger">test/tests/time_steppers/timesequence_stepper/timesequence_failed_solve.i</a></li><li><a href="#b9d4aa01-35b1-4184-8eb1-3b1eee22adff" class="modal-trigger">test/tests/fvkernels/fv_adapt/transient-adapt.i</a></li><li><a href="#36b32f70-0d73-48ba-8fac-7fa823915251" class="modal-trigger">test/tests/multiapps/grid-sequencing/vi-fine.i</a></li><li><a href="#5b35e667-5ee4-4e98-803f-b8bd4b4ba9ea" class="modal-trigger">test/tests/postprocessors/nodal_max_value/nodal_max_value_test.i</a></li><li><a href="#84a08292-890a-47ab-b1f0-ac8bbb4a9f43" class="modal-trigger">test/tests/dgkernels/2d_diffusion_dg/no_mallocs_with_action.i</a></li><li><a href="#5dea69c0-f009-4390-b8e3-11104998eadc" class="modal-trigger">test/tests/postprocessors/element_vec_l2_error_pps/element_vec_l2_error.i</a></li><li><a href="#89590f8e-ecc2-459d-adf2-e00130b18875" class="modal-trigger">test/tests/outputs/exodus/exodus_discontinuous.i</a></li><li><a href="#bcb5186a-40b2-49ee-b76e-67db63bd315d" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined_constM.i</a></li><li><a href="#356ad4fe-9451-4860-9eb6-729f9bf21e78" class="modal-trigger">test/tests/time_steppers/timesequence_stepper/csvtimesequence.i</a></li><li><a href="#db0762ff-9892-4342-bfad-dd2fd9a55a36" class="modal-trigger">test/tests/materials/material/adv_mat_couple_test.i</a></li><li><a href="#8802f005-ced3-4e05-a087-9d6e8ad262d4" class="modal-trigger">modules/navier_stokes/test/tests/ins/mms/supg/supg_pspg_adv_dominated_mms.i</a></li><li><a href="#1ad42386-65c5-469b-9531-b9e5f8871680" class="modal-trigger">modules/tensor_mechanics/test/tests/initial_stress/gravity.i</a></li><li><a href="#d28b010c-150f-49f1-8ff2-2ce2a5930f40" class="modal-trigger">modules/ray_tracing/test/tests/coord_type/rz_line_integral.i</a></li><li><a href="#fcad3ede-5dc6-4d82-973a-88f46221038b" class="modal-trigger">test/tests/executioners/executioner/sln-time-adapt.i</a></li><li><a href="#510caada-258b-4803-ab96-cdb912b14724" class="modal-trigger">modules/tensor_mechanics/test/tests/inertial_torque/simple.i</a></li><li><a href="#09651f64-e3ed-47a2-a8d8-e4fab838cd7f" class="modal-trigger">test/tests/bcs/nodal_normals/circle_tris.i</a></li><li><a href="#aa754444-06c5-4568-b6aa-4c8feab25dc3" class="modal-trigger">test/tests/executioners/executioner/steady-adapt.i</a></li><li><a href="#b38857ce-70a7-4cb8-9b4b-552a8d272e01" class="modal-trigger">test/tests/time_steppers/timesequence_stepper/timesequence_restart1.i</a></li><li><a href="#dc14693d-3751-4f8c-b2ee-3705610790e0" class="modal-trigger">test/tests/interfacekernels/2d_interface/coupled_value_coupled_flux.i</a></li><li><a href="#9eb1914b-a376-4661-9ab8-1c2eeae097c6" class="modal-trigger">test/tests/postprocessors/interface_value/interface_integral_variable_value_postprocessor.i</a></li><li><a href="#dddc4ef1-06fd-46a1-a046-6ffc74c2258c" class="modal-trigger">test/tests/time_integrators/explicit-euler/ee-2d-linear.i</a></li><li><a href="#61aba623-0259-4696-829a-ee9b9d909da5" class="modal-trigger">test/tests/dampers/interactions/interacting_node_elem_dampers.i</a></li><li><a href="#7c7d1325-93b5-4198-8d03-85a57f982bed" class="modal-trigger">test/tests/bcs/penalty_dirichlet_bc/function_penalty_dirichlet_bc_test.i</a></li><li><a href="#25b0c8a3-e124-41ed-8b99-175db17dcfa9" class="modal-trigger">test/tests/transfers/multiapp_conservative_transfer/sub_nearest_point.i</a></li><li><a href="#4b31cef6-b063-4699-981a-856da99a5ddd" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_xy_lsdep1mat.i</a></li><li><a href="#5a2b0bc9-11d3-4a7c-9972-7e83dcc5b268" class="modal-trigger">test/tests/postprocessors/num_adaptivity_cycles/num_adaptivity_cycles_toggle_adaptivity_wait.i</a></li><li><a href="#8a4435b2-e526-4119-a79a-c3239af6aedc" class="modal-trigger">test/tests/controls/time_periods/dgkernels/dgkernels.i</a></li><li><a href="#b2e94779-d1fd-411b-a776-1697b8b8a9e5" class="modal-trigger">modules/porous_flow/test/tests/poro_elasticity/pp_generation.i</a></li><li><a href="#7ed7479a-19ff-4030-814d-dc531697fa60" class="modal-trigger">test/tests/materials/material/adv_mat_couple_test2.i</a></li><li><a href="#66882c61-aae6-44fe-9cc8-0d086179edfe" class="modal-trigger">test/tests/auxkernels/element_var/element_var_test.i</a></li><li><a href="#7bfd0bf0-6e0a-4cfa-907a-e54ebbae59fb" class="modal-trigger">python/peacock/tests/common/transient.i</a></li><li><a href="#907650b1-9e5a-4e05-a6ba-fdae8b2924e0" class="modal-trigger">test/tests/time_integrators/actually_explicit_euler_verification/ee-1d-linear.i</a></li><li><a href="#4509e79a-bd3e-4151-9263-28c4738cd86b" class="modal-trigger">test/tests/postprocessors/element_l2_error_pps/element_l2_error_pp_test.i</a></li><li><a href="#aa485e20-5f70-49e9-ba43-7f52f71140c8" class="modal-trigger">test/tests/dgkernels/2d_diffusion_dg/dg_stateful.i</a></li><li><a href="#aa805bf9-2bae-49a1-a4eb-97a250db0a5d" class="modal-trigger">test/tests/time_integrators/actually_explicit_euler_verification/ee-1d-quadratic-neumann.i</a></li><li><a href="#567f88b7-8270-4cba-ba79-ea1236fa6e44" class="modal-trigger">test/tests/postprocessors/pps_interval/pps_bad_interval3.i</a></li><li><a href="#7142a787-5801-446e-a8d5-3afa24172c32" class="modal-trigger">test/tests/kernels/forcing_function/forcing_function_test.i</a></li><li><a href="#ca584785-ddcc-4fd7-92fe-e5749210a71d" class="modal-trigger">test/tests/functions/parsed/mms_transient_coupled.i</a></li><li><a href="#76366fff-03c2-4bcf-9484-034925efadf7" class="modal-trigger">test/tests/time_integrators/aee/aee.i</a></li><li><a href="#cd99db0a-a1c3-4fb4-9b6c-878a9e92ad69" class="modal-trigger">modules/tensor_mechanics/test/tests/initial_stress/gravity_cosserat.i</a></li><li><a href="#604e8f61-4294-468d-990b-4f18b8c1d6c8" class="modal-trigger">test/tests/postprocessors/element_integral_var_pps/pps_old_value.i</a></li><li><a href="#21edde6d-07d6-44bc-b13c-5d45ef73d450" class="modal-trigger">test/tests/time_steppers/postprocessor_dt/postprocessor_dt.i</a></li><li><a href="#ad462a8e-7d07-49d0-922c-45f37c138e96" class="modal-trigger">test/tests/time_steppers/timesequence_stepper/timesequence_restart2.i</a></li></ul><div class="modal moose-modal" id="26f673ef-63f9-4552-8140-cbd1ee6ccdd4"><div class="modal-content"><h4>test/tests/materials/boundary_material/bnd_coupling_vol.i</h4><pre class="moose-pre"><code class="language-text">#
# Coupling volumetric material property inside boundary restricted material
# Also bringing boundary restricted material inside another boundary restricted
# material
#
# Solving: k \Laplace u + u - f = 0
#
# u = x^2 + y^2
# k = 3, but is decomposed as k3vol = k1vol + k2vol, where k1vol = 1 and k2vol = 2
#
# Boundary material property is computed as k3bnd = k1vol + k2bnd
#
# The material properties with suffix `vol` are volumetric, the ones with suffix `bnd`
# are boundary restricted
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 4
  ny = 4
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./f_fn]
    type = ParsedFunction
    value = -4*3+x*x+y*y
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[Kernels]
  [./diff]
    type = DiffMKernel
    variable = u

    offset = 0
    mat_prop = k3vol
  [../]

  [./r]
    type = Reaction
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = MatDivergenceBC
    variable = u
    prop_name = k3bnd
    boundary = &#x27;left right top bottom&#x27;
  [../]
[]

[Materials]
  [./k1vol]
    type = GenericConstantMaterial
    prop_names = &#x27;k1vol&#x27;
    prop_values = 1
    block = 0
  [../]

  [./k2vol]
    type = GenericConstantMaterial
    prop_names = &#x27;k2vol&#x27;
    prop_values = 2
    block = 0
  [../]
  [./k2bnd]
    type = GenericConstantMaterial
    prop_names = &#x27;k2bnd&#x27;
    prop_values = 2
    boundary = &#x27;left right top bottom&#x27;
  [../]

  [./k3vol]
    type = SumMaterial
    sum_prop_name = k3vol
    mp1 = k1vol
    mp2 = k2vol
    block = 0

    val1 = 1
    val2 = 2
  [../]

  [./k3bnd]
    type = SumMaterial
    sum_prop_name = &#x27;k3bnd&#x27;
    mp1 = k1vol
    mp2 = k2bnd
    boundary = &#x27;left right top bottom&#x27;

    val1 = 1
    val2 = 2
  [../]
[]

[Postprocessors]
  [./l2err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4af018df-920c-466e-a7f8-48a3e9541c08"><div class="modal-content"><h4>test/tests/functions/constant_function/constant_function_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 4
  ny = 4
  elem_type = QUAD4
[]

[Functions]
  [./bc_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./icfn]
    type = ConstantFunction
    value = 1
  [../]

  [./ffn]
    type = ConstantFunction
    value = -4
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = icfn
    [../]
  [../]
[]

[Kernels]
  # Coupling of nonlinear to Aux
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = bc_fn
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;

[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cf0eb4f8-3441-431d-8678-3da7797a2a97"><div class="modal-content"><h4>test/tests/time_steppers/function_dt/function_dt_no_interpolation.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]

  [./dts]
    type = PiecewiseConstant
    x = &#x27;0  4  8 12  20&#x27;
    y = &#x27;0  1  2  4  8&#x27;
    direction = right
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  start_time = 0
  end_time = 20
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dc5eef3f-0af0-4e80-8ed5-98f3c8b5c197"><div class="modal-content"><h4>test/tests/postprocessors/element_time_derivative/el_time_deriv_1d_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -5
  xmax = 5
  ymin = -1
  nx = 5
  elem_type = EDGE
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = t*x+1
  [../]
[]

[Kernels]
  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
  [./diffusion]
    type = Diffusion
    variable = u
  [../]
  [./timeDer]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./all]
    type = DirichletBC
    variable = u
    boundary = &#x27;0 1&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  [./elementAvgTimeDerivative]
    type = ElementAverageTimeDerivative
    variable = u
  [../]
  [./elementAvgValue]
    type = ElementAverageValue
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  scheme = implicit-euler

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_el_time_deriv_1d
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1c8ef1f5-3c88-4bf8-b5f7-789a1b8bf116"><div class="modal-content"><h4>test/tests/utils/spline_interpolation/bicubic_spline_interpolation_x_normal.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1 # needed to ensure Z is the problem dimension
  ny = 4
  nz = 4
  ymax = 4
  zmax = 4
[]

[Functions]
  [./yx1]
    type = ParsedFunction
    value = &#x27;3*y^2&#x27;
  [../]
  [./yx2]
    type = ParsedFunction
    value = &#x27;6*z^2&#x27;
  [../]
  [./spline_fn]
    type = BicubicSplineFunction
    normal_component = &#x27;x&#x27;
    x1 = &#x27;0 2 4&#x27;
    x2 = &#x27;0 2 4 6&#x27;
    y = &#x27;0 16 128 432 8 24 136 440 64 80 192 496&#x27;
    yx11 = &#x27;0 0 0 0&#x27;
    yx1n = &#x27;48 48 48 48&#x27;
    yx21 = &#x27;0 0 0&#x27;
    yx2n = &#x27;216 216 216&#x27;
    yx1 = &#x27;yx1&#x27;
    yx2 = &#x27;yx2&#x27;
  [../]
  [./u_func]
    type = ParsedFunction
    value = &#x27;y^3 + 2*z^3&#x27;
  [../]
  [./u2_forcing_func]
    type = ParsedFunction
    value = &#x27;-6*y - 12*z&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./bi_func_value]
    order = FIRST
    family = LAGRANGE
  [../]
  [./y_deriv]
    order = FIRST
    family = LAGRANGE
  [../]
  [./z_deriv]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./bi_func_value]
    type = FunctionAux
    variable = bi_func_value
    function = spline_fn
  [../]
  [./deriv_1]
    type = FunctionDerivativeAux
    function = spline_fn
    variable = y_deriv
    component = 2
  [../]
  [./deriv_2]
    type = FunctionDerivativeAux
    function = spline_fn
    variable = z_deriv
    component = 3
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./body_force]
    type = BodyForce
    variable = u
    function = u2_forcing_func
  [../]
[]

[BCs]
  [./sides]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right front back&#x27;
    function = u_func
  [../]
[]

[Postprocessors]
  [./nodal_l2_err_spline]
    type = NodalL2Error
    variable = u
    function = spline_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./nodal_l2_err_analytic]
    type = NodalL2Error
    variable = u
    function = u_func
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./y_deriv_err_analytic]
    type = NodalL2Error
    variable = y_deriv
    function = yx1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./z_deriv_err_analytic]
    type = NodalL2Error
    variable = z_deriv
    function = yx2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
  nl_rel_tol = 1e-12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b620ab60-ed31-4589-9809-e299e9f75b2b"><div class="modal-content"><h4>test/tests/kernels/scalar_constraint/scalar_constraint_kernel.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]

  [./bottom_bc_fn]
    type = ParsedFunction
    value = -2*y
  [../]

  [./right_bc_fn]
    type = ParsedFunction
    value =  2*x
  [../]

  [./top_bc_fn]
    type = ParsedFunction
    value =  2*y
  [../]

  [./left_bc_fn]
    type = ParsedFunction
    value = -2*x
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]

  [./lambda]
    family = SCALAR
    order = FIRST
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffnk]
    type = BodyForce
    variable = u
    function = ffn
  [../]

  [./sk_lm]
    type = ScalarLagrangeMultiplier
    variable = u
    lambda = lambda
  [../]
[]

[ScalarKernels]
  [./constraint]
    type = AverageValueConstraint
    variable = lambda
    pp_name = pp
    value = 2.666666666666666
  [../]
[]

[BCs]
  [./bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bottom_bc_fn
  [../]
  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_bc_fn
  [../]
  [./top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = top_bc_fn
  [../]
  [./left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = left_bc_fn
  [../]
[]

[Postprocessors]
  [./pp]
    type = ElementIntegralVariablePostprocessor
    variable = u
    execute_on = linear
  [../]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./pc]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-9
  l_tol = 1.e-10
  nl_max_its = 10
  # This example builds an indefinite matrix, so &quot;-pc_type hypre -pc_hypre_type boomeramg&quot; cannot
  # be used reliably on this problem. ILU(0) seems to do OK in both serial and parallel in my testing,
  # I have not seen any zero pivot issues.
  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;bjacobi  ilu&#x27;
  # This is a linear problem, so we don&#x27;t need to recompute the
  # Jacobian. This isn&#x27;t a big deal for a Steady problems, however, as
  # there is only one solve.
  solve_type = &#x27;LINEAR&#x27;
[]

[Outputs]
  exodus = true
  hide = lambda
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="68e4ab80-ef64-49f0-b99a-188a0fe5cc56"><div class="modal-content"><h4>modules/richards/test/tests/jacobian_2/jn_fu_01.i</h4><pre class="moose-pre"><code class="language-text"># two phase
# unsaturated = true

# gravity = false
# supg = false
# transient = false

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]

[GlobalParams]
  richardsVarNames_UO = PPNames
  density_UO = &#x27;DensityWater DensityGas&#x27;
  relperm_UO = &#x27;RelPermWater RelPermGas&#x27;
  SUPG_UO = &#x27;SUPGwater SUPGgas&#x27;
  sat_UO = &#x27;SatWater SatGas&#x27;
  seff_UO = &#x27;SeffWater SeffGas&#x27;
[]

[UserObjects]
  [./PPNames]
    type = RichardsVarNames
    richards_vars = &#x27;pwater pgas&#x27;
  [../]
  [./DensityWater]
    type = RichardsDensityConstBulk
    dens0 = 1
    bulk_mod = 1.0 # notice small quantity, so the PETSc constant state works
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5 # notice small quantity, so the PETSc constant state works
  [../]
  [./SeffWater]
    type = RichardsSeff2waterVG
    m = 0.8
    al = 1 # notice small quantity, so the PETSc constant state works
  [../]
  [./SeffGas]
    type = RichardsSeff2gasVG
    m = 0.8
    al = 1 # notice small quantity, so the PETSc constant state works
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.2
    n = 2
  [../]
  [./RelPermGas]
    type = RichardsRelPermPower
    simm = 0.1
    n = 3
  [../]
  [./SatWater]
    type = RichardsSat
    s_res = 0.1
    sum_s_res = 0.15
  [../]
  [./SatGas]
    type = RichardsSat
    s_res = 0.05
    sum_s_res = 0.15
  [../]
  [./SUPGwater]
    type = RichardsSUPGnone
  [../]
  [./SUPGgas]
    type = RichardsSUPGnone
  [../]
[]

[Variables]
  [./pwater]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      block = 0
      min = -1
      max = 0
    [../]
  [../]
  [./pgas]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      block = 0
      min = 0
      max = 1
    [../]
  [../]
  [./non_Richards]
  [../]
[]


[Kernels]
  active = &#x27;richardsfwater richardsfgas non_Richards_should_have_0_off_diag&#x27;
  [./richardstwater]
    type = RichardsMassChange
    variable = pwater
  [../]
  [./richardsfwater]
    type = RichardsFullyUpwindFlux
    variable = pwater
  [../]
  [./richardstgas]
    type = RichardsMassChange
    variable = pgas
  [../]
  [./richardsfgas]
    type = RichardsFullyUpwindFlux
    variable = pgas
  [../]
  [./non_Richards_should_have_0_off_diag]
    type = BodyForce
    variable = non_Richards
    function = 0
  [../]
[]

[Materials]
  [./rock]
    type = RichardsMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1E-5 0 0  0 1E-5 0  0 0 1E-5&#x27;
    viscosity = &#x27;1E-3 0.5E-3&#x27;
    gravity = &#x27;0 0 0&#x27;
    linear_shape_fcns = true
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -snes_type&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-10 10000 test&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1E-5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = jn01
  exodus = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fa2dc504-a3a3-43a5-8b4c-90d3a6bc01c5"><div class="modal-content"><h4>test/tests/problems/no_kernel_coverage_check/no_coverage_check.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Problem]
  kernel_coverage_check = false
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
    block = 1
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[BCs]
  active = &#x27;left&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cf799a32-237f-4e01-829b-4be0b23b6769"><div class="modal-content"><h4>test/tests/restart/restart_add_variable/add_variable_restart.i</h4><pre class="moose-pre"><code class="language-text"># Use the exodus file for restarting the problem:
# - restart one variable
# - and have one extra variable
# - have PBP active to have more system in Equation system
#

[Mesh]
  file = transient_with_stateful_out.e
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./diffusivity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./out_diffusivity]
    type = MaterialRealAux
    variable = diffusivity
    property = diffusivity
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = MatDiffusionTest
    variable = u
    prop_name = diffusivity
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[Materials]
  [./mat]
    type = StatefulMaterial
    block = 0
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    value = 0
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;1&#x27;
    value = 1
  [../]
[]

[Preconditioning]
  [./PBP]
    type = PBP
    solve_order = &#x27;u v&#x27;
    preconditioner = &#x27;AMG AMG&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = JFNK
  dt = 0.1
  reset_dt = true #NECESSARY to force a change in DT when using restart!
  num_steps = 3
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
    execute_elemental_on = none
  [../]
[]

[Problem]
  restart_file_base = transient_with_stateful_out_cp/LATEST
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7eced0b2-652c-47f7-8aa4-504d2968470a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/initial_stress/gravity_with_aux.i</h4><pre class="moose-pre"><code class="language-text"># Apply an initial stress, using AuxVariables, that should be
# exactly that caused by gravity, and then
# do a transient step to check that nothing
# happens

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 10
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -10
  zmax = 0
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./weight]
    type = BodyForce
    variable = disp_z
    value = -0.5 # this is density*gravity
  [../]
[]


[BCs]
  # back = zmin
  # front = zmax
  # bottom = ymin
  # top = ymax
  # left = xmin
  # right = xmax
  [./x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left right&#x27;
    value = 0
  [../]
  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom top&#x27;
    value = 0
  [../]
  [./z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;back&#x27;
    value = 0
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./aux_equals_1]
    initial_condition = 1
  [../]
  [./aux_equals_2]
    initial_condition = 2
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]


[Functions]
  [./half_weight]
    type = ParsedFunction
    value = &#x27;0.25*z&#x27; # half of the initial stress that should result from the weight force
  [../]
  [./kxx]
    type = ParsedFunction
    value = &#x27;0.4*z&#x27; # some arbitrary xx and yy stress that should not affect the result
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputeSmallStrain
    eigenstrain_names = ini_stress
  [../]
  [./strain_from_initial_stress]
    type = ComputeEigenstrainFromInitialStress
    initial_stress = &#x27;kxx 0 0  0 kxx 0  0 0 half_weight&#x27;
    initial_stress_aux = &#x27;aux_equals_1 aux_equals_1 aux_equals_1  aux_equals_1 aux_equals_1 aux_equals_1  aux_equals_1 aux_equals_1 aux_equals_2&#x27;
    eigenstrain_name = ini_stress
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]


[Executioner]
  end_time = 1.0
  dt = 1.0
  solve_type = NEWTON
  type = Transient

  nl_abs_tol = 1E-8
  nl_rel_tol = 1E-12
  l_tol = 1E-3
  l_max_its = 200
  nl_max_its = 400

  petsc_options_iname = &#x27;-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27; asm      2              lu            gmres     200&#x27;
[]



[Outputs]
  file_base = gravity_with_aux
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d92de933-765b-44e9-bd77-46b9e41ea2d5"><div class="modal-content"><h4>test/tests/postprocessors/element_average_value/elem_pps_multi_block_test.i</h4><pre class="moose-pre"><code class="language-text">#
# Tests elemental PPS running on multiple block
#
[Mesh]
  type = StripeMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 3
  ny = 3
  elem_type = QUAD4
  stripes = 3
  # StripeMesh currently only works correctly with ReplicatedMesh.
  parallel_type = replicated
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]
[]

[Variables]
  [./u]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Kernels]
  [./uv]
    type = Reaction
    variable = u
  [../]

  [./fv]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[Postprocessors]
  [./avg_1_2]
    type = ElementAverageValue
    variable = u
    block = &#x27;0 1&#x27;
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8f76d882-904e-4226-88f1-5d784e342624"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed linear level set function
# Description:
#   A simple transient heat transfer problem in Cartesian coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is a single, constant value at all points in the system.
# Results:
#   The temperature at the left boundary (x=0) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM results
#   at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0000064
#      0.6                  520         520.0000323
#      0.8                  560         560.0000896
#      1.0                  600         600.0001870
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+200)&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;1-(x-0.04)-0.2*t&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*200*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1344af3b-803f-4a67-9686-2e940e9935e8"><div class="modal-content"><h4>test/tests/bcs/function_neumann_bc/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 32
    ny = 32
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./exact_func]
    type = ParsedFunction
    value = x*x
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    value = 2
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionNeumannBC
    function = exact_func
    variable = u
    boundary = right
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = neumannbc_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0d4081db-f288-4dee-9c64-8eb8a179f30a"><div class="modal-content"><h4>test/tests/time_integrators/explicit-euler/ee-1d-linear.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 200
  elem_type = EDGE2
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    lumping = true
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1&#x27;
    function = exact_fn
    implicit = true
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;explicit-euler&#x27;
  solve_type = &#x27;LINEAR&#x27;

  start_time = 0.0
  num_steps = 20
  dt = 0.00005
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c3033b2f-3db2-4088-b93e-f7c06c27558f"><div class="modal-content"><h4>test/tests/adaptivity/interval/adapt_interval.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 6
  dt = 1

  solve_type = &#x27;PJFNK&#x27;

[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  interval = 2
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6d8c12c9-07de-4e18-8ace-945a2d83316a"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/pp_generation_fullysat_action.i</h4><pre class="moose-pre"><code class="language-text"># Same as pp_generation.i, but using an Action
#
# A sample is constrained on all sides and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie kg/second per cubic meter), and the
# rise in porepressure is observed.
#
# Source = s  (units = kg/m^3/second)
#
# Expect:
# fluid_mass = mass0 + s*t
# stress = 0 (remember this is effective stress)
# Porepressure = fluid_bulk*log(fluid_mass_density/density_P0), where fluid_mass_density = fluid_mass*porosity
# porosity = biot+(phi0-biot)*exp(pp(biot-1)/solid_bulk)
#
# Parameters:
# Biot coefficient = 0.3
# Phi0 = 0.1
# Solid Bulk modulus = 2
# fluid_bulk = 13
# density_P0 = 1

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]
[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.0
      bulk_modulus = 13.0
      viscosity = 1.0
      density0 = 1.0
    [../]
  [../]
[]

[PorousFlowFullySaturated]
  coupling_type = HydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  biot_coefficient = 0.3
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
[]


[Kernels]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./porosity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./porosity]
    type = PorousFlowPropertyAux
    variable = porosity
    property = porosity
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./porosity]
    type = PorousFlowPorosity
    fluid = true
    mechanical = true
    porosity_zero = 0.1
    biot_coefficient = 0.3
    solid_bulk = 2
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0   0 1 0   0 0 1&#x27; # unimportant
  [../]
[]

[Functions]
  [./porosity_analytic]
    type = ParsedFunction
    value = &#x27;biot+(phi0-biot)*exp(pp*(biot-1)/bulk)&#x27;
    vars = &#x27;biot phi0 pp bulk&#x27;
    vals = &#x27;0.3 0.1 p0 2&#x27;
  [../]
[]

[Postprocessors]
  [./fluid_mass]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;initial timestep_end&#x27;
    use_displaced_mesh = true
  [../]
  [./porosity]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    point = &#x27;0 0 0&#x27;
    variable = porosity
  [../]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./porosity_analytic]
    type = FunctionValuePostprocessor
    function = porosity_analytic
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]

[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_fullysat_action
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3bad934c-7f8a-414f-87e1-432277aab040"><div class="modal-content"><h4>modules/heat_conduction/test/tests/sideset_heat_transfer/gap_thermal_ktemp_1D.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [mesh]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 2
    xmax = 2
  []
  [split]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    block_id = 1
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 0 0&#x27;
  []
  [interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = split
    primary_block = 1
    paired_block = 0
    new_boundary = &#x27;interface0&#x27;
  []
  uniform_refine = 4
[]

[Variables]
  [T]
    order = FIRST
    family = MONOMIAL
  []
[]

[AuxVariables]
  [Tbulk]
    order = FIRST
    family = LAGRANGE
    initial_condition = 300 # K
  []
[]

[Kernels]
  [diff]
    type = MatDiffusion
    variable = T
    diffusivity = conductivity
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[DGKernels]
  [dg_diff]
    type = DGDiffusion
    variable = T
    epsilon = -1
    sigma = 6
    diff = conductivity
    exclude_boundary = &#x27;interface0&#x27;
  []
[]

[InterfaceKernels]
  [gap_var]
    type = SideSetHeatTransferKernel
    variable = T
    neighbor_var = T
    boundary = &#x27;interface0&#x27;
    Tbulk_var = Tbulk
  []
[]

[Functions]
  # Defining temperature dependent fucntion for conductivity across side set
  [kgap]
    type = ParsedFunction
    value = &#x27;t / 200&#x27;
  []
  [bc_func]
    type = ConstantFunction
    value = 300
  []
  [exact]
    type = ParsedFunction
    value = &#x27;
            A := if(x &lt; 1, -0.5, -0.25);
            B := if(x &lt; 1, -0.293209850655001, 0.0545267662299068);
            C := if(x &lt; 1, 300.206790149345, 300.19547323377);
            d := -1;
            A * (x+d) * (x+d) + B * (x+d) + C&#x27;
  []
[]

[BCs]
  [bc_left]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;left&#x27;
    variable = T
    diff = &#x27;conductivity&#x27;
    epsilon = -1
    sigma = 6
    function = bc_func
  []
  [bc_right]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;right&#x27;
    variable = T
    diff = &#x27;conductivity&#x27;
    epsilon = -1
    sigma = 6
    function = bc_func
  []
[]

[Materials]
  [k0]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 1.0
    block = 0
  []
  [k1]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 2.0
    block = 1
  []
  [gap_mat]
    type = SideSetHeatTransferMaterial
    boundary = &#x27;interface0&#x27;
    # Using temperature dependent function for gap conductivity
    conductivity_temperature_function = kgap
    # Variable to evaluate conductivity with
    gap_temperature = Tbulk
    gap_length = 1.0
    h_primary = 1
    h_neighbor = 1
    emissivity_primary = 1
    emissivity_neighbor = 1
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    variable = T
    function = exact
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e7ff65a5-5307-4622-af6c-bb7d743d12be"><div class="modal-content"><h4>test/tests/misc/check_error/missing_req_par_mesh_block_test.i</h4><pre class="moose-pre"><code class="language-text">#
# Tests elemental PPS running on multiple block
#

[Mesh]
  type = StripeMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 3
  ny = 3
  elem_type = QUAD4
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]
[]

[Variables]
  [./u]
   family = MONOMIAL
   order = CONSTANT
  [../]
[]

[Kernels]
  [./uv]
    type = Reaction
    variable = u
  [../]

  [./fv]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[Postprocessors]
  [./avg_1_2]
    type = ElementAverageValue
    variable = u
    block = &#x27;0 1&#x27;
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f42dd33b-1817-41b3-a610-17731513e227"><div class="modal-content"><h4>test/tests/kernels/vector_fe/coupled_scalar_vector_jacobian.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = -1.1
  ymin = -1.1
  xmax = 1.1
  ymax = 1.1
  elem_type = QUAD9
[]

[Variables]
  [./u]
    family = NEDELEC_ONE
    order = FIRST
  [../]
  [./v]
  [../]
[]

[Kernels]
  [./wave]
    type = VectorFEWave
    variable = u
    x_forcing_func = &#x27;x_ffn&#x27;
    y_forcing_func = &#x27;y_ffn&#x27;
  [../]
  [./diff]
    type = Diffusion
    variable = v
  [../]
  [./source]
    type = BodyForce
    variable = v
  [../]
  [./advection]
    type = EFieldAdvection
    variable = v
    efield = u
    charge = &#x27;positive&#x27;
    mobility = 100
  [../]
[]

[Functions]
  [./x_ffn]
    type = ParsedFunction
    value = &#x27;(2*pi*pi + 1)*cos(pi*x)*sin(pi*y)&#x27;
  [../]
  [./y_ffn]
    type = ParsedFunction
    value = &#x27;-(2*pi*pi + 1)*sin(pi*x)*cos(pi*y)&#x27;
  [../]
[]

[Preconditioning]
  [./pre]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;asm&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0da04291-1965-4394-8eb6-646baf3def75"><div class="modal-content"><h4>test/tests/restart/restart_transient_from_transient/restart_trans_with_2subs.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  parallel_type = &#x27;replicated&#x27;
[]

[Problem]
  restart_file_base = pseudo_trans_with_2subs_out_cp/LATEST
[]

[AuxVariables]
  [Tf]
  []
[]

[Variables]
  [power_density]
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27; # increase this function to drive transient
  []
[]

[Kernels]
  [timedt]
    type = TimeDerivative
    variable = power_density
  []

  [diff]
    type = Diffusion
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = power_density
    boundary = left
    value = 50
  []
  [right]
    type = DirichletBC
    variable = power_density
    boundary = right
    value = 1e3
  []
[]

[Postprocessors]
  [pwr_avg]
    type = ElementAverageValue
    block = &#x27;0&#x27;
    variable = power_density
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_avg]
    type = ElementAverageValue
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_max]
    type = ElementExtremeValue
    value_type = max
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_min]
    type = ElementExtremeValue
    value_type = min
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 3
  dt = 1.0

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  line_search = none
[]

[MultiApps]
  [./sub]
    type = TransientMultiApp
    app_type = MooseTestApp
    positions = &#x27;0   0 0
                 0.5 0 0&#x27;
    input_files  = restart_trans_with_2subs_sub.i
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[Transfers]
  [p_to_sub]
    type = MultiAppProjectionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
  [t_from_sub]
    type = MultiAppInterpolationTransfer
    direction = from_multiapp
    source_variable = temp
    variable = Tf
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="650950b5-f6e0-40c2-ab94-adcf3043d017"><div class="modal-content"><h4>test/tests/mortar/cant-do-3d/periodic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [file]
    type = FileMeshGenerator
    file = flow_test.e
  []
  [secondary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    new_block_id = 11
    new_block_name = &quot;secondary&quot;
    sidesets = &#x27;1&#x27;
  []
  [primary]
    input = secondary
    type = LowerDBlockFromSidesetGenerator
    new_block_id = 12
    new_block_name = &quot;primary&quot;
    sidesets = &#x27;2&#x27;
  []
[]

[Variables]
  [u]
    block = &#x27;bottom middle top&#x27;
  []
  [lm]
    block = &#x27;secondary&#x27;
  []
[]

[Kernels]
  [diffusion]
    type = Diffusion
    variable = u
    block = &#x27;bottom middle top&#x27;
  []
  [force]
    type = BodyForce
    variable = u
    block = &#x27;bottom middle top&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    value = 1
    boundary = &#x27;around&#x27;
  []
[]

[Constraints]
  [ev]
    type = EqualValueConstraint
    variable = lm
    secondary_variable = u
    primary_boundary = top
    secondary_boundary = bottom
    primary_subdomain = 12
    secondary_subdomain = 11

    periodic = true
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="389b0768-a9af-4a11-b5ee-3f00b6a56421"><div class="modal-content"><h4>test/tests/bcs/penalty_dirichlet_bc/penalty_dirichlet_bc_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = -2*(x*x+y*y-2)+(1-x*x)*(1-y*y)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (1-x*x)*(1-y*y)
    grad_x = 2*(x*y*y-x)
    grad_y = 2*(x*x*y-y)
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;bc_all&#x27;
  [./bc_all]
    type = PenaltyDirichletBC
    variable = u
    value = 0
    boundary = &#x27;top left right bottom&#x27;
    penalty = 1e5
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-14
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e6b35a12-4b1e-4aa1-ad93-de5e0e72d1b5"><div class="modal-content"><h4>test/tests/restart/restart_transient_from_steady/restart_trans_with_2subs.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  parallel_type = &#x27;replicated&#x27;
[]

[Problem]
  restart_file_base = steady_with_2subs_out_cp/LATEST
  skip_additional_restart_data = true
[]

[AuxVariables]
  [Tf]
  []
[]

[Variables]
  [power_density]
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27; # increase this function to drive transient
  []
[]

[Kernels]
  [timedt]
    type = TimeDerivative
    variable = power_density
  []

  [diff]
    type = Diffusion
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = power_density
    boundary = left
    value = 50
  []
  [right]
    type = DirichletBC
    variable = power_density
    boundary = right
    value = 1e3
  []
[]

[Postprocessors]
  [pwr_avg]
    type = ElementAverageValue
    block = &#x27;0&#x27;
    variable = power_density
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_avg]
    type = ElementAverageValue
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_max]
    type = ElementExtremeValue
    value_type = max
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_min]
    type = ElementExtremeValue
    value_type = min
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 3
  dt = 1.0

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-7

  picard_rel_tol = 1e-7
  picard_abs_tol = 1e-07
  picard_max_its = 4

  line_search = none
[]

[MultiApps]
  [./sub]
    type = TransientMultiApp
    app_type = MooseTestApp
    positions = &#x27;0   0 0
                 0.5 0 0&#x27;
    input_files  = restart_trans_with_sub_sub.i
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[Transfers]
  [p_to_sub]
    type = MultiAppProjectionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
  [t_from_sub]
    type = MultiAppInterpolationTransfer
    direction = from_multiapp
    source_variable = temp
    variable = Tf
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0158a0ca-c603-4c90-8e67-1411e3bde040"><div class="modal-content"><h4>test/tests/kernels/coupled_time_derivative/coupled_time_derivative_test.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test of the CoupledTimeDerivative kernel.
# The expected solution for the variable v is
# v(x) = 1/2 * (x^2 + x)
###########################################################

[Mesh]
  type = GeneratedMesh
  nx = 5
  ny = 5
  dim = 2
[]

[Variables]
  [./u]
  [../]
  [./v]
  [../]
[]

[Kernels]
  [./time_u]
    type = TimeDerivative
    variable = u
  [../]
  [./fn_u]
    type = BodyForce
    variable = u
    function = 1
  [../]
  [./time_v]
    type = CoupledTimeDerivative
    variable = v
    v = u
  [../]
  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = v
    boundary = &#x27;left&#x27;
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = v
    boundary = &#x27;right&#x27;
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  solve_type = &#x27;NEWTON&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f79d4f80-acd3-4d3b-979d-e9378f0c90ed"><div class="modal-content"><h4>test/tests/time_integrators/explicit-euler/ee-1d-quadratic-neumann.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  implicit = false
[]

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 10
  elem_type = EDGE3
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x*x-2*t+t*x*x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x*x
  [../]

  [./left_bc_fn]
    type = ParsedFunction
    value = -t*2*x
  [../]
  [./right_bc_fn]
    type = ParsedFunction
    value = t*2*x
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]
    type = Reaction
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;0&#x27;
    function = left_bc_fn
  [../]

  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;1&#x27;
    function = right_bc_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;explicit-euler&#x27;
  solve_type = &#x27;LINEAR&#x27;

  l_tol = 1e-12
  start_time = 0.0
  num_steps = 10
  dt = 0.001
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="30a55306-ae15-4351-8b0c-ec21910d788d"><div class="modal-content"><h4>test/tests/time_integrators/abort/abort.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1

  nx = 10

  xmin = 0.0
  xmax = 1.0

[]

#still need BC for Energy, IC&#x27;s for both.
[Variables]
  active = &#x27;Time&#x27;

  [./Time]
    order =  FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[Functions]
  active = &#x27;func&#x27;

  [./func]
    type = ParsedFunction
    value = 2.0*t
  [../]
[]

[Kernels]
  active = &#x27;t_time func_time&#x27;

  [./t_time]
    type = TimeDerivative
    variable = Time
  [../]

  [./func_time]
    type = BodyForce
    variable = Time
    function = func
  [../]
[]

[BCs]
  active = &#x27;Top_Temperature&#x27;

  [./Top_Temperature]
    type = NeumannBC
    variable = Time
    boundary = &#x27;left right&#x27;
  [../]

[]

[Executioner]
  type = Transient
  #scheme = &#x27;BDF2&#x27;
  #scheme = &#x27;crank-nicolson&#x27;
  start_time = 0
  num_steps = 4
  dt = 1000000000

  [./Predictor]
    type = SimplePredictor
    scale = 1.0
  [../]

  steady_state_tolerance = .00000000000000001
  steady_state_detection = true
  nl_abs_tol = 1e-15
  petsc_options = &#x27;-snes_converged_reason&#x27;
  abort_on_solve_fail = true
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1d76496c-a5be-43a4-b75d-2fb5231ba59d"><div class="modal-content"><h4>test/tests/time_steppers/timesequence_stepper/timesequence.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  end_time = 4.0
  [./TimeStepper]
    type = TimeSequenceStepper
    time_sequence  = &#x27;0   0.85 1.3 2 4&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9a904d81-8556-49fc-85ad-cad712887998"><div class="modal-content"><h4>test/tests/postprocessors/element_integral_var_pps/initial_pps.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 3
  ny = 3
  elem_type = QUAD9
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 2.8
    [../]
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 5.4
    [../]
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;1&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  [./initial_u]
    type = ElementIntegralVariablePostprocessor
    variable = u
    execute_on = initial
  [../]

  [./initial_v]
    type = ElementIntegralVariablePostprocessor
    variable = v
    execute_on = initial
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 0.3
[]

[Outputs]
  file_base = out_initial_pps
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aae9bbc4-b59b-47e3-8313-82617099f4fd"><div class="modal-content"><h4>test/tests/variables/fe_hermite/hermite-3-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 3*y*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -3*y*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x-6*y+(x*x*x)+(y*y*y)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (x*x*x)+(y*y*y)
    grad_x = 3*x*x
    grad_y = 3*y*y
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;NEWTON&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3b6917de-85a7-43b8-b924-dd801b0b2fc8"><div class="modal-content"><h4>test/tests/time_integrators/actually_explicit_euler_verification/ee-1d-quadratic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 20
  elem_type = EDGE3
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x*x-2*t
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x*x
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  l_tol = 1e-12
  start_time = 0.0
  num_steps = 20
  dt = 0.00005

  [./TimeIntegrator]
    type = ActuallyExplicitEuler
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="df8c2aec-a462-4742-abfa-052a041108ef"><div class="modal-content"><h4>test/tests/transfers/multiapp_userobject_transfer/tosub_sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 8
  xmax = 0.1
  ymax = 0.5
[]

[Variables]
  [./u]
    initial_condition = 1
  [../]
[]

[AuxVariables]
  [./multi_layered_average]
  [../]
  [./element_multi_layered_average]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./axial_force]
    type = ParsedFunction
    value = 1000*y
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = axial_force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  dt = 0.001

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[Problem]
  coord_type = rz
  type = FEProblem
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9aeffac2-9ee8-46ea-aa1c-e0816641c47a"><div class="modal-content"><h4>test/tests/dgkernels/2d_diffusion_dg/2d_diffusion_dg_test.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a test of the Discontinuous Galerkin System.
# Discontinous basis functions are used (Monomials) and
# a the Laplacian DGKernel contributes to the
# internal edges around each element. Jumps are allowed
# by penalized by this method.
#
# @Requirement F3.60
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
#  xmin = -1
#  xmax = 1
#  ymin = -1
#  ymax = 1
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = MONOMIAL

    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[Functions]
  active = &#x27;forcing_fn exact_fn&#x27;

  [./forcing_fn]
    type = ParsedFunction
#    function = -4.0+(x*x)+(y*y)
#    function = x
#    function = (x*x)-2.0
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
#    function = (x*x*x)-6.0*x
  [../]

  [./exact_fn]
    type = ParsedGradFunction
#    function = x
#    grad_x = 1
#    grad_y = 0

#    function = (x*x)+(y*y)
#    grad_x = 2*x
#    grad_y = 2*y

#    function = (x*x)
#    grad_x = 2*x
#    grad_y = 0

    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))

#    function = (x*x*x)
#    grad_x = 3*x*x
#    grad_y = 0
  [../]
[]

[Kernels]
  active = &#x27;diff abs forcing&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]          # u * v
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  active = &#x27;dg_diff&#x27;

  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes_mf&#x27;
#  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
#  petsc_options_value = &#x27;hypre    boomeramg&#x27;

#  petsc_options = &#x27;-snes_mf&#x27;
#  max_r_steps = 2
  [./Adaptivity]
    steps = 2
    refine_fraction = 1.0
    coarsen_fraction = 0
    max_h_level = 8
  [../]

  nl_rel_tol = 1e-10

#  nl_rel_tol = 1e-12
[]

[Postprocessors]
  active = &#x27;h dofs l2_err&#x27;

  [./h]
    type = AverageElementSize
  [../]

  [./dofs]
    type = NumDOFs
  [../]

  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Outputs]
  file_base = out
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f1a5c86e-d361-4e36-9098-e9fecd64fd31"><div class="modal-content"><h4>test/tests/postprocessors/relative_solution_difference_norm/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  elem_type = QUAD4
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./ffn]
    type = ParsedFunction
    value = &#x27;2 - t&#x27;
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 1
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  [../]
[]

[Postprocessors]
  [./rsn]
    type = RelativeSolutionDifferenceNorm
    execute_on = TIMESTEP_END
  [../]
[]

[Executioner]
  type = Transient
  dt = 1
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="56f29187-39c5-41cc-be8b-75889603c85e"><div class="modal-content"><h4>test/tests/dampers/bounding_value_element_damper/bounding_value_max_test.i</h4><pre class="moose-pre"><code class="language-text"># This model tests the BoundingValueElementDamper. The converged solution
# for u starts out in the range from 0 to 1, but after several steps,
# a volumetric source drives it to a value greater than 1, which is
# outside the range of the damper. At that point, the solution can
# no longer converge, and the model errors out with a failure to converge.
# The test verifies that the damper computes the correct value in the first
# nonlinear iteration when the solution exceeds the bounds.

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./source]
    type = BodyForce
    variable = u
    function = &#x27;t&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Dampers]
  [./bounding_value_damp]
    type = BoundingValueElementDamper
    min_value = 0.0
    max_value = 1.0
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  end_time = 3.0
  dt = 0.5
  dtmin = 0.5
  nl_max_its = 5
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f35f3d63-2604-4266-a74d-deb7fd4799ab"><div class="modal-content"><h4>modules/functional_expansion_tools/examples/3D_volumetric_Cartesian_direct/main.i</h4><pre class="moose-pre"><code class="language-text"># Derived from the example &#x27;3D_volumetric_Cartesian&#x27; with the following differences:
#
#   1) The coupling is performed via BodyForce instead of the
#      FunctionSeriesToAux+CoupledForce approach
[Mesh]
  type = GeneratedMesh
  dim = 3

  xmin = 0.0
  xmax = 10.0
  nx = 15

  ymin = 1.0
  ymax = 11.0
  ny = 25

  zmin = 2.0
  zmax = 12.0
  nz = 35
[]

[Variables]
  [./m]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff_m]
    type = HeatConduction
    variable = m
  [../]
  [./time_diff_m]
    type = HeatConductionTimeDerivative
    variable = m
  [../]
  [./s_in] # Add in the contribution from the SubApp
    type = BodyForce
    variable = m
    function = FX_Basis_Value_Main
  [../]
[]

[Materials]
  [./Unobtanium]
    type = GenericConstantMaterial
    prop_names =  &#x27;thermal_conductivity specific_heat density&#x27;
    prop_values = &#x27;1.0                  1.0           1.0&#x27; # W/(cm K), J/(g K), g/cm^3
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    variable = m
    value = 1
  [../]
[]

[BCs]
  [./surround]
    type = DirichletBC
    variable = m
    value = 1
    boundary = &#x27;top bottom left right front back&#x27;
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;3   4   5&#x27;
    physical_bounds = &#x27;0.0  10.0    1.0 11.0    2.0 12.0&#x27;
    x = Legendre
    y = Legendre
    z = Legendre
    enable_cache = true
  [../]
[]

[UserObjects]
  [./FX_Value_UserObject_Main]
    type = FXVolumeUserObject
    function = FX_Basis_Value_Main
    variable = m
  [../]
[]

[Postprocessors]
  [./average_value]
    type = ElementAverageValue
    variable = m
  [../]
  [./peak_value]
    type = ElementExtremeValue
    value_type = max
    variable = m
  [../]
  [./picard_iterations]
    type = NumPicardIterations
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 0.5
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = sub.i
  [../]
[]

[Transfers]
  [./ValueToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Value_UserObject_Main
    multi_app_object_name = FX_Basis_Value_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fb54dbe1-839e-4878-b36e-3cbf7f86e38c"><div class="modal-content"><h4>test/tests/interfacekernels/1d_interface/mixed_shapes.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 10
    xmax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;1.0 0 0&#x27;
    block_id = 1
    top_right = &#x27;2.0 1.0 0&#x27;
  [../]
  [./interface]
    input = subdomain1
    type = SideSetsBetweenSubdomainsGenerator
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./interface_again]
    input = interface
    type = SideSetsBetweenSubdomainsGenerator
    primary_block = &#x27;1&#x27;
    paired_block = &#x27;0&#x27;
    new_boundary = &#x27;primary1_interface&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;0&#x27;
  [../]


  [./v]
    order = FIRST
    family = MONOMIAL
    block = &#x27;1&#x27;
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
  [../]
  [./body_u]
    type = BodyForce
    variable = u
    block = 0
    function = &#x27;x^3+x^2+x+1&#x27;
  [../]
  [./body_v]
    type = BodyForce
    variable = v
    block = 1
    function = &#x27;x^3+x^2+x+1&#x27;
  [../]
[]

[DGKernels]
  [./dg_diff_v]
    type = DGDiffusion
    variable = v
    block = 1
    diff = 2
    sigma = 6
    epsilon = -1
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = OneSideDiffusion
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    D = 4
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    value = 1
  [../]
  # [./right]
  #   type = DirichletBC
  #   variable = v
  #   boundary = &#x27;right&#x27;
  #   value = 0
  # [../]
  [./right]
    type = DGFunctionDiffusionDirichletBC
    variable = v
    boundary = &#x27;right&#x27;
    function = 0
    epsilon = -1
    sigma = 6
  [../]
  [./middle]
    type = NeumannBC
    variable = u
    boundary = &#x27;primary0_interface&#x27;
    value = &#x27;.5&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3ed0df5c-b4c0-4417-a462-84b329a80546"><div class="modal-content"><h4>test/tests/time_integrators/tvdrk2/1d-linear.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 20
  elem_type = EDGE2
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[ICs]
  [./u_ic]
    type = FunctionIC
    variable = u
    function = ic
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  [./TimeIntegrator]
    type = ExplicitTVDRK2
  [../]
  solve_type = &#x27;LINEAR&#x27;

  start_time = 0.0
  num_steps = 10
  dt = 0.001
  l_tol = 1e-15
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fdd6b6f0-7e3c-4c1b-9e49-3bebe8563e52"><div class="modal-content"><h4>modules/porous_flow/test/tests/energy_conservation/heat04_action_KT.i</h4><pre class="moose-pre"><code class="language-text"># heat04, but using an action with KT stabilization.
# See heat04.i for a full discussion of the results.
# The KT stabilization should have no impact as there is no flow, but this input file checks that MOOSE runs.
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.5
      cv = 2
      cp = 2
      bulk_modulus = 2.0
      density0 = 3.0
    [../]
  [../]
[]

[PorousFlowUnsaturated]
  coupling_type = ThermoHydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = pp
  temperature = temp
  dictator_name = Sir
  biot_coefficient = 1.0
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
  van_genuchten_alpha = 1.0E-12
  van_genuchten_m = 0.5
  relative_permeability_type = Corey
  relative_permeability_exponent = 0.0
  stabilization = KT
  flux_limiter_type = superbee
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = Sir
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./pp]
  [../]
  [./temp]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
[]

[Kernels]
  [./heat_source]
    type = BodyForce
    function = 1
    variable = temp
  [../]
[]

[Functions]
  [./err_T_fcn]
    type = ParsedFunction
    vars = &#x27;por0 rte temp rd rhc m0 fhc source&#x27;
    vals = &#x27;0.5 0.25 t0   5  0.2 1.5 2  1&#x27;
    value = &#x27;((1-por0)*exp(rte*temp)*rd*rhc*temp+m0*fhc*temp-source*t)/(source*t)&#x27;
  [../]
  [./err_pp_fcn]
    type = ParsedFunction
    vars = &#x27;por0 rte temp rd rhc m0 fhc source bulk pp fte&#x27;
    vals = &#x27;0.5 0.25 t0   5  0.2 1.5 2  1      2    p0 0.5&#x27;
    value = &#x27;(bulk*(fte*temp-log(1+(por0-1)*exp(rte*temp))+log(por0))-pp)/pp&#x27;
  [../]
[]

[AuxVariables]
  [./porosity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./porosity]
    type = PorousFlowPropertyAux
    property = porosity
    variable = porosity
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./porosity]
    type = PorousFlowPorosity
    thermal = true
    fluid = true
    mechanical = true
    ensure_positive = false
    biot_coefficient = 1.0
    porosity_zero = 0.5
    thermal_expansion_coeff = 0.25
    solid_bulk = 2
  [../]
  [./rock_heat]
    type = PorousFlowMatrixInternalEnergy
    specific_heat_capacity = 0.2
    density = 5.0
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;0 0 0 0 0 0 0 0 0&#x27;
  [../]
  [./thermal_conductivity]
    type = PorousFlowThermalConductivityIdeal
    dry_thermal_conductivity = &#x27;0 0 0  0 0 0  0 0 0&#x27;
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = pp
  [../]
  [./t0]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = temp
  [../]
  [./porosity]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = porosity
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
  [./fluid_mass]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;timestep_end&#x27;
    use_displaced_mesh = true
    outputs = &#x27;console csv&#x27;
  [../]
  [./total_heat]
    type = PorousFlowHeatEnergy
    phase = 0
    execute_on = &#x27;timestep_end&#x27;
    use_displaced_mesh = true
    outputs = &#x27;console csv&#x27;
  [../]
  [./err_T]
    type = FunctionValuePostprocessor
    function = err_T_fcn
  [../]
  [./err_P]
    type = FunctionValuePostprocessor
    function = err_pp_fcn
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-12 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1
  end_time = 5
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  file_base = heat04_action
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1f34c4d2-88e1-4285-9d3c-b77d964e3ecc"><div class="modal-content"><h4>modules/heat_conduction/test/tests/heat_conduction/coupled_convective_heat_flux/coupled_convective_heat_flux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Functions]
  [./T_infinity_fn]
    type = ParsedFunction
    value = (x*x+y*y)+500
  [../]
  [./Hw_fn]
    type = ParsedFunction
    value = ((1-x)*(1-x)+(1-y)*(1-y))+1000
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./T_infinity]
  [../]
  [./Hw]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    value = 1000
  [../]
[]

[AuxKernels]
  [./T_infinity_ak]
    type = FunctionAux
    variable = T_infinity
    function = T_infinity_fn
    execute_on = initial
  [../]
  [./Hw_ak]
    type = FunctionAux
    variable = Hw
    function = Hw_fn
    execute_on = initial
  [../]
[]

[BCs]
  [./right]
    type = CoupledConvectiveHeatFluxBC
    variable = u
    boundary = right
    htc = Hw
    T_infinity = T_infinity
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b471f080-d8e3-4b60-bbe0-f7ef84da3df9"><div class="modal-content"><h4>test/tests/ics/from_exodus_solution/elem_part1.i</h4><pre class="moose-pre"><code class="language-text"># We run a simple problem (5 time steps and save off the solution)
# In part2, we load the solution and solve a steady problem. The test check, that the initial state in part 2 is the same as the last state from part1

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 20
  ny = 20
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)
  [../]
[]

[AuxVariables]
  [./e]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./ak]
    type = FunctionAux
    variable = e
    function = exact_fn
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;ie diff ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.2
  start_time = 0
  num_steps = 5
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d5e396bc-8fc9-4b1d-bdf4-ea8a3a73a927"><div class="modal-content"><h4>test/tests/postprocessors/element_time_derivative/element_time_derivative_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    # dudt = 3*t^2*(x^2 + y^2)
    type = ParsedFunction
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]
  [./forcing_fn2]
    # dudt = 3*t^2*(x^2 + y^2)
    type = ParsedFunction
    value = t*x*y
  [../]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn2
  [../]
[]

[BCs]
  active = &#x27;all&#x27;
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./elementAvgTimeDerivative]
    type = ElementAverageTimeDerivative
    variable = u
  [../]
  [./elementAvgValue]
    type = ElementAverageValue
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  scheme = implicit-euler

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_elm_time_deriv
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="03222d76-9148-4dd7-8eb8-168b7a535bc9"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined_fully_saturated_volume.i</h4><pre class="moose-pre"><code class="language-text"># A sample is constrained on all sides, except its top
# and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie m^3/second per cubic meter), and the
# rise in the top surface, porepressure, and stress are observed.
#
# In the standard poromechanics scenario, the Biot Modulus is held
# fixed and the source has units 1/s.  Then the expected result
# is
# strain_zz = disp_z = BiotCoefficient*BiotModulus*s*t/((bulk + 4*shear/3) + BiotCoefficient^2*BiotModulus)
# porepressure = BiotModulus*(s*t - BiotCoefficient*strain_zz)
# stress_xx = (bulk - 2*shear/3)*strain_zz   (remember this is effective stress)
# stress_zz = (bulk + 4*shear/3)*strain_zz   (remember this is effective stress)
#
# In standard porous_flow, everything is based on mass, eg the source has
# units kg/s/m^3.  This is discussed in the other pp_generation_unconfined
# models.  In this test, we use the FullySaturated Kernel and set
# multiply_by_density = false
# meaning the fluid Kernel has units of volume, and the source, s, has units 1/time
#
# The ratios are:
# stress_xx/strain_zz = (bulk - 2*shear/3) = 1 (for the parameters used here)
# stress_zz/strain_zz = (bulk + 4*shear/3) = 4 (for the parameters used here)
# porepressure/strain_zz = 13.3333333 (for the parameters used here)
#
# Expect
# disp_z = 0.3*10*s*t/((2 + 4*1.5/3) + 0.3^2*10) = 0.612245*s*t
# porepressure = 10*(s*t - 0.3*0.612245*s*t) = 8.163265*s*t
# stress_xx = (2 - 2*1.5/3)*0.612245*s*t = 0.612245*s*t
# stress_zz = (2 + 4*shear/3)*0.612245*s*t = 2.44898*s*t
#
# Finally, note that the volumetric strain has
# consistent_with_displaced_mesh = false
# which is needed when using the FullySaturated version of the Kernels
# in order to generate the above results

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    component = 2
    variable = disp_z
  [../]
  [./mass0]
    type = PorousFlowFullySaturatedMassTimeDerivative
    variable = porepressure
    multiply_by_density = false
    coupling_type = HydroMechanical
    biot_coefficient = 0.3
  [../]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 3.3333333333
      density0 = 1
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature_qp]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
    consistent_with_displaced_mesh = false
  [../]
  [./ppss]
    type = PorousFlow1PhaseFullySaturated
    porepressure = porepressure
  [../]
  [./simple_fluid_qp]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # the &quot;const&quot; is irrelevant here: all that uses Porosity is the BiotModulus, which just uses the initial value of porosity
    porosity = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    biot_coefficient = 0.3
    fluid_bulk_modulus = 3.3333333333
    solid_bulk_compliance = 0.5
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
  [./stress_xx_over_strain]
    type = FunctionValuePostprocessor
    function = stress_xx_over_strain_fcn
    outputs = csv
  [../]
  [./stress_zz_over_strain]
    type = FunctionValuePostprocessor
    function = stress_zz_over_strain_fcn
    outputs = csv
  [../]
  [./p_over_strain]
    type = FunctionValuePostprocessor
    function = p_over_strain_fcn
    outputs = csv
  [../]
[]

[Functions]
  [./stress_xx_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_xx zdisp&#x27;
  [../]
  [./stress_zz_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_zz zdisp&#x27;
  [../]
  [./p_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;p0 zdisp&#x27;
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_unconfined_fully_saturated_volume
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="52fbb204-cd25-4426-b7b3-fc682b3dbf33"><div class="modal-content"><h4>test/tests/restart/restart_add_variable/transient_with_stateful.i</h4><pre class="moose-pre"><code class="language-text"># We run a simple problem (5 time steps and save off the solution)
# In part2, we load the solution and solve a steady problem. The test check, that the initial state in part 2 is the same as the last state from part1

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./diffusivity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./out_diffusivity]
    type = MaterialRealAux
    variable = diffusivity
    property = diffusivity
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = MatDiffusionTest
    variable = u
    prop_name = diffusivity
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Materials]
  [./mat]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 0.5
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  dt = 0.2
  start_time = 0
  num_steps = 5
[]

[Outputs]
  checkpoint = true
  [./out]
    type = Exodus
    elemental_as_nodal = true
    execute_elemental_on = none
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bc959889-ae52-4b6a-ba54-ef1b35712c4e"><div class="modal-content"><h4>test/tests/preconditioners/smp/smp_single_adapt_test.i</h4><pre class="moose-pre"><code class="language-text">#
# This is not very strong test since the problem being solved is linear, so the difference between
# full Jacobian and block diagonal preconditioner is not that big
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD4
[]

[Functions]
  [./exact_v]
    type = ParsedFunction
    value = sin(pi*x)*sin(pi*y)
  [../]
  [./force_fn_v]
    type = ParsedFunction
    value = 2*pi*pi*sin(pi*x)*sin(pi*y)
  [../]
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    off_diag_row    = &#x27;u&#x27;
    off_diag_column = &#x27;v&#x27;
  [../]
[]

[Kernels]
  [./diff_u]
    type = Diffusion
    variable = u
  [../]
  [./conv_u]
    type = CoupledForce
    variable = u
    v = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
  [./ffn_v]
    type = BodyForce
    variable = v
    function = force_fn_v
  [../]
[]

[BCs]
  [./left_u]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]

  [./right_u]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 1
  [../]

  [./all_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_v
  [../]
[]

[Executioner]
  type = Steady


  solve_type = &#x27;PJFNK&#x27;

  [./Adaptivity]
    steps = 3
    coarsen_fraction = 0.1
    refine_fraction = 0.2
    max_h_level = 5
  [../]
[]

[Outputs]
  exodus = true
  print_mesh_changed_info = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ab273171-6a28-4e59-8b3a-ac1b9f69d5c3"><div class="modal-content"><h4>test/tests/variables/fe_monomial_const/monomial-const-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 21
  ny = 21
  nz = 21
  elem_type = HEX8
[]

[Functions]
  [./bc_fn]
    type=ParsedFunction
    value=0
  [../]
  [./bc_fnt]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
#    type = ParsedFunction
#    value = 0
    type = MTPiecewiseConst3D
  [../]

  [./solution]
    type = MTPiecewiseConst3D
  [../]
[]

[Variables]
  [./u]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  # Note: MOOSE&#x27;s DirichletBCs do not work properly with shape functions that do not
  #       have DOFs at the element edges.  This test works because the solution
  #       has been designed to be zero at the boundary which is satisfied by the IC
  #       Ticket #1352
  active = &#x27;&#x27;
  [./bc_all]
    type=FunctionDirichletBC
    variable = u
    boundary = &#x27;top bottom left right&#x27;
    function = bc_fn
  [../]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1.e-9
  [./Adaptivity]

  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  csv = true
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d90fd71a-4949-40d5-9104-cc8ff40911d0"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in Cartesian coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is dependent upon the value of the level set function
#   at each timestep.
# Results:
#   The temperature at the left boundary (x=0) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM
#   results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9999722
#      0.6                  520         519.9998726
#      0.8                  560         559.9997314
#      1.0                  600         599.9996885
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;rhoCp*(-200*x+200)-(0.05*200*t/1.04)&#x27;
    vars = &#x27;rhoCp&#x27;
    vals = 10
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.05/1.04)*(1-(x-0.04)-0.2*t) + 1.5)*200*t&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.05/1.04)*(1-(x-0.04)-0.2*t) + 1.5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;1.04 - x - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4f2ffb83-d9b6-4fb2-80f1-cf1972f78780"><div class="modal-content"><h4>test/tests/time_integrators/bdf2/bdf2_adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 4
  ny = 4
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.25

  [./Adaptivity]
    refine_fraction = 0.2
    coarsen_fraction = 0.3
    max_h_level = 4
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="25119aca-7165-4b05-a846-925d310973e5"><div class="modal-content"><h4>python/peacock/tests/common/oversample.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of a &quot;Transient&quot; Executioner.
#
# @Requirement F1.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./dt]
    type = TimestepSize
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  # Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_transient
  exodus = true
  [./refine_2]
    type = Exodus
    file_base = oversample_2
    refinements = 2
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5bf5de66-b8ce-4004-9dc1-842973354f03"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/poly_chaos/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = D
  []
  [absorption]
    type = MaterialReaction
    variable = u
    coefficient = sig
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
  []
[]

[Materials]
  [diffusivity]
    type = GenericConstantMaterial
    prop_names = D
    prop_values = 2.0
  []
  [xs]
    type = GenericConstantMaterial
    prop_names = sig
    prop_values = 2.0
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Postprocessors]
  [avg]
    type = AverageNodalVariableValue
    variable = u
  []
  [max]
    type = NodalExtremeValue
    variable = u
    value_type = max
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fdb13c00-a8ca-4502-847e-821abe91d164"><div class="modal-content"><h4>test/tests/postprocessors/num_dofs/num_dofs.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
    order = FIRST
    family = LAGRANGE
  [../]
  [./v_aux]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1
  solve_type = PJFNK
[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Postprocessors]
  [./num_dofs_nl]
    type = NumDOFs
    system = NL
  [../]
  [./num_dofs_aux]
    type = NumDOFs
    system = AUX
  [../]

  # default
  [./num_dofs_all]
    type = NumDOFs
    system = ALL
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="465e503d-6800-42ce-a18f-921d95d7adc7"><div class="modal-content"><h4>test/tests/mortar/continuity-2d-non-conforming/soln-continuity.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  second_order = true
  [file]
    type = FileMeshGenerator
    file = nodal_normals_test_offset_nonmatching_gap.e
  []
  [./primary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;2&#x27;
    new_block_id = &#x27;20&#x27;
  [../]
  [./secondary]
    input = primary
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;1&#x27;
    new_block_id = &#x27;10&#x27;
  [../]
[]

[Problem]
  kernel_coverage_check = false
[]

[Variables]
  [./T]
    block = &#x27;1 2&#x27;
    order = SECOND
  [../]
  [./lambda]
    block = &#x27;10&#x27;
  [../]
[]

[BCs]
  [./neumann]
    type = FunctionGradientNeumannBC
    exact_solution = exact_soln
    variable = T
    boundary = &#x27;3 4 5 6 7 8&#x27;
  [../]
[]

[Kernels]
  [./conduction]
    type = Diffusion
    variable = T
    block = &#x27;1 2&#x27;
  [../]
  [./sink]
    type = Reaction
    variable = T
    block = &#x27;1 2&#x27;
  [../]
  [./forcing_function]
    type = BodyForce
    variable = T
    function = forcing_function
    block = &#x27;1 2&#x27;
  [../]
[]

[Functions]
  [./forcing_function]
    type = ParsedFunction
    value = &#x27;-4 + x^2 + y^2&#x27;
  [../]
  [./exact_soln]
    type = ParsedFunction
    value = &#x27;x^2 + y^2&#x27;
  [../]
[]

[Debug]
  show_var_residual_norms = 1
[]

[Constraints]
  [./mortar]
    type = EqualValueConstraint
    primary_boundary = 2
    secondary_boundary = 1
    primary_subdomain = 20
    secondary_subdomain = 10
    variable = lambda
    secondary_variable = T
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  solve_type = NEWTON
  type = Steady
  petsc_options_iname = &#x27;-pc_type -snes_linesearch_type -pc_factor_shift_type -pc_factor_shift_amount&#x27;
  petsc_options_value = &#x27;lu       basic                 NONZERO               1e-15&#x27;
[]

[Outputs]
  exodus = true
  [dofmap]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2f68c534-1401-4d07-80e6-02ec2b5dd69b"><div class="modal-content"><h4>test/tests/variables/fe_hermite/hermite-3-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX27
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 3*y*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -3*y*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]
  [./bc_fnk]
    type = ParsedFunction
    value = -3*z*z
  [../]
  [./bc_fnf]
    type = ParsedFunction
    value = 3*z*z
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x-6*y-6*z+(x*x*x)+(y*y*y)+(z*z*z)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (x*x*x)+(y*y*y)+(z*z*z)
    grad_x = 3*x*x
    grad_y = 3*y*y
    grad_z = 3*z*z
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
  [./bc_front]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;front&#x27;
    function = bc_fnf
  [../]
  [./bc_back]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;back&#x27;
    function = bc_fnk
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = NEWTON
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9c784b9a-255b-4d50-8e56-85521bb66a38"><div class="modal-content"><h4>test/tests/variables/mixed_order_variables/mixed_order_variables_test.i</h4><pre class="moose-pre"><code class="language-text"># FIRST order nodal variables on SECOND order grid
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./force_fn]
    type = ParsedFunction
    value = -4
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = (x*x)+(y*y)
  [../]

  [./aux_fn]
    type = ParsedFunction
    value = (1-x*x)*(1-y*y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = force_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]


[AuxVariables]
  [./aux1]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./ak1]
    type = FunctionAux
    variable = aux1
    function = aux_fn
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="68898b3b-582d-4dae-96b2-7ca8d9cb0152"><div class="modal-content"><h4>test/tests/tag/2d_diffusion_dg_tag.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL

    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[AuxVariables]
  [./tag_variable1]
    order = FIRST
    family = MONOMIAL
  [../]

  [./tag_variable2]
    order = FIRST
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./TagVectorAux1]
    type = TagVectorAux
    variable = tag_variable1
    v = u
    vector_tag = vec_tag2
    execute_on = timestep_end
  [../]

  [./TagVectorAux2]
    type = TagMatrixAux
    variable = tag_variable2
    v = u
    matrix_tag = mat_tag2
    execute_on = timestep_end
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]

  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1 vec_tag2&#x27;
  [../]

  [./abs]
    type = Reaction
    variable = u
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1 vec_tag2&#x27;
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1&#x27;
  [../]
[]

[DGKernels]
  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1 vec_tag2&#x27;
  [../]
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1 vec_tag2&#x27;
  [../]
[]

[Problem]
  type = TagTestProblem
  test_tag_vectors =  &#x27;nontime residual vec_tag1 vec_tag2&#x27;
  test_tag_matrices = &#x27;mat_tag1 mat_tag2&#x27;

  extra_tag_matrices = &#x27;mat_tag1 mat_tag2&#x27;
  extra_tag_vectors  = &#x27;vec_tag1 vec_tag2&#x27;
[]

[Executioner]
  type = Steady

  solve_type = &#x27;NEWTON&#x27;
  nl_rel_tol = 1e-10
[]

[Postprocessors]
  [./h]
    type = AverageElementSize
  [../]

  [./dofs]
    type = NumDOFs
  [../]

  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aee9e86f-f8a8-4762-8388-07a6e7b68fc7"><div class="modal-content"><h4>modules/porous_flow/test/tests/energy_conservation/heat04.i</h4><pre class="moose-pre"><code class="language-text"># The sample is a single unit element, with fixed displacements on
# all sides.  A heat source of strength S (J/m^3/s) is applied into
# the element.  There is no fluid flow or heat flow.  The rise
# in temperature, porepressure and stress, and the change in porosity is
# matched with theory.
#
# In this case, fluid mass must be conserved, and there is no
# volumetric strain, so
# porosity * fluid_density = constant
# Also, the energy-density in the rock-fluid system increases with S:
# d/dt [(1 - porosity) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T] = S
# Also, the porosity evolves according to THM as
# porosity = biot + (porosity0 - biot) * exp( (biot - 1) * P / fluid_bulk + rock_thermal_exp * T)
# Finally, the effective stress must be exactly zero (as there is
# no strain).
#
# Let us assume that
# fluid_density = dens0 * exp(P / fluid_bulk - fluid_thermal_exp * T)
# Then the conservation of fluid mass means
# porosity = por0 * exp(- P / fluid_bulk + fluid_thermal_exp * T)
# where dens0 * por0 = the initial fluid mass.
# The last expression for porosity, combined with the THM one,
# and assuming that biot = 1 for simplicity, gives
# porosity = 1 + (porosity0 - 1) * exp(rock_thermal_exp * T) = por0 * exp(- P / fluid_bulk + fluid_thermal_exp * T) .... (A)
#
# This stuff may be substituted into the heat energy-density equation:
# S = d/dt [(1 - porosity0) * exp(rock_thermal_exp * T) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T]
#
# If S is constant then
# S * t = (1 - porosity0) * exp(rock_thermal_exp * T) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T
# with T(t=0) = 0 then Eqn(A) implies that por0 = porosity0 and
# P / fluid_bulk = fluid_thermal_exp * T - log(1 + (por0 - 1) * exp(rock_thermal_exp * T)) + log(por0)
#
# Parameters:
# A = 2
# fluid_bulk = 2.0
# dens0 = 3.0
# fluid_thermal_exp = 0.5
# fluid_heat_cap = 2
# por0 = 0.5
# rock_thermal_exp = 0.25
# rock_density = 5
# rock_heat_capacity = 0.2

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.5
      cv = 2
      cp = 2
      bulk_modulus = 2.0
      density0 = 3.0
    [../]
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./pp]
  [../]
  [./temp]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 1.0
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 1.0
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 1.0
    component = 2
    variable = disp_z
  [../]
  [./poro_vol_exp]
    type = PorousFlowMassVolumetricExpansion
    variable = pp
    fluid_component = 0
  [../]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pp
  [../]
  [./temp]
    type = PorousFlowEnergyTimeDerivative
    variable = temp
  [../]
  [./poro_vol_exp_temp]
    type = PorousFlowHeatVolumetricExpansion
    variable = temp
  [../]
  [./heat_source]
    type = BodyForce
    function = 1
    variable = temp
  [../]
[]

[Functions]
  [./err_T_fcn]
    type = ParsedFunction
    vars = &#x27;por0 rte temp rd rhc m0 fhc source&#x27;
    vals = &#x27;0.5 0.25 t0   5  0.2 1.5 2  1&#x27;
    value = &#x27;((1-por0)*exp(rte*temp)*rd*rhc*temp+m0*fhc*temp-source*t)/(source*t)&#x27;
  [../]
  [./err_pp_fcn]
    type = ParsedFunction
    vars = &#x27;por0 rte temp rd rhc m0 fhc source bulk pp fte&#x27;
    vals = &#x27;0.5 0.25 t0   5  0.2 1.5 2  1      2    p0 0.5&#x27;
    value = &#x27;(bulk*(fte*temp-log(1+(por0-1)*exp(rte*temp))+log(por0))-pp)/pp&#x27;
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./porosity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./porosity]
    type = PorousFlowPropertyAux
    property = porosity
    variable = porosity
  [../]
[]


[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;temp pp disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
    temperature = temp
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
  [../]
  [./eff_fluid_pressure]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./porosity]
    type = PorousFlowPorosity
    thermal = true
    fluid = true
    mechanical = true
    ensure_positive = false
    biot_coefficient = 1.0
    porosity_zero = 0.5
    thermal_expansion_coeff = 0.25
    solid_bulk = 2
  [../]
  [./rock_heat]
    type = PorousFlowMatrixInternalEnergy
    specific_heat_capacity = 0.2
    density = 5.0
  [../]
  [./ppss]
    type = PorousFlow1PhaseFullySaturated
    porepressure = pp
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    temperature_unit = Kelvin
    fp = the_simple_fluid
    phase = 0
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = pp
  [../]
  [./t0]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = temp
  [../]
  [./porosity]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = porosity
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
  [./fluid_mass]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;timestep_end&#x27;
    use_displaced_mesh = true
    outputs = &#x27;console csv&#x27;
  [../]
  [./total_heat]
    type = PorousFlowHeatEnergy
    phase = 0
    execute_on = &#x27;timestep_end&#x27;
    use_displaced_mesh = true
    outputs = &#x27;console csv&#x27;
  [../]
  [./err_T]
    type = FunctionValuePostprocessor
    function = err_T_fcn
  [../]
  [./err_P]
    type = FunctionValuePostprocessor
    function = err_pp_fcn
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-12 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1
  end_time = 5
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  file_base = heat04
  exodus = true
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e597aeae-de7f-49a0-8a62-a9a15dee92e1"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/pod_rb/boundary/sub.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  type = FEProblem
  extra_tag_vectors  = &#x27;diff react bodyf dir_src dir_imp&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 15
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = k
    extra_vector_tags = &#x27;diff&#x27;
  []
  [reaction]
    type = MaterialReaction
    variable = u
    coefficient = alpha
    extra_vector_tags = &#x27;react&#x27;
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
    extra_vector_tags = &#x27;bodyf&#x27;
  []
[]

[Materials]
  [k]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 1.0
  []
  [alpha]
    type = GenericConstantMaterial
    prop_names = alpha
    prop_values = 1.0
  []
[]

[BCs]
  [dummy_1]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
    extra_vector_tags = &#x27;dir_imp&#x27;
  []
  [dummy_2]
    type = DirichletBCModifier
    variable = u
    boundary = left
    value = 1
    extra_vector_tags = &#x27;dir_src&#x27;
  []
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 1
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2c351e83-bfab-47c1-9e5b-c0f3d00dae98"><div class="modal-content"><h4>test/tests/postprocessors/postprocessor_dependency/element_side_pp.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 3
  ny = 3
  elem_type = QUAD9
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 2.8
    [../]
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 5.4
    [../]
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;1&#x27;
    value = 0
  [../]
[]

[Postprocessors]

  [./sidepp]
    type = SideIntegralVariablePostprocessor
    variable = v
    execute_on = timestep_end
    boundary = &#x27;0 1 2 3&#x27;
  [../]

  [./passsidepp]
    type = ElementSidePP
    side_pp = sidepp
    execute_on = timestep_end
  [../]

[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 0.3
[]

[Outputs]
  file_base = out
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b484f7f4-21d8-4e30-b3d2-eb6f66711aa7"><div class="modal-content"><h4>test/tests/kernels/forcing_function/forcing_function_error_check.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
  uniform_refine = 4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;forcing_func&#x27;

  [./forcing_func]
    type = ParsedFunction
    value = &#x27;&quot;alpha*alpha*pi*pi*sin(alpha*pi*x)&quot;&#x27;
    vars = &#x27;alpha&#x27;
    vals = &#x27;16&#x27;
  [../]
[]

[Kernels]
  active = &#x27;diff forcing&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_func
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="15ccfee0-13a9-4cd5-a2ba-8871daef7f0e"><div class="modal-content"><h4>test/tests/restart/restart_steady_from_transient/steady_from_transient_restart.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = transient_out_cp/LATEST
  parallel_type = replicated
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]

[Problem]
  restart_file_base = transient_out_cp/LATEST
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="53e4bc6a-dbc4-465b-ad90-895324814367"><div class="modal-content"><h4>test/tests/userobjects/postprocessor_spatial_user_object/master.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
[]

[Functions]
  [./ic_fn]
    type = ParsedFunction
    value = &#x27;x * y&#x27;
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]
[]

[ICs]
  [./u_ic]
    type = FunctionIC
    variable = u
    function = ic_fn
  [../]

  [./a_ic]
    type = ConstantIC
    variable = a
    value = 1
  [../]
[]

[AuxVariables]
  [./a]
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./rhs]
    type = BodyForce
    variable = u
    function = 1
  [../]
[]

[MultiApps]
  [./sub]
    type = TransientMultiApp
    app_type = MooseTestApp
    input_files = &#x27;sub.i&#x27;
    positions = &#x27;
      0.25 0.25 0
      0.75 0.75 0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Transfers]
  [./master_to_sub]
    type = MultiAppNearestNodeTransfer
    direction = to_multiapp
    multi_app = sub
    source_variable = u
    variable = a
  [../]

  [./sub_to_master]
    type = MultiAppUserObjectTransfer
    direction = from_multiapp
    multi_app = sub
    user_object = fn_uo
    variable = a
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.1
  num_steps = 10
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="11a04395-0ba9-4f06-a543-da6b851c5b51"><div class="modal-content"><h4>test/tests/transfers/multiapp_conservative_transfer/master_power_density.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmax = 1
    ymax = 1
    nx = 10
    ny = 10
  []
  [block1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    block_id = 1
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
  []
[]

[Variables]
  [power_density]
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27;
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = power_density
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = power_density
    boundary = right
    value = 1e3
  []
[]

[AuxVariables]
  [from_sub]
  []
[]

[Postprocessors]
  [pwr0]
    type = ElementIntegralVariablePostprocessor
    block = 0
    variable = power_density
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
  [pwr1]
    type = ElementIntegralVariablePostprocessor
    block = 1
    variable = power_density
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
  [from_sub0]
    type = ElementIntegralVariablePostprocessor
    block = 0
    variable = from_sub
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
  [from_sub1]
    type = ElementIntegralVariablePostprocessor
    block = 1
    variable = from_sub
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[MultiApps]
  [sub]
    type = FullSolveMultiApp
    input_files = sub_power_density.i
    positions = &#x27;0 0 0 0.5 0 0&#x27;
    execute_on = timestep_end
  []
[]

[Transfers]
  [to_sub]
    type = MultiAppMeshFunctionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = from_master
    multi_app = sub
    execute_on = timestep_end

    # The following inputs specify what postprocessors should be conserved
    # N pps are specified on the master side, where N is the number of subapps
    # 1 pp is specified on the subapp side
    from_postprocessors_to_be_preserved = &#x27;pwr0 pwr1&#x27;
    to_postprocessors_to_be_preserved = &#x27;from_master_pp&#x27;
  []

  [from_sub]
    type = MultiAppMeshFunctionTransfer
    direction = from_multiapp
    source_variable = sink
    variable = from_sub
    multi_app = sub
    execute_on = timestep_end

    # The following inputs specify what postprocessors should be conserved
    # N pps are specified on the master side, where N is the number of subapps
    # 1 pp is specified on the subapp side
    to_postprocessors_to_be_preserved = &#x27;from_sub0 from_sub1&#x27;
    from_postprocessors_to_be_preserved = &#x27;sink&#x27;
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a6d3931d-6165-41c4-b949-e1ced790c64d"><div class="modal-content"><h4>test/tests/materials/ad_material/ad_stateful_material.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 2
[]

[Variables]
  [./u]
    initial_condition = 1
  [../]
[]

[Kernels]
  [./diff]
    type = ADMatDiffusionTest
    variable = u
    prop_to_use = &#x27;AdAd&#x27;
    ad_mat_prop = &#x27;diffusivity&#x27;
    regular_mat_prop = &#x27;unused_diffusivity&#x27;
  [../]
[]

[Kernels]
  [./force]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Materials]
  [./constant_material]
    type = GenericConstantMaterial
    prop_names = &#x27;unused_diffusivity&#x27;
    prop_values = &#x27;0&#x27;
  [../]
  [./ad_stateful]
    type = ADStatefulMaterial
    u = u
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  line_search = &#x27;none&#x27;

  solve_type = &#x27;Newton&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  l_tol = 1e-10
  nl_rel_tol = 1e-9
[]

[Outputs]
  [./exodus]
    type = Exodus
    show_material_properties = &#x27;diffusivity&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a8eb8b37-37de-4104-a78e-e966f7756225"><div class="modal-content"><h4>examples/ex14_pps/ex14_compare_solutions_1.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 100
  ny = 100
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0

  parallel_type = replicated # This uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
[]

[Variables]
  [./forced]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = forced
  [../]

  [./forcing]
    type = BodyForce
    variable = forced
    function = &#x27;x*x+y*y&#x27; # Any object expecting a function name can also receive a ParsedFunction string
  [../]
[]

[BCs]
  [./all]
    type = DirichletBC
    variable = forced
    boundary = &#x27;bottom right top left&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = Steady

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  xda = true #XDA writes out the perfect internal state of all variables, allowing SolutionUserObject to read back in higher order solutions and adapted meshes
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f99b7b2d-6e8e-4df1-b306-d7f088445b47"><div class="modal-content"><h4>modules/functional_expansion_tools/examples/2D_interface/main.i</h4><pre class="moose-pre"><code class="language-text"># Basic example coupling a master and sub app at an interface in a 2D model.
# The master app provides a flux term to the sub app via Functional Expansions, which then performs
# its calculations.  The sub app&#x27;s interface conditions, both value and flux, are transferred back
# to the master app
[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 0.4
  nx = 6
  ymin = 0.0
  ymax = 10.0
  ny = 20
[]

[Variables]
  [./m]
  [../]
[]

[Kernels]
  [./diff_m]
    type = HeatConduction
    variable = m
  [../]
  [./time_diff_m]
    type = HeatConductionTimeDerivative
    variable = m
  [../]
  [./source_m]
    type = BodyForce
    variable = m
    value = 100
  [../]
[]

[Materials]
  [./Impervium]
    type = GenericConstantMaterial
    prop_names =  &#x27;thermal_conductivity specific_heat density&#x27;
    prop_values = &#x27;0.00001              50.0          100.0&#x27; # W/(cm K), J/(g K), g/cm^3
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    value = 2
    variable = m
  [../]
[]

[BCs]
  [./interface_value]
    type = FXValueBC
    variable = m
    boundary = right
    function = FX_Basis_Value_Main
  [../]
  [./interface_flux]
    type = FXFluxBC
    boundary = right
    variable = m
    function = FX_Basis_Flux_Main
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;4&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
  [./FX_Basis_Flux_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;5&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
[]

[UserObjects]
  [./FX_Flux_UserObject_Main]
    type = FXBoundaryFluxUserObject
    function = FX_Basis_Flux_Main
    variable = m
    boundary = right
    diffusivity = thermal_conductivity
  [../]
[]

[Postprocessors]
  [./average_interface_value]
    type = SideAverageValue
    variable = m
    boundary = right
  [../]
  [./total_flux]
    type = SideFluxIntegral
    variable = m
    boundary = right
    diffusivity = thermal_conductivity
  [../]
  [./picard_iterations]
    type = NumPicardIterations
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 1.0
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = sub.i
    sub_cycling = true
  [../]
[]

[Transfers]
  [./FluxToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Flux_UserObject_Main
    multi_app_object_name = FX_Basis_Flux_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
  [./FluxToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Flux_Main
    multi_app_object_name = FX_Flux_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a1b99c9d-f148-4792-b356-fa9341c6f36e"><div class="modal-content"><h4>modules/level_set/test/tests/verification/1d_level_set_mms/level_set_mms.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 32
  nx = 64
  uniform_refine = 0
[]

[Variables]
  [./phi]
  [../]
[]

[AuxVariables]
  [./velocity]
    family = LAGRANGE_VEC
  [../]
[]

[ICs]
  [./phi_ic]
    function = phi_exact
    variable = phi
    type = FunctionIC
  [../]
  [./vel_ic]
    type = VectorFunctionIC
    variable = velocity
    function = velocity_func
  []
[]

[Functions]
  [./phi_exact]
    type = ParsedFunction
    value = &#x27;a*exp(1/(10*t))*sin(2*pi*x/b) + 1&#x27;
    vars = &#x27;a b&#x27;
    vals = &#x27;1 8&#x27;
  [../]
  [./phi_mms]
    type = ParsedFunction
    value = &#x27;-a*exp(1/(10*t))*sin(2*pi*x/b)/(10*t^2) + 2*pi*a*exp(1/(10*t))*cos(2*pi*x/b)/b&#x27;
    vars = &#x27;a b&#x27;
    vals = &#x27;1 8&#x27;
  [../]
  [./velocity_func]
    type = ParsedVectorFunction
    value_x = &#x27;1&#x27;
    value_y = &#x27;1&#x27;
  [../]
[]

[Kernels]
  [./phi_advection]
    type = LevelSetAdvection
    variable = phi
    velocity = velocity
  [../]
  [./phi_time]
    type = TimeDerivative
    variable = phi
  [../]
  [./phi_forcing]
    type = BodyForce
    variable = phi
    function = phi_mms
  [../]
[]

[Postprocessors]
  [./error]
    type = ElementL2Error
    function = phi_exact
    variable = phi
  [../]
  [./h]
    type = AverageElementSize
  [../]
  [./point]
    type = PointValue
    point = &#x27;0.1 0 0&#x27;
    variable = phi
  [../]
[]

[Executioner]
  type = Transient
  start_time = 1
  dt = 0.01
  end_time = 1.25
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_sub_type&#x27;
  petsc_options_value = &#x27;asm      ilu&#x27;
  scheme = bdf2
  nl_rel_tol = 1e-12
[]

[Outputs]
  interval = 10
  execute_on = &#x27;timestep_end&#x27;
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="26982bc5-002e-40c7-86e7-fdec3ecfe7aa"><div class="modal-content"><h4>test/tests/outputs/oversample/over_sampling_second_file.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  # Read in and work with a second order mesh
  file = wedge18_mesh.e
  # If we have an oversample mesh file, we haven not yet implemented
  # synchronization of its partitioning with the problem mesh, so we
  # need to keep the problem mesh replicated.
  parallel_type = replicated
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
  [../]
[]

[Kernels]
  active = &#x27;ie diff ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1 2 4&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.2
  start_time = 0
  num_steps = 3
[]

[Outputs]
  file_base = out_wedge
  [./oversample]
    type = Exodus
    file_base = out_wedge_oversample
    file = wedge6_mesh.e
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c7af8432-cdad-4b4a-b4f4-5daac33a3482"><div class="modal-content"><h4>test/tests/variables/get_elemental_value/get_elemental_value.i</h4><pre class="moose-pre"><code class="language-text"># Tests the getElementalValue function of MooseVariableFE.
#
# The tested aux copies the first elemental value of another variable. The
# setup is the following IVP:
#   du/dt = 1
#   u(0) = 0
# Therefore the solution is u(t) = t. Five time steps of dt = 1 are taken.
# The expected output for each time level is thus the following:
#   current: [0,1,2,3,4,5]
#   old:     [0,0,1,2,3,4]
#   older:   [0,0,0,1,2,3]

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 2
[]

[Variables]
  [./copied_var]
  [../]
[]

[AuxVariables]
  [./test_var]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./test_var_aux]
    type = GetElementalValueAux
    variable = test_var
    copied_variable = copied_var
    # The parameter &quot;time_level&quot; is provided by tests file
  [../]
[]

[ICs]
  [./copied_var_ic]
    type = ConstantIC
    variable = copied_var
    value = 0
  [../]
[]

[Kernels]
  [./time_der]
    type = TimeDerivative
    variable = copied_var
  [../]
  [./src]
    type = BodyForce
    variable = copied_var
    function = 1
  [../]
[]

[Executioner]
  type = Transient
  scheme = implicit-euler
  dt = 1
  num_steps = 5
  abort_on_solve_fail = true

  solve_type = NEWTON
[]

[Postprocessors]
  [./test_pp]
    type = ElementAverageValue
    variable = test_var
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c74b1929-9b46-45bc-bd20-8c297ba00fad"><div class="modal-content"><h4>modules/combined/test/tests/poro_mechanics/pp_generation_unconfined_action.i</h4><pre class="moose-pre"><code class="language-text"># This is identical to pp_generation_unconfined.i but it uses
# and action instead of explicitly writing all the Kernels out
#
# A sample is constrained on all sides, except its top
# and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie m^3/second per cubic meter), and the
# rise in the top surface, porepressure, and stress are observed.
#
# Source = s  (units = 1/second)
#
# Expect:
# strain_zz = disp_z = BiotCoefficient*BiotModulus*s*t/((bulk + 4*shear/3) + BiotCoefficient^2*BiotModulus)
# porepressure = BiotModulus*(s*t - BiotCoefficient*strain_zz)
# stress_xx = (bulk - 2*shear/3)*strain_zz   (remember this is effective stress)
# stress_xx = (bulk + 4*shear/3)*strain_zz   (remember this is effective stress)
#
# Parameters:
# Biot coefficient = 0.3
# Porosity = 0.1
# Bulk modulus = 2
# Shear modulus = 1.5
# fluid bulk modulus = 1/0.3 = 3.333333
# 1/Biot modulus = (1 - 0.3)*(0.3 - 0.1)/2 + 0.1*0.3 = 0.1. BiotModulus = 10
#
# s = 0.1
#
# Expect
# disp_z = 0.3*10*s*t/((2 + 4*1.5/3) + 0.3^2*10) = 0.612245*s*t
# porepressure = 10*(s*t - 0.3*0.612245*s*t) = 8.163265*s*t
# stress_xx = (2 - 2*1.5/3)*0.612245*s*t = 0.612245*s*t
# stress_zz = (2 + 4*shear/3)*0.612245*s*t = 2.44898*s*t


[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  [../]
[]


[Kernels]
  [./PoroMechanics]
  [../]
  [./poro_timederiv]
    type = PoroFullSatTimeDerivative
    variable = porepressure
  [../]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]



[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./poro_material]
    type = PoroFullSatMaterial
    porosity0 = 0.1
    biot_coefficient = 0.3
    solid_bulk_compliance = 0.5
    fluid_bulk_compliance = 0.3
    constant_porosity = true
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]

[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_unconfined_action
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0b7da2af-218d-4a73-8b3a-6abb0d4d5215"><div class="modal-content"><h4>test/tests/outputs/console/console_final.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This test exercises console Output control. The console
# output is only output every third step. Additionally it
# is forced to be output after the final timestep as well.
#
# @Requirement U1.40
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
  # This test uses ElementalVariableValue postprocessors on specific
  # elements, so element numbering needs to stay unchanged
  allow_renumbering = false
[]

[Functions]
  [./ffn]
    type = ParsedFunction
    value = -4
  [../]

  [./exactfn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./aux_exact_fn]
    type = ParsedFunction
    value = t*(x*x+y*y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./force]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[AuxVariables]
  [./aux_u]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./a]
    type = FunctionAux
    variable = aux_u
    function = aux_exact_fn
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exactfn
  [../]
[]

[Postprocessors]
  [./elem_56]
    type = ElementalVariableValue
    variable = u
    elementid = 56
  [../]

  [./aux_elem_99]
    type = ElementalVariableValue
    variable = aux_u
    elementid = 99
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  dt = 0.01
  start_time = 0
  num_steps = 10
[]

[Outputs]
  interval = 3
  execute_on = &#x27;initial timestep_end final&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e9c4f6be-a775-4bb4-a044-c7ab518f94db"><div class="modal-content"><h4>test/tests/userobjects/interface_user_object/interface_mp_real_user_object_QP.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./primary0_interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = primary0_interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 2
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 4
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    function = 0.1*t
  [../]
[]

[InterfaceKernels]
  [./primary0_interface]
    type = PenaltyInterfaceDiffusionDot
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = TRUE
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  dt = 0.1
  num_steps = 3
  dtmin = 0.1
  line_search = none
[]

[Outputs]
  [./out]
    type = Exodus
    sync_only = true
    sync_times = &#x27;0.1 0.2 0.3&#x27;
    execute_on = &#x27;TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [./interface_value_uo]
    type = InterfaceQpMaterialPropertyRealUO
    property = diffusivity
    property_neighbor = diffusivity
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
    interface_value_type = average
  [../]
  [./interface_value_rate_uo]
    type = InterfaceQpMaterialPropertyRealUO
    property = diffusivity
    property_neighbor = diffusivity
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
    interface_value_type = average
    value_type = rate
  [../]
  [./interface_value_increment_uo]
    type = InterfaceQpMaterialPropertyRealUO
    property = diffusivity
    property_neighbor = diffusivity
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
    interface_value_type = average
    value_type = increment
  [../]
[]

[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 5
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
  [../]
[]

[AuxKernels]
  [./interface_avg_value_aux]
    type = InterfaceValueUserObjectAux
    variable = avg
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_value_uo
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
  []
  [./interface_avg_value_rate_aux]
    type = InterfaceValueUserObjectAux
    variable = avg_rate
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_value_rate_uo
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
  []
  [./interface_avg_value_increment_aux]
    type = InterfaceValueUserObjectAux
    variable = avg_increment
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_value_increment_uo
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
  []
[]

[AuxVariables]
  [./avg]
    family = MONOMIAL
    order = CONSTANT
  []
  [./avg_rate]
    family = MONOMIAL
    order = CONSTANT
  []
  [./avg_increment]
    family = MONOMIAL
    order = CONSTANT
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="697d2cc4-f8db-423e-ae33-5b24f2c5fd0f"><div class="modal-content"><h4>test/tests/time_integrators/tvdrk2/2d-quadratic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 20
  ny = 20
  elem_type = QUAD9
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*((x*x)+(y*y))-(4*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*((x*x)+(y*y))
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[ICs]
  [./u_ic]
    type = FunctionIC
    variable = u
    function = ic
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  [./TimeIntegrator]
    type = ExplicitTVDRK2
  [../]
  solve_type = &#x27;LINEAR&#x27;

  start_time = 0.0
  num_steps = 10
  dt = 0.0001
  l_tol = 1e-8
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dbf4ef11-a2ef-453f-9b73-8f035ac6c44b"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-2-1d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
  elem_type = EDGE3
[]

[Functions]
  [./bc_fnl]
    type = ParsedFunction
    value = -2*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 2*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -2+x*x
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x
    grad_x = 2*x
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c9b79feb-2276-4b9f-a99d-2a8cbc4dda4a"><div class="modal-content"><h4>test/tests/executioners/time_period/time_period_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Functions]
  [./exact_p1]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]
  [./ffn_p1]
    type = ParsedFunction
    value = (x*x+y*y)-4*t
  [../]

  [./exact_p2]
    type = ParsedFunction
    value = t*((x*x*x)+(y*y*y))
  [../]
  [./ffn_p2]
    type = ParsedFunction
    value = (x*x*x+y*y*y)-6*t*(x+y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn1]
    type = BodyForce
    variable = u
    function = ffn_p1
  [../]

  [./ffn2]
    type = BodyForce
    variable = u
    function = ffn_p2
  [../]
[]

[BCs]
  [./all1]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_p1
  [../]
  [./all2]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_p2
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  dt = 0.1
  num_steps = 10
[]

[Controls]
  [./first_period]
    type = TimePeriod
    start_time = 0.0
    end_time = 0.45
    enable_objects = &#x27;*/ffn1 */all1&#x27;
    disable_objects = &#x27;*/ffn2 */all2&#x27;
    execute_on = &#x27;initial timestep_begin&#x27;
    set_sync_times = true
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="07e08915-6e92-4318-b410-7903cafdd732"><div class="modal-content"><h4>test/tests/restart/restart_diffusion/exodus_refined_refined_restart_2_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = exodus_refined_restart_1.e
  uniform_refine = 1
  # Restart relies on the ExodusII_IO::copy_nodal_solution()
  # functionality, which only works with ReplicatedMesh.
  parallel_type = replicated
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    initial_from_file_var = u
    initial_from_file_timestep = 2
  [../]
[]

[Kernels]
  active = &#x27;bodyforce ie&#x27;

  [./bodyforce]
    type = BodyForce
    variable = u
    value = 10.0
  [../]

  [./ie]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 10
  dt = .1
[]

[Outputs]
  file_base = exodus_refined_refined_restart_2
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0bf48c88-3c5f-4a60-8d5c-a1509d6f2483"><div class="modal-content"><h4>test/tests/mortar/periodic-value/periodic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [file]
    type = FileMeshGenerator
    file = square.msh
  []
  [secondary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    new_block_id = 11
    new_block_name = &quot;secondary&quot;
    sidesets = &#x27;101&#x27;
  []
  [primary]
    input = secondary
    type = LowerDBlockFromSidesetGenerator
    new_block_id = 12
    new_block_name = &quot;primary&quot;
    sidesets = &#x27;103&#x27;
  []
[]

[Variables]
  [u]
    order = SECOND
    block = &#x27;domain&#x27;
  []
  [lm]
    block = &#x27;secondary&#x27;
  []
[]

[Kernels]
  [diffusion]
    type = Diffusion
    variable = u
    block = &#x27;domain&#x27;
  []
  [force]
    type = BodyForce
    variable = u
    block = &#x27;domain&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    value = 1
    boundary = &#x27;left&#x27;
  []
[]

[Constraints]
  [ev]
    type = EqualValueConstraint
    variable = lm
    secondary_variable = u
    primary_boundary = 103
    secondary_boundary = 101
    primary_subdomain = 12
    secondary_subdomain = 11
    periodic = true
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b5481eae-8473-4f4e-8799-568b6c0f4eae"><div class="modal-content"><h4>test/tests/restart/restart_transient_from_transient/pseudo_trans_with_2subs.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  parallel_type = &#x27;replicated&#x27;
[]

[AuxVariables]
  [Tf]
  []
[]

[Variables]
  [power_density]
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27;
  []
[]

[Kernels]
  [timedt]
    type = TimeDerivative
    variable = power_density
  []
  [diff]
    type = Diffusion
    variable = power_density
  []
  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = power_density
    boundary = left
    value = 50
  []
  [right]
    type = DirichletBC
    variable = power_density
    boundary = right
    value = 1e3
  []
[]

[Postprocessors]
  [pwr_avg]
    type = ElementAverageValue
    variable = power_density
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_avg]
    type = ElementAverageValue
    variable = Tf
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_max]
    type = ElementExtremeValue
    value_type = max
    variable = Tf
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_min]
    type = ElementExtremeValue
    value_type = min
    variable = Tf
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Transient
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  end_time = 20
  dt = 2.0
[]

[MultiApps]
  [sub]
    type = TransientMultiApp
    app_type = MooseTestApp
    positions = &#x27;0   0 0
                 0.5 0 0&#x27;
    input_files  = pseudo_trans_with_2subs_sub.i
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Transfers]
  [p_to_sub]
    type = MultiAppProjectionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
  [t_from_sub]
    type = MultiAppInterpolationTransfer
    direction = from_multiapp
    source_variable = temp
    variable = Tf
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
  checkpoint = true
  execute_on = &#x27;INITIAL TIMESTEP_END FINAL&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6a2ea040-84e0-4b89-953d-404974422c7f"><div class="modal-content"><h4>test/tests/bcs/vectorpostprocessor/vectorpostprocessor.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  type = GeneratedMesh
  nx = 10
  ny = 10
  xmax = 1
  ymax = 1
  dim = 2
[]

[Variables]
  [./u]
  [../]
  [./v]
  [../]
[]

[Kernels]
  [./conv]
    type = ConservativeAdvection
    variable = u
    velocity = &#x27;0 1 0&#x27;
  [../]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./src]
    type = BodyForce
    variable = u
    function = ffn
  [../]
  [./diffv]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = bottom
    value = 2
  [../]
  [./right]
    type = ChannelGradientBC
    variable = u
    boundary = right
    channel_gradient_pps = channel_gradient
    axis = y
    h_name = h
  [../]
  [./top]
    type = OutflowBC
    variable = u
    boundary = top
    velocity = &#x27;0 1 0&#x27;
  [../]
  [./leftv]
    type = DirichletBC
    variable = v
    boundary = left
    value = 0
  [../]
  [./rightv]
    type = DirichletBC
    variable = v
    boundary = right
    value = 1
  [../]
[]

[Materials]
  [./mat]
    type = GenericConstantMaterial
    prop_names = &#x27;h&#x27;

    #Nu = 4
    #k = 1
    #half_channel_length = 0.5
    #h=Nu*k/half_channel_length
    prop_values = &#x27;8&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]

[VectorPostprocessors]
  [./lv1]
    num_points = 30
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;0 1 0&#x27;
    sort_by = &#x27;y&#x27;
    variable = u
    type = LineValueSampler
    execute_on = &#x27;timestep_begin nonlinear timestep_end linear&#x27;
  [../]
  [./lv2]
    num_points = 30
    start_point = &#x27;1 0 0&#x27;
    end_point =   &#x27;1 1 0&#x27;
    sort_by = &#x27;y&#x27;
    variable = v
    type = LineValueSampler
    execute_on = &#x27;timestep_begin nonlinear timestep_end linear&#x27;
  [../]
  [./channel_gradient]
    lv1 = lv1
    lv2 = lv2
    var1 = u
    var2 = v
    axis = y
    type = ChannelGradientVectorPostprocessor
    execute_on = &#x27;timestep_begin nonlinear timestep_end linear&#x27;
  [../]
[]

[Functions]
  [./ffn]
    type = ParsedFunction
    value = &#x27;1&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1738876f-9dc7-4e31-83a6-b929b545dc9b"><div class="modal-content"><h4>test/tests/multiapps/restart_subapp_ic/master2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  ymin = 0
  xmax = 1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./ufn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = v_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;sub2.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]

[Problem]
  restart_file_base = master_out_cp/0005
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ce69c69f-a3b9-4d98-9805-b16c21e1fc85"><div class="modal-content"><h4>test/tests/multiapps/grid-sequencing/vi-fine-alone.i</h4><pre class="moose-pre"><code class="language-text">l=10
nx=80
num_steps=2

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = ${l}
  nx = ${nx}
[]

[Variables]
  [u]
  []
[]

[AuxVariables]
  [bounds][]
[]

[Bounds]
  [./u_upper_bounds]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = upper
    bound_value = ${l}
  [../]
  [./u_lower_bounds]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = lower
    bound_value = 0
  [../]
[]

[ICs]
  [u]
    type = FunctionIC
    variable = u
    function = &#x27;x&#x27;
  []
[]

[Kernels]
  [time]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = &#x27;if(x&lt;5,-1,1)&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    boundary = left
    value = 0
    variable = u
  []
  [right]
    type = DirichletBC
    boundary = right
    value = ${l}
    variable = u
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  num_steps = ${num_steps}
  solve_type = NEWTON
  dtmin = 1
  petsc_options = &#x27;-snes_vi_monitor&#x27;
  petsc_options_iname = &#x27;-snes_max_linear_solve_fail -ksp_max_it -pc_type -sub_pc_factor_levels -snes_linesearch_type -snes_type&#x27;
  petsc_options_value = &#x27;0                           30          asm      16                    basic                 vinewtonrsls&#x27;
[]

[Outputs]
  exodus = true
  [csv]
    type = CSV
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  active = &#x27;upper_violations lower_violations&#x27;
  [upper_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = ${fparse 10+1e-8}
    comparator = &#x27;greater&#x27;
  []
  [lower_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = -1e-8
    comparator = &#x27;less&#x27;
  []
  [nls]
    type = NumNonlinearIterations
  []
  [cum_nls]
    type = CumulativeValuePostprocessor
    postprocessor = nls
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="291b459d-e872-424c-ac36-fb7e6f53b01a"><div class="modal-content"><h4>test/tests/variables/fe_monomial_const/monomial-const-1d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 100
  elem_type = EDGE3
[]

[Functions]
  [./bc_fn]
    type=ParsedFunction
    value=0
  [../]

  [./forcing_fn]
    type = MTPiecewiseConst1D
  [../]

  [./solution]
    type = MTPiecewiseConst1D
  [../]
[]

[Variables]
  [./u]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  # Note: MOOSE&#x27;s DirichletBCs do not work properly with shape functions that do not
  #       have DOFs at the element edges.  This test works because the solution
  #       has been designed to be zero at the boundary which is satisfied by the IC
  #       Ticket #1352
  active = &#x27;&#x27;
  [./bc_all]
    type=FunctionDirichletBC
    variable = u
    boundary = &#x27;left right&#x27;
    function = bc_fn
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1.e-9
  [./Adaptivity]

  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  csv = true
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="77adafc8-0e4c-4775-9359-5da8823601f2"><div class="modal-content"><h4>test/tests/adaptivity/max_h_level/max_h_level.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1
  solve_type = PJFNK
[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  [./out]
    type = Exodus
    execute_scalars_on = none
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="85a939a4-f4e5-46a8-850b-478cdc46f662"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-2-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX27
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 2*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -2*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -2*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 2*x
  [../]
  [./bc_fnf]
    type = ParsedFunction
    value = 2*z
  [../]
  [./bc_fnk]
    type = ParsedFunction
    value = -2*z
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6+x*x+y*y+z*z
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x+y*y+z*z
    grad_x = 2*x
    grad_y = 2*y
    grad_z = 2*z
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
  [./bc_front]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;front&#x27;
    function = bc_fnf
  [../]
  [./bc_back]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;back&#x27;
    function = bc_fnk
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-11

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7c1bf371-0659-40a3-97dc-1d75848d4ab0"><div class="modal-content"><h4>test/tests/postprocessors/element_h1_error_pps/element_h1_error_pp_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 3
  ny = 3

  xmin = 0
  xmax = 2

  ymin = 0
  ymax = 2
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;forcing_func u_func&#x27;

  [./forcing_func]
    type = ParsedFunction
    #value = alpha*alpha*pi*pi*(y*y*sin(alpha*pi*x*y)+y*y*sin(alpha*pi*x*y))
    value = alpha*alpha*pi*pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;4&#x27;
  [../]

  [./u_func]
    type = ParsedGradFunction
    #value = sin(alpha*pi*x*y)
    #grad_x   = alpha*pi*y*cos(alpha*pi*x*y)
    #grad_y   = alpha*pi*x*cos(alpha*pi*x*y)

    value = sin(alpha*pi*x)
    grad_x = alpha*pi*cos(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;4&#x27;
  [../]
[]

[Kernels]
  active = &#x27;diff forcing&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_func
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = &#x27;3&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = Steady

  [./Adaptivity]
    refine_fraction = 1.0
    coarsen_fraction = 0.0
    max_h_level = 10
    steps = 4
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./h1_error]
    type = ElementH1Error
    variable = u
    function = u_func
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./h1_semi]
    type = ElementH1SemiError
    variable = u
    function = u_func
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./l2_error]
    type = ElementL2Error
    variable = u
    function = u_func
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  file_base = out
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0fe18848-f124-45da-b335-55614284e6fe"><div class="modal-content"><h4>test/tests/nodalkernels/constraint_enforcement/lower-bound.i</h4><pre class="moose-pre"><code class="language-text">l=10
nx=100
num_steps=10

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = ${l}
  nx = ${nx}
[]

[Variables]
  [u]
  []
  [lm]
  []
[]

[ICs]
  [u]
    type = FunctionIC
    variable = u
    function = &#x27;${l} - x&#x27;
  []
[]

[Kernels]
  [time]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = &#x27;-1&#x27;
  []
[]

[NodalKernels]
  [positive_constraint]
    type = LowerBoundNodalKernel
    variable = lm
    v = u
    exclude_boundaries = &#x27;left right&#x27;
  []
  [forces]
    type = CoupledForceNodalKernel
    variable = u
    v = lm
  []
[]


[BCs]
  [left]
    type = DirichletBC
    boundary = left
    value = ${l}
    variable = u
  []
  [right]
    type = DirichletBC
    boundary = right
    value = 0
    variable = u
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  num_steps = ${num_steps}
  solve_type = NEWTON
  dtmin = 1
  petsc_options_iname = &#x27;-snes_max_linear_solve_fail -ksp_max_it -pc_type -sub_pc_factor_levels -snes_linesearch_type&#x27;
  petsc_options_value = &#x27;0                           30          asm      16                    basic&#x27;
[]

[Outputs]
  exodus = true
  [csv]
    type = CSV
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  [active_lm]
    type = GreaterThanLessThanPostprocessor
    variable = lm
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = 1e-8
  []
  [violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = -1e-8
    comparator = &#x27;less&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fa4ca32c-f9f1-4378-b4ab-757da725941c"><div class="modal-content"><h4>test/tests/misc/check_error/missing_coupled_mat_prop_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Materials]
  # This material is global and uses a coupled property
  [./mat_global]
    type = CoupledMaterial
    mat_prop = &#x27;some_prop&#x27;
    coupled_mat_prop = &#x27;mp1&#x27;
    block = &#x27;1 2&#x27;
  [../]

  # This material supplies a value for block 1 ONLY
  [./mat_0]
    type = GenericConstantMaterial
    block = 1
    prop_names = &#x27;mp1&#x27;
    prop_values = 2
  [../]
[]

[Executioner]
  type = Steady
#  solve_type = &#x27;PJFNK&#x27;
#  preconditioner = &#x27;ILU&#x27;

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
#  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  file_base = missing_mat_prop_test
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8fa8d915-7251-48b1-852f-1139e0aaa1e1"><div class="modal-content"><h4>test/tests/postprocessors/num_elems/num_elems.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  nz = 0
  zmax = 0
  elem_type = QUAD4
  uniform_refine = 1
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
    order = FIRST
    family = LAGRANGE
  [../]
  [./v_aux]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 3
  dt = 1
  solve_type = PJFNK
[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 3
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Postprocessors]
  [./num_elems_active]
    type = NumElems
    elem_filter = &#x27;ACTIVE&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./num_elems_total]
    type = NumElems
    elem_filter = &#x27;TOTAL&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bf9e36f1-6652-4277-bba6-fb24b07f36dd"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/pod_rb/errors/sub.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  type = FEProblem
  extra_tag_vectors  = &#x27;diff react bodyf&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 15
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = k
    extra_vector_tags = &#x27;diff&#x27;
  []
  [reaction]
    type = MaterialReaction
    variable = u
    coefficient = alpha
    extra_vector_tags = &#x27;react&#x27;
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
    extra_vector_tags = &#x27;bodyf&#x27;
  []
[]

[Materials]
  [k]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 1.0
  []
  [alpha]
    type = GenericConstantMaterial
    prop_names = alpha
    prop_values = 1.0
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="934a9fc8-59a4-4bf7-945a-2e17ff39bfd4"><div class="modal-content"><h4>test/tests/transfers/multiapp_conservative_transfer/sub_power_density.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0.01 # to make sure the meshes don&#x27;t align
    xmax = 0.49 # to make sure the meshes don&#x27;t align
    ymax = 1
    nx = 10
    ny = 10
  []
  [block1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    block_id = 1
    bottom_left = &#x27;0.2 0.2 0&#x27;
    top_right = &#x27;0.3 0.8 0&#x27;
  []
[]

[Variables]
  [sink]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[Functions]
  [sink_func]
    type = ParsedFunction
    value = &#x27;5e2*x*(0.5-x)+5e1&#x27;
  []
[]

[Kernels]
  [reaction]
    type = Reaction
    variable = sink
  []

  [coupledforce]
    type = BodyForce
    variable = sink
    function = sink_func
  []
[]

[AuxVariables]
  [from_master]
    block = 1
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [sink]
    type = ElementIntegralVariablePostprocessor
    block = 1
    variable = sink
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
  [from_master_pp]
    type = ElementIntegralVariablePostprocessor
    block = 1
    variable = from_master
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="896b8698-d065-45cf-aeac-813a1d90d22e"><div class="modal-content"><h4>test/tests/bcs/nodal_normals/cylinder_hexes_1st_2nd.i</h4><pre class="moose-pre"><code class="language-text"># First order normals on second order mesh
[Mesh]
  file = cylinder-hexes-2nd.e
[]

[Functions]
  [./all_bc_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]
[]

[NodalNormals]
  boundary = &#x27;1&#x27;
  corner_boundary = 100
  order = FIRST
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = &#x27;all_bc_fn&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3fc54b8a-7b27-4439-924d-633929bd86e9"><div class="modal-content"><h4>test/tests/restart/restart_transient_from_steady/steady_with_2subs.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  parallel_type = &#x27;replicated&#x27;
[]

[AuxVariables]
  [Tf]
  []
[]

[Variables]
  [power_density]
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27;
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = power_density
    boundary = left
    value = 50
  []
  [right]
    type = DirichletBC
    variable = power_density
    boundary = right
    value = 1e3
  []
[]

[Postprocessors]
  [pwr_avg]
    type = ElementAverageValue
    variable = power_density
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_avg]
    type = ElementAverageValue
    variable = Tf
    execute_on = &#x27;initial final&#x27;
  []
  [temp_max]
    type = ElementExtremeValue
    value_type = max
    variable = Tf
    execute_on = &#x27;initial final&#x27;
  []
  [temp_min]
    type = ElementExtremeValue
    value_type = min
    variable = Tf
    execute_on = &#x27;initial final&#x27;
  []
[]

[Executioner]
  type = Steady
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  picard_rel_tol = 1E-7
  picard_abs_tol = 1.0e-07
  picard_max_its = 12
[]

[MultiApps]
  [sub]
    type = FullSolveMultiApp
    app_type = MooseTestApp
    positions = &#x27;0   0 0
                 0.5 0 0&#x27;
    input_files  = steady_with_sub_sub.i
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Transfers]
  [p_to_sub]
    type = MultiAppProjectionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
  [t_from_sub]
    type = MultiAppInterpolationTransfer
    direction = from_multiapp
    source_variable = temp
    variable = Tf
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
  checkpoint = true
  execute_on = &#x27;INITIAL TIMESTEP_END FINAL&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d405a6e0-a717-4afd-8d15-e2d5dd22614c"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined.i</h4><pre class="moose-pre"><code class="language-text"># A sample is constrained on all sides, except its top
# and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie kg/second per cubic meter), and the
# rise in the top surface, porepressure, and stress are observed.
#
# In the standard poromechanics scenario, the Biot Modulus is held
# fixed and the source has units 1/time.  Then the expected result
# is
# strain_zz = disp_z = BiotCoefficient*BiotModulus*s*t/((bulk + 4*shear/3) + BiotCoefficient^2*BiotModulus)
# porepressure = BiotModulus*(s*t - BiotCoefficient*strain_zz)
# stress_xx = (bulk - 2*shear/3)*strain_zz   (remember this is effective stress)
# stress_zz = (bulk + 4*shear/3)*strain_zz   (remember this is effective stress)
#
# In porous_flow, however, the source has units kg/s/m^3 and the
# Biot Modulus is not held fixed.  This means that disp_z, porepressure,
# etc are not linear functions of t.  Nevertheless, the ratios remain
# fixed:
# stress_xx/strain_zz = (bulk - 2*shear/3) = 1 (for the parameters used here)
# stress_zz/strain_zz = (bulk + 4*shear/3) = 4 (for the parameters used here)
# porepressure/strain_zz = 13.3333333 (for the parameters used here)

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.8
    alpha = 1e-5
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    component = 2
    variable = disp_z
  [../]
  [./poro_vol_exp]
    type = PorousFlowMassVolumetricExpansion
    variable = porepressure
    fluid_component = 0
  [../]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = porepressure
  [../]
  [./flux]
    type = PorousFlowAdvectiveFlux
    variable = porepressure
    gravity = &#x27;0 0 0&#x27;
    fluid_component = 0
  [../]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 3.3333333333
      density0 = 1
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = porepressure
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosity
    fluid = true
    mechanical = true
    porosity_zero = 0.1
    biot_coefficient = 0.3
    solid_bulk = 2
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0   0 1 0   0 0 1&#x27; # unimportant
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityCorey
    n = 0 # unimportant in this fully-saturated situation
    phase = 0
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = none
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = none
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = none
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = none
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = none
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
  [./stress_xx_over_strain]
    type = FunctionValuePostprocessor
    function = stress_xx_over_strain_fcn
    outputs = csv
  [../]
  [./stress_zz_over_strain]
    type = FunctionValuePostprocessor
    function = stress_zz_over_strain_fcn
    outputs = csv
  [../]
  [./p_over_strain]
    type = FunctionValuePostprocessor
    function = p_over_strain_fcn
    outputs = csv
  [../]
[]

[Functions]
  [./stress_xx_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_xx zdisp&#x27;
  [../]
  [./stress_zz_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_zz zdisp&#x27;
  [../]
  [./p_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;p0 zdisp&#x27;
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_unconfined
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="886a04a7-bdc9-4892-9b97-a8932fdc24c4"><div class="modal-content"><h4>test/tests/mortar/continuity-2d-non-conforming/sequencing-stateful-soln-continuity.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  second_order = true
  [file]
    type = FileMeshGenerator
    file = nodal_normals_test_offset_nonmatching_gap.e
  []
  [./primary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;2&#x27;
    new_block_id = &#x27;20&#x27;
  [../]
  [./secondary]
    input = primary
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;1&#x27;
    new_block_id = &#x27;10&#x27;
  [../]
[]

[Variables]
  [./T]
    block = &#x27;1 2&#x27;
    order = SECOND
  [../]
  [./lambda]
    block = &#x27;10&#x27;
  [../]
[]

[AuxVariables]
  [ssm]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;1 2&#x27;
  []
[]

[BCs]
  [./neumann]
    type = FunctionGradientNeumannBC
    exact_solution = exact_soln
    variable = T
    boundary = &#x27;3 4 5 6 7 8&#x27;
  [../]
[]

[Kernels]
  [./conduction]
    type = Diffusion
    variable = T
    block = &#x27;1 2&#x27;
  [../]
  [./sink]
    type = Reaction
    variable = T
    block = &#x27;1 2&#x27;
  [../]
  [./forcing_function]
    type = BodyForce
    variable = T
    function = forcing_function
    block = &#x27;1 2&#x27;
  [../]
[]

[AuxKernels]
  [ssm]
    type = MaterialRealAux
    variable = ssm
    property = diffusivity
    block = &#x27;1 2&#x27;
  []
[]

[Materials]
  [./ssm]
    type = SpatialStatefulMaterial
    block = &#x27;1 2&#x27;
  [../]
[]

[Functions]
  [./forcing_function]
    type = ParsedFunction
    value = &#x27;-4 + x^2 + y^2&#x27;
  [../]
  [./exact_soln]
    type = ParsedFunction
    value = &#x27;x^2 + y^2&#x27;
  [../]
[]

[Debug]
  show_var_residual_norms = 1
[]

[Constraints]
  [./mortar]
    type = EqualValueConstraint
    primary_boundary = 2
    secondary_boundary = 1
    primary_subdomain = 20
    secondary_subdomain = 10
    variable = lambda
    secondary_variable = T
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  solve_type = NEWTON
  type = Steady
  nl_abs_tol = 1e-12
  petsc_options_iname = &#x27;-pc_type -snes_linesearch_type -pc_factor_shift_type -pc_factor_shift_amount&#x27;
  petsc_options_value = &#x27;lu       basic                 NONZERO               1e-15&#x27;
  num_grids = 2
[]

[Outputs]
  exodus = true
[]

[Adaptivity]
  steps = 1
  marker = uniform
  [Markers]
    [uniform]
      type = UniformMarker
      mark = refine
    []
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ffc454a1-54e8-4d2b-910c-7c3ea8e63c5c"><div class="modal-content"><h4>test/tests/dampers/bounding_value_nodal_damper/bounding_value_max_test.i</h4><pre class="moose-pre"><code class="language-text"># This model tests the BoundingValueNodalDamper. The converged solution
# for u starts out in the range from 0 to 1, but after several steps,
# a volumetric source drives it to a value greater than 1, which is
# outside the range of the damper. At that point, the solution can
# no longer converge, and the model errors out with a failure to converge.
# The test verifies that the damper computes the correct value in the first
# nonlinear iteration when the solution exceeds the bounds.

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./source]
    type = BodyForce
    variable = u
    function = &#x27;t&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Dampers]
  [./bounding_value_damp]
    type = BoundingValueNodalDamper
    min_value = 0.0
    max_value = 1.0
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  end_time = 3.0
  dt = 0.5
  dtmin = 0.5
  nl_max_its = 5
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6dbc8d97-053d-4f42-b4de-152810605c81"><div class="modal-content"><h4>test/tests/time_integrators/rk-2/1d-linear.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 20
  elem_type = EDGE2
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  [./TimeIntegrator]
    type = ExplicitMidpoint
  [../]
  solve_type = &#x27;LINEAR&#x27;

  start_time = 0.0
  num_steps = 10
  dt = 0.001
  l_tol = 1e-15
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5043520e-593c-481a-84e7-cad1570ff6dc"><div class="modal-content"><h4>test/tests/misc/check_error/incomplete_kernel_variable_coverage_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    value = 10
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="02e893f6-9dd9-4f0a-8c8c-11caa3faf9a1"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-1-1d.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test demonstrating the use of the
# Hierarchic variable type.
#
# @Requirement F3.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
  elem_type = EDGE3
[]

[Functions]
  [./bc_fnl]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 1
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x
    grad_x = 1
  [../]
[]

# Hierarchic Variable type
[Variables]
  [./u]
    order = FIRST
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-11

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="124d719a-a32f-4a94-a619-dad1b3535e9f"><div class="modal-content"><h4>modules/heat_conduction/test/tests/sideset_heat_transfer/cfem_gap.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # Build 2-by-2 mesh
  [mesh]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []

  # Create blocs 0, 1, 2, 3
  [block_1]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    block_id = 1
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 1 0&#x27;
  []
  [block_2]
    type = SubdomainBoundingBoxGenerator
    input = block_1
    block_id = 2
    bottom_left = &#x27;0 1 0&#x27;
    top_right = &#x27;1 2 0&#x27;
  []
  [block_3]
    type = SubdomainBoundingBoxGenerator
    input = block_2
    block_id = 3
    bottom_left = &#x27;1 1 0&#x27;
    top_right = &#x27;2 2 0&#x27;
  []

  # Create inner sidesets
  [interface_01]
    type = SideSetsBetweenSubdomainsGenerator
    input = block_3
    primary_block = 0
    paired_block = 1
    new_boundary = &#x27;interface_01&#x27;
  []
  [interface_13]
    type = SideSetsBetweenSubdomainsGenerator
    input = interface_01
    primary_block = 1
    paired_block = 3
    new_boundary = &#x27;interface_13&#x27;
  []
  [interface_32]
    type = SideSetsBetweenSubdomainsGenerator
    input = interface_13
    primary_block = 3
    paired_block = 2
    new_boundary = &#x27;interface_32&#x27;
  []
  [interface_20]
    type = SideSetsBetweenSubdomainsGenerator
    input = interface_32
    primary_block = 2
    paired_block = 0
    new_boundary = &#x27;interface_20&#x27;
  []

  # Create outer boundaries
  [boundary_left_0]
    type = SideSetsAroundSubdomainGenerator
    input = interface_20
    block = 0
    normal = &#x27;-1 0 0&#x27;
    new_boundary = &#x27;left_0&#x27;
  []
  [boundary_bot_0]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_left_0
    block = 0
    normal = &#x27;0 -1 0&#x27;
    new_boundary = &#x27;bot_0&#x27;
  []
  [boundary_bot_1]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_bot_0
    block = 1
    normal = &#x27;0 -1 0&#x27;
    new_boundary = &#x27;bot_1&#x27;
  []
  [boundary_right_1]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_bot_1
    block = 1
    normal = &#x27;1 0 0&#x27;
    new_boundary = &#x27;right_1&#x27;
  []
  [boundary_right_3]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_right_1
    block = 3
    normal = &#x27;1 0 0&#x27;
    new_boundary = &#x27;right_3&#x27;
  []
  [boundary_top_3]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_right_3
    block = 3
    normal = &#x27;0 1 0&#x27;
    new_boundary = &#x27;top_3&#x27;
  []
  [boundary_top_2]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_top_3
    block = 2
    normal = &#x27;0 1 0&#x27;
    new_boundary = &#x27;top_2&#x27;
  []
  [boundary_left_2]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_top_2
    block = 2
    normal = &#x27;-1 0 0&#x27;
    new_boundary = &#x27;left_2&#x27;
  []
  uniform_refine = 4
[]

[Variables]
  # Need to have variable for each block to allow discontinuity
  [T0]
    block = 0
  []
  [T1]
    block = 1
  []
  [T2]
    block = 2
  []
  [T3]
    block = 3
  []
[]

[Kernels]
  # Diffusion kernel for each block&#x27;s variable
  [diff_0]
    type = MatDiffusion
    variable = T0
    diffusivity = conductivity
    block = 0
  []
  [diff_1]
    type = MatDiffusion
    variable = T1
    diffusivity = conductivity
    block = 1
  []
  [diff_2]
    type = MatDiffusion
    variable = T2
    diffusivity = conductivity
    block = 2
  []
  [diff_3]
    type = MatDiffusion
    variable = T3
    diffusivity = conductivity
    block = 3
  []

  # Source for two of the blocks
  [source_0]
    type = BodyForce
    variable = T0
    value = 5e5
    block = &#x27;0&#x27;
  []
  [source_3]
    type = BodyForce
    variable = T3
    value = 5e5
    block = &#x27;3&#x27;
  []
[]

[InterfaceKernels]
  # Side set kernel to represent heat transfer across blocks
  # Automatically uses the materials defined in SideSetHeatTransferMaterial
  [gap_01]
    type = SideSetHeatTransferKernel
    # This variable defined on a given block must match the primary_block given when the side set was generated
    variable = T0
    # This variable defined on a given block must match the paired_block given when the side set was generated
    neighbor_var = T1
    boundary = &#x27;interface_01&#x27;
  []
  [gap_13]
    type = SideSetHeatTransferKernel
    variable = T1
    neighbor_var = T3
    boundary = &#x27;interface_13&#x27;
  []
  [gap_32]
    type = SideSetHeatTransferKernel
    variable = T3
    neighbor_var = T2
    boundary = &#x27;interface_32&#x27;
  []
  [gap_20]
    type = SideSetHeatTransferKernel
    variable = T2
    neighbor_var = T0
    boundary = &#x27;interface_20&#x27;
  []
[]

# Creating auxiliary variable to combine block restricted solutions
# Ignores discontinuity though
[AuxVariables]
  [T]
  []
[]

[AuxKernels]
  [temp_0]
    type = NormalizationAux
    variable = T
    source_variable = T0
    block = 0
  []
  [temp_1]
    type = NormalizationAux
    variable = T
    source_variable = T1
    block = 1
  []
  [temp_2]
    type = NormalizationAux
    variable = T
    source_variable = T2
    block = 2
  []
  [temp_3]
    type = NormalizationAux
    variable = T
    source_variable = T3
    block = 3
  []
[]

[BCs]
  # Boundary condition for each block&#x27;s outer surface
  [bc_left_2]
    type = DirichletBC
    boundary = &#x27;left_2&#x27;
    variable = T2
    value = 300.0
  []
  [bc_left_0]
    type = DirichletBC
    boundary = &#x27;left_0&#x27;
    variable = T0
    value = 300.0
  []

  [bc_bot_0]
    type = DirichletBC
    boundary = &#x27;bot_0&#x27;
    variable = T0
    value = 300.0
  []
  [bc_bot_1]
    type = DirichletBC
    boundary = &#x27;bot_1&#x27;
    variable = T1
    value = 300.0
  []

  [./bc_top_2]
    type = ConvectiveFluxFunction # (Robin BC)
    variable = T2
    boundary = &#x27;top_2&#x27;
    coefficient = 1e3 # W/K/m^2
    T_infinity = 600.0
  [../]
  [./bc_top_3]
    type = ConvectiveFluxFunction # (Robin BC)
    variable = T3
    boundary = &#x27;top_3&#x27;
    coefficient = 1e3 # W/K/m^2
    T_infinity = 600.0
  [../]

  [./bc_right_3]
    type = ConvectiveFluxFunction # (Robin BC)
    variable = T3
    boundary = &#x27;right_3&#x27;
    coefficient = 1e3 # W/K/m^2
    T_infinity = 600.0
  [../]
  [./bc_right_1]
    type = ConvectiveFluxFunction # (Robin BC)
    variable = T1
    boundary = &#x27;right_1&#x27;
    coefficient = 1e3 # W/K/m^2
    T_infinity = 600.0
  [../]
[]

[Materials]
  [fuel]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 75
    block = &#x27;0 3&#x27;
  []
  [mod]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 7.5
    block = &#x27;1 2&#x27;
  []
  # Interface material used for SideSetHeatTransferKernel
  # Heat transfer meachnisms ignored if certain properties are not supplied
  [gap_mat]
    type = SideSetHeatTransferMaterial
    boundary = &#x27;interface_01 interface_13 interface_32 interface_20&#x27;
    conductivity = 0.41
    gap_length = 0.002
    Tbulk = 750
    h_primary = 3000
    h_neighbor = 3000
    emissivity_primary = 0.85
    emissivity_neighbor = 0.85
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
  l_tol = 1e-8
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       superlu_dist                  50&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="312f0ecb-fde7-45c9-857a-06e86cb75eb6"><div class="modal-content"><h4>test/tests/dgkernels/dg_block_restrict/2d_dg_diffusion_block_restrict.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmax = 2
    nx = 10
    ymax = 2
    ny = 10
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    block_id = 1
    top_right = &#x27;1 1 0&#x27;
  [../]
  [./interface]
    input = subdomain1
    type = SideSetsBetweenSubdomainsGenerator
    primary_block = &#x27;1&#x27;
    paired_block = &#x27;0&#x27;
    new_boundary = &#x27;primary1_interface&#x27;
  [../]
  [./boundaries]
    input = interface
    type = BreakBoundaryOnSubdomainGenerator
    boundaries = &#x27;left bottom&#x27;
  [../]
[]

[Problem]
  kernel_coverage_check = false
[]

[Variables]
  [./u]
    order = FIRST
    family = L2_LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./source]
    type = BodyForce
    variable = u
  [../]
[]

[DGKernels]
  [./dg_diffusion]
    type = DGDiffusion
    variable = u
    sigma = 4
    epsilon = 1
  [../]
[]

[BCs]
  [./vacuum]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
  [./primary1_inteface]
    type = VacuumBC
    variable = u
    boundary = &#x27;primary1_interface&#x27;
  [../]
[]

[Postprocessors]
  [./norm]
    type = ElementL2Norm
    variable = u
    block = 1
  [../]
[]

[Executioner]
  type = Steady
  nl_abs_tol = 1e-12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="44ba9f16-396f-4b32-b507-3eb717b3a4c4"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined_basicthm.i</h4><pre class="moose-pre"><code class="language-text"># Identical to pp_generation_unconfined_fullysat_volume.i but using an Action
#
# A sample is constrained on all sides, except its top
# and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie m^3/second per cubic meter), and the
# rise in the top surface, porepressure, and stress are observed.
#
# In the standard poromechanics scenario, the Biot Modulus is held
# fixed and the source has units 1/s.  Then the expected result
# is
# strain_zz = disp_z = BiotCoefficient*BiotModulus*s*t/((bulk + 4*shear/3) + BiotCoefficient^2*BiotModulus)
# porepressure = BiotModulus*(s*t - BiotCoefficient*strain_zz)
# stress_xx = (bulk - 2*shear/3)*strain_zz   (remember this is effective stress)
# stress_zz = (bulk + 4*shear/3)*strain_zz   (remember this is effective stress)
#
# In standard porous_flow, everything is based on mass, eg the source has
# units kg/s/m^3.  This is discussed in the other pp_generation_unconfined
# models.  In this test, we use the FullySaturated Kernel and set
# multiply_by_density = false
# meaning the fluid Kernel has units of volume, and the source, s, has units 1/time
#
# The ratios are:
# stress_xx/strain_zz = (bulk - 2*shear/3) = 1 (for the parameters used here)
# stress_zz/strain_zz = (bulk + 4*shear/3) = 4 (for the parameters used here)
# porepressure/strain_zz = 13.3333333 (for the parameters used here)
#
# Expect
# disp_z = 0.3*10*s*t/((2 + 4*1.5/3) + 0.3^2*10) = 0.612245*s*t
# porepressure = 10*(s*t - 0.3*0.612245*s*t) = 8.163265*s*t
# stress_xx = (2 - 2*1.5/3)*0.612245*s*t = 0.612245*s*t
# stress_zz = (2 + 4*shear/3)*0.612245*s*t = 2.44898*s*t
#
# Finally, note that the volumetric strain has
# consistent_with_displaced_mesh = false
# which is needed when using the FullySaturated version of the Kernels
# in order to generate the above results

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  [../]
[]


[Kernels]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.0
      bulk_modulus = 3.3333333333
      viscosity = 1.0
      density0 = 1.0
    [../]
  [../]
[]

[PorousFlowBasicTHM]
  coupling_type = HydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  multiply_by_density = false
  porepressure = porepressure
  biot_coefficient = 0.3
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
[]


[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # the &quot;const&quot; is irrelevant here: all that uses Porosity is the BiotModulus, which just uses the initial value of porosity
    porosity = 0.1
    PorousFlowDictator = dictator
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    PorousFlowDictator = dictator
    biot_coefficient = 0.3
    fluid_bulk_modulus = 3.3333333333
    solid_bulk_compliance = 0.5
  [../]
  [./permeability_irrelevant]
    type = PorousFlowPermeabilityConst
    PorousFlowDictator = dictator
    permeability = &#x27;1.5 0 0   0 1.5 0   0 0 1.5&#x27;
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
  [./stress_xx_over_strain]
    type = FunctionValuePostprocessor
    function = stress_xx_over_strain_fcn
    outputs = csv
  [../]
  [./stress_zz_over_strain]
    type = FunctionValuePostprocessor
    function = stress_zz_over_strain_fcn
    outputs = csv
  [../]
  [./p_over_strain]
    type = FunctionValuePostprocessor
    function = p_over_strain_fcn
    outputs = csv
  [../]
[]

[Functions]
  [./stress_xx_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_xx zdisp&#x27;
  [../]
  [./stress_zz_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_zz zdisp&#x27;
  [../]
  [./p_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;p0 zdisp&#x27;
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_unconfined_basicthm
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a8d98bdd-89aa-46be-ac2b-bdcb9104f654"><div class="modal-content"><h4>test/tests/restart/restart_steady_from_transient/transient.i</h4><pre class="moose-pre"><code class="language-text"># We run a simple problem (5 time steps and save off the solution)
# In part2, we load the solution and solve a steady problem. The test check, that the initial state in part 2 is the same as the last state from part1

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 20
  ny = 20
  parallel_type = replicated
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;ie diff ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.2
  start_time = 0
  num_steps = 5
[]

[Outputs]
  exodus = true
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aaaa32f8-90bf-4d81-9bfb-430aadc40486"><div class="modal-content"><h4>modules/level_set/test/tests/kernels/advection/advection_mms.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 12
  nx = 48
[]

[Adaptivity]
  steps = 5
  marker = marker
  [./Markers]
    [./marker]
      type = UniformMarker
      mark = REFINE
    [../]
  [../]
[]

[Variables]
  [./phi]
  [../]
[]

[AuxVariables]
  [./velocity]
    family = LAGRANGE_VEC
  [../]
[]

[ICs]
  [./vel_ic]
    type = VectorFunctionIC
    variable = velocity
    function = velocity_func
  []
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    boundary = &#x27;left&#x27;
    function = phi_exact
    variable = phi
  [../]
[]

[Functions]
  [./phi_exact]
    type = ParsedFunction
    value = &#x27;a*sin(pi*x/b)*cos(pi*x)&#x27;
    vars = &#x27;a b&#x27;
    vals = &#x27;2 12&#x27;
  [../]
  [./phi_mms]
    type = ParsedFunction
    value = &#x27;-2*pi*a*sin(pi*x)*sin(pi*x/b) + 2*pi*a*cos(pi*x)*cos(pi*x/b)/b&#x27;
    vars = &#x27;a b&#x27;
    vals = &#x27;2 12&#x27;
  [../]
  [./velocity_func]
    type = ParsedVectorFunction
    value_x = &#x27;2&#x27;
    value_y = &#x27;2&#x27;
  [../]
[]

[Kernels]
  [./phi_advection]
    type = LevelSetAdvection
    variable = phi
    velocity = velocity
  [../]
  [./phi_forcing]
    type = BodyForce
    variable = phi
    function = phi_mms
  [../]
[]

[Postprocessors]
  [./error]
    type = ElementL2Error
    function = phi_exact
    variable = phi
  [../]
  [./h]
    type = AverageElementSize
  [../]
[]

[VectorPostprocessors]
  active = &#x27;&#x27;
  [./results]
    type = LineValueSampler
    variable = phi
    start_point = &#x27;0 0 0&#x27;
    end_point = &#x27;12 0 0&#x27;
    num_points = 500
    sort_by = x
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-10
  solve_type = NEWTON
  # A steady-state pure advection problem is numerically challenging,
  # it has a zero diagonal in the Jabocian matrix. The following solver
  # settings seem to reliably solve this problem.
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;
[]

[Outputs]
  execute_on = &#x27;TIMESTEP_END&#x27;
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b0dddc8a-6fb9-4d71-b164-22c5ea519212"><div class="modal-content"><h4>test/tests/executioners/transient_sync_time/transient_sync_time_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./bc_func]
    type = ParsedFunction
    value = sin(pi*0.1*x*t)
  [../]

  # Laplacian of the function above
  [./interior_func]
    type = ParsedFunction
    value = 0.01*pi*pi*t*t*sin(0.1*pi*x*t)
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = interior_func
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1 2 3&#x27;
    function = bc_func
  [../]
[]

[Executioner]
  type = Transient

  dt = 1
  start_time = 0
  end_time = 40
  num_steps = 1000
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out
  csv = true
  exodus = true
  sync_times = &#x27;10.5 20 30.5&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="45554c19-6fd8-4410-b718-3253a380e9e9"><div class="modal-content"><h4>test/tests/userobjects/interface_user_object/interface_value_user_object_QP.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./primary0_interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = primary0_interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 2
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 4
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    function = 0.1*t
  [../]
[]

[InterfaceKernels]
  [./primary0_interface]
    type = PenaltyInterfaceDiffusionDot
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = TRUE
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  dt = 0.1
  num_steps = 3
  dtmin = 0.1
  line_search = none
[]

[Outputs]
  [./out]
    type = Exodus
    sync_only = true
    sync_times = &#x27;0.1 0.2 0.3&#x27;
    execute_on = &#x27;TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [./interface_value_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = average
  [../]
  [./interface_primary_minus_secondary_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = jump_primary_minus_secondary
  [../]
  [./interface_secondary_minus_primary_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = jump_secondary_minus_primary
  [../]
  [./interface_absolute_jump_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = jump_abs
  [../]
  [./interface_primary_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = primary
  [../]
  [./interface_secondary_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = secondary
  [../]
[]


[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 5
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
  [../]
[]

[AuxKernels]
  [./diffusivity_1]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_1
    execute_on = &#x27;INITIAL  NONLINEAR&#x27;
  []
  [./diffusivity_2]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_2
    execute_on = &#x27;INITIAL NONLINEAR&#x27;
  []
  [./interface_avg_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = avg_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_value_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [./interface_primary_minus_secondary_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = primary_minus_secondary_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_primary_minus_secondary_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./interface_secondary_minus_primary_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = secondary_minus_primary_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_secondary_minus_primary_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./interface_absolute_jump_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = abs_jump_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_absolute_jump_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./interface_primary_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = primary_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_primary_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./interface_secondary_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = secondary_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_secondary_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]


[]

[AuxVariables]
  [./diffusivity_1]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_2]
    family = MONOMIAL
    order = CONSTANT
  []
  [./avg_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./primary_minus_secondary_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./secondary_minus_primary_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./abs_jump_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./primary_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./secondary_qp]
    family = MONOMIAL
    order = CONSTANT
  []
[]



[Postprocessors]
  [./interface_average_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  avg_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./primary_minus_secondary_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  primary_minus_secondary_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./secondary_minus_primary_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  secondary_minus_primary_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./abs_jump_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  abs_jump_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./primary_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  primary_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./secondary_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  secondary_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9286fa5e-4eee-4b65-ad49-e4360919f502"><div class="modal-content"><h4>test/tests/userobjects/internal_side_user_object/internal_side_user_object.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  ymin = -1
  xmax = 1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD4
[]

[Functions]
  [./fn_exact]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]
[]

[UserObjects]
  [./isuo]
    type = InsideUserObject
    variable = u
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = fn_exact
  [../]
[]

[Postprocessors]
  [./value]
    type = InsideValuePPS
    user_object = isuo
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="491f3fc3-7221-4933-8d48-daed06b03e51"><div class="modal-content"><h4>test/tests/variables/fe_hermite_convergence/hermite_converge_dirichlet.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 4
  ny = 4
  elem_type = QUAD4
  # This test will not work in parallel with DistributedMesh enabled
  # due to a bug in PeriodicBCs.
  parallel_type = replicated
[]

[Functions]
  [./bc_fn]
    type = ParsedGradFunction
    value = -sin(pi*x)*sin(pi*y)
    grad_x = -pi*cos(pi*x)*sin(pi*y)
    grad_y = -pi*sin(pi*x)*cos(pi*y)
  [../]
  [./forcing_fn]
    type = ParsedFunction
    value = -2*pi*pi*sin(pi*x)*sin(pi*y)-sin(pi*x)*sin(pi*y)
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./reaction]
    type = Reaction
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionPenaltyDirichletBC
    variable = u
    boundary = &#x27;bottom right top left&#x27;
    function = bc_fn
    penalty = 1e10
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]
  [./h]
    type = AverageElementSize
  [../]
  [./L2error]
    type = ElementL2Error
    variable = u
    function = bc_fn
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = bc_fn
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = bc_fn
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;

  # We use higher-order quadrature to ensure that the forcing function
  # is integrated accurately.
  [./Quadrature]
    order=ELEVENTH
  [../]
[]

[Adaptivity]
  steps = 2
  marker = uniform
  [./Markers]
    [./uniform]
      type = UniformMarker
      mark = refine
    [../]
  [../]
[]


[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
  print_mesh_changed_info = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2b548409-76f5-46b0-b119-2255de85aeea"><div class="modal-content"><h4>test/tests/kernels/ode/parsedode_sys_impl_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD4
[]

[Functions]
  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]
  [./bc_all_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  # ODEs
  [./exact_x_fn]
    type = ParsedFunction
    value = (-1/3)*exp(-t)+(4/3)*exp(5*t)
  [../]
[]

# NL

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]

  # ODE variables
  [./x]
    family = SCALAR
    order = FIRST
    initial_condition = 1
  [../]
  [./y]
    family = SCALAR
    order = FIRST
    initial_condition = 2
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./uff]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[ScalarKernels]
  [./td1]
    type = ODETimeDerivative
    variable = x
  [../]
  [./ode1]
    type = ParsedODEKernel
    function = &#x27;-3*x - 2*y&#x27;
    variable = x
    args = y
  [../]

  [./td2]
    type = ODETimeDerivative
    variable = y
  [../]
  [./ode2]
    type = ParsedODEKernel
    function = &#x27;-4*x - y&#x27;
    variable = y
    args = x
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = bc_all_fn
  [../]
[]

[Postprocessors]
  active = &#x27;exact_x l2err_x x y&#x27;

  [./x]
    type = ScalarVariable
    variable = x
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./y]
    type = ScalarVariable
    variable = y
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./exact_x]
    type = FunctionValuePostprocessor
    function = exact_x_fn
    execute_on = &#x27;initial timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
  [../]

  [./l2err_x]
    type = ScalarL2Error
    variable = x
    function = exact_x_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  dt = 0.01
  num_steps = 100

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = ode_sys_impl_test_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="45761604-3f52-4124-a3c4-2f16aab8d002"><div class="modal-content"><h4>test/tests/restart/restart_diffusion/exodus_refined_restart_2_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = exodus_refined_restart_1.e
  # Restart relies on the ExodusII_IO::copy_nodal_solution()
  # functionality, which only works with ReplicatedMesh.
  parallel_type = replicated
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    initial_from_file_var = u
    initial_from_file_timestep = 2
  [../]
[]

[Kernels]
  active = &#x27;bodyforce ie&#x27;

  [./bodyforce]
    type = BodyForce
    variable = u
    value = 10.0
  [../]

  [./ie]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 10
  dt = .1
[]

[Outputs]
  file_base = exodus_refined_restart_2
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b6a32f74-d9bd-4d60-9c36-c20d3b519d53"><div class="modal-content"><h4>test/tests/restart/restart_subapp_not_master/complete_solve_no_subapp.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./average]
    type = ElementAverageValue
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0.0
  end_time = 4.0
  dt = 1.0
[]

[Outputs]
  file_base = complete_solve_no_subapp
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="106115a7-7c4f-4f17-9f0b-95b63452c5df"><div class="modal-content"><h4>test/tests/postprocessors/num_vars/num_vars.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fnu]
    type = ParsedFunction
    value = -6*(x+y)+x*x+y*y
  [../]
  [./forcing_fnv]
    type = ParsedFunction
    value = -4+x*x*x-x+y*y*y-y
  [../]
  [./bc_fnut]
    type = ParsedFunction
    value = 3*y*y-1
  [../]
  [./bc_fnub]
    type = ParsedFunction
    value = -3*y*y+1
  [../]
  [./bc_fnul]
    type = ParsedFunction
    value = -3*x*x+1
  [../]
  [./bc_fnur]
    type = ParsedFunction
    value = 3*x*x-1
  [../]
  [./slnu]
    type = ParsedGradFunction
    value = x*x*x-x+y*y*y-y
    grad_x = 3*x*x-1
    grad_y = 3*y*y-1
  [../]
  [./slnv]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff1]
    type = Diffusion
    variable = u
  [../]
  [./diff2]
    type = Diffusion
    variable = v
  [../]
  [./forceu]
    type = BodyForce
    variable = u
    function = forcing_fnu
  [../]
  [./forcev]
    type = BodyForce
    variable = v
    function = forcing_fnv
  [../]
[]

[BCs]
  # active = &#x27;bc_u bc_v&#x27;
  # [./bc_u]
  # type = FunctionDirichletBC
  # variable = u
  # function = slnu
  # boundary = &#x27;top left right bottom&#x27;
  # [../]
  [./bc_ut]
    type = FunctionDirichletBC
    variable = u
    boundary = top
    function = bc_fnut
  [../]
  [./bc_ub]
    type = FunctionDirichletBC
    variable = u
    boundary = bottom
    function = bc_fnub
  [../]
  [./bc_ul]
    type = FunctionDirichletBC
    variable = u
    boundary = left
    function = bc_fnul
  [../]
  [./bc_ur]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = bc_fnur
  [../]
  [./bc_v]
    type = FunctionDirichletBC
    variable = v
    function = slnv
    boundary = &#x27;top left right bottom&#x27;
  [../]
[]

[Preconditioning]
  [./prec]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active = &#x27;num_vars&#x27;
  [./dofs]
    type = NumDOFs
  [../]
  [./h]
    type = AverageElementSize
  [../]
  [./L2u]
    type = ElementL2Error
    variable = u
    function = slnu
  [../]
  [./L2v]
    type = ElementL2Error
    variable = v
    function = slnv
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
  [./num_vars]
    type = NumVars
    system = &#x27;NL&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
  nl_rel_tol = 1e-15

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre    boomeramg&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="05d1efb6-0b57-41a1-8f02-90a3f0079e23"><div class="modal-content"><h4>test/tests/transfers/multiapp_userobject_transfer/tosub_displaced_sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 8
  xmax = 0.1
  ymax = 0.5
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./u]
    initial_condition = 1
  [../]
[]

[AuxVariables]
  [./multi_layered_average]
  [../]
  [./element_multi_layered_average]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./disp_x]
    initial_condition = 0.0
  [../]
  [./disp_y]
    initial_condition = 0.5
  [../]
[]

[Functions]
  [./axial_force]
    type = ParsedFunction
    value = 1000*y
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = axial_force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  dt = 0.001

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[Problem]
  coord_type = rz
  type = FEProblem
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="26ff0c18-8f2f-40ad-99ed-c3e319f899d1"><div class="modal-content"><h4>test/tests/variables/fe_hermite_convergence/hermite_converge_periodic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 4
  ny = 4
  elem_type = QUAD4
  # This test will not work in parallel with DistributedMesh enabled
  # due to a bug in PeriodicBCs.
  parallel_type = replicated
[]

[Functions]
  [./bc_fn]
    type = ParsedGradFunction
    value = -sin(pi*x)*sin(pi*y)
    grad_x = -pi*cos(pi*x)*sin(pi*y)
    grad_y = -pi*sin(pi*x)*cos(pi*y)
  [../]
  [./bc_fnt]
    type = ParsedFunction
    value = -pi*sin(pi*x)*cos(pi*y)
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = pi*sin(pi*x)*cos(pi*y)
  [../]
  [./forcing_fn]
    type = ParsedFunction
    value = -2*pi*pi*sin(pi*x)*sin(pi*y)-sin(pi*x)*sin(pi*y)
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./reaction]
    type = Reaction
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      variable = u
      auto_direction= &#x27;x y&#x27;
    [../]
  [../]
  [./bc_top]
    type=FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type=FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]
  [./h]
    type = AverageElementSize
  [../]
  [./L2error]
    type = ElementL2Error
    variable = u
    function = bc_fn
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = bc_fn
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = bc_fn
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;

  # We use higher-order quadrature to ensure that the forcing function
  # is integrated accurately.
  [./Quadrature]
    order=ELEVENTH
  [../]
[]

[Adaptivity]
  steps = 2
  marker = uniform
  [./Markers]
    [./uniform]
      type = UniformMarker
      mark = refine
    [../]
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
  print_mesh_changed_info = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b5b188c3-8f67-4381-9e63-65343a802da4"><div class="modal-content"><h4>modules/stochastic_tools/examples/surrogates/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 1
  elem_type = EDGE3
[]

[Variables]
  [T]
    order = SECOND
    family = LAGRANGE
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = T
    diffusivity = k
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[Materials]
  [conductivity]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 2.0
  []
[]

[BCs]
  [right]
    type = DirichletBC
    variable = T
    boundary = right
    value = 300
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [avg]
    type = AverageNodalVariableValue
    variable = T
  []
  [max]
    type = NodalExtremeValue
    variable = T
    value_type = max
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4baf5559-2dd8-46af-a413-92e103e2bfa3"><div class="modal-content"><h4>test/tests/mesh_modifiers/lower_d_block/lower_d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[MeshModifiers]
  [./lower]
    type = LowerDBlockFromSideset
    new_block_id = 10
    sidesets = &#x27;0 0 1 2 3&#x27;
  [../]
[]

[Variables]
  [./u]
    block = 0
  [../]
  [./v]
    block = 10
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
    block = 0
  [../]
  [./srcv]
    type = BodyForce
    block = 10
    variable = v
    function = 1
  [../]
  [./time_v]
    type = TimeDerivative
    block = 10
    variable = v
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 2
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8dae77c4-4dbe-40e0-b01b-8ed94037c00a"><div class="modal-content"><h4>test/tests/userobjects/interface_user_object/interface_userobject_material_value.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./primary0_interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = primary0_interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]


[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 2
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 4
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    function = 0.1*t
  [../]
[]

[InterfaceKernels]
  [./primary0_interface]
    type = PenaltyInterfaceDiffusionDot
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = TRUE
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  dt = 0.1
  num_steps = 3
  dtmin = 0.1
  line_search = none
[]

[Outputs]
  exodus = true
[]


[UserObjects]
  [./interface_material_uo]
    type = InterfaceUserObjectTestGetMaterialProperty
    property = &#x27;primary_prop&#x27;
    property_neighbor = &#x27;secondary_prop&#x27;
    property_boundary = &#x27;boundary_prop&#x27;
    property_interface = &#x27;interface_prop&#x27;
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
  [../]
[]

[Materials]
  [./mat_primary]
    type = LinearNonLinearIterationMaterial
    block = 0
    prefactor = 1
    prop_name = &#x27;primary_prop&#x27;
  [../]
  [./mat_secondary]
    type = LinearNonLinearIterationMaterial
    block = 1
    prefactor = 2
    prop_name = &#x27;secondary_prop&#x27;
  [../]
  [./mat_boundary]
    type = LinearNonLinearIterationMaterial
    prefactor = 3
    boundary = &#x27;primary0_interface&#x27;
    prop_name = &#x27;boundary_prop&#x27;
  [../]
  [./mat_interface]
    type = LinearNonLinearIterationInterfaceMaterial
    prefactor = 4
    boundary = &#x27;primary0_interface&#x27;
    prop_name = &#x27;interface_prop&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d9128350-72d1-4b80-82f5-dd20c7f3ce31"><div class="modal-content"><h4>test/tests/multiapps/restart_multilevel/master.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  ymin = 0
  xmax = 1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./ufn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = v_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
  checkpoint = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;sub.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ca41cec2-d2a6-4e23-b395-172463930f46"><div class="modal-content"><h4>test/tests/outputs/debug/show_var_residual_norms.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fnu]
    type = ParsedFunction
    value = -5.8*(x+y)+x*x*x-x+y*y*y-y
  [../]
  [./forcing_fnv]
    type = ParsedFunction
    value = -4
  [../]

  [./slnu]
    type = ParsedGradFunction
    value = x*x*x-x+y*y*y-y
    grad_x = 3*x*x-1
    grad_y = 3*y*y-1
  [../]
  [./slnv]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]

  #NeumannBC functions
  [./bc_fnut]
    type = ParsedFunction
    value = 3*y*y-1
  [../]
  [./bc_fnub]
    type = ParsedFunction
    value = -3*y*y+1
  [../]
  [./bc_fnul]
    type = ParsedFunction
    value = -3*x*x+1
  [../]
  [./bc_fnur]
    type = ParsedFunction
    value = 3*x*x-1
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff1 diff2 test1 forceu forcev react&#x27;
  [./diff1]
    type = Diffusion
    variable = u
  [../]
  [./test1]
    type = CoupledConvection
    variable = u
    velocity_vector = v
  [../]
  [./diff2]
    type = Diffusion
    variable = v
  [../]
  [./react]
    type = Reaction
    variable = u
  [../]

  [./forceu]
    type = BodyForce
    variable = u
    function = forcing_fnu
  [../]
  [./forcev]
    type = BodyForce
    variable = v
    function = forcing_fnv
  [../]

[]

[BCs]
  active = &#x27;bc_u_tb bc_v bc_ul bc_ur bc_ut bc_ub&#x27;
  [./bc_u]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_v]
    type = FunctionDirichletBC
    variable = v
    function = slnv
    boundary = &#x27;left right top bottom&#x27;
  [../]

  [./bc_u_lr]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_u_tb]
    type = CoupledKernelGradBC
    variable = u
    var2 = v
    vel = &#x27;0.1 0.1&#x27;
    boundary = &#x27;top bottom left right&#x27;
  [../]

  [./bc_ul]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnul
    boundary = &#x27;left&#x27;
  [../]
  [./bc_ur]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnur
    boundary = &#x27;right&#x27;
  [../]
  [./bc_ut]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnut
    boundary = &#x27;top&#x27;
  [../]
  [./bc_ub]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnub
    boundary = &#x27;bottom&#x27;
  [../]
[]

[Preconditioning]
  active = &#x27; &#x27;
  [./prec]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active=&#x27;L2u L2v&#x27;
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2u]
    type = ElementL2Error
    variable = u
    function = slnu
  [../]
  [./L2v]
    type = ElementL2Error
    variable = v
    function = slnv
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes&#x27;
  nl_rel_tol = 1e-15
  nl_abs_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  [./debug] # This is a test, use the [Debug] block to enable this
    type = VariableResidualNormsDebugOutput
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="56d262f1-58ba-4876-bfd6-e950bd37e488"><div class="modal-content"><h4>test/tests/adaptivity/initial_marker/initial_marker.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1

  solve_type = &#x27;PJFNK&#x27;

[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  initial_steps = 4
  initial_marker = initial_box
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = dont_mark
      type = BoxMarker
    [../]
    [./initial_box]
      type = BoxMarker
      bottom_left = &#x27;0.8 0.1 0&#x27;
      top_right = &#x27;0.9 0.2 0&#x27;
      inside = refine
      outside = dont_mark
    [../]
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1919fa76-4a43-4a3f-b460-6cd33e68532c"><div class="modal-content"><h4>test/tests/time_integrators/convergence/implicit_convergence.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim  = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx   = 4
  ny   = 4
  elem_type = QUAD9
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    preset = false
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  start_time = 0.0
  end_time = 1.0
  dt = 0.0625

 [./TimeIntegrator]
   type = ImplicitMidpoint
 [../]
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="07c1b8df-c0b2-4c81-a5bb-b86b01917a85"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_xy_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      xy
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with homogeneous material
#   properties. This problem can be exactly evaluated by FEM/Moose without the
#   moving interface. Both the temperature and level set function are designed
#   to be linear to attempt to minimize error between the Moose/exact solution
#   and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=0, y=0) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9998791
#      0.6                  520         519.9995307
#      0.8                  560         559.9989724
#      1.0                  600         599.9984541
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+200)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+100)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+100)*t+400&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 1.04 - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="629684f1-8ffb-40fb-aeff-32d54cc14343"><div class="modal-content"><h4>modules/functional_expansion_tools/test/tests/standard_use/interface_coupled.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 0.4
  nx = 6
  ymin = 0.0
  ymax = 10.0
  ny = 20
[]

[Variables]
  [./m]
  [../]
[]

[Kernels]
  [./diff_m]
    type = Diffusion
    variable = m
  [../]
  [./time_diff_m]
    type = TimeDerivative
    variable = m
  [../]
  [./source_m]
    type = BodyForce
    variable = m
    value = 100
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    value = 2
    variable = m
  [../]
[]

[BCs]
  [./interface_value]
    type = FXValueBC
    variable = m
    boundary = right
    function = FX_Basis_Value_Main
  [../]
  [./interface_flux]
    type = FXFluxBC
    boundary = right
    variable = m
    function = FX_Basis_Flux_Main
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;4&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
  [./FX_Basis_Flux_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;5&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
[]

[UserObjects]
  [./FX_Flux_UserObject_Main]
    type = FXBoundaryFluxUserObject
    function = FX_Basis_Flux_Main
    variable = m
    boundary = right
    diffusivity = 0.1
  [../]
[]

[Postprocessors]
  [./average_interface_value]
    type = SideAverageValue
    variable = m
    boundary = right
  [../]
  [./total_flux]
    type = SideFluxIntegral
    variable = m
    boundary = right
    diffusivity = 0.1
  [../]
  [./picard_iterations]
    type = NumPicardIterations
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1.0
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = interface_sub.i
    sub_cycling = true
  [../]
[]

[Transfers]
  [./FluxToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Flux_UserObject_Main
    multi_app_object_name = FX_Basis_Flux_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
  [./FluxToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Flux_Main
    multi_app_object_name = FX_Flux_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0b96f307-7292-47a1-a9e9-e5f129ba5dd5"><div class="modal-content"><h4>test/tests/multiapps/restart_subapp_ic/master.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  ymin = 0
  xmax = 1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./ufn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = v_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
  checkpoint = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;sub.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fd0e8208-e116-4621-9dea-6c5eb8479d09"><div class="modal-content"><h4>test/tests/mortar/continuity-2d-conforming/conforming-2nd-order.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [file]
    type = FileMeshGenerator
    file = 2blk-conf-2nd.e
  []
  [secondary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;101&#x27;
    new_block_id = &#x27;10001&#x27;
    new_block_name = &#x27;secondary_lower&#x27;
  []
  [primary]
    input = secondary
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;100&#x27;
    new_block_id = &#x27;10000&#x27;
    new_block_name = &#x27;primary_lower&#x27;
  []
[]

[Problem]
  kernel_coverage_check = false
[]

[Functions]
  [./exact_sln]
    type = ParsedFunction
    value = x*x+y*y
  [../]
  [./ffn]
    type = ParsedFunction
    value = -4
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]

  [./lm]
    order = SECOND
    family = LAGRANGE
    block = secondary_lower
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[Constraints]
  [./ced]
    type = EqualValueConstraint
    variable = lm
    secondary_variable = u
    primary_boundary = 100
    primary_subdomain = 10000
    secondary_boundary = 101
    secondary_subdomain = 10001
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1 2 3 4&#x27;
    function = exact_sln
  [../]
[]

[Postprocessors]
  [./l2_error]
    type = ElementL2Error
    variable = u
    function = exact_sln
    block = &#x27;1 2&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./fmp]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-14
  l_tol = 1e-14
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="97ab8eeb-d8df-437e-8c1b-d815e5f6e253"><div class="modal-content"><h4>test/tests/time_integrators/implicit-euler/ie.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of the TimeIntegrator system.
#
# Testing a solution that is second order in space
# and first order in time
#
# @Requirement F1.30
###########################################################

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))-(4*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  # Test of the TimeIntegrator System
  scheme = &#x27;implicit-euler&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.25
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c1cb0954-db08-4ef9-be52-136c8c90767d"><div class="modal-content"><h4>test/tests/auxkernels/constant_scalar_aux/constant_scalar_aux.i</h4><pre class="moose-pre"><code class="language-text">#
# Testing a solution that is second order in space and first order in time
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[AuxVariables]
  [./x]
    family = SCALAR
    order = FIRST
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[ICs]
  [./ic_x]
    type = ScalarConstantIC
    variable = x
    value = 11
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))-(4*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]
[]

[AuxScalarKernels]
  [./const_x]
    type = ConstantScalarAux
    variable = x
    value = 11
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./x]
    type = ScalarVariable
    variable = x
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.25

#  [./Adaptivity]
#    refine_fraction = 0.2
#    coarsen_fraction = 0.3
#    max_h_level = 4
#  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="528e22f2-e729-4cee-a390-89e8e052714a"><div class="modal-content"><h4>test/tests/interfacekernels/2d_interface/coupled_value_coupled_flux_with_jump_material.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
    input = gen
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
    jump_prop_name = jump
  [../]
[]

[Materials]
  [./jump]
    type = JumpInterfaceMaterial
    var = u
    neighbor_var = v
    boundary = primary0_interface
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9245df2b-885f-407d-9108-f02cd691eb26"><div class="modal-content"><h4>test/tests/kernels/vector_fe/coupled_scalar_default_vector_value.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = -1.1
  ymin = -1.1
  xmax = 1.1
  ymax = 1.1
[]

[Variables]
  [./v]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = v
  [../]
  [./source]
    type = BodyForce
    variable = v
  [../]
  [./advection]
    type = EFieldAdvection
    variable = v
    charge = &#x27;positive&#x27;
    mobility = 1
  [../]
[]

[BCs]
  [left]
    type = DirichletBC
    variable = v
    value = 0
    boundary = left
  []
  [right]
    type = DirichletBC
    variable = v
    value = 1
    boundary = right
  []
[]

[Preconditioning]
  [./pre]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;asm&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cc061018-6338-42fe-9ce0-e507e3004e6a"><div class="modal-content"><h4>test/tests/misc/save_in/dg_save_in_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 9
  ny = 9
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL

    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[AuxVariables]
  [./tot_resid]
    order = FIRST
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
    save_in = &#x27;tot_resid&#x27;
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = 1
    save_in = &#x27;tot_resid&#x27;
  [../]
[]

[DGKernels]
  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
    save_in = &#x27;tot_resid&#x27;
  [../]
[]

[BCs]
  [./robin]
    type = RobinBC
    boundary = &#x27;left right top bottom&#x27;
    variable = u
    save_in = &#x27;tot_resid&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="847c7fff-e813-4e5f-bbba-4cb9a8c23315"><div class="modal-content"><h4>test/tests/time_integrators/actually_explicit_euler_verification/ee-2d-quadratic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))-(4*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  l_tol = 1e-13
  start_time = 0.0
  num_steps = 20
  dt = 0.00005

  [./TimeIntegrator]
    type = ActuallyExplicitEuler
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="010b06bc-b2eb-47fc-bc53-6bb9ba11efaf"><div class="modal-content"><h4>test/tests/postprocessors/num_adaptivity_cycles/num_adaptivity_cycles_toggle_adaptivity.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1

  solve_type = &#x27;PJFNK&#x27;

[]

[Adaptivity]
  cycles_per_step = 1
  marker = box
  max_h_level = 2
  initial_steps = 4
  initial_marker = initial_box
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = dont_mark
      type = BoxMarker
    [../]
    [./initial_box]
      type = BoxMarker
      bottom_left = &#x27;0.8 0.1 0&#x27;
      top_right = &#x27;0.9 0.2 0&#x27;
      inside = refine
      outside = dont_mark
    [../]
  [../]
[]

[UserObjects]
  [./toggle_adaptivity]
    type = ToggleMeshAdaptivity
    mesh_adaptivity = &#x27;off&#x27;
  [../]
[]

[Postprocessors]
  [./adaptivity_cycles]
    type = NumAdaptivityCycles
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7bdd6048-1296-46fd-a7aa-979a0c1ee620"><div class="modal-content"><h4>test/tests/postprocessors/side_pps/side_pps_multi_bnd_test.i</h4><pre class="moose-pre"><code class="language-text">#
# Tests elemental PPS running on multiple blocks
#
[Mesh]
  type = StripeMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 3
  ny = 3
  elem_type = QUAD4
  stripes = 3
  # StripeMesh currently only works correctly with ReplicatedMesh.
  parallel_type = replicated
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = x*(y+1)
  [../]
[]

[Variables]
  [./u]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Kernels]
  [./uv]
    type = Reaction
    variable = u
  [../]

  [./fv]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[Postprocessors]
  [./int_0_1]
    type = SideIntegralVariablePostprocessor
    variable = u
    boundary = &#x27;0 1&#x27;
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="44d93675-250f-45ea-99b9-9af407a58caa"><div class="modal-content"><h4>python/peacock/tests/input_tab/InputTree/gold/transient.i</h4><pre class="moose-pre"><code class="language-text"># ##########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of a &quot;Transient&quot; Executioner.
#
# @Requirement F1.10
# ##########################################################
[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Variables]
  [u]
    order = FIRST
    family = LAGRANGE
    [InitialCondition]
      type = ConstantIC
      value = 0
    []
  []
[]

[Functions]
  [forcing_fn]
    # dudt = 3*t^2*(x^2 + y^2)
    type = ParsedFunction
    value = &#x27;3*t*t*((x*x)+(y*y))-(4*t*t*t)&#x27;
  []
  [exact_fn]
    type = ParsedFunction
    value = &#x27;t*t*t*((x*x)+(y*y))&#x27;
  []
[]

[Kernels]
  [ie]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  []
[]

[BCs]
  inactive = &#x27;left right&#x27;
  [all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  []
  [left]
    type = DirichletBC
    variable = u
    boundary = &#x27;3&#x27;
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    value = 1
  []
[]

[Postprocessors]
  [l2_err]
    type = ElementL2Error
    variable = &#x27;u&#x27;
    function = exact_fn
  []
  [dt]
    type = TimestepSize
  []
[]

[Executioner]
  # Preconditioned JFNK (default)
  type = Transient
  scheme = implicit-euler
  solve_type = PJFNK
  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_transient
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="36d2ca24-2d89-446a-aa01-6ef3858b256e"><div class="modal-content"><h4>test/tests/outputs/oversample/over_sampling_test_file.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = square_3x3.e
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;ie diff ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1 2 3 4&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./dt]
    type = TimestepSize
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.2
  start_time = 0
  num_steps = 5
[]

[Outputs]
  file_base = out_file
  exodus = true
  [./oversampling]
    file_base = out_file_oversample
    type = Exodus
    refinements = 3
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0af75b07-0118-41a3-aaa9-2bced103a60b"><div class="modal-content"><h4>test/tests/dgkernels/2d_diffusion_dg/no_functor_additions.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL
    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[AuxVariables]
  [v]
    order = FIRST
    family = MONOMIAL
  []
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]
  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))

  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./abs]          # u * v
    type = Reaction
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  [regular_dg_diffusion]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
  []
[]

[DGDiffusionAction]
  variable = u
  kernels_to_add = &#x27;COUPLED&#x27;
  coupled_var = v
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
  csv = true
[]

[Problem]
  error_on_jacobian_nonzero_reallocation = true
[]

[Postprocessors]
  [num_rm]
    type = NumRelationshipManagers
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2d7cd73a-ab0e-43c6-8786-d1a8c65ac3b4"><div class="modal-content"><h4>test/tests/misc/initial_solution_copy/solutions_equal.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./initial_func]
    type = ParsedFunction
    value = sin(pi*x)*sin(pi*y)
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
  [./source]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[BCs]
  active = &#x27;func_bc&#x27;
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./func_bc]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;bottom right top left&#x27;
    function = initial_func
  [../]
[]

[Postprocessors]
  [./test_pp]
    type = TestCopyInitialSolution
    execute_on = timestep_begin
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[ICs]
  [./initial]
    function = initial_func
    variable = u
    type = FunctionIC
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="24be86fc-196b-4fae-a126-ab069f2a00af"><div class="modal-content"><h4>modules/combined/test/tests/elastic_thermal_patch/elastic_thermal_patch_rz.i</h4><pre class="moose-pre"><code class="language-text">#
# This problem is modified from the Abaqus verification manual:
#   &quot;1.5.4 Patch test for axisymmetric elements&quot;
# The original stress solution is given as:
#   xx = yy = zz = 2000
#   xy = 400
#
# Here, E=1e6 and nu=0.25.
# However, with a +100 degree change in temperature and a coefficient
#   of thermal expansion of 1e-6, the solution becomes:
#   xx = yy = zz = 1800
#   xy = 400
#   since
#   E*(1-nu)/(1+nu)/(1-2*nu)*(1+2*nu/(1-nu))*(1e-3-1e-4) = 1800
#
# Also,
#
#   dSrr   dSrz   Srr-Stt
#   ---- + ---- + ------- + br = 0
#    dr     dz       r
#
# and
#
#   dSrz   Srz   dSzz
#   ---- + --- + ---- + bz = 0
#    dr     r     dz
#
# where
#   Srr = stress in rr
#   Szz = stress in zz
#   Stt = stress in theta-theta
#   Srz = stress in rz
#   br  = body force in r direction
#   bz  = body force in z direction
#
[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
  volumetric_locking_correction = true
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = elastic_thermal_patch_rz_test.e
[]

[Functions]
  [./ur]
    type = ParsedFunction
    value = &#x27;1e-3*x&#x27;
  [../]
  [./uz]
    type = ParsedFunction
    value = &#x27;1e-3*(x+y)&#x27;
  [../]
  [./body]
    type = ParsedFunction
    value = &#x27;-400/x&#x27;
  [../]
  [./temp]
    type = ParsedFunction
    value = &#x27;117.56+100*t&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]

  [./temp]
    initial_condition = 117.56
  [../]
[]

[Modules/TensorMechanics/Master/All]
  add_variables = true
  strain = SMALL
  incremental = true
  eigenstrain_names = eigenstrain
  generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
[]

[Kernels]
  [./body]
    type = BodyForce
    variable = disp_y
    value = 1
    function = body
  [../]

  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]

[BCs]
  [./ur]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 10
    function = ur
  [../]
  [./uz]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 10
    function = uz
  [../]

  [./temp]
    type = FunctionDirichletBC
    variable = temp
    boundary = 10
    function = temp
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    lambda = 400000.0
    poissons_ratio = 0.25
  [../]
  [./thermal_strain]
    type = ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-6
    stress_free_temperature = 117.56
    eigenstrain_name = eigenstrain
  [../]
  [./stress]
    type = ComputeStrainIncrementBasedStress
  [../]

  [./heat]
    type = HeatConductionMaterial
    specific_heat = 0.116
    thermal_conductivity = 4.85e-4
  [../]

  [./density]
    type = Density
    density = 0.283
    disp_r = disp_x
    disp_z = disp_y
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-11
  nl_rel_tol = 1e-12

  l_max_its = 20

  start_time = 0.0
  dt = 1.0
  num_steps = 1
  end_time = 1.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2c499340-a493-4699-bf3c-617d955ea269"><div class="modal-content"><h4>test/tests/restart/restart_transient_from_steady/steady_with_sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[AuxVariables]
  [Tf]
  []
[]

[Variables]
  [power_density]
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27;
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = power_density
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = power_density
    boundary = right
    value = 1e3
  []
[]

[Postprocessors]
  [pwr_avg]
    type = ElementAverageValue
    variable = power_density
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_avg]
    type = ElementAverageValue
    variable = Tf
    execute_on = &#x27;initial final&#x27;
  []
  [temp_max]
    type = ElementExtremeValue
    value_type = max
    variable = Tf
    execute_on = &#x27;initial final&#x27;
  []
  [temp_min]
    type = ElementExtremeValue
    value_type = min
    variable = Tf
    execute_on = &#x27;initial final&#x27;
  []
[]

[Executioner]
  type = Steady
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12

  picard_rel_tol = 1E-7
  picard_abs_tol = 1.0e-07
  picard_max_its = 12
[]

[MultiApps]
  [sub]
    type = FullSolveMultiApp
    app_type = MooseTestApp
    positions = &#x27;0 0 0&#x27;
    input_files  = steady_with_sub_sub.i
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Transfers]
  [p_to_sub]
    type = MultiAppMeshFunctionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
  [t_from_sub]
    type = MultiAppMeshFunctionTransfer
    direction = from_multiapp
    source_variable = temp
    variable = Tf
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
  checkpoint = true
  execute_on = &#x27;INITIAL TIMESTEP_END FINAL&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="44484c51-95b0-465f-9c75-76d55371aed9"><div class="modal-content"><h4>test/tests/ics/from_exodus_solution/nodal_part2.i</h4><pre class="moose-pre"><code class="language-text"># Use the exodus file for restarting the problem:
# - restart one variable
# - and have one extra variable with IC
#

[Mesh]
  file = out_nodal_part1.e
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4
  [../]
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    initial_from_file_var = u
    initial_from_file_timestep = 6
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = BoundingBoxIC
      x1 = 0.0
      x2 = 1.0
      y1 = 0.0
      y2 = 1.0
      inside = 3.0
      outside = 1.0
    [../]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    value = 0
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;1&#x27;
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out_nodal_var_restart
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="419c729a-9264-4732-bbbe-cafd56caf306"><div class="modal-content"><h4>test/tests/time_integrators/implicit-euler/ie_adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 4
  ny = 4
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.25

  [./Adaptivity]
    refine_fraction = 0.2
    coarsen_fraction = 0.3
    max_h_level = 4
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="540c4ce2-17c8-4acc-a079-65506ed766bb"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-1-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 1
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 1
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x+y
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x+y
    grad_x = 1
    grad_y = 1
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c55d3101-c0ce-411e-be32-868c7e02f5a4"><div class="modal-content"><h4>test/tests/misc/check_error/subdomain_restricted_kernel_mismatch.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = v
    block = 2
    value = 10
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes_mf_operator&#x27;
#  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
#  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f5a7f0b3-337a-4bf1-a62a-698da82985b3"><div class="modal-content"><h4>test/tests/indicators/laplacian_jump_indicator/biharmonic.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  # Parameters used by Functions.
  vars   = &#x27;c&#x27;
  vals   = &#x27;50&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -.5
  xmax = .5
  ymin = -.5
  ymax = .5
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  [./biharmonic]
    type = Biharmonic
    variable = u
  [../]
  [./body_force]
    type = BodyForce
    variable = u
    function = forcing_func
  [../]
[]

[BCs]
  active = &#x27;all_value all_flux&#x27;
  [./all_value]
    type = FunctionPenaltyDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = u_func
    penalty = 1e10
  [../]
  [./all_flux]
    type = FunctionPenaltyFluxBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = u_func
    penalty = 1e10
  [../]
  [./all_laplacian]
    type = BiharmonicLapBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    laplacian_function = lapu_func
  [../]
[]

[Adaptivity]
  [Indicators]
    [error]
      type = LaplacianJumpIndicator
      variable = u
      scale_by_flux_faces = true
    []
  []
[]

[Executioner]
  type = Steady

  # Note: the unusually tight tolerances here are due to the penalty
  # BCs (currently the only way of accurately Dirichlet boundary
  # conditions on Hermite elements in MOOSE).
  nl_rel_tol = 1.e-15
  l_tol = 1.e-15

  # We have exact Jacobians
  solve_type = &#x27;NEWTON&#x27;

  # Use 6x6 quadrature to ensure the forcing function is integrated
  # accurately.
  [./Quadrature]
    type = GAUSS
    order = ELEVENTH
  [../]
[]

[Functions]
  [./u_func]
    type   = ParsedGradFunction
    value  = &#x27;exp(-c*(x^2+y^2))&#x27;
    grad_x = &#x27;-2*c*exp(-c*(x^2+y^2))*x&#x27;
    grad_y = &#x27;-2*c*exp(-c*(x^2+y^2))*y&#x27;
  [../]
  [./lapu_func]
    type   = ParsedFunction
    value  = &#x27;4*c*(c*(x^2+y^2) - 1)*exp(-c*(x^2+y^2))&#x27;
  [../]
  [./forcing_func]
    type   = ParsedFunction
    value  = &#x27;16*c^2*(c^2*(x^2+y^2)^2 - 4*c*(x^2+y^2) + 2)*exp(-c*(x^2+y^2))&#x27;
  [../]
[]

[Postprocessors]
  [./l2_error]
    type = ElementL2Error
    variable = u
    function = u_func
  [../]
  [./h1_error]
    type = ElementH1Error
    variable = u
    function = u_func
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5332017e-3214-4dd6-8c26-a71a094c5e93"><div class="modal-content"><h4>test/tests/multiapps/restart/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 10
[]

[Functions]
  [./u_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = u_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="442b7afc-4304-444b-bd12-88c6daa3c6c9"><div class="modal-content"><h4>test/tests/problems/no_material_coverage_check/no_material_coverage_check.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Problem]
  material_coverage_check = false
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Materials]
  [./mat1]
    type = GenericConstantMaterial
    block = 1
    prop_names =  &#x27;diff1&#x27;
    prop_values = &#x27;1&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="211be852-0967-4f61-aa0c-0cbae2814545"><div class="modal-content"><h4>python/peacock/tests/common/transient_with_date.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of a &quot;Transient&quot; Executioner.
#
# @Requirement F1.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./dt]
    type = TimestepSize
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  # Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = with_date
  exodus = true
  [./with_date]
    type = Exodus
    file_base = with_date
    append_date = true
    append_date_format = &#x27;%Y-%m-%d&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3db46cda-d66d-4fbe-be08-65c4982c99ea"><div class="modal-content"><h4>test/tests/dampers/min_damping/min_nodal_damping.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./u_dt]
    type = TimeDerivative
    variable = u
  [../]
  [./u_source]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[BCs]
  [./u_left]
    type = DirichletBC
    boundary = left
    variable = u
    value = 0.0
  [../]
[]

[Dampers]
  [./limit]
    type = BoundingValueNodalDamper
    variable = u
    max_value = 1.5
    min_value = -1.5
    min_damping = 0.001
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 2
[]

[Postprocessors]
  [./u_avg]
    type = ElementAverageValue
    variable = u
  [../]
  [./dt]
    type = TimestepSize
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f96d815d-ae3a-4597-8c8f-accc6ca230df"><div class="modal-content"><h4>test/tests/dgkernels/advection_diffusion_mixed_bcs_test_resid_jac/dg_advection_diffusion_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  nx = 2
  dim = 1
[]

[Kernels]
  [./source]
    type = BodyForce
    variable = u
    function = &#x27;forcing_func&#x27;
  [../]
  [./convection]
    type = ConservativeAdvection
    variable = u
    velocity = &#x27;1 0 0&#x27;
  [../]
  [./diffusion]
    type = MatDiffusionTest
    variable = u
    prop_name = &#x27;k&#x27;
  [../]
[]

[DGKernels]
  [./convection]
    type = DGConvection
    variable = u
    velocity = &#x27;1 0 0&#x27;
  [../]
  [./diffusion]
    type = DGDiffusion
    variable = u
    diff = &#x27;k&#x27;
    sigma = 6
    epsilon = -1
  [../]
[]

[BCs]
  [./advection]
    type = OutflowBC
    boundary = &#x27;right&#x27;
    variable = u
    velocity = &#x27;1 0 0&#x27;
  [../]
  [./diffusion_left]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;left&#x27;
    variable = u
    sigma = 6
    epsilon = -1
    function = &#x27;boundary_left_func&#x27;
    diff = &#x27;k&#x27;
  [../]
[]

[Variables]
  [./u]
    family = MONOMIAL
    order = THIRD
  [../]
[]

[Materials]
  [./test]
    block = 0
    type = GenericFunctionMaterial
    prop_names = &#x27;k&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Functions]
  [./forcing_func]
    type = ParsedFunction
    value = &#x27;1&#x27;
  [../]
  [./boundary_left_func]
    type = ParsedFunction
    value = &#x27;0&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;1 + x&#x27;
  [../]
[]

[Outputs]
  exodus = true
  execute_on = &#x27;timestep_end&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3791d55c-39e8-46b6-9d3c-390c031fb1a8"><div class="modal-content"><h4>test/tests/postprocessors/mms_slope/mms_slope_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]

#  do not use uniform refine, we are using adaptive refining
#  uniform_refine = 6
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;forcing_func u_func&#x27;

  [./forcing_func]
    type = ParsedFunction
    value = alpha*alpha*pi*pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;4&#x27;
  [../]

  [./u_func]
    type = ParsedGradFunction
    value = sin(alpha*pi*x)
    grad_x   = alpha*pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;4&#x27;
  [../]
[]

[Kernels]
  active = &#x27;diff forcing&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_func
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;3&#x27;
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = Steady

  solve_type = NEWTON

  nl_abs_tol = 1e-14

  [./Adaptivity]
    # if the refine fraction is 1 it will refine every element
    # remember &lt; 1 means only refine that percentage of elements
    refine_fraction = 1

    steps = 6

    # do not coarsen at all
    coarsen_fraction = 0

    # maximum level of refinement steps, make sure this is &gt; max_r_steps
    max_h_level = 10

    # leave this as is
    error_estimator = KellyErrorEstimator
  [../]
[]

# print l2 and h1 errors from the Postprocessors too so I can compare
[Postprocessors]
  active = &#x27;l2_error h1_error dofs&#x27;
#  active = &#x27; &#x27;

  [./l2_error]
    type = ElementL2Error
    variable = u
    function = u_func
  [../]

  [./h1_error]
    type = ElementH1Error
    variable = u
    function = u_func
  [../]

  [./dofs]
    type = NumDOFs
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aa552e0f-7245-469b-a046-a6b8835680e9"><div class="modal-content"><h4>test/tests/multiapps/restart/master.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  ymin = 0
  xmax = 1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./ufn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = v_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
  checkpoint = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;sub.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="733885a0-8056-40e0-b3eb-4c08bb2d9d46"><div class="modal-content"><h4>test/tests/actions/meta_action_multiple_tasks/circle_quads.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = circle-quads.e
[]

[Functions]
  [./all_bc_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]

  [./analytical_normal_x]
    type = ParsedFunction
    value = x
  [../]
  [./analytical_normal_y]
    type = ParsedFunction
    value = y
  [../]
[]

# An Action that adds an Action that satisfies multiple tasks!
[MetaNodalNormals]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = &#x27;all_bc_fn&#x27;
  [../]
[]

[Postprocessors]
  [./nx_pps]
    type = NodalL2Error
    variable = nodal_normal_x
    boundary = &#x27;1&#x27;
    function = analytical_normal_x
  [../]
  [./ny_pps]
    type = NodalL2Error
    variable = nodal_normal_y
    boundary = &#x27;1&#x27;
    function = analytical_normal_y
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c49b0b85-b6dc-4a9e-b1fa-8b3f6a757c91"><div class="modal-content"><h4>test/tests/kernels/vector_fe/coupled_scalar_vector.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  xmin = -1
  ymin = -1
  elem_type = QUAD9
[]

[Variables]
  [./u]
    family = NEDELEC_ONE
    order = FIRST
  [../]
  [./v]
  [../]
[]

[Kernels]
  [./wave]
    type = VectorFEWave
    variable = u
    x_forcing_func = &#x27;x_ffn&#x27;
    y_forcing_func = &#x27;y_ffn&#x27;
  [../]
  [./diff]
    type = Diffusion
    variable = v
  [../]
  [./source]
    type = BodyForce
    variable = v
  [../]
  [./advection]
    type = EFieldAdvection
    variable = v
    efield = u
    charge = &#x27;positive&#x27;
    mobility = 100
  [../]
[]

[BCs]
  [./bnd]
    type = VectorCurlPenaltyDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e10
    function_x = &#x27;x_sln&#x27;
    function_y = &#x27;y_sln&#x27;
    variable = u
  [../]
  [./bnd_v]
    type = DirichletBC
    boundary = &#x27;left right top bottom&#x27;
    value = 0
    variable = v
  [../]
[]

[Functions]
  [./x_ffn]
    type = ParsedFunction
    value = &#x27;(2*pi*pi + 1)*cos(pi*x)*sin(pi*y)&#x27;
  [../]
  [./y_ffn]
    type = ParsedFunction
    value = &#x27;-(2*pi*pi + 1)*sin(pi*x)*cos(pi*y)&#x27;
  [../]
  [./x_sln]
    type = ParsedFunction
    value = &#x27;cos(pi*x)*sin(pi*y)&#x27;
  [../]
  [./y_sln]
    type = ParsedFunction
    value = &#x27;-sin(pi*x)*cos(pi*y)&#x27;
  [../]
[]

[Preconditioning]
  [./pre]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;asm&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="552deddd-deac-4557-9762-937e89e10d1a"><div class="modal-content"><h4>modules/stochastic_tools/examples/surrogates/pod_rb/2d_multireg/sub.i</h4><pre class="moose-pre"><code class="language-text">halfa = 10
fulla = 20

[Problem]
  type = FEProblem
  extra_tag_vectors  = &#x27;diff0 diff1 diff2 diff3 abs0 abs1 abs2 abs3 src0 src1 src2&#x27;
[]

[Mesh]
  [msh]
    type = CartesianMeshGenerator
    dim = 2
    dx = &#x27;10 20 20 20 20 20 20 20 20&#x27;
    dy = &#x27;10 20 20 20 20 20 20 20 20&#x27;
    ix = &#x27;${halfa} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla}&#x27;
    iy = &#x27;${halfa} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla}&#x27;
    subdomain_id = &#x27;1 0 0 0 1 0 0 2 3
                    0 0 0 0 0 0 0 2 3
                    0 0 1 0 0 0 2 2 3
                    0 0 0 0 0 0 2 3 3
                    1 0 0 0 1 2 2 3 3
                    0 0 0 0 2 2 3 3 3
                    0 0 2 2 2 3 3 3 3
                    2 2 2 3 3 3 3 3 3
                    3 3 3 3 3 3 3 3 3&#x27;
  []
[]

[Variables]
  [psi]
  []
[]

[Kernels]
  [diff0]
    type = MatDiffusion
    variable = psi
    diffusivity = D0
    extra_vector_tags = &#x27;diff0&#x27;
    block = 0
  []
  [diff1]
    type = MatDiffusion
    variable = psi
    diffusivity = D1
    extra_vector_tags = &#x27;diff1&#x27;
    block = 1
  []
  [diff2]
    type = MatDiffusion
    variable = psi
    diffusivity = D2
    extra_vector_tags = &#x27;diff2&#x27;
    block = 2
  []
  [diff3]
    type = MatDiffusion
    variable = psi
    diffusivity = D3
    extra_vector_tags = &#x27;diff3&#x27;
    block = 3
  []
  [abs0]
    type = MaterialReaction
    variable = psi
    coefficient = absxs0
    extra_vector_tags = &#x27;abs0&#x27;
    block = 0
  []
  [abs1]
    type = MaterialReaction
    variable = psi
    coefficient = absxs1
    extra_vector_tags = &#x27;abs1&#x27;
    block = 1
  []
  [abs2]
    type = MaterialReaction
    variable = psi
    coefficient = absxs2
    extra_vector_tags = &#x27;abs2&#x27;
    block = 2
  []
  [abs3]
    type = MaterialReaction
    variable = psi
    coefficient = absxs3
    extra_vector_tags = &#x27;abs3&#x27;
    block = 3
  []
  [src0]
    type = BodyForce
    variable = psi
    value = 1
    extra_vector_tags = &#x27;src0&#x27;
    block = 0
  []
  [src1]
    type = BodyForce
    variable = psi
    value = 1
    extra_vector_tags = &#x27;src1&#x27;
    block = 1
  []
  [src2]
    type = BodyForce
    variable = psi
    value = 1
    extra_vector_tags = &#x27;src2&#x27;
    block = 2
  []
[]

[Materials]
  [D0]
    type = GenericConstantMaterial
    prop_names = D0
    prop_values = 1
    block = 0
  []
  [D1]
    type = GenericConstantMaterial
    prop_names = D1
    prop_values = 1
    block = 1
  []
  [D2]
    type = GenericConstantMaterial
    prop_names = D2
    prop_values = 1
    block = 2
  []
  [D3]
    type = GenericConstantMaterial
    prop_names = D3
    prop_values = 1
    block = 3
  []
  [absxs0]
    type = GenericConstantMaterial
    prop_names = absxs0
    prop_values = 1
    block = 0
  []
  [absxs1]
    type = GenericConstantMaterial
    prop_names = absxs1
    prop_values = 1
    block = 1
  []
  [absxs2]
    type = GenericConstantMaterial
    prop_names = absxs2
    prop_values = 1
    block = 2
  []
  [absxs3]
    type = GenericConstantMaterial
    prop_names = absxs3
    prop_values = 1
    block = 3
  []
[]

[BCs]
  [left]
    type = NeumannBC
    variable = psi
    boundary = left
    value = 0
  []
  [bottom]
    type = NeumannBC
    variable = psi
    boundary = bottom
    value = 0
  []
  [top]
    type = DirichletBC
    variable = psi
    boundary = top
    value = 0
  []
  [right]
    type = DirichletBC
    variable = psi
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = linear
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Postprocessors]
  [nodal_l2]
    type = NodalL2Norm
    variable = psi
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0f1c9597-aec4-4592-8c97-45bac9ff113a"><div class="modal-content"><h4>test/tests/restart/restart_diffusion/restart_diffusion_test_transient.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = steady_out.e
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_from_file_var = u
    initial_from_file_timestep = 2
  [../]
[]

[Kernels]
  active = &#x27;bodyforce ie&#x27;

  [./bodyforce]
    type = BodyForce
    variable = u
    value = 10.0
  [../]

  [./ie]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 10
  dt = .1
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7620c4ca-ce3d-44bd-9d36-7d8bb2002a86"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/load_store/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = D
  []
  [absorption]
    type = MaterialReaction
    variable = u
    coefficient = sig
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
  []
[]

[Materials]
  [diffusivity]
    type = GenericConstantMaterial
    prop_names = D
    prop_values = 2.0
  []
  [xs]
    type = GenericConstantMaterial
    prop_names = sig
    prop_values = 2.0
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Postprocessors]
  [avg]
    type = AverageNodalVariableValue
    variable = u
  []
  [max]
    type = NodalExtremeValue
    variable = u
    value_type = max
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="55093b77-496e-476e-8b02-b3dec4d379ed"><div class="modal-content"><h4>test/tests/misc/line_source/line_source.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = line_source_cube.e
  dim = 2
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
    block = bulk
  [../]
  [./heating]
    type = BodyForce
    variable = u
    function = 1
    block = heater
  [../]
[]

[BCs]
  [./outside]
    type = DirichletBC
    variable = u
    boundary = outside
    value = 0
  [../]
[]

[Materials]
  [./diffusivity]
    type = GenericConstantMaterial
    block = &#x27;bulk heater&#x27;
    prop_names = diffusivity
    prop_values = 1
  [../]
[]

[Postprocessors]
  [./total_flux]
    type = SideFluxIntegral
    variable = u
    boundary = outside
    diffusivity = diffusivity
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="eefcca91-1db6-497d-8259-a9c2bd35ce86"><div class="modal-content"><h4>test/tests/executioners/solve_type_linear/linear_with_full_smp.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 5
[]

[Variables]
  [u]
  []
  [v]
  []
[]

[Kernels]
  [u_diffusion]
    type = Diffusion
    variable = u
  []
  [v_diffusion]
    type = Diffusion
    variable = v
  []

  [u_reaction]
    type = Reaction
    variable = u
  []
  [v_reaction]
    type = Reaction
    variable = v
  []

  [u_force]
    type = BodyForce
    variable = u
  []
  [v_force]
    type = CoupledForce
    variable = v
    v = u
  []
[]

[Executioner]
  type = Steady
  solve_type = LINEAR
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6b8dfa61-e733-4ced-8288-51dd5b8835b1"><div class="modal-content"><h4>modules/functional_expansion_tools/examples/2D_interface_different_submesh/main.i</h4><pre class="moose-pre"><code class="language-text"># Derived from the example &#x27;2D_interface&#x27; with the following differences:
#
#   1) The number of y divisions in the sub app is not the same as the master app
#   2) The subapp mesh is skewed in y
#   3) The Functional Expansion order for the flux term was increased to 7
[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 0.4
  nx = 6
  ymin = 0.0
  ymax = 10.0
  ny = 20
[]

[Variables]
  [./m]
  [../]
[]

[Kernels]
  [./diff_m]
    type = HeatConduction
    variable = m
  [../]
  [./time_diff_m]
    type = HeatConductionTimeDerivative
    variable = m
  [../]
  [./source_m]
    type = BodyForce
    variable = m
    value = 100
  [../]
[]

[Materials]
  [./Impervium]
    type = GenericConstantMaterial
    prop_names =  &#x27;thermal_conductivity specific_heat density&#x27;
    prop_values = &#x27;0.00001              50.0          100.0&#x27; # W/(cm K), J/(g K), g/cm^3
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    value = 2
    variable = m
  [../]
[]

[BCs]
  [./interface_value]
    type = FXValueBC
    variable = m
    boundary = right
    function = FX_Basis_Value_Main
  [../]
  [./interface_flux]
    type = FXFluxBC
    boundary = right
    variable = m
    function = FX_Basis_Flux_Main
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;4&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
  [./FX_Basis_Flux_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;7&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
[]

[UserObjects]
  [./FX_Flux_UserObject_Main]
    type = FXBoundaryFluxUserObject
    function = FX_Basis_Flux_Main
    variable = m
    boundary = right
    diffusivity = thermal_conductivity
  [../]
[]

[Postprocessors]
  [./average_interface_value]
    type = SideAverageValue
    variable = m
    boundary = right
  [../]
  [./total_flux]
    type = SideFluxIntegral
    variable = m
    boundary = right
    diffusivity = thermal_conductivity
  [../]
  [./picard_iterations]
    type = NumPicardIterations
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 1.0
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = sub.i
    sub_cycling = true
  [../]
[]

[Transfers]
  [./FluxToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Flux_UserObject_Main
    multi_app_object_name = FX_Basis_Flux_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
  [./FluxToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Flux_Main
    multi_app_object_name = FX_Flux_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="97eda157-f41b-4264-bb98-d30761b4d57e"><div class="modal-content"><h4>test/tests/mesh/named_entities/named_entities_test_xda.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = named_entities.xda
  uniform_refine = 1
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 center_block 3&#x27;

    [./InitialCondition]
      type = ConstantIC
      value = 20
      block = &#x27;center_block 3&#x27;
    [../]
  [../]
[]

[AuxVariables]
  [./reporter]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;left_block 3&#x27;
  [../]
[]

[ICs]
  [./reporter_ic]
    type = ConstantIC
    variable = reporter
    value = 10
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
    # Note we are using both names and numbers here
    block = &#x27;left_block 2 right_block&#x27;
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = &#x27;center_block&#x27;
    value = 10
  [../]
[]

[AuxKernels]
  [./hardness]
    type = MaterialRealAux
    variable = reporter
    property = &#x27;hardness&#x27;
    block = &#x27;left_block 3&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left_side&#x27;
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = &#x27;right_side&#x27;
    value = 1
  [../]
[]

[Postprocessors]
  [./elem_average]
    type = ElementAverageValue
    variable = u
    block = &#x27;center_block&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./side_average]
    type = SideAverageValue
    variable = u
    boundary = &#x27;right_side&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Materials]
  [./constant]
    type = GenericConstantMaterial
    prop_names = &#x27;hardness&#x27;
    prop_values = 10
    block = &#x27;1 right_block&#x27;
  [../]

  [./empty]
    type = MTMaterial
    block = &#x27;center_block&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3a10296d-c7ab-4c9d-89e7-28ef64684ec0"><div class="modal-content"><h4>modules/ray_tracing/test/tests/coord_type/rspherical_line_integral.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 5
  []
[]

[Variables/u]
[]

[BCs]
  [fixed]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Kernels]
  [diffusion]
    type = Diffusion
    variable = u
  []
  [source]
    type = BodyForce
    variable = u
    value = 10
  []
[]

[UserObjects]
  [study]
    type = RepeatableRayStudy
    names = &#x27;ray0&#x27;
    start_points = &#x27;0 0 0&#x27;
    end_points = &#x27;1 0 0&#x27;
  []
[]

[RayKernels]
  [variable_integral]
    type = VariableIntegralRayKernel
    study = study
    variable = u
    rays = &#x27;ray0&#x27;
  []
[]

[Postprocessors]
  [value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = ray0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Problem]
  coord_type = RSPHERICAL
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="293c6d8d-a5d1-4fe3-8e17-0a1f81ee10cf"><div class="modal-content"><h4>python/mms/test/mms_temporal.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 8
  ny = 8
[]

[Variables]
  [u][]
[]

[Kernels]
  [time]
    type = ADTimeDerivative
    variable = u
  []
  [diff]
    type = ADDiffusion
    variable = u
  []
  [force]
    type = BodyForce
    variable = u
    function = force
  []
[]

[Functions]
  [exact]
    type = ParsedFunction
    value = &#x27;t^3*x*y&#x27;
  []
  [force]
    type = ParsedFunction
    value = &#x27;3*x*y*t^2&#x27;
  []
[]

[BCs]
  [all]
    type = FunctionDirichletBC
    variable = u
    function = exact
    boundary = &#x27;left right top bottom&#x27;
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    function = exact
    variable = u
  []
  [h]
    type = AverageElementSize
  []
[]

[Executioner]
  type = Transient
  dt = 1
  end_time = 3
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="75cad589-2e5c-49bc-ab06-101521297ecf"><div class="modal-content"><h4>test/tests/transfers/multiapp_conservative_transfer/master_nearest_point.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmax = 1
    ymax = 1
    nx = 10
    ny = 10
  []
  [block1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    block_id = 1
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
  []
[]

[Variables]
  [power_density]
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27;
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = power_density
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = power_density
    boundary = right
    value = 1e3
  []
[]

[AuxVariables]
  [from_sub]
  []
[]

[VectorPostprocessors]
  [from_nearest_point]
    type = NearestPointIntegralVariablePostprocessor
    variable = power_density
    points = &#x27;0 0.5 0 1 0.5 0&#x27;
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []

  [to_nearest_point]
    type = NearestPointIntegralVariablePostprocessor
    variable = from_sub
    points = &#x27;0 0.5 0 1 0.5 0&#x27;
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[MultiApps]
  [sub]
    type = FullSolveMultiApp
    input_files = sub_nearest_point.i
    positions = &#x27;0 0 0 0.5 0 0&#x27;
    execute_on = timestep_end
  []
[]

[Transfers]
  [to_sub]
    type = MultiAppMeshFunctionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = from_master
    multi_app = sub
    execute_on = timestep_end

    # The following inputs specify what postprocessors should be conserved
    # 1 NearestPointIntegralVariablePostprocessor is specified on the master
    # side with N points, where N is the number of subapps
    # 1 pp is specified on the subapp side
    from_postprocessors_to_be_preserved = &#x27;from_nearest_point&#x27;
    to_postprocessors_to_be_preserved = &#x27;from_master_pp&#x27;
  []

  [from_sub]
    type = MultiAppMeshFunctionTransfer
    direction = from_multiapp
    source_variable = sink
    variable = from_sub
    multi_app = sub
    execute_on = timestep_end

    # The following inputs specify what postprocessors should be conserved
    # 1 NearestPointIntegralVariablePostprocessor is specified on the master
    # with N points, where N is the number of subapps
    # 1 pp is specified on the subapp side
    to_postprocessors_to_be_preserved = &#x27;to_nearest_point&#x27;
    from_postprocessors_to_be_preserved = &#x27;sink&#x27;
  []
[]

[Outputs]
  csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9004d1a1-bf20-4edb-a4d5-60beeaed3d98"><div class="modal-content"><h4>test/tests/time_integrators/multi_stage_time_integrator/unconverged_1st_stage.i</h4><pre class="moose-pre"><code class="language-text"># This test is designed to check that a time step solve should stop if *any*
# time integrator solve stage fails, not just the *last* stage. If a time
# integrator does not check convergence per stage, then a time step proceeds
# past intermediate stages without checking nonlinear convergence. This test
# is designed to check that the 2nd stage is never even entered by making it
# impossible for the first stage to converge.

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./time]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[ICs]
  [./u_ic]
    type = FunctionIC
    variable = u
    function = ic
  [../]
[]

[BCs]
  [./bcs]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  [./TimeIntegrator]
    type = LStableDirk2
  [../]
  num_steps = 1
  abort_on_solve_fail = true

  solve_type = NEWTON
  nl_max_its = 0
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bbe9d707-bf3e-4e65-a5ab-27c32e29fef2"><div class="modal-content"><h4>test/tests/ics/from_exodus_solution/nodal_part1.i</h4><pre class="moose-pre"><code class="language-text"># We run a simple problem (5 time steps and save off the solution)
# In part2, we load the solution and solve a steady problem. The test check, that the initial state in part 2 is the same as the last state from part1

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 20
  ny = 20
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;ie diff ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.2
  start_time = 0
  num_steps = 5
[]

[Outputs]
  file_base = out_nodal_part1
  exodus = true
  xda = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c477ed0e-072b-4c9b-a1aa-0b1886960dda"><div class="modal-content"><h4>modules/combined/examples/publications/rapid_dev/fig6.i</h4><pre class="moose-pre"><code class="language-text">#
# Fig. 6 input for 10.1016/j.commatsci.2017.02.017
# D. Schwen et al./Computational Materials Science 132 (2017) 36-45
# Three phase interface simulation demonstrating the interfacial stability
# w.r.t. formation of a tspurious third phase
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 120
  ny = 120
  nz = 0
  xmin = 0
  xmax = 40
  ymin = 0
  ymax = 40
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  # concentration
  [./c]
  [../]

  # order parameter 1
  [./eta1]
  [../]

  # order parameter 2
  [./eta2]
  [../]

  # order parameter 3
  [./eta3]
  [../]

  # phase concentration 1
  [./c1]
    initial_condition = 0.4
  [../]

  # phase concentration 2
  [./c2]
    initial_condition = 0.5
  [../]

  # phase concentration 3
  [./c3]
    initial_condition = 0.8
  [../]

  # Lagrange multiplier
  [./lambda]
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./T]
    [./InitialCondition]
      type = FunctionIC
      function = &#x27;x-10&#x27;
    [../]
  [../]
[]


[Functions]
  [./ic_func_eta1]
    type = ParsedFunction
    value = &#x27;0.5*(1.0+tanh((x-10)/sqrt(2.0))) * 0.5*(1.0+tanh((y-10)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_eta2]
    type = ParsedFunction
    value = &#x27;0.5*(1.0-tanh((x-10)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_eta3]
    type = ParsedFunction
    value = &#x27;1 - 0.5*(1.0-tanh((x-10)/sqrt(2.0)))
              - 0.5*(1.0+tanh((x-10)/sqrt(2.0))) * 0.5*(1.0+tanh((y-10)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_c]
    type = ParsedFunction
    value = &#x27;0.5 * 0.5*(1.0-tanh((x-10)/sqrt(2.0)))
              + 0.4 * 0.5*(1.0+tanh((x-10)/sqrt(2.0))) * 0.5*(1.0+tanh((y-10)/sqrt(2.0)))
              + 0.8 * (1 - 0.5*(1.0-tanh((x-10)/sqrt(2.0)))
                        - 0.5*(1.0+tanh((x-10)/sqrt(2.0))) * 0.5*(1.0+tanh((y-10)/sqrt(2.0))))&#x27;
  [../]
[]

[ICs]
  [./eta1]
    variable = eta1
    type = FunctionIC
    function = ic_func_eta1
  [../]
  [./eta2]
    variable = eta2
    type = FunctionIC
    function = ic_func_eta2
  [../]
  [./eta3]
    variable = eta3
    type = FunctionIC
    function = ic_func_eta3
  [../]
  [./c]
    variable = c
    type = FunctionIC
    function = ic_func_c
  [../]
[]

[Materials]
  # simple toy free energies
  [./f1]
    type = DerivativeParsedMaterial
    f_name = F1
    args = &#x27;c1&#x27;
    function = &#x27;20*(c1-0.4)^2&#x27;
  [../]
  [./f2]
    type = DerivativeParsedMaterial
    f_name = F2
    args = &#x27;c2 T&#x27;
    function = &#x27;20*(c2-0.5)^2 + 0.01*T&#x27;
  [../]
  [./f3]
    type = DerivativeParsedMaterial
    f_name = F3
    args = &#x27;c3&#x27;
    function = &#x27;20*(c3-0.8)^2&#x27;
  [../]

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [./h1]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta1
    eta_j = eta2
    eta_k = eta3
    f_name = h1
  [../]
  # h2(eta1, eta2, eta3)
  [./h2]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta2
    eta_j = eta3
    eta_k = eta1
    f_name = h2
  [../]
  # h3(eta1, eta2, eta3)
  [./h3]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta3
    eta_j = eta1
    eta_k = eta2
    f_name = h3
  [../]

  # Coefficients for diffusion equation
  [./Dh1]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h1&#x27;
    function = D*h1
    f_name = Dh1
  [../]
  [./Dh2]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h2&#x27;
    function = D*h2
    f_name = Dh2
  [../]
  [./Dh3]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h3&#x27;
    function = D*h3
    f_name = Dh3
  [../]

  # Barrier functions for each phase
  [./g1]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta1
    function_name = g1
  [../]
  [./g2]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta2
    function_name = g2
  [../]
  [./g3]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta3
    function_name = g3
  [../]

  # constant properties
  [./constants]
    type = GenericConstantMaterial
    prop_names  = &#x27;L   kappa  D&#x27;
    prop_values = &#x27;1.0 1.0    1&#x27;
  [../]
[]

[Kernels]
  #Kernels for diffusion equation
  [./diff_time]
    type = TimeDerivative
    variable = c
  [../]
  [./diff_c1]
    type = MatDiffusion
    variable = c
    diffusivity = Dh1
    v = c1
  [../]
  [./diff_c2]
    type = MatDiffusion
    variable = c
    diffusivity = Dh2
    v = c2
  [../]
  [./diff_c3]
    type = MatDiffusion
    variable = c
    diffusivity = Dh3
    v = c3
  [../]

  # Kernels for Allen-Cahn equation for eta1
  [./deta1dt]
    type = TimeDerivative
    variable = eta1
  [../]
  [./ACBulkF1]
    type = KKSMultiACBulkF
    variable  = eta1
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g1
    eta_i     = eta1
    wi        = 1.0
    args      = &#x27;c1 c2 c3 eta2 eta3&#x27;
  [../]
  [./ACBulkC1]
    type = KKSMultiACBulkC
    variable  = eta1
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta1
    args      = &#x27;eta2 eta3&#x27;
  [../]
  [./ACInterface1]
    type = ACInterface
    variable = eta1
    kappa_name = kappa
  [../]
  [./multipler1]
    type = MatReaction
    variable = eta1
    v = lambda
    mob_name = L
  [../]

  # Kernels for Allen-Cahn equation for eta2
  [./deta2dt]
    type = TimeDerivative
    variable = eta2
  [../]
  [./ACBulkF2]
    type = KKSMultiACBulkF
    variable  = eta2
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g2
    eta_i     = eta2
    wi        = 1.0
    args      = &#x27;c1 c2 c3 eta1 eta3&#x27;
  [../]
  [./ACBulkC2]
    type = KKSMultiACBulkC
    variable  = eta2
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta2
    args      = &#x27;eta1 eta3&#x27;
  [../]
  [./ACInterface2]
    type = ACInterface
    variable = eta2
    kappa_name = kappa
  [../]
  [./multipler2]
    type = MatReaction
    variable = eta2
    v = lambda
    mob_name = L
  [../]

  # Kernels for the Lagrange multiplier equation
  [./mult_lambda]
    type = MatReaction
    variable = lambda
    mob_name = 3
  [../]
  [./mult_ACBulkF_1]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g1
    eta_i     = eta1
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta2 eta3&#x27;
  [../]
  [./mult_ACBulkC_1]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta1
    args      = &#x27;eta2 eta3&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_1]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta1
    kappa_name = kappa
    mob_name = 1
  [../]
  [./mult_ACBulkF_2]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g2
    eta_i     = eta2
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta1 eta3&#x27;
  [../]
  [./mult_ACBulkC_2]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta2
    args      = &#x27;eta1 eta3&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_2]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta2
    kappa_name = kappa
    mob_name = 1
  [../]
  [./mult_ACBulkF_3]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g3
    eta_i     = eta3
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta1 eta2&#x27;
  [../]
  [./mult_ACBulkC_3]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta3
    args      = &#x27;eta1 eta2&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_3]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta3
    kappa_name = kappa
    mob_name = 1
  [../]

  # Kernels for constraint equation eta1 + eta2 + eta3 = 1
  # eta3 is the nonlinear variable for the constraint equation
  [./eta3reaction]
    type = MatReaction
    variable = eta3
    mob_name = 1
  [../]
  [./eta1reaction]
    type = MatReaction
    variable = eta3
    v = eta1
    mob_name = 1
  [../]
  [./eta2reaction]
    type = MatReaction
    variable = eta3
    v = eta2
    mob_name = 1
  [../]
  [./one]
    type = BodyForce
    variable = eta3
    value = -1.0
  [../]

  # Phase concentration constraints
  [./chempot12]
    type = KKSPhaseChemicalPotential
    variable = c1
    cb       = c2
    fa_name  = F1
    fb_name  = F2
  [../]
  [./chempot23]
    type = KKSPhaseChemicalPotential
    variable = c2
    cb       = c3
    fa_name  = F2
    fb_name  = F3
  [../]
  [./phaseconcentration]
    type = KKSMultiPhaseConcentration
    variable = c3
    cj = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    etas = &#x27;eta1 eta2 eta3&#x27;
    c = c
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;
  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-11

  num_steps = 1000
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.2
    optimal_iterations = 10
    iteration_window = 2
  [../]
[]

[Preconditioning]
  active = &#x27;full&#x27;
  [./full]
    type = SMP
    full = true
  [../]
  [./mydebug]
    type = FDP
    full = true
  [../]
[]

[Outputs]
  exodus = true
  checkpoint = true
  print_linear_residuals = false
  [./csv]
    type = CSV
    execute_on = &#x27;final&#x27;
  [../]
[]

#[VectorPostprocessors]
#  [./c]
#    type =  LineValueSampler
#    start_point = &#x27;-25 0 0&#x27;
#    end_point = &#x27;25 0 0&#x27;
#    variable = c
#    num_points = 151
#    sort_by =  id
#    execute_on = timestep_end
#  [../]
#  [./eta1]
#    type =  LineValueSampler
#    start_point = &#x27;-25 0 0&#x27;
#    end_point = &#x27;25 0 0&#x27;
#    variable = eta1
#    num_points = 151
#    sort_by =  id
#    execute_on = timestep_end
#  [../]
#  [./eta2]
#    type =  LineValueSampler
#    start_point = &#x27;-25 0 0&#x27;
#    end_point = &#x27;25 0 0&#x27;
#    variable = eta2
#    num_points = 151
#    sort_by =  id
#    execute_on = timestep_end
#  [../]
#  [./eta3]
#    type =  LineValueSampler
#    start_point = &#x27;-25 0 0&#x27;
#    end_point = &#x27;25 0 0&#x27;
#    variable = eta3
#    num_points = 151
#    sort_by =  id
#    execute_on = timestep_end
#  [../]
#[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="deea3d80-885f-40bf-a7ee-eac6c624d423"><div class="modal-content"><h4>test/tests/meshgenerators/lower_d_block_generator/ids.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 10
    ny = 10
  []

  [./lower_d_block]
    type = LowerDBlockFromSidesetGenerator
    input = gmg
    new_block_id = 10
    sidesets = &#x27;0 0 1 2 3&#x27;
  []
[]

[Variables]
  [./u]
    block = 0
  [../]
  [./v]
    block = 10
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
    block = 0
  [../]
  [./srcv]
    type = BodyForce
    block = 10
    variable = v
    function = 1
  [../]
  [./time_v]
    type = TimeDerivative
    block = 10
    variable = v
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 2
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="41788fdd-427b-44ee-b88d-0d273fa7dddc"><div class="modal-content"><h4>test/tests/functions/pps_function/pp_function.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./function_force]
    function = pp_func
    variable = u
    type = BodyForce
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]

[Functions]
  [./pp_func]
    pp = right_value
    type = PostprocessorFunction
  [../]
[]

[Postprocessors]
  [./right_value]
    variable = u
    execute_on = linear
    boundary = 1
    type = SideAverageValue
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bd827111-26dc-42c5-ae79-4b1436361713"><div class="modal-content"><h4>test/tests/interfacekernels/ik_displaced/displaced.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  displacements = &#x27;disp_x disp_y&#x27;
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[AuxVariables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = InterfacialSource
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  file_base = displaced
  exodus = true
[]

[Functions]
  [./disp_x_func]
    type = ParsedFunction
    value = x
  [../]
  [./disp_y_func]
    type = ParsedFunction
    value = y
  [../]
[]

[ICs]
  [./disp_x_ic]
    function = disp_x_func
    variable = disp_x
    type = FunctionIC
  [../]
  [./disp_y_ic]
    function = disp_y_func
    variable = disp_y
    type = FunctionIC
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f89b0290-140e-4d8f-ade3-30357787a6b8"><div class="modal-content"><h4>test/tests/auxkernels/time_integration/time_integration.i</h4><pre class="moose-pre"><code class="language-text"># This test covers the usage of the VariableTimeIntegrationAux
# kernel. Here we test three different schemes for integrating a field
# variable in time.  Midpoint, Trapezoidal, and Simpson&#x27;s rule are
# used.  For this test, we use a manufactured solution and we compare
# the Trapezoidal and Simpson&#x27;s rule, which must be exact for this
# exact solution, which is a linear function of time.
#
# The set up problem is
#
#  du/dt - Laplacian(u) = Q
#
# with exact solution: u = t*(x*x+y*y).
[Mesh]
  type = GeneratedMesh
  dim = 2
  elem_type = QUAD9
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./dts]
    type = PiecewiseLinear
    x = &#x27;0.01 0.1&#x27;
    y = &#x27;0.005 0.05&#x27;
  [../]
[]

[Variables]
  [./u]
    initial_condition = 0.0
    family = LAGRANGE
    order = SECOND
  [../]
[]

[Kernels]
  active = &#x27;diff timederivative sourceterm&#x27;
  [./diff]
     type = Diffusion
     variable = u
  [../]
  [./timederivative]
     type = TimeDerivative
     variable = u
  [../]
  [./sourceterm]
     type = BodyForce
     variable = u
     function = Source
  [../]
[]

[AuxVariables]
  active = &#x27;v_midpoint v_trapazoid v_simpson&#x27;
  [./v_midpoint]
  [../]
  [./v_trapazoid]
  [../]
  [./v_simpson]
  [../]
[]

[AuxKernels]
  [./MidpointTimeIntegrator]
    type = VariableTimeIntegrationAux
    variable_to_integrate = u
    variable = v_midpoint
    order = 1
  [../]
  [./TrapazoidalTimeIntegrator]
    type = VariableTimeIntegrationAux
    variable_to_integrate = u
    variable = v_trapazoid
    order = 2
  [../]
  [./SimpsonsTimeIntegrator]
    type = VariableTimeIntegrationAux
    variable_to_integrate = u
    variable = v_simpson
    order = 3
  [../]
[]

[BCs]
  active = &#x27;RightBC LeftBC TopBC BottomBC&#x27;
 [./RightBC]
    type = FunctionDirichletBC
    variable = u
    function = RightBC
    boundary = &#x27;right&#x27;
 [../]
 [./LeftBC]
    type = FunctionDirichletBC
    variable = u
    function = LeftBC
    boundary = &#x27;left&#x27;
 [../]
 [./TopBC]
    type = FunctionDirichletBC
    variable = u
    function = TopBC
    boundary = &#x27;top&#x27;
 [../]
 [./BottomBC]
    type = FunctionDirichletBC
    variable = u
    function = BottomBC
    boundary = &#x27;bottom&#x27;
 [../]
[]

[Functions]
  active = &#x27;Soln Source TopBC BottomBC RightBC LeftBC&#x27;
 [./Soln]
    type = ParsedFunction
    value = &#x27;t*(x*x+y*y)&#x27;
 [../]
 [./Source]
    type = ParsedFunction
    value = &#x27;(x*x + y*y) - 4*t&#x27;
 [../]
 [./TopBC]
    type = ParsedFunction
    value = &#x27;t*(x*x+1)&#x27;
 [../]
 [./BottomBC]
    type = ParsedFunction
    value = &#x27;t*x*x&#x27;
 [../]
 [./RightBC]
   type = ParsedFunction
   value = &#x27;t*(y*y+1)&#x27;
 [../]
 [./LeftBC]
    type = ParsedFunction
    value = &#x27;t*y*y&#x27;
  [../]
[]
[Postprocessors]
  [./l2_error]
    type = NodalL2Error
    variable = u
    function = Soln
  [../]
[]

[Executioner]
  type = Transient

  end_time = 0.1
#  dt = 0.1
#  num_steps = 10
  [./TimeStepper]
     type = FunctionDT
     function = dts
  [../]

  nl_abs_tol = 1.e-15
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fd29d25e-c6cd-4d84-a121-2d047ae58c46"><div class="modal-content"><h4>test/tests/mesh/named_entities/named_entities_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = named_entities.e
  uniform_refine = 1
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 center_block 3&#x27;

    [./InitialCondition]
      type = ConstantIC
      value = 20
      block = &#x27;center_block 3&#x27;
    [../]
  [../]
[]

[AuxVariables]
  [./reporter]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;left_block 3&#x27;
  [../]
[]

[ICs]
  [./reporter_ic]
    type = ConstantIC
    variable = reporter
    value = 10
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
    # Note we are using both names and numbers here
    block = &#x27;left_block 2 right_block&#x27;
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = &#x27;center_block&#x27;
    value = 10
  [../]
[]

[AuxKernels]
  [./hardness]
    type = MaterialRealAux
    variable = reporter
    property = &#x27;hardness&#x27;
    block = &#x27;left_block 3&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left_side&#x27;
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = &#x27;right_side&#x27;
    value = 1
  [../]
[]

[Postprocessors]
  [./elem_average]
    type = ElementAverageValue
    variable = u
    block = &#x27;center_block&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./side_average]
    type = SideAverageValue
    variable = u
    boundary = &#x27;right_side&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Materials]
  [./constant]
    type = GenericConstantMaterial
    prop_names = &#x27;hardness&#x27;
    prop_values = 10
    block = &#x27;1 right_block&#x27;
  [../]

  [./empty]
    type = MTMaterial
    block = &#x27;center_block&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e6e8625f-c728-4acc-9c81-7a757150d895"><div class="modal-content"><h4>modules/combined/test/tests/poro_mechanics/pp_generation_unconfined.i</h4><pre class="moose-pre"><code class="language-text"># A sample is constrained on all sides, except its top
# and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie m^3/second per cubic meter), and the
# rise in the top surface, porepressure, and stress are observed.
#
# Source = s  (units = 1/second)
#
# Expect:
# strain_zz = disp_z = BiotCoefficient*BiotModulus*s*t/((bulk + 4*shear/3) + BiotCoefficient^2*BiotModulus)
# porepressure = BiotModulus*(s*t - BiotCoefficient*strain_zz)
# stress_xx = (bulk - 2*shear/3)*strain_zz   (remember this is effective stress)
# stress_xx = (bulk + 4*shear/3)*strain_zz   (remember this is effective stress)
#
# Parameters:
# Biot coefficient = 0.3
# Porosity = 0.1
# Bulk modulus = 2
# Shear modulus = 1.5
# fluid bulk modulus = 1/0.3 = 3.333333
# 1/Biot modulus = (1 - 0.3)*(0.3 - 0.1)/2 + 0.1*0.3 = 0.1. BiotModulus = 10
#
# s = 0.1
#
# Expect
# disp_z = 0.3*10*s*t/((2 + 4*1.5/3) + 0.3^2*10) = 0.612245*s*t
# porepressure = 10*(s*t - 0.3*0.612245*s*t) = 8.163265*s*t
# stress_xx = (2 - 2*1.5/3)*0.612245*s*t = 0.612245*s*t
# stress_zz = (2 + 4*shear/3)*0.612245*s*t = 2.44898*s*t


[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  [../]
[]


[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PoroMechanicsCoupling
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PoroMechanicsCoupling
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PoroMechanicsCoupling
    variable = disp_z
    component = 2
  [../]
  [./poro_timederiv]
    type = PoroFullSatTimeDerivative
    variable = porepressure
  [../]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]



[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./poro_material]
    type = PoroFullSatMaterial
    porosity0 = 0.1
    biot_coefficient = 0.3
    solid_bulk_compliance = 0.5
    fluid_bulk_compliance = 0.3
    constant_porosity = true
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]

[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_unconfined
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="54f69e4f-a3eb-462a-a408-0562ba0c4af9"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined_fully_saturated.i</h4><pre class="moose-pre"><code class="language-text"># A sample is constrained on all sides, except its top
# and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie kg/second per cubic meter), and the
# rise in the top surface, porepressure, and stress are observed.
#
# In the standard poromechanics scenario, the Biot Modulus is held
# fixed and the source has units 1/time.  Then the expected result
# is
# strain_zz = disp_z = BiotCoefficient*BiotModulus*s*t/((bulk + 4*shear/3) + BiotCoefficient^2*BiotModulus)
# porepressure = BiotModulus*(s*t - BiotCoefficient*strain_zz)
# stress_xx = (bulk - 2*shear/3)*strain_zz   (remember this is effective stress)
# stress_zz = (bulk + 4*shear/3)*strain_zz   (remember this is effective stress)
#
# In porous_flow, however, the source has units kg/s/m^3.  The ratios remain
# fixed:
# stress_xx/strain_zz = (bulk - 2*shear/3) = 1 (for the parameters used here)
# stress_zz/strain_zz = (bulk + 4*shear/3) = 4 (for the parameters used here)
# porepressure/strain_zz = 13.3333333 (for the parameters used here)
#
# Expect
# disp_z = 0.3*10*s*t/((2 + 4*1.5/3) + 0.3^2*10) = 0.612245*s*t
# porepressure = 10*(s*t - 0.3*0.612245*s*t) = 8.163265*s*t
# stress_xx = (2 - 2*1.5/3)*0.612245*s*t = 0.612245*s*t
# stress_zz = (2 + 4*shear/3)*0.612245*s*t = 2.44898*s*t
# The relationship between the constant poroelastic source
# s (m^3/second/m^3) and the PorousFlow source, S (kg/second/m^3) is
# S = fluid_density * s = s * exp(porepressure/fluid_bulk)
#
# Finally, note that the volumetric strain has
# consistent_with_displaced_mesh = false
# which is needed when using the FullySaturated version of the Kernels
# in order to generate the above results
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    component = 2
    variable = disp_z
  [../]
  [./mass0]
    type = PorousFlowFullySaturatedMassTimeDerivative
    variable = porepressure
    coupling_type = HydroMechanical
    biot_coefficient = 0.3
  [../]
  [./source]
    type = BodyForce
    function = &#x27;0.1*exp(8.163265306*0.1*t/3.3333333333)&#x27;
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 3.3333333333
      density0 = 1
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature_qp]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
    consistent_with_displaced_mesh = false
  [../]
  [./ppss]
    type = PorousFlow1PhaseFullySaturated
    porepressure = porepressure
  [../]
  [./simple_fluid_qp]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst # the &quot;const&quot; is irrelevant here: all that uses Porosity is the BiotModulus, which just uses the initial value of porosity
    porosity = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    biot_coefficient = 0.3
    fluid_bulk_modulus = 3.3333333333
    solid_bulk_compliance = 0.5
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
  [./stress_xx_over_strain]
    type = FunctionValuePostprocessor
    function = stress_xx_over_strain_fcn
    outputs = csv
  [../]
  [./stress_zz_over_strain]
    type = FunctionValuePostprocessor
    function = stress_zz_over_strain_fcn
    outputs = csv
  [../]
  [./p_over_strain]
    type = FunctionValuePostprocessor
    function = p_over_strain_fcn
    outputs = csv
  [../]
[]

[Functions]
  [./stress_xx_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_xx zdisp&#x27;
  [../]
  [./stress_zz_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_zz zdisp&#x27;
  [../]
  [./p_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;p0 zdisp&#x27;
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_unconfined_fully_saturated
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2a457218-5fe3-4be8-93c4-9f57e4efe70e"><div class="modal-content"><h4>test/tests/outputs/variables/show_single_vars.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
  # This test uses ElementalVariableValue postprocessors on specific
  # elements, so element numbering needs to stay unchanged
  allow_renumbering = false
[]

[Functions]
  [./ffn]
    type = ParsedFunction
    value = -4
  [../]

  [./exactfn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./aux_exact_fn]
    type = ParsedFunction
    value = t*(x*x+y*y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./force]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[AuxVariables]
  [./aux_u]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./a]
    type = FunctionAux
    variable = aux_u
    function = aux_exact_fn
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exactfn
  [../]
[]

[Postprocessors]
  [./elem_56]
    type = ElementalVariableValue
    variable = u
    elementid = 56
  [../]

  [./aux_elem_99]
    type = ElementalVariableValue
    variable = aux_u
    elementid = 99
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  dt = 0.01
  start_time = 0
  num_steps = 1
[]

[Outputs]
  exodus = true
  show = &#x27;aux_u&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="14e21561-7345-40e0-8428-754a24e9cabb"><div class="modal-content"><h4>test/tests/bcs/function_dirichlet_bc/test.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a test of Boundary Condition System. The
# FunctionDirichletBC is used to contribute the residuals
# to the boundary term operators in the weak form.
#
# @Requirement F3.40
###########################################################


[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 32
    ny = 32
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./ff_1]
    type = ParsedFunction
    value = alpha*alpha*pi
    vars = &#x27;alpha&#x27;
    vals = &#x27;16&#x27;
  [../]

  [./ff_2]
    type = ParsedFunction
    value = pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;16&#x27;
  [../]

  [./forcing_func]
    type = CompositeFunction
    functions = &#x27;ff_1 ff_2&#x27;
  [../]

  [./bc_func]
    type = ParsedFunction
    value = sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;16&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_func
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right&#x27;
    function = bc_func
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2fb6f089-e9ff-46cc-b7e3-ae48ed635b2f"><div class="modal-content"><h4>test/tests/postprocessors/element_l2_difference/element_l2_difference.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Variables]
  [./u]
  [../]
  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff_u]
    type = Diffusion
    variable = u
  [../]
  [./force_u]
    type = BodyForce
    variable = u
    function = &#x27;x*x*x+y*y*y&#x27;
  [../]
  [./diff_v]
    type = Diffusion
    variable = v
  [../]
  [./force_v]
    type = BodyForce
    variable = v
    function = &#x27;x*x*x+y*y*y&#x27;
  [../]
[]

[BCs]
  [./left_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;left bottom right top&#x27;
    value = 0
  [../]
  [./left_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;left bottom right top&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;


  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [./l2_difference]
    type = ElementL2Difference
    variable = u
    other_variable = v
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="909d4b94-6864-47c3-9f81-c2f3ec97b0f5"><div class="modal-content"><h4>test/tests/bcs/second_deriv/test_lap_bc.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  elem_type = QUAD9
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = force_fn
  [../]
[]

[Functions]
  [./left_bc_func]
    type = ParsedFunction
    value = &#x27;1+y*y&#x27;
  [../]
  [./top_bc_func]
    type = ParsedFunction
    value = &#x27;1+x*x&#x27;
  [../]
  [./bottom_bc_func]
    type = ParsedFunction
    value = &#x27;1+x*x&#x27;
  [../]
  [./force_fn]
    type = ParsedFunction
    value = -4
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = u
    boundary = left
    function = left_bc_func
  [../]
  [./bottom]
    type = FunctionDirichletBC
    variable = u
    boundary = bottom
    function = bottom_bc_func
  [../]
  [./top]
    type = FunctionDirichletBC
    variable = u
    boundary = top
    function = top_bc_func
  [../]
  [./right_test]
    type = TestLapBC
    variable = u
    boundary = right
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="61a952a1-71af-4a13-b3cd-0431d57bcd72"><div class="modal-content"><h4>test/tests/transfers/multiapp_high_order_variable_transfer/master_L2_Lagrange_conservative.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
[]

[Variables]
  [power_density]
    family = L2_LAGRANGE
    order = FIRST
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27;
  []
[]

[Kernels]
  [diff]
    type = Reaction
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[Postprocessors]
  [pwr_avg]
    type = ElementAverageValue
    block = &#x27;0&#x27;
    variable = power_density
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Steady
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12
[]

[Postprocessors]
  [./from_postprocessor]
    type = ElementIntegralVariablePostprocessor
    variable = power_density
    execute_on = &#x27;Nonlinear TIMESTEP_END&#x27;
  [../]
[]

[MultiApps]
  [sub]
    type = FullSolveMultiApp
    app_type = MooseTestApp
    positions = &#x27;0 0 0&#x27;
    input_files  = sub_L2_Lagrange_conservative.i
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Transfers]
  [p_to_sub]
    type = MultiAppMeshFunctionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
    from_postprocessors_to_be_preserved  = &#x27;from_postprocessor&#x27;
    to_postprocessors_to_be_preserved  = &#x27;pwr_density&#x27;
  []
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="68f03de9-c057-48df-a58a-7548fb2dd2bd"><div class="modal-content"><h4>test/tests/restart/restart_subapp_not_master/two_step_solve_sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./average]
    type = ElementAverageValue
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0.0
  end_time = 2.0
  dt = 1.0
[]

[Outputs]
  [./checkpoint]
    type = Checkpoint
    num_files = 3
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="35324e41-51e7-41fa-a29c-6d772b712b8f"><div class="modal-content"><h4>test/tests/time_integrators/dirk/dirk-2d-heat-adap.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim  = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx   = 4
  ny   = 4
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value    = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value    = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  start_time = 0.0
  num_steps  = 5
  dt         = 0.25

  [./TimeIntegrator]
    type = LStableDirk2
  [../]

  [./Adaptivity]
    refine_fraction  = 0.07
    coarsen_fraction = 0.
    max_h_level      = 4
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e50802f2-cd8d-4605-bf60-27d6a3583048"><div class="modal-content"><h4>test/tests/variables/fe_hermite/hermite-3-1d.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test demonstrating the use of the
# Hermite variable type.
#
# @Requirement F3.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
  elem_type = EDGE3
[]

[Functions]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x+(x*x*x)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x*x
    grad_x = 3*x*x
  [../]
[]

# Hermite Variable type
[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;NEWTON&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="980e1b31-765a-416e-9fc3-9ef05016e551"><div class="modal-content"><h4>modules/stochastic_tools/examples/parameter_study/nonlin_diff_react/nonlin_diff_react_sub.i</h4><pre class="moose-pre"><code class="language-text">[Functions]
  [source]
    type = ParsedFunction
    value = &quot;100 * sin(2 * pi * x) * sin(2 * pi * y)&quot;
  []
[]

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 50
    xmin = 0
    xmax = 1
    ny = 50
    ymin = 0
    ymax = 1
  []
[]

[Variables]
  [U]
    family = lagrange
    order = first
  []
[]

[Kernels]
  [diffusion]
    type = Diffusion
    variable = U
  []
  [nonlin_function]
    type = ExponentialReaction
    variable = U
    mu1 = 0.3
    mu2 = 9
  []
  [source]
    type = BodyForce
    variable = U
    function = source
  []
[]

[BCs]
  [dirichlet_all]
    type = DirichletBC
    variable = U
    boundary = &#x27;left right top bottom&#x27;
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [max]
    type = ElementExtremeValue
    variable = U
  []
  [min]
    type = ElementExtremeValue
    variable = U
    value_type = min
  []
  [average]
    type = ElementAverageValue
    variable = U
  []
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="02642170-cffd-4d52-b8d0-dec38f8d19c5"><div class="modal-content"><h4>test/tests/mortar/gap-conductance-2d-non-conforming/gap-conductance.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [file]
    type = FileMeshGenerator
    file = nodal_normals_test_offset_nonmatching_gap.e
  []
  [./primary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;2&#x27;
    new_block_id = &#x27;20&#x27;
  [../]
  [./secondary]
    input = primary
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;1&#x27;
    new_block_id = &#x27;10&#x27;
  [../]
[]

[Problem]
  kernel_coverage_check = false
[]

[Variables]
  [./T]
    block = &#x27;1 2&#x27;
  [../]
  [./lambda]
    block = &#x27;10&#x27;
  [../]
[]

[BCs]
  [./neumann]
    type = FunctionGradientNeumannBC
    exact_solution = exact_soln
    variable = T
    boundary = &#x27;3 4 5 6 7 8&#x27;
  [../]
[]

[Kernels]
  [./conduction]
    type = Diffusion
    variable = T
    block = &#x27;1 2&#x27;
  [../]
  [./sink]
    type = Reaction
    variable = T
    block = &#x27;1 2&#x27;
  [../]
  [./forcing_function]
    type = BodyForce
    variable = T
    function = forcing_function
    block = &#x27;1 2&#x27;
  [../]
[]

[Functions]
  [./forcing_function]
    type = ParsedFunction
    value = &#x27;-4 + x^2 + y^2&#x27;
  [../]
  [./exact_soln]
    type = ParsedFunction
    value = &#x27;x^2 + y^2&#x27;
  [../]
[]

[Debug]
  show_var_residual_norms = 1
[]

[Constraints]
  [./mortar]
    type = GapHeatConductanceTest
    primary_boundary = 2
    secondary_boundary = 1
    primary_subdomain = 20
    secondary_subdomain = 10
    variable = lambda
    secondary_variable = T
  [../]
[]

[Materials]
  [constant]
    type = ADGenericConstantMaterial
    prop_names = &#x27;gap_conductance&#x27;
    prop_values = &#x27;.03&#x27;
    block = &#x27;1 2&#x27;
  []
  [./ssm]
    type = SpatialStatefulMaterial
    block = &#x27;1 2&#x27;
  [../]
[]


[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  solve_type = NEWTON
  type = Steady
  petsc_options_iname = &#x27;-pc_type -snes_linesearch_type&#x27;
  petsc_options_value = &#x27;lu       basic&#x27;
[]

[Outputs]
  exodus = true
  [dofmap]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fe3ee967-40d9-49e2-95f0-7b35f17c915e"><div class="modal-content"><h4>python/mms/test/mms_spatial.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 8
  ny = 8
[]

[Variables]
  [u][]
[]

[Kernels]
  [diff]
    type = ADDiffusion
    variable = u
  []
  [force]
    type = BodyForce
    variable = u
    function = force
  []
[]

[Functions]
  [exact]
    type = ParsedFunction
    value = &#x27;sin(2*pi*x)*sin(2*pi*y)&#x27;
  []
  [force]
    type = ParsedFunction
    value = &#x27;8*pi^2*sin(2*x*pi)*sin(2*y*pi)&#x27;
  []
[]

[BCs]
  [all]
    type = FunctionDirichletBC
    variable = u
    function = exact
    boundary = &#x27;left right top bottom&#x27;
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    function = exact
    variable = u
  []
  [h]
    type = AverageElementSize
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b5b7a4bf-3990-4212-b2b8-b6c60c953fee"><div class="modal-content"><h4>test/tests/dgkernels/3d_diffusion_dg/3d_diffusion_dg_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 5
  ny = 5
  nz = 5
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  zmin = 0
  zmax = 1
  elem_type = HEX8
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = MONOMIAL

    [./InitialCondition]
      type = ConstantIC
      value = 0.5
    [../]
  [../]
[]

[Functions]
  active = &#x27;forcing_fn exact_fn&#x27;

  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]

  [./exact_fn]
    type = ParsedGradFunction

    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff abs forcing&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]          # u * v
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  active = &#x27;dg_diff&#x27;

  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3 4 5&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Postprocessors]
  active = &#x27;h dofs l2_err&#x27;

  [./h]
    type = AverageElementSize
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./dofs]
    type = NumDOFs
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="23ff0e0d-08ba-4ac2-a482-dc668717805f"><div class="modal-content"><h4>test/tests/transfers/multiapp_userobject_transfer/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 8
  xmax = 0.1
  ymax = 0.5
[]

[Variables]
  [./u]
    initial_condition = 1
  [../]
[]

[AuxVariables]
  [./layered_average_value]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./axial_force]
    type = ParsedFunction
    value = 1000*y
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = axial_force
  [../]
[]

[AuxKernels]
  [./layered_aux]
    type = SpatialUserObjectAux
    variable = layered_average_value
    execute_on = timestep_end
    user_object = layered_average
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[UserObjects]
  [./layered_average]
    type = LayeredAverage
    variable = u
    direction = y
    num_layers = 4
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  dt = 0.001

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[Problem]
  coord_type = rz
  type = FEProblem
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6352bc93-c837-42a7-be14-792eacc7417e"><div class="modal-content"><h4>test/tests/postprocessors/nodal_var_value/nodal_var_value.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
  # NodalVariableValue is not safe on renumbered meshes
  allow_renumbering = false
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  active = &#x27;l2 scalednode1 node1 node4&#x27;

  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = NodalVariableValue
    variable = u
    nodeid = 15
  [../]

  [./scalednode1]
    type = NodalVariableValue
    variable = u
    nodeid = 15
    scale_factor = 2
  [../]

  [./node4]
    type = NodalVariableValue
    variable = v
    nodeid = 10
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_nodal_var_value
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d6a18f0d-8a9b-4937-804c-a2c099d439e4"><div class="modal-content"><h4>test/tests/kernels/ode/ode_expl_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD4
[]

[Functions]
  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]
  [./bc_all_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]
[]

# NL

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./uff]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = bc_all_fn
  [../]
[]

# Aux

[AuxVariables]
  [./y]
    family = SCALAR
    order = FIRST
    initial_condition = 1
  [../]
[]

[AuxScalarKernels]
  [./ode1]
    type = ExplicitODE
    variable = y
  [../]
[]

[Postprocessors]
  [./y]
    type = ScalarVariable
    variable = y
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  dt = 0.1
  num_steps = 10
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a93f904c-2024-437c-8896-e2c46a2ebb2b"><div class="modal-content"><h4>modules/combined/test/tests/elastic_patch/elastic_patch_rz.i</h4><pre class="moose-pre"><code class="language-text">#
# This problem is taken from the Abaqus verification manual:
#   &quot;1.5.4 Patch test for axisymmetric elements&quot;
# The stress solution is given as:
#   xx = yy = zz = 2000
#   xy = 400
#
# Since the strain is 1e-3 in all three directions, the new density should be
#   new_density = original_density * V_0 / V
#   new_density = 0.283 / (1 + 1e-3 + 1e-3 + 1e-3) = 0.282153

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = elastic_patch_rz.e
[]

[Variables]
  [./temp]
    initial_condition = 117.56
  [../]
[]

[Modules/TensorMechanics/Master/All]
  strain = SMALL
  incremental = true
  add_variables = true
  generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
[]

[Kernels]
  [./body]
    type = BodyForce
    variable = disp_y
    value = 1
    function = &#x27;-400/x&#x27;
  [../]

  [./heat]
    type = TimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./ur]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 10
    function = &#x27;1e-3*x&#x27;
  [../]
  [./uz]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 10
    function = &#x27;1e-3*(x+y)&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
  [../]
  [./stress]
    type = ComputeStrainIncrementBasedStress
  [../]

  [./density]
    type = Density
    density = 0.283
    outputs = all
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  end_time = 1.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="00b9932f-59e8-4443-af78-0f0c68e544e0"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/gaussian_process/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 1
  elem_type = EDGE3
[]

[Variables]
  [T]
    order = SECOND
    family = LAGRANGE
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = T
    diffusivity = k
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[Materials]
  [conductivity]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 2.0
  []
[]

[BCs]
  [right]
    type = DirichletBC
    variable = T
    boundary = right
    value = 300
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [avg]
    type = AverageNodalVariableValue
    variable = T
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d110fa92-66c7-4e6f-ac98-cd627a3c7cc9"><div class="modal-content"><h4>test/tests/misc/check_error/incomplete_kernel_block_coverage_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
    block = 1
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0cbef84f-8647-4d51-a2f8-099fa2c14e7a"><div class="modal-content"><h4>test/tests/userobjects/postprocessor_spatial_user_object/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -0.01
  xmax = 0.01
[]

[Functions]
  [./fn]
    type = ParsedFunction
    value = &#x27;if(a &lt; 0.8625, 1, 0)&#x27;
    vars = &#x27;a&#x27;
    vals = &#x27;a_avg&#x27;
  [../]
[]

[Variables]
  [./u]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxVariables]
  [./a]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./rhs]
    type = BodyForce
    variable = u
    function = 1
  [../]
[]

[Postprocessors]
  [./fn_pps]
    type = FunctionValuePostprocessor
    function = fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./a_avg]
    type = ElementAverageValue
    variable = a
  [../]
[]

[UserObjects]
  [./fn_uo]
    type = PostprocessorSpatialUserObject
    postprocessor = fn_pps
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.1
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2893a190-2a4e-4c88-bca4-77749573d750"><div class="modal-content"><h4>test/tests/multiapps/restart_multilevel/master2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  ymin = 0
  xmax = 1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./ufn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = v_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;sub.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]

[Problem]
  restart_file_base = master_out_cp/0005
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e1b6760e-2d8c-4bf3-b0d3-8f9f7a3df7c0"><div class="modal-content"><h4>test/tests/multiapps/restart/master2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  ymin = 0
  xmax = 1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./ufn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = v_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;sub2.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]

[Problem]
  restart_file_base = master_out_cp/0005
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3307a079-6cfc-49ca-938f-77b712772e4c"><div class="modal-content"><h4>test/tests/misc/check_error/missing_material_prop_test2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  active = &#x27;u&#x27;
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff_km_kernel]
    type = DiffMKernel
    variable = u
    mat_prop = diff1
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Materials]
  [./mat11]
    type = GenericConstantMaterial
    block = 1
    prop_names =  &#x27;diff1&#x27;
    prop_values = &#x27;1&#x27;
  [../]

  [./mat12]
    type = GenericConstantMaterial
    block = 1
    prop_names =  &#x27;diff2&#x27;
    prop_values = &#x27;1&#x27;
  [../]

  [./mat22]
    type = GenericConstantMaterial
    block = 2
    prop_names =  &#x27;diff2&#x27;
    prop_values = &#x27;1&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]

[Debug]
  show_material_props = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f7a96031-682e-4192-9c36-07e2f94c1ce3"><div class="modal-content"><h4>test/tests/auxkernels/error_function_aux/error_function_aux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./element_l2_error]
    # Aux field variable representing the L2 error on each element
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./element_h1_error]
    # Aux field variable representing the H1 error on each element
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./element_l2_norm]
    # Aux field variable representing the L^2 norm of the solution variable
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = sin(2*pi*x)*sin(2*pi*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 8*pi^2*sin(2*pi*x)*sin(2*pi*y)
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[AuxKernels]
  [./l2_norm_aux]
    type = ElementLpNormAux
    variable = element_l2_norm
    coupled_variable = u
  [../]
  [./l2_error_aux]
    type = ElementL2ErrorFunctionAux
    variable = element_l2_error
    # A function representing the exact solution for the solution
    function = exact_fn
    # The nonlinear variable representing the FEM solution
    coupled_variable = u
  [../]
  [./h1_error_aux]
    type = ElementH1ErrorFunctionAux
    variable = element_h1_error
    # A function representing the exact solution for the solution
    function = exact_fn
    # The nonlinear variable representing the FEM solution
    coupled_variable = u
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;bottom left right top&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./L2_error]
    # The L2 norm of the error over the entire mesh.  Note: this is
    # *not* equal to the sum over all the elements of the L2-error
    # norms.
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Steady
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="57c1d3e2-c3b4-4bd9-8316-e0ddcb4a967f"><div class="modal-content"><h4>test/tests/bcs/ad_function_neumann_bc/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 32
    ny = 32
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./exact_func]
    type = ParsedFunction
    value = x*x
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = 2
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionNeumannBC
    function = x
    variable = u
    boundary = right
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = neumannbc_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="237fa828-f1a6-4f3c-9c0c-83a2bcb6e924"><div class="modal-content"><h4>modules/porous_flow/test/tests/energy_conservation/heat04_action.i</h4><pre class="moose-pre"><code class="language-text"># heat04, but using an action
#
# The sample is a single unit element, with fixed displacements on
# all sides.  A heat source of strength S (J/m^3/s) is applied into
# the element.  There is no fluid flow or heat flow.  The rise
# in temperature, porepressure and stress, and the change in porosity is
# matched with theory.
#
# In this case, fluid mass must be conserved, and there is no
# volumetric strain, so
# porosity * fluid_density = constant
# Also, the energy-density in the rock-fluid system increases with S:
# d/dt [(1 - porosity) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T] = S
# Also, the porosity evolves according to THM as
# porosity = biot + (porosity0 - biot) * exp( (biot - 1) * P / fluid_bulk + rock_thermal_exp * T)
# Finally, the effective stress must be exactly zero (as there is
# no strain).
#
# Let us assume that
# fluid_density = dens0 * exp(P / fluid_bulk - fluid_thermal_exp * T)
# Then the conservation of fluid mass means
# porosity = por0 * exp(- P / fluid_bulk + fluid_thermal_exp * T)
# where dens0 * por0 = the initial fluid mass.
# The last expression for porosity, combined with the THM one,
# and assuming that biot = 1 for simplicity, gives
# porosity = 1 + (porosity0 - 1) * exp(rock_thermal_exp * T) = por0 * exp(- P / fluid_bulk + fluid_thermal_exp * T) .... (A)
#
# This stuff may be substituted into the heat energy-density equation:
# S = d/dt [(1 - porosity0) * exp(rock_thermal_exp * T) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T]
#
# If S is constant then
# S * t = (1 - porosity0) * exp(rock_thermal_exp * T) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T
# with T(t=0) = 0 then Eqn(A) implies that por0 = porosity0 and
# P / fluid_bulk = fluid_thermal_exp * T - log(1 + (por0 - 1) * exp(rock_thermal_exp * T)) + log(por0)
#
# Parameters:
# A = 2
# fluid_bulk = 2.0
# dens0 = 3.0
# fluid_thermal_exp = 0.5
# fluid_heat_cap = 2
# por0 = 0.5
# rock_thermal_exp = 0.25
# rock_density = 5
# rock_heat_capacity = 0.2

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.5
      cv = 2
      cp = 2
      bulk_modulus = 2.0
      density0 = 3.0
    [../]
  [../]
[]

[PorousFlowUnsaturated]
  coupling_type = ThermoHydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = pp
  temperature = temp
  dictator_name = Sir
  biot_coefficient = 1.0
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
  van_genuchten_alpha = 1.0E-12
  van_genuchten_m = 0.5
  relative_permeability_type = Corey
  relative_permeability_exponent = 0.0
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = Sir
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./pp]
  [../]
  [./temp]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
[]

[Kernels]
  [./heat_source]
    type = BodyForce
    function = 1
    variable = temp
  [../]
[]

[Functions]
  [./err_T_fcn]
    type = ParsedFunction
    vars = &#x27;por0 rte temp rd rhc m0 fhc source&#x27;
    vals = &#x27;0.5 0.25 t0   5  0.2 1.5 2  1&#x27;
    value = &#x27;((1-por0)*exp(rte*temp)*rd*rhc*temp+m0*fhc*temp-source*t)/(source*t)&#x27;
  [../]
  [./err_pp_fcn]
    type = ParsedFunction
    vars = &#x27;por0 rte temp rd rhc m0 fhc source bulk pp fte&#x27;
    vals = &#x27;0.5 0.25 t0   5  0.2 1.5 2  1      2    p0 0.5&#x27;
    value = &#x27;(bulk*(fte*temp-log(1+(por0-1)*exp(rte*temp))+log(por0))-pp)/pp&#x27;
  [../]
[]

[AuxVariables]
  [./porosity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./porosity]
    type = PorousFlowPropertyAux
    property = porosity
    variable = porosity
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./porosity]
    type = PorousFlowPorosity
    thermal = true
    fluid = true
    mechanical = true
    ensure_positive = false
    biot_coefficient = 1.0
    porosity_zero = 0.5
    thermal_expansion_coeff = 0.25
    solid_bulk = 2
  [../]
  [./rock_heat]
    type = PorousFlowMatrixInternalEnergy
    specific_heat_capacity = 0.2
    density = 5.0
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;0 0 0 0 0 0 0 0 0&#x27;
  [../]
  [./thermal_conductivity]
    type = PorousFlowThermalConductivityIdeal
    dry_thermal_conductivity = &#x27;0 0 0  0 0 0  0 0 0&#x27;
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = pp
  [../]
  [./t0]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = temp
  [../]
  [./porosity]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = porosity
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
  [./fluid_mass]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;timestep_end&#x27;
    use_displaced_mesh = true
    outputs = &#x27;console csv&#x27;
  [../]
  [./total_heat]
    type = PorousFlowHeatEnergy
    phase = 0
    execute_on = &#x27;timestep_end&#x27;
    use_displaced_mesh = true
    outputs = &#x27;console csv&#x27;
  [../]
  [./err_T]
    type = FunctionValuePostprocessor
    function = err_T_fcn
  [../]
  [./err_P]
    type = FunctionValuePostprocessor
    function = err_pp_fcn
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-12 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1
  end_time = 5
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  file_base = heat04_action
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b30d1bf1-fd9a-4400-bcc5-f3a3202e5c81"><div class="modal-content"><h4>test/tests/transfers/multiapp_high_order_variable_transfer/master_L2_Lagrange.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
[]

[Variables]
  [power_density]
    family = L2_LAGRANGE
    order = FIRST
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27;
  []
[]

[Kernels]
  [diff]
    type = Reaction
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[Postprocessors]
  [pwr_avg]
    type = ElementAverageValue
    block = &#x27;0&#x27;
    variable = power_density
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Steady
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12
[]

[MultiApps]
  [sub]
    type = FullSolveMultiApp
    app_type = MooseTestApp
    positions = &#x27;0 0 0&#x27;
    input_files  = sub_L2_Lagrange.i
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Transfers]
  [p_to_sub]
    type = MultiAppMeshFunctionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="125bc462-ccb6-4645-8fd6-a4e4a64724dc"><div class="modal-content"><h4>test/tests/nodalkernels/constraint_enforcement/upper-and-lower-bound.i</h4><pre class="moose-pre"><code class="language-text">l=10
nx=100
num_steps=10

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = ${l}
  nx = ${nx}
[]

[Variables]
  [u]
  []
  [lm_upper]
  []
  [lm_lower]
  []
[]

[ICs]
  [u]
    type = FunctionIC
    variable = u
    function = &#x27;x&#x27;
  []
[]

[Kernels]
  [time]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = &#x27;if(x&lt;5,-1,1)&#x27;
  []
[]

[NodalKernels]
  [upper_bound]
    type = UpperBoundNodalKernel
    variable = lm_upper
    v = u
    exclude_boundaries = &#x27;left right&#x27;
    upper_bound = 10
  []
  [forces_from_upper]
    type = CoupledForceNodalKernel
    variable = u
    v = lm_upper
    coef = -1
  []
  [lower_bound]
    type = LowerBoundNodalKernel
    variable = lm_lower
    v = u
    exclude_boundaries = &#x27;left right&#x27;
    lower_bound = 0
  []
  [forces_from_lower]
    type = CoupledForceNodalKernel
    variable = u
    v = lm_lower
    coef = 1
  []
[]


[BCs]
  [left]
    type = DirichletBC
    boundary = left
    value = 0
    variable = u
  []
  [right]
    type = DirichletBC
    boundary = right
    value = ${l}
    variable = u
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  num_steps = ${num_steps}
  solve_type = NEWTON
  dtmin = 1
  petsc_options_iname = &#x27;-snes_max_linear_solve_fail -ksp_max_it -pc_type -sub_pc_factor_levels -snes_linesearch_type&#x27;
  petsc_options_value = &#x27;0                           30          asm      16                    basic&#x27;
[]

[Outputs]
  exodus = true
  [csv]
    type = CSV
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  [active_upper_lm]
    type = GreaterThanLessThanPostprocessor
    variable = lm_upper
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = 1e-8
    comparator = &#x27;greater&#x27;
  []
  [upper_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = ${fparse 10+1e-8}
    comparator = &#x27;greater&#x27;
  []
  [active_lower_lm]
    type = GreaterThanLessThanPostprocessor
    variable = lm_lower
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = 1e-8
    comparator = &#x27;greater&#x27;
  []
  [lower_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = -1e-8
    comparator = &#x27;less&#x27;
  []
  [nls]
    type = NumNonlinearIterations
  []
  [cum_nls]
    type = CumulativeValuePostprocessor
    postprocessor = nls
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="412bec33-e772-49ba-9de0-96c91a83fea3"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/pp_generation_action.i</h4><pre class="moose-pre"><code class="language-text"># Same as pp_generation.i, but using an Action
#
# A sample is constrained on all sides and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie kg/second per cubic meter), and the
# rise in porepressure is observed.
#
# Source = s  (units = kg/m^3/second)
#
# Expect:
# fluid_mass = mass0 + s*t
# stress = 0 (remember this is effective stress)
# Porepressure = fluid_bulk*log(fluid_mass_density/density_P0), where fluid_mass_density = fluid_mass*porosity
# porosity = biot+(phi0-biot)*exp(pp(biot-1)/solid_bulk)
#
# Parameters:
# Biot coefficient = 0.3
# Phi0 = 0.1
# Solid Bulk modulus = 2
# fluid_bulk = 13
# density_P0 = 1

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]
[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.0
      bulk_modulus = 13.0
      viscosity = 1.0
      density0 = 1.0
    [../]
  [../]
[]

[PorousFlowUnsaturated]
  coupling_type = HydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  biot_coefficient = 0.3
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
  van_genuchten_alpha = 1.0
  van_genuchten_m = 0.8
  relative_permeability_type = Corey
  relative_permeability_exponent = 0.0
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
[]

[Kernels]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./porosity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./porosity]
    type = PorousFlowPropertyAux
    variable = porosity
    property = porosity
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./porosity]
    type = PorousFlowPorosity
    fluid = true
    mechanical = true
    porosity_zero = 0.1
    biot_coefficient = 0.3
    solid_bulk = 2
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0   0 1 0   0 0 1&#x27; # unimportant
  [../]
[]

[Functions]
  [./porosity_analytic]
    type = ParsedFunction
    value = &#x27;biot+(phi0-biot)*exp(pp*(biot-1)/bulk)&#x27;
    vars = &#x27;biot phi0 pp bulk&#x27;
    vals = &#x27;0.3 0.1 p0 2&#x27;
  [../]
[]

[Postprocessors]
  [./fluid_mass]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;initial timestep_end&#x27;
    use_displaced_mesh = true
  [../]
  [./porosity]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    point = &#x27;0 0 0&#x27;
    variable = porosity
  [../]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./porosity_analytic]
    type = FunctionValuePostprocessor
    function = porosity_analytic
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]

[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_action
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d14484ae-3372-435b-95ff-d32d53d31a08"><div class="modal-content"><h4>test/tests/multiapps/restart_multilevel/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 10
[]

[Functions]
  [./u_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = u_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;subsub.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0a42c0b4-e795-4e1f-8844-423a9c76d5fe"><div class="modal-content"><h4>modules/heat_conduction/test/tests/convective_heat_flux/coupled.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
[]

[Variables]
  [./temp]
    initial_condition = 200.0
  [../]
[]

[Kernels]
  [./heat_dt]
    type = TimeDerivative
    variable = temp
  [../]
  [./heat_conduction]
    type = Diffusion
    variable = temp
  [../]
  [./heat]
    type = BodyForce
    variable = temp
    value = 0
  [../]
[]

[BCs]
  [./right]
    type = ConvectiveHeatFluxBC
    variable = temp
    boundary = &#x27;right&#x27;
    T_infinity = T_inf
    heat_transfer_coefficient = htc
    heat_transfer_coefficient_dT = dhtc_dT
  [../]
[]

[Materials]
  [./T_inf]
    type = ParsedMaterial
    f_name = T_inf
    args = temp
    function = &#x27;temp + 1&#x27;
  [../]
  [./htc]
    type = ParsedMaterial
    f_name = htc
    args = temp
    function = &#x27;temp / 100 + 1&#x27;
  [../]
  [./dhtc_dT]
    type = ParsedMaterial
    f_name = dhtc_dT
    args = temp
    function = &#x27;1 / 100&#x27;
  [../]
[]

[Postprocessors]
  [./left_temp]
    type = SideAverageValue
    variable = temp
    boundary = left
    execute_on = &#x27;TIMESTEP_END initial&#x27;
  [../]
  [./right_temp]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./right_flux]
    type = SideFluxAverage
    variable = temp
    boundary = right
    diffusivity = 1
  [../]
[]

[Executioner]
  type = Transient

  num_steps = 10
  dt = 1

  nl_abs_tol = 1e-12
[]

[Outputs]
  [./out]
    type = CSV
    interval = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8acd67c0-ee47-4344-9305-4de57335f122"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-3-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 1
  ny = 1
  nz = 1
  elem_type = HEX27
  # This problem only has 1 element, so using DistributedMesh in parallel
  # isn&#x27;t really an option, and we don&#x27;t care that much about DistributedMesh
  # in serial.
  parallel_type = replicated
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 3*y*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -3*y*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]
  [./bc_fnk]
    type = ParsedFunction
    value = -3*z*z
  [../]
  [./bc_fnf]
    type = ParsedFunction
    value = 3*z*z
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x-6*y-6*z+(x*x*x)+(y*y*y)+(z*z*z)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (x*x*x)+(y*y*y)+(z*z*z)
    grad_x = 3*x*x
    grad_y = 3*y*y
    grad_z = 3*z*z
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
  [./bc_front]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;front&#x27;
    function = bc_fnf
  [../]
  [./bc_back]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;back&#x27;
    function = bc_fnk
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3e5f9b53-185e-4ef3-a559-bafa4bcf6c82"><div class="modal-content"><h4>test/tests/misc/check_error/missing_material_prop_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = DiffMKernel
    variable = u
    mat_prop = diff1
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Materials]
  [./mat1]
    type = GenericConstantMaterial
    block = 1
    prop_names =  &#x27;diff1&#x27;
    prop_values = &#x27;1&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8cdf9f6c-422e-43b7-b7ee-3e47f2b7c930"><div class="modal-content"><h4>test/tests/kernels/coupled_time_derivative/ad_coupled_time_derivative_test.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test of the CoupledTimeDerivative kernel.
# The expected solution for the variable v is
# v(x) = 1/2 * (x^2 + x)
###########################################################

[Mesh]
  type = GeneratedMesh
  nx = 5
  ny = 5
  dim = 2
[]

[Variables]
  [./u]
  [../]
  [./v]
  [../]
[]

[Kernels]
  [./time_u]
    type = TimeDerivative
    variable = u
  [../]
  [./fn_u]
    type = BodyForce
    variable = u
    function = 1
  [../]
  [./time_v]
    type = ADCoupledTimeDerivative
    variable = v
    v = u
  [../]
  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = v
    boundary = &#x27;left&#x27;
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = v
    boundary = &#x27;right&#x27;
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  solve_type = &#x27;NEWTON&#x27;
[]

[Outputs]
  exodus = true
  file_base = coupled_time_derivative_test_out
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8ffbcbf3-ec7c-45d8-a453-09c4b893d9e4"><div class="modal-content"><h4>test/tests/time_steppers/function_dt/function_dt_min.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]

  [./dts]
    type = PiecewiseLinear
    x = &#x27;0   0.85 2&#x27;
    y = &#x27;0.2 0.2  0.2&#x27;
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  start_time = 0
  num_steps = 10
  [./TimeStepper]
    type = FunctionDT
    function = dts
    min_dt = 0.1
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="879661b4-f560-4e01-b4d6-f7b040ad5e17"><div class="modal-content"><h4>test/tests/outputs/oversample/over_sampling_test_gen.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 3
  ny = 3
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+(x*x+y*y)
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  active = &#x27;ie diff ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./dt]
    type = TimestepSize
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.2
  start_time = 0
  num_steps = 5
[]

[Outputs]
  file_base = out_gen
  exodus = true
  [./oversampling]
    file_base = out_gen_oversample
    type = Exodus
    refinements = 3
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cd2b4ac6-9676-40ff-af6a-c2f9fad6dcc0"><div class="modal-content"><h4>test/tests/postprocessors/nodal_var_value/screen_output_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
  # This test can only be run with renumering disabled, so the
  # NodalVariableValue postprocessor&#x27;s node id is well-defined.
  allow_renumbering = false
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  active = &#x27;l2 node1 node4&#x27;

  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = NodalVariableValue
    variable = u
    nodeid = 15
  [../]

  [./node4]
    type = NodalVariableValue
    variable = v
    nodeid = 10
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    max_rows = 2
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fc966b2b-2d48-4f99-bd45-f8e66ee620d4"><div class="modal-content"><h4>test/tests/problems/no_material_dependency_check/no_material_coverage_check.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[Problem]
  material_dependency_check = false
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    value = 10
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Materials]
  [./mat1]
    type = GenericConstantMaterial
    prop_names =  &#x27;diff1&#x27;
    prop_values = &#x27;1&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3072e26a-ff4e-44f0-83e9-13fb2307d5d0"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_rz_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      rz
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in cylindrical coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with homogeneous material
#   properties. This problem can be exactly evaluated by FEM/Moose without the
#   moving interface. Both the temperature and level set function are designed
#   to be linear to attempt to minimize error between the Moose/exact solution
#   and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=1, y=1) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9998745
#      0.6                  520         519.9995067
#      0.8                  560         559.9989409
#      1.0                  600         599.9987054
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 1.0
  xmax = 2.0
  ymin = 1.0
  ymax = 2.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+400) + 100*1.5*t/x&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+200)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+200)*t+400&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 2.04 - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3c7cbd76-9089-47cc-ae48-f31c6ca003c2"><div class="modal-content"><h4>modules/stochastic_tools/examples/surrogates/combined/trans_diff_2d/trans_diff_sub.i</h4><pre class="moose-pre"><code class="language-text">[Functions]
  [src_func]
    type = ParsedFunction
    value = &quot;1000*sin(f*t)&quot;
    vars = &#x27;f&#x27;
    vals = &#x27;20&#x27;
  []
[]

[Mesh]
  [msh]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 100
    xmin = -0.5
    xmax = 0.5
    ny = 100
    ymin = -0.5
    ymax = 0.5
  []
  [source_domain]
    type = ParsedSubdomainMeshGenerator
    input = msh
    combinatorial_geometry = &#x27;(x&lt;0.1 &amp; x&gt;-0.1) &amp; (y&lt;0.1 &amp; y&gt;-0.1)&#x27;
    block_id=1
  []
[]

[Variables]
  [T]
    initial_condition = 300
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = T
    diffusivity = diff_coeff
  []
  [source]
    type = BodyForce
    variable = T
    function = src_func
    block = 1
  []
  [time_deriv]
    type = TimeDerivative
    variable = T
  []
[]

[Materials]
  [diff_coeff]
    type = ParsedMaterial
    f_name = diff_coeff
    args = &#x27;T&#x27;
    constant_names = &#x27;C&#x27;
    constant_expressions = 0.02
    function = &#x27;C * pow(300/T, 2)&#x27;
  []
[]

[BCs]
  [neumann_all]
    type = NeumannBC
    variable = T
    boundary = &#x27;left right top bottom&#x27;
    value = 0
  []
[]

[Executioner]
  type = Transient
  num_steps = 100
  dt = 0.01
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  nl_rel_tol = 1e-6
  l_abs_tol = 1e-6
  timestep_tolerance = 1e-6
[]

[Postprocessors]
  [max]
    type = NodalExtremeValue
    variable = T
  []
  [min]
    type = NodalExtremeValue
    variable = T
    value_type = min
  []
  [time_max]
    type = TimeExtremeValue
    postprocessor = max
  []
  [time_min]
    type = TimeExtremeValue
    postprocessor = min
    value_type = min
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5ebe5e18-b9f8-4229-8c48-4ac7240623ea"><div class="modal-content"><h4>test/tests/nodalkernels/constraint_enforcement/upper-bound.i</h4><pre class="moose-pre"><code class="language-text">l=10
nx=100
num_steps=10

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = ${l}
  nx = ${nx}
[]

[Variables]
  [u]
  []
  [lm]
  []
[]

[ICs]
  [u]
    type = FunctionIC
    variable = u
    function = &#x27;${l} - x&#x27;
  []
[]

[Kernels]
  [time]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = &#x27;1&#x27;
  []
[]

[NodalKernels]
  [positive_constraint]
    type = UpperBoundNodalKernel
    variable = lm
    v = u
    exclude_boundaries = &#x27;left right&#x27;
    upper_bound = 10
  []
  [forces]
    type = CoupledForceNodalKernel
    variable = u
    v = lm
    coef = -1
  []
[]


[BCs]
  [left]
    type = DirichletBC
    boundary = left
    value = ${l}
    variable = u
  []
  [right]
    type = DirichletBC
    boundary = right
    value = 0
    variable = u
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  num_steps = ${num_steps}
  solve_type = NEWTON
  dtmin = 1
  petsc_options_iname = &#x27;-snes_max_linear_solve_fail -ksp_max_it -pc_type -sub_pc_factor_levels -snes_linesearch_type&#x27;
  petsc_options_value = &#x27;0                           30          asm      16                    basic&#x27;
[]

[Outputs]
  exodus = true
  [csv]
    type = CSV
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  [active_lm]
    type = GreaterThanLessThanPostprocessor
    variable = lm
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = 1e-8
  []
  [violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = ${fparse 10+1e-8}
    comparator = &#x27;greater&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1af0023c-fa76-4f9b-bf75-48e4c287dfa9"><div class="modal-content"><h4>modules/heat_conduction/test/tests/sideset_heat_transfer/gap_thermal_1D.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [mesh]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 2
    xmax = 2
  []
  [split]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    block_id = 1
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 0 0&#x27;
  []
  [interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = split
    primary_block = 1
    paired_block = 0
    new_boundary = &#x27;interface0&#x27;
  []
  uniform_refine = 4
[]

[Variables]
  # Defining a DFEM variable to handle gap discontinuity
  [T]
    order = FIRST
    family = MONOMIAL
  []
[]

[AuxVariables]
  # Auxvariable containing bulk temperature of gap
  [Tbulk]
    order = FIRST
    family = LAGRANGE
    initial_condition = 300 # K
  []
[]

[Kernels]
  [diff]
    type = MatDiffusion
    variable = T
    diffusivity = conductivity
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[DGKernels]
  # DG kernel to represent diffusion accross element faces
  [./dg_diff]
    type = DGDiffusion
    variable = T
    epsilon = -1
    sigma = 6
    diff = conductivity
    # Ignoring gap side set because no diffusion accross there
    exclude_boundary = &#x27;interface0&#x27;
  [../]
[]

[InterfaceKernels]
  active = &#x27;gap&#x27;
  # Heat transfer kernel using Tbulk as material
  [gap]
    type = SideSetHeatTransferKernel
    variable = T
    neighbor_var = T
    boundary = &#x27;interface0&#x27;
  []
  # Heat transfer kernel using Tbulk as auxvariable
  [gap_var]
    type = SideSetHeatTransferKernel
    variable = T
    neighbor_var = T
    boundary = &#x27;interface0&#x27;
    Tbulk_var = Tbulk
  []
[]

[Functions]
  [bc_func]
    type = ConstantFunction
    value = 300
  []
  [exact]
    type = ParsedFunction
    value = &#x27;
            A := if(x &lt; 1, -0.5, -0.25);
            B := if(x &lt; 1, -0.293209850655001, 0.0545267662299068);
            C := if(x &lt; 1, 300.206790149345, 300.19547323377);
            d := -1;
            A * (x+d) * (x+d) + B * (x+d) + C&#x27;
  []
[]

[BCs]
  [bc_left]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;left&#x27;
    variable = T
    diff = &#x27;conductivity&#x27;
    epsilon = -1
    sigma = 6
    function = bc_func
  []
  [bc_right]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;right&#x27;
    variable = T
    diff = &#x27;conductivity&#x27;
    epsilon = -1
    sigma = 6
    function = bc_func
  []
[]

[Materials]
  [k0]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 1.0
    block = 0
  []
  [k1]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 2.0
    block = 1
  []
  [gap_mat]
    type = SideSetHeatTransferMaterial
    boundary = &#x27;interface0&#x27;
    conductivity = 1.5
    gap_length = 1.0
    h_primary = 1
    h_neighbor = 1
    Tbulk = 300
    emissivity_primary = 1
    emissivity_neighbor = 1
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    variable = T
    function = exact
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b3648a9b-d94b-4417-8e59-193c131d7476"><div class="modal-content"><h4>test/tests/postprocessors/pps_interval/pps_out_interval.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
  # This test can only be run with renumering disabled, so the
  # NodalVariableValue postprocessor&#x27;s node id is well-defined.
  allow_renumbering = false
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  active = &#x27;l2 node1 node4&#x27;

  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = NodalVariableValue
    variable = u
    nodeid = 15
  [../]

  [./node4]
    type = NodalVariableValue
    variable = v
    nodeid = 10
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  file_base = pps_out_interval
  interval = 2
  exodus = true
  [./console]
    type = Console
    interval = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a10200ab-16ca-4455-afd1-cdce7a2850a2"><div class="modal-content"><h4>test/tests/time_integrators/crank-nicolson/cranic.i</h4><pre class="moose-pre"><code class="language-text">#
# Testing a solution that is second order in space and second order in time
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*((x*x)+(y*y))-(4*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;crank-nicolson&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.25

#  [./Adaptivity]
#    refine_fraction = 0.2
#    coarsen_fraction = 0.3
#    max_h_level = 4
#  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="537e7678-6777-43e2-9167-77365ac88f4e"><div class="modal-content"><h4>test/tests/misc/check_error/coupled_grad_without_declare.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fnu]
    type = ParsedFunction
    value = -5.8*(x+y)+x*x*x-x+y*y*y-y
  [../]
  [./forcing_fnv]
    type = ParsedFunction
    value = -4
  [../]

  [./slnu]
    type = ParsedGradFunction
    value = x*x*x-x+y*y*y-y
    grad_x = 3*x*x-1
    grad_y = 3*y*y-1
  [../]
  [./slnv]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]

  #NeumannBC functions
  [./bc_fnut]
    type = ParsedFunction
    value = 3*y*y-1
  [../]
  [./bc_fnub]
    type = ParsedFunction
    value = -3*y*y+1
  [../]
  [./bc_fnul]
    type = ParsedFunction
    value = -3*x*x+1
  [../]
  [./bc_fnur]
    type = ParsedFunction
    value = 3*x*x-1
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff1 diff2 test1 forceu forcev react&#x27;
  [./diff1]
    type = Diffusion
    variable = u
  [../]
  [./test1]
    type = CoupledConvection
    variable = u
    velocity_vector = v

    # Trigger the error in this class
    test_coupling_declaration_error = true
  [../]
  [./diff2]
    type = Diffusion
    variable = v
  [../]
  [./react]
    type = Reaction
    variable = u
  [../]

  [./forceu]
    type = BodyForce
    variable = u
    function = forcing_fnu
  [../]
  [./forcev]
    type = BodyForce
    variable = v
    function = forcing_fnv
  [../]

[]

[BCs]
  active = &#x27;bc_u_tb bc_v bc_ul bc_ur bc_ut bc_ub&#x27;
  [./bc_u]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_v]
    type = FunctionDirichletBC
    variable = v
    function = slnv
    boundary = &#x27;left right top bottom&#x27;
  [../]

  [./bc_u_lr]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_u_tb]
    type = CoupledKernelGradBC
    variable = u
    var2 = v
    vel = &#x27;0.1 0.1&#x27;
    boundary = &#x27;top bottom left right&#x27;
  [../]

  [./bc_ul]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnul
    boundary = &#x27;left&#x27;
  [../]
  [./bc_ur]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnur
    boundary = &#x27;right&#x27;
  [../]
  [./bc_ut]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnut
    boundary = &#x27;top&#x27;
  [../]
  [./bc_ub]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnub
    boundary = &#x27;bottom&#x27;
  [../]
[]

[Preconditioning]
  active = &#x27; &#x27;
  [./prec]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active=&#x27;L2u L2v&#x27;
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2u]
    type = ElementL2Error
    variable = u
    function = slnu
  [../]
  [./L2v]
    type = ElementL2Error
    variable = v
    function = slnv
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes&#x27;
  nl_rel_tol = 1e-15
  nl_abs_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="760dd380-da4d-4260-b798-ee2767e6f00a"><div class="modal-content"><h4>modules/fluid_properties/test/tests/ideal_gas/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  elem_type = QUAD4
[]

[Functions]
  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]
  [./bc_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./e]
    initial_condition = 6232.5
  [../]
  [./v]
    initial_condition = 0.02493
  [../]

  [./p]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./T]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./cp]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./cv]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./c]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./mu]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./k]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./g]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./p]
    type = MaterialRealAux
     variable = p
     property = pressure
  [../]
  [./T]
    type = MaterialRealAux
     variable = T
     property = temperature
  [../]
  [./cp]
    type = MaterialRealAux
     variable = cp
     property = cp
  [../]
  [./cv]
    type = MaterialRealAux
     variable = cv
     property = cv
  [../]
  [./c]
    type = MaterialRealAux
     variable = c
     property = c
  [../]
  [./mu]
    type = MaterialRealAux
     variable = mu
     property = mu
  [../]
  [./k]
    type = MaterialRealAux
     variable = k
     property = k
  [../]
  [./g]
    type = MaterialRealAux
     variable = g
     property = g
  [../]
[]

[Modules]
  [./FluidProperties]
    [./ideal_gas]
      type = IdealGasFluidProperties
      gamma = 1.4
      molar_mass = 1.000536678700361
    [../]
  []
[]

[Materials]
  [./fp_mat]
    type = FluidPropertiesMaterial
    e = e
    v = v
    fp = ideal_gas
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = bc_fn
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e2ec372e-7c11-4413-b9a8-d19df9cc0887"><div class="modal-content"><h4>test/tests/misc/check_error/subdomain_restricted_auxkernel_mismatch.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./foo]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[AuxKernels]
  [./foo]
    type = ConstantAux
    variable = foo
    value = 1
    block = 2
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes_mf_operator&#x27;
#  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
#  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e8497b36-a337-417b-a769-d19aff5c3bd5"><div class="modal-content"><h4>test/tests/restart/start_time_override/start_time_override.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  nx = 5
  ny = 5
  dim = 2
[]

[Problem]
  restart_file_base = transient_out_cp/LATEST
  skip_additional_restart_data = true
[]

[Variables]
  [u]
    order = FIRST
    family = LAGRANGE
  []
[]

[Kernels]
  [bodyforce]
    type = BodyForce
    variable = u
    value = 10.0
  []

  [ie]
    type = TimeDerivative
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  []

  [right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 10
  []
[]

[Postprocessors]
  [u_norm]
    type = ElementL2Norm
    variable = u
  []
[]

[Executioner]
  type = Transient

  # Start time can be set explicitly here or be picked up from the restart file
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9b12f8d3-9ad2-4662-b743-4873aaa4694c"><div class="modal-content"><h4>modules/heat_conduction/test/tests/convective_heat_flux/t_inf.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
[]

[Variables]
  [./temp]
    initial_condition = 200.0
  [../]
[]

[Kernels]
  [./heat_dt]
    type = TimeDerivative
    variable = temp
  [../]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
    diffusion_coefficient = 1
  [../]
  [./heat]
    type = BodyForce
    variable = temp
    value = 0
  [../]
[]

[BCs]
  [./right]
    type = ConvectiveHeatFluxBC
    variable = temp
    boundary = &#x27;right&#x27;
    T_infinity = 100.0
    heat_transfer_coefficient = 1
    heat_transfer_coefficient_dT = 0
  [../]
[]

[Postprocessors]
  [./left_temp]
    type = SideAverageValue
    variable = temp
    boundary = left
    execute_on = &#x27;TIMESTEP_END initial&#x27;
  [../]
  [./right_temp]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./right_flux]
    type = SideFluxAverage
    variable = temp
    boundary = right
    diffusivity = 1
  [../]
[]

[Executioner]
  type = Transient

  num_steps = 10
  dt = 1e1

  nl_abs_tol = 1e-12
[]

[Outputs]
  # csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="196c0227-8053-4872-b849-29d11e1725a1"><div class="modal-content"><h4>modules/navier_stokes/test/tests/ins/mms/pspg/pspg_mms_test.i</h4><pre class="moose-pre"><code class="language-text">mu=1.5
rho=2.5

[GlobalParams]
  gravity = &#x27;0 0 0&#x27;
  pspg = true
  convective_term = true
  integrate_p_by_parts = true
  laplace = true
  u = vel_x
  v = vel_y
  p = p
  alpha = 1e-6
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1.0
    ymin = 0
    ymax = 1.0
    elem_type = QUAD9
    nx = 4
    ny = 4
  []
  [./corner_node]
    type = ExtraNodesetGenerator
    new_boundary = &#x27;pinned_node&#x27;
    nodes = &#x27;0&#x27;
    input = gen
  [../]
[]

[Variables]
  [./vel_x]
  [../]

  [./vel_y]
  [../]

  [./p]
  [../]
[]

[Kernels]
  # mass
  [./mass]
    type = INSMass
    variable = p
    x_vel_forcing_func = vel_x_source_func
    y_vel_forcing_func = vel_y_source_func
  [../]

  # x-momentum, space
  [./x_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_x
    component = 0
    forcing_func = vel_x_source_func
  [../]

  # y-momentum, space
  [./y_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_y
    component = 1
    forcing_func = vel_y_source_func
  [../]

  [./p_source]
    type = BodyForce
    function = p_source_func
    variable = p
  [../]
[]

[BCs]
  [./vel_x]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = vel_x_func
    variable = vel_x
  [../]
  [./vel_y]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = vel_y_func
    variable = vel_y
  [../]
  [./p]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = p_func
    variable = p
  [../]
[]

[Functions]
  [./vel_x_source_func]
    type = ParsedFunction
    value = &#x27;-${mu}*(-0.028*pi^2*x^2*sin(0.2*pi*x*y) - 0.028*pi^2*y^2*sin(0.2*pi*x*y) - 0.1*pi^2*sin(0.5*pi*x) - 0.4*pi^2*sin(pi*y)) + ${rho}*(0.14*pi*x*cos(0.2*pi*x*y) + 0.4*pi*cos(pi*y))*(0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3) + ${rho}*(0.14*pi*y*cos(0.2*pi*x*y) + 0.2*pi*cos(0.5*pi*x))*(0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5) + 0.1*pi*y*cos(0.2*pi*x*y) + 0.25*pi*cos(0.5*pi*x)&#x27;
  [../]
  [./vel_y_source_func]
    type = ParsedFunction
    value = &#x27;-${mu}*(-0.018*pi^2*x^2*sin(0.3*pi*x*y) - 0.018*pi^2*y^2*sin(0.3*pi*x*y) - 0.384*pi^2*sin(0.8*pi*x) - 0.027*pi^2*sin(0.3*pi*y)) + ${rho}*(0.06*pi*x*cos(0.3*pi*x*y) + 0.09*pi*cos(0.3*pi*y))*(0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3) + ${rho}*(0.06*pi*y*cos(0.3*pi*x*y) + 0.48*pi*cos(0.8*pi*x))*(0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5) + 0.1*pi*x*cos(0.2*pi*x*y) + 0.3*pi*cos(0.3*pi*y)&#x27;
  [../]
  [./p_source_func]
    type = ParsedFunction
    value = &#x27;-0.06*pi*x*cos(0.3*pi*x*y) - 0.14*pi*y*cos(0.2*pi*x*y) - 0.2*pi*cos(0.5*pi*x) - 0.09*pi*cos(0.3*pi*y)&#x27;
  [../]
  [./vel_x_func]
    type = ParsedFunction
    value = &#x27;0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5&#x27;
  [../]
  [./vel_y_func]
    type = ParsedFunction
    value = &#x27;0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3&#x27;
  [../]
  [./p_func]
    type = ParsedFunction
    value = &#x27;0.5*sin(0.5*pi*x) + 1.0*sin(0.3*pi*y) + 0.5*sin(0.2*pi*x*y) + 0.5&#x27;
  [../]
  [./vxx_func]
    type = ParsedFunction
    value = &#x27;0.14*pi*y*cos(0.2*pi*x*y) + 0.2*pi*cos(0.5*pi*x)&#x27;
  [../]
  [./px_func]
    type = ParsedFunction
    value = &#x27;0.1*pi*y*cos(0.2*pi*x*y) + 0.25*pi*cos(0.5*pi*x)&#x27;
  [../]
[]

[Materials]
  [./const]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;rho mu&#x27;
    prop_values = &#x27;${rho}  ${mu}&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Steady
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu NONZERO&#x27;
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-13
  nl_max_its = 6
  l_tol = 1e-6
  l_max_its = 500
[]

[Outputs]
  [./exodus]
    type = Exodus
  [../]
  [./csv]
    type = CSV
  [../]
[]

[Postprocessors]
  [./L2vel_x]
    type = ElementL2Error
    variable = vel_x
    function = vel_x_func
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2vel_y]
    variable = vel_y
    function = vel_y_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2p]
    variable = p
    function = p_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2vxx]
    variable = vxx
    function = vxx_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2px]
    variable = px
    function = px_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[AuxVariables]
  [./vxx]
    family = MONOMIAL
    order = FIRST
  [../]
  [./px]
    family = MONOMIAL
    order = FIRST
  [../]
[]

[AuxKernels]
  [./vxx]
    type = VariableGradientComponent
    component = x
    variable = vxx
    gradient_variable = vel_x
  [../]
  [./px]
    type = VariableGradientComponent
    component = x
    variable = px
    gradient_variable = p
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="807bf51b-7e8b-46c7-8846-6724e3e3bffd"><div class="modal-content"><h4>test/tests/executioners/steady_time/steady_time.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
  nx = 4
  ny = 4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./force]
    type = BodyForce
    variable = u
    function = time_function
  [../]
[]

[Functions]
  [./time_function]
    type = ParsedFunction
    value = &#x27;t+1&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left right bottom top&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  [./norm]
    type = ElementL2Norm
    variable = u
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="99da9e0b-0600-47a8-909f-13260dbddace"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_rz_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      rz
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in cylindrical coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is a single, constant value at all points in the system.
# Results:
#   The temperature at the left boundary (x=1) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM results
#   at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0008118
#      0.6                  520         520.0038529
#      0.8                  560         560.0089177
#      1.0                  600         600.0133344
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 1.0
  xmax = 2.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+400) + 200*1.5*t/x&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*200*t&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;2.04 - x - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1941a41d-cee2-48f8-80a5-a9cc9d8f316e"><div class="modal-content"><h4>test/tests/transfers/multiapp_high_order_variable_transfer/master_L2_Lagrange_userobject.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  parallel_type = replicated
[]

[Variables]
  [power_density]
    family = L2_LAGRANGE
    order = FIRST
  []
[]

[AuxVariables]
  [./multi_layered_average]
    family = LAGRANGE
    order = FIRST
  [../]
[]

[UserObjects]
  [./multi_layered_average]
    type = LayeredAverage
    variable = power_density
    direction = y
    num_layers = 4
  [../]
[]

[AuxKernels]
  [./layered_aux]
    type = SpatialUserObjectAux
    variable = multi_layered_average
    execute_on = &#x27;nonlinear TIMESTEP_END&#x27;
    user_object = multi_layered_average
  [../]
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27;
  []
[]

[Kernels]
  [diff]
    type = Reaction
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[Postprocessors]
  [layered_avg]
    type = ElementAverageValue
    block = &#x27;0&#x27;
    variable = multi_layered_average
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Steady
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-12
[]

[MultiApps]
  [sub]
    type = FullSolveMultiApp
    app_type = MooseTestApp
    positions = &#x27;0 0 0&#x27;
    input_files  = sub_L2_Lagrange.i
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Transfers]
  [p_to_sub]
    type = MultiAppUserObjectTransfer
    direction = to_multiapp
    user_object = multi_layered_average
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3574b3cf-562f-4bc1-8b04-67f1bbbff847"><div class="modal-content"><h4>test/tests/dgkernels/dg_displacement/dg_displacement.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL
  [../]
[]

[AuxVariables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]
  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))
  [../]
  [./disp_func]
    type = ParsedFunction
    value = x
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./abs]
    type = Reaction
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  nl_rel_tol = 1e-10
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out
  exodus = true
[]

[ICs]
  [./disp_x_ic]
    function = disp_func
    variable = disp_x
    type = FunctionIC
  [../]
[]

</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fad46f4a-a1bf-42a6-b4c4-1e83de532490"><div class="modal-content"><h4>test/tests/nodalkernels/constraint_enforcement/vi-bounding.i</h4><pre class="moose-pre"><code class="language-text">l=10
nx=100
num_steps=10

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = ${l}
  nx = ${nx}
[]

[Variables]
  [u]
  []
[]

[AuxVariables]
  [bounds][]
[]

[Bounds]
  [./u_upper_bounds]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = upper
    bound_value = ${l}
  [../]
  [./u_lower_bounds]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = lower
    bound_value = 0
  [../]
[]

[ICs]
  [u]
    type = FunctionIC
    variable = u
    function = &#x27;x&#x27;
  []
[]

[Kernels]
  [time]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = &#x27;if(x&lt;5,-1,1)&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    boundary = left
    value = 0
    variable = u
  []
  [right]
    type = DirichletBC
    boundary = right
    value = ${l}
    variable = u
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  num_steps = ${num_steps}
  solve_type = NEWTON
  dtmin = 1
  petsc_options_iname = &#x27;-snes_max_linear_solve_fail -ksp_max_it -pc_type -sub_pc_factor_levels -snes_linesearch_type -snes_type&#x27;
  petsc_options_value = &#x27;0                           30          asm      16                    basic                 vinewtonrsls&#x27;
[]

[Outputs]
  exodus = true
  [csv]
    type = CSV
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  [upper_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = ${fparse 10+1e-8}
    comparator = &#x27;greater&#x27;
  []
  [lower_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = -1e-8
    comparator = &#x27;less&#x27;
  []
  [nls]
    type = NumNonlinearIterations
  []
  [cum_nls]
    type = CumulativeValuePostprocessor
    postprocessor = nls
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="81ed60f4-77ff-4e90-8d47-88dc38f64bbb"><div class="modal-content"><h4>test/tests/time_integrators/explicit-euler/ee-2d-quadratic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))-(4*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    implicit = true
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;explicit-euler&#x27;
  solve_type = &#x27;LINEAR&#x27;

  l_tol = 1e-13
  start_time = 0.0
  num_steps = 20
  dt = 0.00005
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b8f4d11c-8dbd-44d8-bb8f-89536e34fe41"><div class="modal-content"><h4>modules/porous_flow/test/tests/energy_conservation/heat04_fullysat_action.i</h4><pre class="moose-pre"><code class="language-text"># heat04, but using an action
#
# The sample is a single unit element, with fixed displacements on
# all sides.  A heat source of strength S (J/m^3/s) is applied into
# the element.  There is no fluid flow or heat flow.  The rise
# in temperature, porepressure and stress, and the change in porosity is
# matched with theory.
#
# In this case, fluid mass must be conserved, and there is no
# volumetric strain, so
# porosity * fluid_density = constant
# Also, the energy-density in the rock-fluid system increases with S:
# d/dt [(1 - porosity) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T] = S
# Also, the porosity evolves according to THM as
# porosity = biot + (porosity0 - biot) * exp( (biot - 1) * P / fluid_bulk + rock_thermal_exp * T)
# Finally, the effective stress must be exactly zero (as there is
# no strain).
#
# Let us assume that
# fluid_density = dens0 * exp(P / fluid_bulk - fluid_thermal_exp * T)
# Then the conservation of fluid mass means
# porosity = por0 * exp(- P / fluid_bulk + fluid_thermal_exp * T)
# where dens0 * por0 = the initial fluid mass.
# The last expression for porosity, combined with the THM one,
# and assuming that biot = 1 for simplicity, gives
# porosity = 1 + (porosity0 - 1) * exp(rock_thermal_exp * T) = por0 * exp(- P / fluid_bulk + fluid_thermal_exp * T) .... (A)
#
# This stuff may be substituted into the heat energy-density equation:
# S = d/dt [(1 - porosity0) * exp(rock_thermal_exp * T) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T]
#
# If S is constant then
# S * t = (1 - porosity0) * exp(rock_thermal_exp * T) * rock_density * rock_heat_cap * T + porosity * fluid_density * fluid_heat_cap * T
# with T(t=0) = 0 then Eqn(A) implies that por0 = porosity0 and
# P / fluid_bulk = fluid_thermal_exp * T - log(1 + (por0 - 1) * exp(rock_thermal_exp * T)) + log(por0)
#
# Parameters:
# A = 2
# fluid_bulk = 2.0
# dens0 = 3.0
# fluid_thermal_exp = 0.5
# fluid_heat_cap = 2
# por0 = 0.5
# rock_thermal_exp = 0.25
# rock_density = 5
# rock_heat_capacity = 0.2

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0.5
      cv = 2
      cp = 2
      bulk_modulus = 2.0
      density0 = 3.0
    [../]
  [../]
[]

[PorousFlowFullySaturated]
  coupling_type = ThermoHydroMechanical
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = pp
  temperature = temp
  dictator_name = Sir
  biot_coefficient = 1.0
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = Sir
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./pp]
  [../]
  [./temp]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
[]

[Kernels]
  [./heat_source]
    type = BodyForce
    function = 1
    variable = temp
  [../]
[]

[Functions]
  [./err_T_fcn]
    type = ParsedFunction
    vars = &#x27;por0 rte temp rd rhc m0 fhc source&#x27;
    vals = &#x27;0.5 0.25 t0   5  0.2 1.5 2  1&#x27;
    value = &#x27;((1-por0)*exp(rte*temp)*rd*rhc*temp+m0*fhc*temp-source*t)/(source*t)&#x27;
  [../]
  [./err_pp_fcn]
    type = ParsedFunction
    vars = &#x27;por0 rte temp rd rhc m0 fhc source bulk pp fte&#x27;
    vals = &#x27;0.5 0.25 t0   5  0.2 1.5 2  1      2    p0 0.5&#x27;
    value = &#x27;(bulk*(fte*temp-log(1+(por0-1)*exp(rte*temp))+log(por0))-pp)/pp&#x27;
  [../]
[]

[AuxVariables]
  [./porosity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./porosity]
    type = PorousFlowPropertyAux
    property = porosity
    variable = porosity
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./porosity]
    type = PorousFlowPorosity
    thermal = true
    fluid = true
    mechanical = true
    ensure_positive = false
    biot_coefficient = 1.0
    porosity_zero = 0.5
    thermal_expansion_coeff = 0.25
    solid_bulk = 2
  [../]
  [./rock_heat]
    type = PorousFlowMatrixInternalEnergy
    specific_heat_capacity = 0.2
    density = 5.0
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;0 0 0 0 0 0 0 0 0&#x27;
  [../]
  [./thermal_conductivity]
    type = PorousFlowThermalConductivityIdeal
    dry_thermal_conductivity = &#x27;0 0 0  0 0 0  0 0 0&#x27;
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = pp
  [../]
  [./t0]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = temp
  [../]
  [./porosity]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
    variable = porosity
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
  [./fluid_mass]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;timestep_end&#x27;
    use_displaced_mesh = true
    outputs = &#x27;console csv&#x27;
  [../]
  [./total_heat]
    type = PorousFlowHeatEnergy
    phase = 0
    execute_on = &#x27;timestep_end&#x27;
    use_displaced_mesh = true
    outputs = &#x27;console csv&#x27;
  [../]
  [./err_T]
    type = FunctionValuePostprocessor
    function = err_T_fcn
  [../]
  [./err_P]
    type = FunctionValuePostprocessor
    function = err_pp_fcn
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-12 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1
  end_time = 5
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  file_base = heat04_fullysat_action
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fbb1b5f5-68af-43be-a3ff-833451dc3447"><div class="modal-content"><h4>test/tests/time_integrators/dirk/dirk-2d-heat.i</h4><pre class="moose-pre"><code class="language-text">#
# Testing a solution that is second order in space and first order in time.
#

[Mesh]
  type = GeneratedMesh
  dim  = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx   = 20
  ny   = 20
  elem_type = QUAD9
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = exact_fn
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))-(4*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  start_time = 0.0
  end_time   = 1.0
  dt         = 1.0
  nl_abs_tol=1e-13
  nl_rel_tol=1e-13

  [./TimeIntegrator]
    type = LStableDirk2
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus         = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aa2268fa-0407-4926-bc6f-f3175e1dec3c"><div class="modal-content"><h4>test/tests/misc/save_in/block-restricted-save-in.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[AuxVariables]
  [./vres]
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
    save_in = &#x27;vres&#x27;
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
  [./vres_int]
    type = ElementIntegralVariablePostprocessor
    variable = vres
    block = 1
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5443cbb9-0b0a-435d-839d-7f00df43d9b7"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-3-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 3*y*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -3*y*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x-6*y+(x*x*x)+(y*y*y)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (x*x*x)+(y*y*y)
    grad_x = 3*x*x
    grad_y = 3*y*y
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9ac7f9f1-1843-4c79-8c97-70c64cb964bd"><div class="modal-content"><h4>modules/navier_stokes/test/tests/ins/mms/supg/supg_mms_test.i</h4><pre class="moose-pre"><code class="language-text">mu=1.5
rho=2.5

[GlobalParams]
  gravity = &#x27;0 0 0&#x27;
  supg = true
  convective_term = true
  integrate_p_by_parts = false
  laplace = true
  u = vel_x
  v = vel_y
  p = p
  alpha = 1
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1.0
    ymin = 0
    ymax = 1.0
    elem_type = QUAD9
    nx = 4
    ny = 4
  []
  [./corner_node]
    type = ExtraNodesetGenerator
    new_boundary = &#x27;pinned_node&#x27;
    nodes = &#x27;0&#x27;
    input = gen
  [../]
[]

[Variables]
  [./vel_x]
  [../]

  [./vel_y]
  [../]

  [./p]
    order = FIRST
  [../]
[]

[Kernels]
  # mass
  [./mass]
    type = INSMass
    variable = p
  [../]

  # x-momentum, space
  [./x_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_x
    component = 0
    forcing_func = vel_x_source_func
  [../]

  # y-momentum, space
  [./y_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_y
    component = 1
    forcing_func = vel_y_source_func
  [../]

  [./p_source]
    type = BodyForce
    function = p_source_func
    variable = p
  [../]
[]

[BCs]
  [./vel_x]
    type = FunctionDirichletBC
    preset = false
    boundary = &#x27;left right top bottom&#x27;
    function = vel_x_func
    variable = vel_x
  [../]
  [./vel_y]
    type = FunctionDirichletBC
    preset = false
    boundary = &#x27;left right top bottom&#x27;
    function = vel_y_func
    variable = vel_y
  [../]
  [./p]
    type = FunctionDirichletBC
    preset = false
    boundary = &#x27;left right top bottom&#x27;
    function = p_func
    variable = p
  [../]
[]

[Functions]
  [./vel_x_source_func]
    type = ParsedFunction
    value = &#x27;-${mu}*(-0.028*pi^2*x^2*sin(0.2*pi*x*y) - 0.028*pi^2*y^2*sin(0.2*pi*x*y) - 0.1*pi^2*sin(0.5*pi*x) - 0.4*pi^2*sin(pi*y)) + ${rho}*(0.14*pi*x*cos(0.2*pi*x*y) + 0.4*pi*cos(pi*y))*(0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3) + ${rho}*(0.14*pi*y*cos(0.2*pi*x*y) + 0.2*pi*cos(0.5*pi*x))*(0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5) + 0.1*pi*y*cos(0.2*pi*x*y) + 0.25*pi*cos(0.5*pi*x)&#x27;
  [../]
  [./vel_y_source_func]
    type = ParsedFunction
    value = &#x27;-${mu}*(-0.018*pi^2*x^2*sin(0.3*pi*x*y) - 0.018*pi^2*y^2*sin(0.3*pi*x*y) - 0.384*pi^2*sin(0.8*pi*x) - 0.027*pi^2*sin(0.3*pi*y)) + ${rho}*(0.06*pi*x*cos(0.3*pi*x*y) + 0.09*pi*cos(0.3*pi*y))*(0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3) + ${rho}*(0.06*pi*y*cos(0.3*pi*x*y) + 0.48*pi*cos(0.8*pi*x))*(0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5) + 0.1*pi*x*cos(0.2*pi*x*y) + 0.3*pi*cos(0.3*pi*y)&#x27;
  [../]
  [./p_source_func]
    type = ParsedFunction
    value = &#x27;-0.06*pi*x*cos(0.3*pi*x*y) - 0.14*pi*y*cos(0.2*pi*x*y) - 0.2*pi*cos(0.5*pi*x) - 0.09*pi*cos(0.3*pi*y)&#x27;
  [../]
  [./vel_x_func]
    type = ParsedFunction
    value = &#x27;0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5&#x27;
  [../]
  [./vel_y_func]
    type = ParsedFunction
    value = &#x27;0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3&#x27;
  [../]
  [./p_func]
    type = ParsedFunction
    value = &#x27;0.5*sin(0.5*pi*x) + 1.0*sin(0.3*pi*y) + 0.5*sin(0.2*pi*x*y) + 0.5&#x27;
  [../]
  [./vxx_func]
    type = ParsedFunction
    value = &#x27;0.14*pi*y*cos(0.2*pi*x*y) + 0.2*pi*cos(0.5*pi*x)&#x27;
  [../]
[]

[Materials]
  [./const]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;rho mu&#x27;
    prop_values = &#x27;${rho}  ${mu}&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Steady
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu NONZERO&#x27;
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-13
  nl_max_its = 6
  l_tol = 1e-6
  l_max_its = 500
[]

[Outputs]
  [./exodus]
    type = Exodus
  [../]
  [./csv]
    type = CSV
  [../]
[]

[Postprocessors]
  [./L2vel_x]
    type = ElementL2Error
    variable = vel_x
    function = vel_x_func
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2vel_y]
    variable = vel_y
    function = vel_y_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2p]
    variable = p
    function = p_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2vxx]
    variable = vxx
    function = vxx_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[AuxVariables]
  [./vxx]
    family = MONOMIAL
    order = FIRST
  [../]
[]

[AuxKernels]
  [./vxx]
    type = VariableGradientComponent
    component = x
    variable = vxx
    gradient_variable = vel_x
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0f22a726-9ce4-485c-8cb8-661ac9d3d633"><div class="modal-content"><h4>modules/combined/test/tests/elastic_patch/ad_elastic_patch_rz.i</h4><pre class="moose-pre"><code class="language-text">#
# This problem is taken from the Abaqus verification manual:
#   &quot;1.5.4 Patch test for axisymmetric elements&quot;
# The stress solution is given as:
#   xx = yy = zz = 2000
#   xy = 400
#
# Since the strain is 1e-3 in all three directions, the new density should be
#   new_density = original_density * V_0 / V
#   new_density = 0.283 / (1 + 1e-3 + 1e-3 + 1e-3) = 0.282153

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  temperature = temp
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = elastic_patch_rz.e
[]

[Variables]
  [./temp]
    initial_condition = 117.56
  [../]
[]

[Modules/TensorMechanics/Master/All]
  strain = SMALL
  incremental = true
  add_variables = true
  generate_output = &#x27;stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx&#x27;
[]

[Kernels]
  [./body]
    type = BodyForce
    variable = disp_y
    value = 1
    function = &#x27;-400/x&#x27;
  [../]

  [./heat]
    type = TimeDerivative
    variable = temp
  [../]
[]

[BCs]
  [./ur]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 10
    function = &#x27;1e-3*x&#x27;
  [../]
  [./uz]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 10
    function = &#x27;1e-3*(x+y)&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
  [../]
  [./stress]
    type = ComputeStrainIncrementBasedStress
  [../]
[]

[Materials]
  [./density]
    type = ADDensity
    density = 0.283
    outputs = all
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  end_time = 1.0
[]

[Outputs]
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ae6d646f-f019-4dc0-9216-5300dd5bda89"><div class="modal-content"><h4>test/tests/ics/from_exodus_solution/elem_part2.i</h4><pre class="moose-pre"><code class="language-text"># Use the exodus file for restarting the problem:
# - restart elemental aux variable

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = elem_part1_out.e
    use_for_exodus_restart = true
  []
  # This problem uses ExodusII_IO::copy_elemental_solution(), which only
  # works with ReplicatedMesh
  parallel_type = replicated
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4
  [../]
[]

[AuxVariables]
  [./e]
    order = CONSTANT
    family = MONOMIAL
    initial_from_file_var = e
    initial_from_file_timestep = 6
  [../]
[]

[AuxKernels]
  [./ak]
    type = SelfAux
    variable = e
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="16866cab-3bd4-4069-af67-66d7f096521a"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_rz_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      rz
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in cylindrical coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is dependent upon the value of the level set function
#   at each timestep.
# Results:
#   The temperature at the left boundary (x=1) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM
#   results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0008131
#      0.6                  520         520.0038333
#      0.8                  560         560.0088286
#      1.0                  600         600.0131612
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 1.0
  xmax = 2.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+400) + (1/x)*(310*t - (10/1.02)*x*t - (1/1.02)*t^2)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.05/2.04)*(2.04-x-0.2*t) + 1.5)*200*t&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.05/2.04)*(2.04-x-0.2*t) + 1.5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;2.04 - x -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="54ac29bc-a7d6-4a84-a52a-c7320972c543"><div class="modal-content"><h4>test/tests/controls/bool_function_control/bool_function_control.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 1
[]

[Functions]
  [solve_fn]
    type = ParsedFunction
    value = &#x27;if(t&lt;0.3, 1, 0)&#x27;
  []
[]

[Variables]
  [u]
    initial_condition = 1
  []
[]

[Kernels]
  [td]
    type = TimeDerivative
    variable = u
  []
  [bf]
    type = BodyForce
    variable = u
    function = 1
  []
[]

[Controls]
  [solve_ctrl]
    type = BoolFunctionControl
    function = solve_fn
    parameter = &#x27;*/*/solve&#x27;
    execute_on = timestep_begin
  []
[]

[Postprocessors]
  [./u_val]
    type = ElementAverageValue
    variable = u
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6707e26e-a89d-4552-9396-2515f340c6d6"><div class="modal-content"><h4>test/tests/userobjects/interface_user_object/interface_value_rate_increment_user_object_QP.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./primary0_interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = primary0_interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]


[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 2
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 4
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    function = 0.1*t
  [../]
[]

[InterfaceKernels]
  [./primary0_interface]
    type = PenaltyInterfaceDiffusionDot
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = TRUE
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  dt = 0.1
  num_steps = 3
  dtmin = 0.1
  line_search = none
[]

[Outputs]
  exodus = true
[]

[UserObjects]
  [./interface_avg_value_uo]
    type = InterfaceQpValueUserObject
    var = v1
    var_neighbor = v2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
    interface_value_type = average
  [../]
  [./interface_avg_value_rate_uo]
    type = InterfaceQpValueUserObject
    var = v1
    var_neighbor = v2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
    interface_value_type = average
    value_type = rate
  [../]
  [./interface_avg_value_increment_uo]
    type = InterfaceQpValueUserObject
    var = v1
    var_neighbor = v2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
    interface_value_type = average
    value_type = increment
  [../]
[]

[AuxKernels]
  [./v1_saux]
    type = StatefulAux
    coupled = v1
    variable = v1
  [../]
  [./v2_saux]
    type = StatefulAux
    coupled = v2
    variable = v2
  [../]
  [./interface_avg_value_aux]
    type = InterfaceValueUserObjectAux
    variable = avg_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_avg_value_uo
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
  []
  [./interface_avg_value_rate_aux]
    type = InterfaceValueUserObjectAux
    variable = avg_rate_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_avg_value_rate_uo
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
  []
  [./interface_avg_value_increment_aux]
    type = InterfaceValueUserObjectAux
    variable = avg_increment_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_avg_value_increment_uo
    execute_on = &#x27;INITIAL LINEAR NONLINEAR TIMESTEP_BEGIN TIMESTEP_END FINAL&#x27;
  []
[]

[AuxVariables]
  [./v1]
    family = MONOMIAL
    order = FIRST
    initial_condition = 5
  [../]
  [./v2]
    family = MONOMIAL
    order = FIRST
    initial_condition = 2
  [../]
  [./avg_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./avg_rate_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./avg_increment_qp]
    family = MONOMIAL
    order = CONSTANT
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ab3a2d16-35db-49d4-8f13-7432bc669f21"><div class="modal-content"><h4>test/tests/bcs/nodal_normals/cylinder_hexes_2nd.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cylinder-hexes-2nd.e
[]

[Functions]
  [./all_bc_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]
[]

[NodalNormals]
  boundary = &#x27;1&#x27;
  corner_boundary = 100
  order = SECOND
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = &#x27;all_bc_fn&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="02ef947c-a2cf-4fbe-9b9e-7b433ef74f39"><div class="modal-content"><h4>test/tests/postprocessors/pps_interval/pps_bad_interval2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
  # This test can only be run with renumering disabled, so the
  # NodalVariableValue postprocessor&#x27;s node id is well-defined.
  allow_renumbering = false
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  active = &#x27;l2 node1 node4&#x27;

  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = NodalVariableValue
    variable = u
    nodeid = 15
  [../]

  [./node4]
    type = NodalVariableValue
    variable = v
    nodeid = 10
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  file_base = ignore_bad
  exodus = true
  [./console]
    type = Console
    interval = 2
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b71b541b-a2fd-4aec-afb3-52451e45e0ee"><div class="modal-content"><h4>test/tests/preconditioners/pbp/pbp_adapt_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = -4
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]

  [./conv_v]
    type = CoupledForce
    variable = v
    v = u
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = DirichletBC
    variable = v
    boundary = 1
    value = 0
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = 2
    value = 0
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Preconditioning]
  [./PBP]
    type = PBP
    solve_order = &#x27;u v&#x27;
    preconditioner  = &#x27;AMG ASM&#x27;
    off_diag_row    = &#x27;v&#x27;
    off_diag_column = &#x27;u&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = JFNK

  [./Adaptivity]
    steps = 3
    coarsen_fraction = 0.1
    refine_fraction = 0.2
    max_h_level = 5
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_pbp_adapt
  print_mesh_changed_info = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="63482b33-3bd7-45e6-ba5e-83e681f196a5"><div class="modal-content"><h4>test/tests/dampers/min_damping/min_general_damping.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./u_dt]
    type = TimeDerivative
    variable = u
  [../]
  [./u_source]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[Dampers]
  [./limit]
    type = ConstantDamper
    damping = 0.25
    min_damping = 0.5
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 2
  dt = 1.0
  dtmin = 0.5
[]

[Postprocessors]
  [./u_avg]
    type = ElementAverageValue
    variable = u
  [../]
  [./dt]
    type = TimestepSize
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="666f6b4a-83c9-4135-8a69-3f6979f6f950"><div class="modal-content"><h4>test/tests/auxkernels/function_scalar_aux/function_scalar_aux.i</h4><pre class="moose-pre"><code class="language-text">#
# Testing a solution that is second order in space and first order in time
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[AuxVariables]
  [./x]
    family = SCALAR
    order = FIRST
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))-(4*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*((x*x)+(y*y))
  [../]

  [./x_fn]
    type = ParsedFunction
    value = t
  [../]
[]

[AuxScalarKernels]
  [./x_saux]
    type = FunctionScalarAux
    variable = x
    function = x_fn
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./x]
    type = ScalarVariable
    variable = x
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.25
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="af5bebbe-38e0-4ac8-b078-7fadd459e955"><div class="modal-content"><h4>test/tests/bcs/nodal_normals/circle_quads.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = circle-quads.e
[]

[Functions]
  [./all_bc_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]

  [./analytical_normal_x]
    type = ParsedFunction
    value = x
  [../]
  [./analytical_normal_y]
    type = ParsedFunction
    value = y
  [../]
[]

[NodalNormals]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = &#x27;all_bc_fn&#x27;
  [../]
[]

[Postprocessors]
  [./nx_pps]
    type = NodalL2Error
    variable = nodal_normal_x
    boundary = &#x27;1&#x27;
    function = analytical_normal_x
  [../]
  [./ny_pps]
    type = NodalL2Error
    variable = nodal_normal_y
    boundary = &#x27;1&#x27;
    function = analytical_normal_y
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="50d4f9a1-e7e6-4347-84f6-392a31a083ad"><div class="modal-content"><h4>test/tests/executioners/executioner/transient.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of a &quot;Transient&quot; Executioner.
#
# @Requirement F1.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./dt]
    type = TimestepSize
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;
  solve_type = &#x27;PJFNK&#x27;
  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_transient
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a17365fe-18d7-4958-b5ac-972f706e4802"><div class="modal-content"><h4>test/tests/time_integrators/explicit-euler/ee-1d-quadratic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 20
  elem_type = EDGE3
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x*x-2*t
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x*x
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
#    lumping = true
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1&#x27;
    function = exact_fn
    implicit = true
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;explicit-euler&#x27;
  solve_type = &#x27;LINEAR&#x27;

  l_tol = 1e-12
  start_time = 0.0
  num_steps = 20
  dt = 0.00005
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="48c90c5d-29f6-42b2-860f-2fb33a079940"><div class="modal-content"><h4>test/tests/outputs/exodus/variable_output_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./aux]
    family = SCALAR
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1
  solve_type = PJFNK
[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Postprocessors]
  [./aux_pp]
    type = ScalarVariable
    variable = aux
    outputs = none
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  [./exodus]
    type = Exodus
    file_base = new_out
    hide_variables = &#x27;u box aux_pp&#x27;
    scalar_as_nodal = true
    execute_scalars_on = none
  [../]
  [./console]
    Type = Console
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6b9c5e2a-1bfe-490f-9909-3775e994c03d"><div class="modal-content"><h4>test/tests/postprocessors/interface_value/interface_average_variable_value_postprocessor.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 6
    xmax = 3
    ny = 9
    ymax = 3
    elem_type = QUAD4
  []
  [./subdomain_id]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;2 1 0&#x27;
    block_id = 1
    [../]
  [./interface]
    input = subdomain_id
    type = SideSetsBetweenSubdomainsGenerator
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;interface&#x27;
  [../]
[]

[Functions]
  [./fn_exact]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]
[]


[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = fn_exact
  [../]
[]

[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 5
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
  [../]
[]

[AuxKernels]
  [./diffusivity_1]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_1
  []
  [./diffusivity_2]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_2
  []
[]

[AuxVariables]
  [./diffusivity_1]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_2]
    family = MONOMIAL
    order = CONSTANT
  []
[]



[Postprocessors]
  [./diffusivity_average]
    type = InterfaceAverageVariableValuePostprocessor
    interface_value_type = average
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_jump_primary_secondary]
    type = InterfaceAverageVariableValuePostprocessor
    interface_value_type = jump_primary_minus_secondary
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_jump_secondary_primary]
    type = InterfaceAverageVariableValuePostprocessor
    interface_value_type = jump_secondary_minus_primary
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_jump_abs]
    type = InterfaceAverageVariableValuePostprocessor
    interface_value_type = jump_abs
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_primary]
    type = InterfaceAverageVariableValuePostprocessor
    interface_value_type = primary
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_secondary]
    type = InterfaceAverageVariableValuePostprocessor
    interface_value_type = secondary
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="40115f40-c099-49e7-b77c-d2e0544541f1"><div class="modal-content"><h4>examples/ex14_pps/ex14_compare_solutions_2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 11
  ny = 11
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
[]

[Variables]
  [./forced]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = forced
  [../]

  [./forcing]
    type = BodyForce
    variable = forced
    function = &#x27;x*x+y*y&#x27; # Any object expecting a function name can also receive a ParsedFunction string
  [../]
[]

[BCs]
  [./all]
    type = DirichletBC
    variable = forced
    boundary = &#x27;bottom right top left&#x27;
    value = 0
  [../]
[]

[UserObjects]
  [./fine_solution]
    # Read in the fine grid solution
    type = SolutionUserObject
    system_variables = forced
    mesh = ex14_compare_solutions_1_out_0000_mesh.xda
    es = ex14_compare_solutions_1_out_0000.xda
  [../]
[]

[Functions]
  [./fine_function]
    # Create a Function out of the fine grid solution
    # Note: This references the SolutionUserObject above
    type = SolutionFunction
    solution = fine_solution
  [../]
[]

[Executioner]
  type = Steady

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  [./Quadrature]
    # The integration of the error happens on the coarse mesh
    # To reduce integration error of the finer solution we can
    # raise the integration order.
    # Note: This will slow down the calculation a bit
    order = SIXTH
  [../]
[]

[Postprocessors]
  [./error]
    # Compute the error between the computed solution and the fine-grid solution
    type = ElementL2Error
    variable = forced
    function = fine_function
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1e8b31c4-d8c4-4d89-954d-7c2bd9bf1fdd"><div class="modal-content"><h4>test/tests/postprocessors/num_adaptivity_cycles/num_adaptivity_cycles.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1

  solve_type = &#x27;PJFNK&#x27;

[]

[Adaptivity]
  cycles_per_step = 1
  marker = box
  max_h_level = 2
  initial_steps = 4
  initial_marker = initial_box
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = dont_mark
      type = BoxMarker
    [../]
    [./initial_box]
      type = BoxMarker
      bottom_left = &#x27;0.8 0.1 0&#x27;
      top_right = &#x27;0.9 0.2 0&#x27;
      inside = refine
      outside = dont_mark
    [../]
  [../]
[]

[Postprocessors]
  [./adaptivity_cycles]
    type = NumAdaptivityCycles
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7a7b3467-eeb3-4022-ac96-8373c1fa5240"><div class="modal-content"><h4>test/tests/postprocessors/nodal_var_value/pps_output_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
  # This test can only be run with renumering disabled, so the
  # NodalVariableValue postprocessor&#x27;s node id is well-defined.
  allow_renumbering = false
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = NodalVariableValue
    variable = u
    nodeid = 15
    outputs = exodus
  [../]

  [./node4]
    type = NodalVariableValue
    variable = v
    nodeid = 10
    outputs = console
  [../]

  [./avg_v]
    type = AverageElementSize
    outputs = none
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="67d41022-6468-45bf-abcb-82f585412005"><div class="modal-content"><h4>test/tests/utils/spline_interpolation/bicubic_spline_interpolation.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nz = 1
  nx = 4
  ny = 4
  xmax = 4
  ymax = 4
[]

[Functions]
  [./yx1]
    type = ParsedFunction
    value = &#x27;3*x^2&#x27;
  [../]
  [./yx2]
    type = ParsedFunction
    value = &#x27;6*y^2&#x27;
  [../]
  [./spline_fn]
    type = BicubicSplineFunction
    x1 = &#x27;0 2 4&#x27;
    x2 = &#x27;0 2 4 6&#x27;
    y = &#x27;0 16 128 432 8 24 136 440 64 80 192 496&#x27;
    yx11 = &#x27;0 0 0 0&#x27;
    yx1n = &#x27;48 48 48 48&#x27;
    yx21 = &#x27;0 0 0&#x27;
    yx2n = &#x27;216 216 216&#x27;
    yx1 = &#x27;yx1&#x27;
    yx2 = &#x27;yx2&#x27;
  [../]
  [./u_func]
    type = ParsedFunction
    value = &#x27;x^3 + 2*y^3&#x27;
  [../]
  [./u2_forcing_func]
    type = ParsedFunction
    value = &#x27;-6*x - 12*y&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./bi_func_value]
    order = FIRST
    family = LAGRANGE
  [../]
  [./x_deriv]
    order = FIRST
    family = LAGRANGE
  [../]
  [./y_deriv]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./bi_func_value]
    type = FunctionAux
    variable = bi_func_value
    function = spline_fn
  [../]
  [./deriv_1]
    type = FunctionDerivativeAux
    function = spline_fn
    variable = x_deriv
    component = 1
  [../]
  [./deriv_2]
    type = FunctionDerivativeAux
    function = spline_fn
    variable = y_deriv
    component = 2
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./body_force]
    type = BodyForce
    variable = u
    function = u2_forcing_func
  [../]
[]

[BCs]
  [./sides]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = u_func
  [../]
[]

[Postprocessors]
  [./nodal_l2_err_spline]
    type = NodalL2Error
    variable = u
    function = spline_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./nodal_l2_err_analytic]
    type = NodalL2Error
    variable = u
    function = u_func
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./x_deriv_err_analytic]
    type = NodalL2Error
    variable = x_deriv
    function = yx1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./y_deriv_err_analytic]
    type = NodalL2Error
    variable = y_deriv
    function = yx2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9ae85d23-abe9-4390-92a9-8ac18341c58b"><div class="modal-content"><h4>examples/ex13_functions/ex13.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2

  nx = 100
  ny = 100

  xmin = 0.0
  xmax = 1.0

  ymin = 0.0
  ymax = 1.0
[]

[Variables]
  [./forced]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  # A ParsedFunction allows us to supply analytic expressions
  # directly in the input file
  [./bc_func]
    type = ParsedFunction
    value = sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;16&#x27;
  [../]

  # This function is an actual compiled function
  # We could have used ParsedFunction for this as well
  [./forcing_func]
    type = ExampleFunction
    alpha = 16
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = forced
  [../]

  # This Kernel can take a function name to use
  [./forcing]
    type = BodyForce
    variable = forced
    function = forcing_func
  [../]
[]

[BCs]
  # The BC can take a function name to use
  [./all]
    type = FunctionDirichletBC
    variable = forced
    boundary = &#x27;bottom right top left&#x27;
    function = bc_func
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="41606cb6-8646-4e47-8d79-1543fd6dbd9c"><div class="modal-content"><h4>modules/phase_field/test/tests/KKS_system/kks_multiphase.i</h4><pre class="moose-pre"><code class="language-text">#
# This test is for the 3-phase KKS model
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  nz = 0
  xmin = 0
  xmax = 40
  ymin = 0
  ymax = 40
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[AuxVariables]
  [./Energy]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Variables]
  # concentration
  [./c]
    order = FIRST
    family = LAGRANGE
  [../]

  # order parameter 1
  [./eta1]
    order = FIRST
    family = LAGRANGE
  [../]

  # order parameter 2
  [./eta2]
    order = FIRST
    family = LAGRANGE
  [../]

  # order parameter 3
  [./eta3]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]

  # phase concentration 1
  [./c1]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.2
  [../]

  # phase concentration 2
  [./c2]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.5
  [../]

  # phase concentration 3
  [./c3]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.8
  [../]

  # Lagrange multiplier
  [./lambda]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[ICs]
  [./eta1]
    variable = eta1
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.9
    outvalue = 0.1
    int_width = 4
  [../]
  [./eta2]
    variable = eta2
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.1
    outvalue = 0.9
    int_width = 4
  [../]
  [./c]
    variable = c
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.2
    outvalue = 0.5
    int_width = 2
  [../]
[]


[Materials]
  # simple toy free energies
  [./f1]
    type = DerivativeParsedMaterial
    f_name = F1
    args = &#x27;c1&#x27;
    function = &#x27;20*(c1-0.2)^2&#x27;
  [../]
  [./f2]
    type = DerivativeParsedMaterial
    f_name = F2
    args = &#x27;c2&#x27;
    function = &#x27;20*(c2-0.5)^2&#x27;
  [../]
  [./f3]
    type = DerivativeParsedMaterial
    f_name = F3
    args = &#x27;c3&#x27;
    function = &#x27;20*(c3-0.8)^2&#x27;
  [../]

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [./h1]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta1
    eta_j = eta2
    eta_k = eta3
    f_name = h1
  [../]
  # h2(eta1, eta2, eta3)
  [./h2]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta2
    eta_j = eta3
    eta_k = eta1
    f_name = h2
  [../]
  # h3(eta1, eta2, eta3)
  [./h3]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta3
    eta_j = eta1
    eta_k = eta2
    f_name = h3
  [../]

  # Coefficients for diffusion equation
  [./Dh1]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h1&#x27;
    function = D*h1
    f_name = Dh1
  [../]
  [./Dh2]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h2&#x27;
    function = D*h2
    f_name = Dh2
  [../]
  [./Dh3]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h3&#x27;
    function = D*h3
    f_name = Dh3
  [../]

  # Barrier functions for each phase
  [./g1]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta1
    function_name = g1
  [../]
  [./g2]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta2
    function_name = g2
  [../]
  [./g3]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta3
    function_name = g3
  [../]

  # constant properties
  [./constants]
    type = GenericConstantMaterial
    prop_names  = &#x27;L   kappa  D&#x27;
    prop_values = &#x27;0.7 1.0    1&#x27;
  [../]
[]

[Kernels]
  #Kernels for diffusion equation
  [./diff_time]
    type = TimeDerivative
    variable = c
  [../]
  [./diff_c1]
    type = MatDiffusion
    variable = c
    diffusivity = Dh1
    v = c1
  [../]
  [./diff_c2]
    type = MatDiffusion
    variable = c
    diffusivity = Dh2
    v = c2
  [../]
  [./diff_c3]
    type = MatDiffusion
    variable = c
    diffusivity = Dh3
    v = c3
  [../]

  # Kernels for Allen-Cahn equation for eta1
  [./deta1dt]
    type = TimeDerivative
    variable = eta1
  [../]
  [./ACBulkF1]
    type = KKSMultiACBulkF
    variable  = eta1
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g1
    eta_i     = eta1
    wi        = 1.0
    args      = &#x27;c1 c2 c3 eta2 eta3&#x27;
  [../]
  [./ACBulkC1]
    type = KKSMultiACBulkC
    variable  = eta1
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta1
    args      = &#x27;eta2 eta3&#x27;
  [../]
  [./ACInterface1]
    type = ACInterface
    variable = eta1
    kappa_name = kappa
  [../]
  [./multipler1]
    type = MatReaction
    variable = eta1
    v = lambda
    mob_name = L
  [../]

  # Kernels for Allen-Cahn equation for eta2
  [./deta2dt]
    type = TimeDerivative
    variable = eta2
  [../]
  [./ACBulkF2]
    type = KKSMultiACBulkF
    variable  = eta2
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g2
    eta_i     = eta2
    wi        = 1.0
    args      = &#x27;c1 c2 c3 eta1 eta3&#x27;
  [../]
  [./ACBulkC2]
    type = KKSMultiACBulkC
    variable  = eta2
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta2
    args      = &#x27;eta1 eta3&#x27;
  [../]
  [./ACInterface2]
    type = ACInterface
    variable = eta2
    kappa_name = kappa
  [../]
  [./multipler2]
    type = MatReaction
    variable = eta2
    v = lambda
    mob_name = L
  [../]

  # Kernels for the Lagrange multiplier equation
  [./mult_lambda]
    type = MatReaction
    variable = lambda
    mob_name = 3
  [../]
  [./mult_ACBulkF_1]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g1
    eta_i     = eta1
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta2 eta3&#x27;
  [../]
  [./mult_ACBulkC_1]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta1
    args      = &#x27;eta2 eta3&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_1]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta1
    kappa_name = kappa
    mob_name = 1
  [../]
  [./mult_ACBulkF_2]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g2
    eta_i     = eta2
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta1 eta3&#x27;
  [../]
  [./mult_ACBulkC_2]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta2
    args      = &#x27;eta1 eta3&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_2]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta2
    kappa_name = kappa
    mob_name = 1
  [../]
  [./mult_ACBulkF_3]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g3
    eta_i     = eta3
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta1 eta2&#x27;
  [../]
  [./mult_ACBulkC_3]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta3
    args      = &#x27;eta1 eta2&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_3]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta3
    kappa_name = kappa
    mob_name = 1
  [../]

  # Kernels for constraint equation eta1 + eta2 + eta3 = 1
  # eta3 is the nonlinear variable for the constraint equation
  [./eta3reaction]
    type = MatReaction
    variable = eta3
    mob_name = 1
  [../]
  [./eta1reaction]
    type = MatReaction
    variable = eta3
    v = eta1
    mob_name = 1
  [../]
  [./eta2reaction]
    type = MatReaction
    variable = eta3
    v = eta2
    mob_name = 1
  [../]
  [./one]
    type = BodyForce
    variable = eta3
    value = -1.0
  [../]

  # Phase concentration constraints
  [./chempot12]
    type = KKSPhaseChemicalPotential
    variable = c1
    cb       = c2
    fa_name  = F1
    fb_name  = F2
  [../]
  [./chempot23]
    type = KKSPhaseChemicalPotential
    variable = c2
    cb       = c3
    fa_name  = F2
    fb_name  = F3
  [../]
  [./phaseconcentration]
    type = KKSMultiPhaseConcentration
    variable = c3
    cj = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    etas = &#x27;eta1 eta2 eta3&#x27;
    c = c
  [../]
[]

[AuxKernels]
  [./Energy_total]
    type = KKSMultiFreeEnergy
    Fj_names = &#x27;F1 F2 F3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    gj_names = &#x27;g1 g2 g3&#x27;
    variable = Energy
    w = 1
    interfacial_vars =  &#x27;eta1  eta2  eta3&#x27;
    kappa_names =       &#x27;kappa kappa kappa&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;
  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-11

  num_steps = 2
  dt = 0.5
[]

[Preconditioning]
  active = &#x27;full&#x27;
  [./full]
    type = SMP
    full = true
  [../]
  [./mydebug]
    type = FDP
    full = true
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1f2df51c-a080-47ec-bd63-320a077194e4"><div class="modal-content"><h4>modules/heat_conduction/test/tests/recover/recover.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = recover_in.e
[]

[Variables]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat_source]
    type = BodyForce
    variable = temp
    block = pellet_type_1
    value = 1e3
    function = &#x27;t&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 5
    secondary = 10
    emissivity_primary = 0
    emissivity_secondary = 0
    quadrature = true
  [../]
[]

[BCs]
  [./outside]
    type = DirichletBC
    value = 580
    boundary = &#x27;1 2 3&#x27;
    variable = temp
  [../]
  [./edge]
    type = DirichletBC
    value = 700
    boundary = 10
    variable = temp
  [../]
[]

[Materials]
  [./thermal_3]
    type = HeatConductionMaterial
    block = 3
    thermal_conductivity = 5
    specific_heat = 12
  [../]
  [./thermal_1]
    type = HeatConductionMaterial
    block = 1
    thermal_conductivity = 16.0
    specific_heat = 330.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27; lu       superlu_dist&#x27;

  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-11

  start_time = -200
  n_startup_steps = 1
  end_time = 1.02e5
  num_steps = 10

  dtmax = 2e6
  dtmin = 1

  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 2.0e2
    optimal_iterations = 15
    iteration_window = 2
  [../]

  [./Quadrature]
    order = FIFTH
    side_order = SEVENTH
  [../]
[]

[Postprocessors]
  [./ave_temp_interior]
     type = SideAverageValue
     boundary = 9
     variable = temp
     execute_on = &#x27;initial linear&#x27;
  [../]
  [./avg_clad_temp]
    type = SideAverageValue
    boundary = 7
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./flux_from_clad]
    type = SideFluxIntegral
    variable = temp
    boundary = 5
    diffusivity = thermal_conductivity
  [../]
  [./_dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fa994588-394f-43c6-8814-d9b09d806646"><div class="modal-content"><h4>test/tests/adaptivity/initial_adapt/initial_adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1

  solve_type = &#x27;PJFNK&#x27;

[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  initial_steps = 2
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a74b5ee9-9dde-4e3e-87a7-b9462f8c74ab"><div class="modal-content"><h4>test/tests/time_steppers/timesequence_stepper/timesequence_restart3.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = timesequence_restart1_cp/0002_mesh.cpr
[]

[Problem]
  restart_file_base = timesequence_restart1_cp/0002
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  end_time = 4.5
  [./TimeStepper]
    type = TimeSequenceStepper
    time_sequence  = &#x27;0   0.85 1.3 1.9 2 4 4.5&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="164e21b4-6198-4587-b588-a6d7d7610f11"><div class="modal-content"><h4>test/tests/multiapps/restart_multilevel/subsub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 10
[]

[Functions]
  [./u_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = u_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ea2d198f-5aba-49a0-b6f7-1dedfd6bbb52"><div class="modal-content"><h4>test/tests/dgkernels/ad_dg_diffusion/2d_diffusion_ad_dg_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL

    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]

  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]          # u * v
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  [./dg_diff]
    type = ADDGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
    diff = diff
  [../]
[]

[Materials]
  [./ad_coupled_mat]
    type = ADCoupledMaterial
    coupled_var = u
    ad_mat_prop = diff
    regular_mat_prop = diff_regular
  [../]
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;NEWTON&#x27;
  [./Adaptivity]
    steps = 2
    refine_fraction = 1.0
    coarsen_fraction = 0
    max_h_level = 8
  [../]

  nl_rel_tol = 1e-10
[]

[Postprocessors]
  [./h]
    type = AverageElementSize
  [../]

  [./dofs]
    type = NumDOFs
  [../]

  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="01de52fb-1eaa-4887-82fa-81770cd97d73"><div class="modal-content"><h4>test/tests/multiapps/picard/function_dt_sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 10
[]

[Functions]
  [./u_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]

  [./dts]
    type = PiecewiseLinear
    x = &#x27;0.1  10&#x27;
    y = &#x27;0.1  10&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = u_fn
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10
  start_time = 0
  num_steps = 3
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="31d7bdc7-3aea-428b-8bcf-e320ab693ff3"><div class="modal-content"><h4>test/tests/meshgenerators/lower_d_block_generator/names.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 10
    ny = 10
  []

  [./lower_d_block]
    type = LowerDBlockFromSidesetGenerator
    input = gmg
    new_block_id = 10
    sidesets = &#x27;bottom bottom right top left&#x27;
  []
[]

[Variables]
  [./u]
    block = 0
  [../]
  [./v]
    block = 10
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
    block = 0
  [../]
  [./srcv]
    type = BodyForce
    block = 10
    variable = v
    function = 1
  [../]
  [./time_v]
    type = TimeDerivative
    block = 10
    variable = v
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 2
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="77408f8a-0583-4ed0-9e03-65242936c930"><div class="modal-content"><h4>test/tests/time_steppers/timesequence_stepper/timesequence_restart_failure.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = timesequence_restart_failure1_cp/0002_mesh.cpr
[]

[Problem]
  restart_file_base = timesequence_restart_failure1_cp/0002
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  end_time = 4.0
  [./TimeStepper]
    type = TimeSequenceStepper
    time_sequence  = &#x27;0   0.85 1.2 1.3 2 4&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3ea62aeb-ac1c-4438-87f2-7bfdca07f91f"><div class="modal-content"><h4>test/tests/interfacekernels/gmsh_sidesets/coupled_value_coupled_flux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = gmsh_mesh.msh
[]

[Variables]
  [./u]
    block = 6
  [../]

  [./v]
    block = 5
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 6
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 5
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[InterfaceKernels]
 [./interface]
   type = PenaltyInterfaceDiffusion
   variable = u
   neighbor_var = v
   boundary = &#x27;1 2&#x27;
   penalty = 1e6
 [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = 4
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = 3
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 6
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 5
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="02c8c8a9-7cd9-4359-a2b5-6a12a96f005f"><div class="modal-content"><h4>test/tests/outputs/residual/output_residual_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = sq-2blk.e
  uniform_refine = 3
[]

[Variables]
  # variable in the whole domain
  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]

  # subdomain restricted variable
  [./v]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]

  [./exact_fn_v]
    type = ParsedFunction
    value = t+1
  [../]
[]

[Kernels]
  [./ie_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]


  [./ie_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]

[]

[BCs]
  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1 2 3 4&#x27;
    function = exact_fn
  [../]

  [./bottom_v]
    type = DirichletBC
    variable = v
    boundary = 5
    value = 0
  [../]

  [./top_v]
    type = FunctionDirichletBC
    variable = v
    boundary = 6
    function = exact_fn_v
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out
  exodus = true
[]

[Debug]
  show_var_residual = &#x27;u v&#x27;
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="35dedd52-d878-4444-b336-3201d541cea8"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-3-1d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 5
  elem_type = EDGE3
[]

[Functions]
  [./bc_fnl]
    type = ParsedFunction
    value = -3*x*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 3*x*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -6*x+(x*x*x)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x*x
    grad_x = 3*x*x
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c0f45bca-ca7e-4c12-a8f1-bdd85a399fd1"><div class="modal-content"><h4>modules/heat_conduction/test/tests/heat_conduction/coupled_convective_heat_flux/const_hw.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./t_infinity]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    value = 1000
  [../]
[]

[AuxKernels]
  [./t_infinity]
    type = ConstantAux
    variable = t_infinity
    value = 500
    execute_on = initial
  [../]
[]

[BCs]
  [./right]
    type = CoupledConvectiveHeatFluxBC
    variable = u
    boundary = right
    htc = 10
    T_infinity = t_infinity
  [../]
[]

[Executioner]
  type = Steady

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;



  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9fe93da6-9111-4e76-ae9e-600766356dd4"><div class="modal-content"><h4>test/tests/multiapps/restart_subapp_ic/sub2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 10
[]

[Functions]
  [./u_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[Variables]
  [./u]
    initial_condition = 4.2
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = u_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f2031ba1-5aba-4600-8841-31c07b6ae8dc"><div class="modal-content"><h4>test/tests/kernels/ode/ode_sys_impl_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD4
[]

[Functions]
  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]
  [./bc_all_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  # ODEs
  [./exact_x_fn]
    type = ParsedFunction
    value = (-1/3)*exp(-t)+(4/3)*exp(5*t)
  [../]
[]

# NL

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]

  # ODE variables
  [./x]
    family = SCALAR
    order = FIRST
    initial_condition = 1
  [../]
  [./y]
    family = SCALAR
    order = FIRST
    initial_condition = 2
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./uff]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[ScalarKernels]
  [./td1]
    type = ODETimeDerivative
    variable = x
  [../]
  [./ode1]
    type = ImplicitODEx
    variable = x
    y = y
  [../]

  [./td2]
    type = ODETimeDerivative
    variable = y
  [../]
  [./ode2]
    type = ImplicitODEy
    variable = y
    x = x
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = bc_all_fn
  [../]
[]

[Postprocessors]
  active = &#x27;exact_x l2err_x x y&#x27;

  [./x]
    type = ScalarVariable
    variable = x
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./y]
    type = ScalarVariable
    variable = y
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./exact_x]
    type = FunctionValuePostprocessor
    function = exact_x_fn
    execute_on = &#x27;initial timestep_end&#x27;
    point = &#x27;0 0 0&#x27;
  [../]

  [./l2err_x]
    type = ScalarL2Error
    variable = x
    function = exact_x_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  start_time = 0
  dt = 0.01
  num_steps = 100

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="39e78bd5-0396-4151-abe6-a7d2c3c7fdbc"><div class="modal-content"><h4>modules/heat_conduction/test/tests/heat_conduction/coupled_convective_heat_flux/coupled_convective_heat_flux_two_phase.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Functions]
  [./alpha_liquid_fn]
    type = ParsedFunction
    value = &#x27;sin(pi*y)&#x27;
  [../]
  [./T_infinity_liquid_fn]
    type = ParsedFunction
    value = &#x27;(x*x+y*y)+500&#x27;
  [../]
  [./Hw_liquid_fn]
    type = ParsedFunction
    value = &#x27;((1-x)*(1-x)+(1-y)*(1-y))+1000&#x27;
  [../]

  [./alpha_vapor_fn]
    type = ParsedFunction
    value = &#x27;1-sin(pi*y)&#x27;
  [../]
  [./T_infinity_vapor_fn]
    type = ParsedFunction
    value = &#x27;(x*x+y*y)+5&#x27;
  [../]
  [./Hw_vapor_fn]
    type = ParsedFunction
    value = &#x27;((1-x)*(1-x)+(1-y)*(1-y))+10&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./T_infinity_liquid]
  [../]
  [./Hw_liquid]
  [../]
  [./alpha_liquid]
  [../]
  [./T_infinity_vapor]
  [../]
  [./Hw_vapor]
  [../]
  [./alpha_vapor]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    value = 1000
  [../]
[]

[AuxKernels]
  [./alpha_liquid_ak]
    type = FunctionAux
    variable = alpha_liquid
    function = alpha_liquid_fn
    execute_on = initial
  [../]
  [./T_infinity_liquid_ak]
    type = FunctionAux
    variable = T_infinity_liquid
    function = T_infinity_liquid_fn
    execute_on = initial
  [../]
  [./Hw_liquid_ak]
    type = FunctionAux
    variable = Hw_liquid
    function = Hw_liquid_fn
    execute_on = initial
  [../]

  [./alpha_vapor_ak]
    type = FunctionAux
    variable = alpha_vapor
    function = alpha_vapor_fn
    execute_on = initial
  [../]
  [./T_infinity_vapor_ak]
    type = FunctionAux
    variable = T_infinity_vapor
    function = T_infinity_vapor_fn
    execute_on = initial
  [../]
  [./Hw_vapor_ak]
    type = FunctionAux
    variable = Hw_vapor
    function = Hw_vapor_fn
    execute_on = initial
  [../]
[]

[BCs]
  [./right]
    type = CoupledConvectiveHeatFluxBC
    variable = u
    boundary = right
    alpha = &#x27;alpha_liquid alpha_vapor&#x27;
    htc = &#x27;Hw_liquid Hw_vapor&#x27;
    T_infinity = &#x27;T_infinity_liquid T_infinity_vapor&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3d002eeb-5d2d-4fff-b480-d57310251908"><div class="modal-content"><h4>test/tests/utils/spline_interpolation/bicubic_spline_interpolation_y_normal.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  ny = 1 # needed to ensure Z is the problem dimension
  nx = 4
  nz = 4
  xmax = 4
  zmax = 4
[]

[Functions]
  [./yx1]
    type = ParsedFunction
    value = &#x27;3*z^2&#x27;
  [../]
  [./yx2]
    type = ParsedFunction
    value = &#x27;6*x^2&#x27;
  [../]
  [./spline_fn]
    type = BicubicSplineFunction
    normal_component = y
    x1 = &#x27;0 2 4&#x27;
    x2 = &#x27;0 2 4 6&#x27;
    y = &#x27;0 16 128 432 8 24 136 440 64 80 192 496&#x27;
    yx11 = &#x27;0 0 0 0&#x27;
    yx1n = &#x27;48 48 48 48&#x27;
    yx21 = &#x27;0 0 0&#x27;
    yx2n = &#x27;216 216 216&#x27;
    yx1 = &#x27;yx1&#x27;
    yx2 = &#x27;yx2&#x27;
  [../]
  [./u_func]
    type = ParsedFunction
    value = &#x27;z^3 + 2*x^3&#x27;
  [../]
  [./u2_forcing_func]
    type = ParsedFunction
    value = &#x27;-6*z - 12*x&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./bi_func_value]
    order = FIRST
    family = LAGRANGE
  [../]
  [./x_deriv]
    order = FIRST
    family = LAGRANGE
  [../]
  [./z_deriv]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./bi_func_value]
    type = FunctionAux
    variable = bi_func_value
    function = spline_fn
  [../]
  [./deriv_1]
    type = FunctionDerivativeAux
    function = spline_fn
    variable = z_deriv
    component = 3
  [../]
  [./deriv_2]
    type = FunctionDerivativeAux
    function = spline_fn
    variable = x_deriv
    component = 1
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./body_force]
    type = BodyForce
    variable = u
    function = u2_forcing_func
  [../]
[]

[BCs]
  [./sides]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right front back&#x27;
    function = u_func
  [../]
[]

[Postprocessors]
  [./nodal_l2_err_spline]
    type = NodalL2Error
    variable = u
    function = spline_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./nodal_l2_err_analytic]
    type = NodalL2Error
    variable = u
    function = u_func
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./x_deriv_err_analytic]
    type = NodalL2Error
    variable = x_deriv
    function = yx2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./z_deriv_err_analytic]
    type = NodalL2Error
    variable = z_deriv
    function = yx1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
  nl_rel_tol = 1e-12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5b2bf978-fde5-4504-bbb6-057c8a9441ee"><div class="modal-content"><h4>test/tests/variables/fe_monomial_const/monomial-const-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 100
  ny = 100
  elem_type = QUAD4
[]

[Functions]
  [./bc_fn]
    type=ParsedFunction
    value=0
  [../]
  [./bc_fnt]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = 0
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
#    type = ParsedFunction
#    value = 0
    type = MTPiecewiseConst2D
  [../]

  [./solution]
    type = MTPiecewiseConst2D
  [../]
[]

[Variables]
  [./u]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  # Note: MOOSE&#x27;s DirichletBCs do not work properly with shape functions that do not
  #       have DOFs at the element edges.  This test works because the solution
  #       has been designed to be zero at the boundary which is satisfied by the IC
  #       Ticket #1352
  active = &#x27;&#x27;
  [./bc_all]
    type=FunctionDirichletBC
    variable = u
    boundary = &#x27;top bottom left right&#x27;
    function = bc_fn
  [../]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1.e-10
  [./Adaptivity]

  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  csv = true
  [./out]
    type = Exodus
    elemental_as_nodal = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b935c6b5-76d3-4562-bed4-c013fd27133f"><div class="modal-content"><h4>test/tests/kernels/scalar_constraint/scalar_constraint_kernel_disp.i</h4><pre class="moose-pre"><code class="language-text">#
# This test is identical to scalar_constraint_kernel.i, but it everything is evaluated on the displaced mesh
#

[GlobalParams]
  use_displaced_mesh = true
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]

  [./bottom_bc_fn]
    type = ParsedFunction
    value = -2*y
  [../]

  [./right_bc_fn]
    type = ParsedFunction
    value =  2*x
  [../]

  [./top_bc_fn]
    type = ParsedFunction
    value =  2*y
  [../]

  [./left_bc_fn]
    type = ParsedFunction
    value = -2*x
  [../]
[]

[AuxVariables]
  [./disp_x]
    family = LAGRANGE
    order = SECOND
  [../]
  [./disp_y]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[AuxKernels]
  [./disp_x_ak]
    type = ConstantAux
    variable = disp_x
    value = 0
  [../]
  [./disp_y_ak]
    type = ConstantAux
    variable = disp_y
    value = 0
  [../]
[]

# NL

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]

  [./lambda]
    family = SCALAR
    order = FIRST
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffnk]
    type = BodyForce
    variable = u
    function = ffn
  [../]

  [./sk_lm]
    type = ScalarLagrangeMultiplier
    variable = u
    lambda = lambda
  [../]
[]

[ScalarKernels]
  [./constraint]
    type = AverageValueConstraint
    variable = lambda
    pp_name = pp
    value = 2.666666666666666
    # overrride the global setting, scalar kernels do not live on a mesh
    use_displaced_mesh = false
  [../]
[]

[BCs]
  [./bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;0&#x27;
    function = bottom_bc_fn
  [../]
  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;1&#x27;
    function = right_bc_fn
  [../]
  [./top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;2&#x27;
    function = top_bc_fn
  [../]
  [./left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;3&#x27;
    function = left_bc_fn
  [../]
[]

[Postprocessors]
  [./pp]
    type = ElementIntegralVariablePostprocessor
    variable = u
    execute_on = linear
  [../]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./pc]
    type = SMP
    full = true
    solve_type = &#x27;PJFNK&#x27;
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-14
  l_tol = 1e-7
[]

[Outputs]
  exodus = true
  hide = lambda
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0d862a69-0628-4cdf-9974-43afc4598e50"><div class="modal-content"><h4>test/tests/mortar/continuity-2d-non-conforming/dual-soln-continuity.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  second_order = false
  [file]
    type = FileMeshGenerator
    file = nodal_normals_test_offset_nonmatching_gap.e
  []
  [./primary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;2&#x27;
    new_block_id = &#x27;20&#x27;
  [../]
  [./secondary]
    input = primary
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;1&#x27;
    new_block_id = &#x27;10&#x27;
  [../]
[]

[Problem]
  kernel_coverage_check = false
[]

[Variables]
  [./T]
    block = &#x27;1 2&#x27;
    order = FIRST
  [../]
  [./lambda]
    block = &#x27;10&#x27;
    order = FIRST
    use_dual = true
  [../]
[]

[BCs]
  [./neumann]
    type = FunctionGradientNeumannBC
    exact_solution = exact_soln
    variable = T
    boundary = &#x27;3 4 5 6 7 8&#x27;
  [../]
[]

[Kernels]
  [./conduction]
    type = Diffusion
    variable = T
    block = &#x27;1 2&#x27;
  [../]
  [./sink]
    type = Reaction
    variable = T
    block = &#x27;1 2&#x27;
  [../]
  [./forcing_function]
    type = BodyForce
    variable = T
    function = forcing_function
    block = &#x27;1 2&#x27;
  [../]
[]

[Functions]
  [./forcing_function]
    type = ParsedFunction
    value = &#x27;-4 + x^2 + y^2&#x27;
  [../]
  [./exact_soln]
    type = ParsedFunction
    value = &#x27;x^2 + y^2&#x27;
  [../]
[]

[Debug]
  show_var_residual_norms = 1
[]

[Constraints]
  [./mortar]
    type = EqualValueConstraint
    primary_boundary = 2
    secondary_boundary = 1
    primary_subdomain = 20
    secondary_subdomain = 10
    variable = lambda
    secondary_variable = T
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  solve_type = NEWTON
  type = Steady
  petsc_options_iname = &#x27;-pc_type -snes_linesearch_type -pc_factor_shift_type -pc_factor_shift_amount&#x27;
  petsc_options_value = &#x27;lu       basic                 NONZERO               1e-15&#x27;
[]

[Outputs]
  exodus = true
  [dofmap]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f3b43cf9-28cf-4328-a061-6761c08b7147"><div class="modal-content"><h4>modules/fluid_properties/test/tests/stiffened_gas/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  elem_type = QUAD4
[]

[Functions]
  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]
  [./bc_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./e]
    initial_condition = 113206.45935406466
  [../]
  [./v]
    initial_condition = 0.0007354064593540647
  [../]

  [./p]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./T]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./cp]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./cv]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./c]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./mu]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./k]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./g]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./p]
    type = MaterialRealAux
     variable = p
     property = pressure
  [../]
  [./T]
    type = MaterialRealAux
     variable = T
     property = temperature
  [../]
  [./cp]
    type = MaterialRealAux
     variable = cp
     property = cp
  [../]
  [./cv]
    type = MaterialRealAux
     variable = cv
     property = cv
  [../]
  [./c]
    type = MaterialRealAux
     variable = c
     property = c
  [../]
  [./mu]
    type = MaterialRealAux
     variable = mu
     property = mu
  [../]
  [./k]
    type = MaterialRealAux
     variable = k
     property = k
  [../]
  [./g]
    type = MaterialRealAux
     variable = g
     property = g
  [../]
[]

[Modules]
  [./FluidProperties]
    [./sg]
      type = StiffenedGasFluidProperties
      gamma = 2.35
      q = -1167e3
      q_prime = 0
      p_inf = 1.e9
      cv = 1816

      mu = 0.9
      k = 0.6
    [../]
  []
[]

[Materials]
  [./fp_mat]
    type = FluidPropertiesMaterial
    e = e
    v = v
    fp = sg
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = bc_fn
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="706e33d7-f83f-45ae-8f03-2604e0aec1bf"><div class="modal-content"><h4>test/tests/restart/restart_subapp_not_master/two_step_solve_sub_restart.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = two_step_solve_master_full_solve0_checkpoint_cp/0002_mesh.cpr
[]

[Problem]
  restart_file_base = two_step_solve_master_full_solve0_checkpoint_cp/LATEST
  force_restart = true
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

# Initial Condition will come from the restart file

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./average]
    type = ElementAverageValue
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  end_time = 2.0
  dt = 1.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0b603a29-2c26-41b0-975c-4b332a9858ae"><div class="modal-content"><h4>test/tests/outputs/debug/show_var_residual_norms_debug.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fnu]
    type = ParsedFunction
    value = -5.8*(x+y)+x*x*x-x+y*y*y-y
  [../]
  [./forcing_fnv]
    type = ParsedFunction
    value = -4
  [../]

  [./slnu]
    type = ParsedGradFunction
    value = x*x*x-x+y*y*y-y
    grad_x = 3*x*x-1
    grad_y = 3*y*y-1
  [../]
  [./slnv]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]

  #NeumannBC functions
  [./bc_fnut]
    type = ParsedFunction
    value = 3*y*y-1
  [../]
  [./bc_fnub]
    type = ParsedFunction
    value = -3*y*y+1
  [../]
  [./bc_fnul]
    type = ParsedFunction
    value = -3*x*x+1
  [../]
  [./bc_fnur]
    type = ParsedFunction
    value = 3*x*x-1
  [../]
[]

[Variables]
  [./u]
    order = THIRD
    family = HIERARCHIC
  [../]
  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff1 diff2 test1 forceu forcev react&#x27;
  [./diff1]
    type = Diffusion
    variable = u
  [../]
  [./test1]
    type = CoupledConvection
    variable = u
    velocity_vector = v
  [../]
  [./diff2]
    type = Diffusion
    variable = v
  [../]
  [./react]
    type = Reaction
    variable = u
  [../]

  [./forceu]
    type = BodyForce
    variable = u
    function = forcing_fnu
  [../]
  [./forcev]
    type = BodyForce
    variable = v
    function = forcing_fnv
  [../]

[]

[BCs]
  active = &#x27;bc_u_tb bc_v bc_ul bc_ur bc_ut bc_ub&#x27;
  [./bc_u]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_v]
    type = FunctionDirichletBC
    variable = v
    function = slnv
    boundary = &#x27;left right top bottom&#x27;
  [../]

  [./bc_u_lr]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = slnu
    boundary = &#x27;left right top bottom&#x27;
    penalty = 1e6
  [../]
  [./bc_u_tb]
    type = CoupledKernelGradBC
    variable = u
    var2 = v
    vel = &#x27;0.1 0.1&#x27;
    boundary = &#x27;top bottom left right&#x27;
  [../]

  [./bc_ul]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnul
    boundary = &#x27;left&#x27;
  [../]
  [./bc_ur]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnur
    boundary = &#x27;right&#x27;
  [../]
  [./bc_ut]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnut
    boundary = &#x27;top&#x27;
  [../]
  [./bc_ub]
    type = FunctionNeumannBC
    variable = u
    function = bc_fnub
    boundary = &#x27;bottom&#x27;
  [../]
[]

[Preconditioning]
  active = &#x27; &#x27;
  [./prec]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active=&#x27;L2u L2v&#x27;
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2u]
    type = ElementL2Error
    variable = u
    function = slnu
  [../]
  [./L2v]
    type = ElementL2Error
    variable = v
    function = slnv
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options = &#x27;-snes&#x27;
  nl_rel_tol = 1e-15
  nl_abs_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="abd4a44b-1f14-4170-8642-519ee956e5db"><div class="modal-content"><h4>modules/heat_conduction/test/tests/heat_conduction/coupled_convective_heat_flux/on_off.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./t_infinity]
  [../]

  [./active]
    initial_condition = 1
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    value = 1000
  [../]
[]

[AuxKernels]
  [./t_infinity]
    type = ConstantAux
    variable = t_infinity
    value = 500
    execute_on = initial
  [../]

  [./active_right]
    type = ConstantAux
    variable = active
    value = 0
    boundary = right
  [../]
[]

[BCs]
  [./right]
    type = CoupledConvectiveHeatFluxBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    htc = 10
    T_infinity = t_infinity
    scale_factor = active
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="852887a9-dc40-4efa-a55a-67f587f2e37c"><div class="modal-content"><h4>test/tests/multiapps/restart_subapp_ic/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 10
[]

[Functions]
  [./u_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = u_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1d503a40-298a-4b7c-a20c-1eeb411f3f8b"><div class="modal-content"><h4>test/tests/kernels/block_kernel/block_kernel_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
  uniform_refine = 1
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1.0
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
    function = &#x27;x+y&#x27;
  [../]

  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  dt = 0.1
  num_steps = 10
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d39f2319-44a8-4349-b97b-31520dfc4f42"><div class="modal-content"><h4>test/tests/transfers/multiapp_conservative_transfer/sub_userobject.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 8
  xmax = 0.1
  ymax = 0.5
[]

[Variables]
  [./u]
    initial_condition = 1
  [../]
[]

[AuxVariables]
  [./layered_average_value]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Postprocessors]
  [./from_postprocessor]
    type = ElementIntegralVariablePostprocessor
    variable = layered_average_value
    execute_on = &#x27;nonlinear TIMESTEP_END&#x27;
  [../]
[]

[Functions]
  [./axial_force]
    type = ParsedFunction
    value = 1000*y
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = axial_force
  [../]
[]

[AuxKernels]
  [./layered_aux]
    type = SpatialUserObjectAux
    variable = layered_average_value
    execute_on = &#x27;nonlinear TIMESTEP_END&#x27;
    user_object = layered_average
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[UserObjects]
  [./layered_average]
    type = LayeredAverage
    variable = u
    direction = y
    num_layers = 4
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  dt = 0.001

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[Problem]
  coord_type = rz
  type = FEProblem
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="69a8222d-2ced-4649-9bbd-187d821941b1"><div class="modal-content"><h4>test/tests/interfacekernels/2d_interface/coupled_value_coupled_flux_dot.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 2
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 4
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    function = 0.1*t
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = PenaltyInterfaceDiffusionDot
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = TRUE
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27; lu       superlu_dist                &#x27;
  dt = 0.1
  num_steps = 10
  dtmin = 0.1
  line_search = none
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0f9be7b0-5b9c-4893-b3e6-d9562fb5ab82"><div class="modal-content"><h4>test/tests/postprocessors/avg_nodal_var_value/avg_nodal_var_value.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = AverageNodalVariableValue
    variable = u
    boundary = 10
  [../]

  [./node4]
    type = AverageNodalVariableValue
    variable = v
    boundary = 13
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_avg_nodal_var_value
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b8008e06-c99a-467f-b0f3-04e39762339e"><div class="modal-content"><h4>test/tests/vectorpostprocessors/element_variables_difference_max/element_variables_difference_max.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
  ny = 10
  nz = 10
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./forcing_v]
    type = ParsedFunction
    value = &#x27;x * y * z&#x27;
  [../]
[]

[Kernels]
  [./diffusion_u]
    type = Diffusion
    variable = u
  [../]
  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diffusion_v]
    type = Diffusion
    variable = v
  [../]
  [./forcing_v]
    type = BodyForce
    variable = v
    function = forcing_v
  [../]
  [./time_v]
    type = TimeDerivative
    variable = v
  [../]
[]

[BCs]
  [./bottom]
    type = DirichletBC
    variable = &#x27;u&#x27;
    boundary = &#x27;bottom&#x27;
    value = 1
  [../]

  [./top]
    type = DirichletBC
    variable = &#x27;u&#x27;
    boundary = &#x27;top&#x27;
    value = 0
  [../]
[]

[VectorPostprocessors]
  [./difference]
    type = ElementVariablesDifferenceMax
    compare_a = u
    compare_b = v
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 2
  dt = 1
  solve_type = PJFNK
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2f732fe4-b133-4a17-90dc-1e3fa4660dd1"><div class="modal-content"><h4>test/tests/bcs/nodal_normals/cylinder_hexes.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cylinder-hexes.e
[]

[Functions]
  [./all_bc_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]
[]

[NodalNormals]
  boundary = &#x27;1&#x27;
  corner_boundary = 100
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = &#x27;all_bc_fn&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="61b45f9f-a5d5-4e4e-a481-daf2822c9c89"><div class="modal-content"><h4>test/tests/restart/restart_subapp_not_master/two_step_solve_master.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  active = &#x27;&#x27;
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./average]
    type = ElementAverageValue
    variable = u
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  start_time = 2.0
  end_time = 4.0
  dt = 1.0
[]

[MultiApps]
  [./full_solve]
    type = FullSolveMultiApp
    execute_on = initial
    positions = &#x27;0 0 0&#x27;
    # input file will come from cli-args
  [../]
[]

[Transfers]
  [./transfer_u]
    type = MultiAppProjectionTransfer
    multi_app = full_solve
    direction = FROM_MULTIAPP
    variable = u
    source_variable = u
  [../]
[]

[Outputs]
  #file_base will come from cli-args
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="130d808a-3c7b-4e2a-9b60-ea7ce40584ea"><div class="modal-content"><h4>test/tests/mortar/continuity-2d-conforming/conforming_two_var.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [file]
    type = FileMeshGenerator
    file = 2blk-conf.e
  []
  [secondary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;101&#x27;
    new_block_id = &#x27;10001&#x27;
    new_block_name = &#x27;secondary_lower&#x27;
  []
  [primary]
    input = secondary
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;100&#x27;
    new_block_id = &#x27;10000&#x27;
    new_block_name = &#x27;primary_lower&#x27;
  []
[]

[Functions]
  [./exact_sln]
    type = ParsedFunction
    value = y
  [../]
  [./ffn]
    type = ParsedFunction
    value = 0
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]

  [./lm_u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;secondary_lower&#x27;
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]

  [./lm_v]
    order = FIRST
    family = LAGRANGE
    block = &#x27;secondary_lower&#x27;
  [../]

[]

[Kernels]
  [./diff_u]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
  [./diff_v]
    type = Diffusion
    variable = v
  [../]
  [./coupled_u]
    type = CoupledForce
    variable = v
    v = u
  [../]
[]

[Constraints]
  [./ced_u]
    type = EqualValueConstraint
    variable = lm_u
    secondary_variable = u
    primary_boundary = 100
    primary_subdomain = 10000
    secondary_boundary = 101
    secondary_subdomain = 10001
  [../]
  [./ced_v]
    type = EqualValueConstraint
    variable = lm_v
    secondary_variable = v
    primary_boundary = 100
    primary_subdomain = 10000
    secondary_boundary = 101
    secondary_subdomain = 10001
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1 2 3 4&#x27;
    function = exact_sln
  [../]
  [./allv]
    type = DirichletBC
    variable = v
    boundary = &#x27;1 2 3 4&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  [./l2_error]
    type = ElementL2Error
    variable = u
    function = exact_sln
    block = &#x27;1 2&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./l2_v]
    type = ElementL2Norm
    variable = v
    block = &#x27;1 2&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./fmp]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
  l_tol = 1e-12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="22df9a46-e1e4-4ed6-b69f-bbfed1f6161e"><div class="modal-content"><h4>test/tests/time_integrators/actually_explicit_euler_verification/ee-2d-linear-adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = (x+y)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*(x+y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  [./Markers]
    [./box]
      bottom_left = &#x27;-0.4 -0.4 0&#x27;
      inside = refine
      top_right = &#x27;0.4 0.4 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  start_time = 0.0
  num_steps = 4
  dt = 0.005
  l_tol = 1e-12

  [./TimeIntegrator]
    type = ActuallyExplicitEuler
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6a493b2c-3849-4b25-85ca-cf10cbfe19df"><div class="modal-content"><h4>test/tests/mortar/continuity-2d-conforming/conforming.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [file]
    type = FileMeshGenerator
    file = 2blk-conf.e
  []
  [secondary]
    input = file
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;101&#x27;
    new_block_id = &#x27;10001&#x27;
    new_block_name = &#x27;secondary_lower&#x27;
  []
  [primary]
    input = secondary
    type = LowerDBlockFromSidesetGenerator
    sidesets = &#x27;100&#x27;
    new_block_id = &#x27;10000&#x27;
    new_block_name = &#x27;primary_lower&#x27;
  []
[]

[Functions]
  [./exact_sln]
    type = ParsedFunction
    value = y
  [../]
  [./ffn]
    type = ParsedFunction
    value = 0
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]

  [./lm]
    order = FIRST
    family = LAGRANGE
    block = &#x27;secondary_lower&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[Constraints]
  [./ced]
    type = EqualValueConstraint
    variable = lm
    secondary_variable = u
    primary_boundary = 100
    primary_subdomain = 10000
    secondary_boundary = 101
    secondary_subdomain = 10001
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1 2 3 4&#x27;
    function = exact_sln
  [../]
[]

[Postprocessors]
  [./l2_error]
    type = ElementL2Error
    variable = u
    function = exact_sln
    block = &#x27;1 2&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./fmp]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-11
  l_tol = 1e-10
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a92ce018-b289-4bd3-86a9-8bc0fc5b442f"><div class="modal-content"><h4>test/tests/postprocessors/pps_interval/pps_interval_mismatch.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
  # This test can only be run with renumering disabled, so the
  # NodalVariableValue postprocessor&#x27;s node id is well-defined.
  allow_renumbering = false
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  active = &#x27;l2 node1 node4&#x27;

  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = NodalVariableValue
    variable = u
    nodeid = 15
  [../]

  [./node4]
    type = NodalVariableValue
    variable = v
    nodeid = 10
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  interval = 4
  exodus = true
  [./console]
    type = Console
    interval = 3
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="267c31b8-c96e-40f4-8e0c-ece9d30583fd"><div class="modal-content"><h4>test/tests/preconditioners/pbp/pbp_dg_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL
  [../]

  [./v]
    order = FIRST
    family = MONOMIAL
  [../]
[]

[Preconditioning]
  [./PBP]
    type = PBP
    solve_order = &#x27;u v&#x27;
    preconditioner  = &#x27;AMG AMG&#x27;
  [../]
[]

[Kernels]
  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./abs_u]
    type = Reaction
    variable = u
  [../]

  [./forcing_u]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]

  [./abs_v]
    type = Reaction
    variable = v
  [../]

  [./forcing_v]
    type = BodyForce
    variable = v
    function = forcing_fn
  [../]

  [./conv_v]
    type = CoupledForce
    variable = v
    v = u
  [../]
[]

[DGKernels]
  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
  [../]

  [./dg_diff_2]
    type = DGDiffusion
    variable = v
    epsilon = -1
    sigma = 6
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]

  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))
  [../]
[]

[BCs]
  [./all_u]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]

  [./all_v]
    type = DGFunctionDiffusionDirichletBC
    variable = v
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Problem]
  type = FEProblem
  error_on_jacobian_nonzero_reallocation = true
[]

[Executioner]
  type = Steady

  l_max_its = 10
  nl_max_its = 10

  solve_type = JFNK
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="15af39a9-049d-4bad-adb5-8c225176cd24"><div class="modal-content"><h4>test/tests/postprocessors/num_nodes/num_nodes.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  nz = 0
  zmax = 0
  elem_type = QUAD4
  uniform_refine = 1
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
    order = FIRST
    family = LAGRANGE
  [../]
  [./v_aux]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 3
  dt = 1
  solve_type = PJFNK
[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 3
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Postprocessors]
  [./num_nodes]
    type = NumNodes
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="eb8f05dc-131e-4b49-b486-c0ffd83ed435"><div class="modal-content"><h4>test/tests/auxkernels/element_aux_var/block_global_depend_elem_aux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./coupled_left]
    order = CONSTANT
    family = MONOMIAL
    block = 1
  [../]

  [./coupled_right]
    order = CONSTANT
    family = MONOMIAL
    block = 2
  [../]

  [./two]
    order = CONSTANT
    family = MONOMIAL
    initial_condition = 0
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[AuxKernels]
  [./coupled_left]
    variable = coupled_left
    type = CoupledAux
    value = 8
    operator = /
    coupled = two
  [../]

  [./coupled_right]
    variable = coupled_right
    type = CoupledAux
    value = 8
    operator = /
    coupled = two
  [../]

  [./two]
    type = ConstantAux
    variable = two
    value = 2
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b32c7c4f-e0f1-4089-8465-d6f7c5a03472"><div class="modal-content"><h4>modules/richards/test/tests/jacobian_2/jnQ2P.i</h4><pre class="moose-pre"><code class="language-text"># quick two phase

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
[]


[UserObjects]
  [./DensityWater]
    type = RichardsDensityConstBulkCut
    dens0 = 1
    cut_limit = 1.1
    zero_point = -1.1
    bulk_mod = 1.0 # notice small quantity, so the PETSc constant state works
  [../]
  [./DensityGas]
    type = RichardsDensityConstBulk
    dens0 = 0.5
    bulk_mod = 0.5 # notice small quantity, so the PETSc constant state works
  [../]
  [./RelPermWater]
    type = RichardsRelPermPower
    simm = 0.2
    n = 2
  [../]
  [./RelPermWaterCubic]
    type = RichardsRelPermMonomial
    simm = 0.05
    n = 3
  [../]
  [./RelPermGas]
    type = Q2PRelPermPowerGas
    simm = 0.1
    n = 3
  [../]
[]

[Variables]
  [./pp]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      block = 0
      min = 0
      max = 1
    [../]
  [../]
  [./sat]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      block = 0
      min = 0
      max = 1
    [../]
  [../]
  [./nonQ2P_var]
  []
[]

[Q2P]
  porepressure = pp
  saturation = sat
  water_density = DensityWater
  water_relperm = RelPermWater
  water_relperm_for_diffusion = RelPermWaterCubic
  water_viscosity = 1
  gas_density = DensityGas
  gas_relperm = RelPermGas
  gas_viscosity = 1
  diffusivity = 1E-2
[]

[Kernels]
  [./nonQ2P_variable_check]
    type = BodyForce
    variable = nonQ2P_var
    function = 0
  [../]
[]


[Materials]
  [./rock]
    type = Q2PMaterial
    block = 0
    mat_porosity = 0.1
    mat_permeability = &#x27;1.1 0 0  0 2.2 0  0 0 3.3&#x27;
    gravity = &#x27;1 2 3&#x27;
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    #petsc_options = &#x27;-snes_test_display&#x27;
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it -snes_type&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-15 1E-10 10000 test&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = jnQ2P
  exodus = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ee17f4d6-db8e-4181-a472-98c843ae34c1"><div class="modal-content"><h4>test/tests/materials/material/material_test_dg.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = sq-2blk.e
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = MONOMIAL

    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[Functions]
  active = &#x27;forcing_fn exact_fn&#x27;

  [./forcing_fn]
    type = ParsedFunction
    value = (x*x*x)-6.0*x
  [../]

  [./exact_fn]
    type = ParsedGradFunction

    value = (x*x*x)
    grad_x = 3*x*x
    grad_y = 0
  [../]
[]

[Kernels]
  active = &#x27;diff abs forcing&#x27;

  [./diff]
    type = MatDiffusionTest
    variable = u
    prop_name = matp
  [../]

  [./abs]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  active = &#x27;dgdiff&#x27;

  [./dgdiff]
    type = DGDiffusion
    variable = u
    sigma = 6
    epsilon = -1.0
    diff = matp
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = DGMDDBC
    variable = u
    boundary = &#x27;1 2 3 4&#x27;
    function = exact_fn
    prop_name = matp
    sigma = 6
    epsilon = -1.0
  [../]
[]

[Materials]
  active = &#x27;mat_1 mat_2&#x27;

  [./mat_1]
    type = MTMaterial
    block = 1
    value = 1
  [../]

  [./mat_2]
    type = MTMaterial
    block = 2
    value = 2
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out_dg
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="73364374-2d9d-4e99-a0f9-6bd1eb93d397"><div class="modal-content"><h4>test/tests/multiapps/picard/function_dt_master.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  ymin = 0
  xmax = 1
  ymax = 1
  nx = 10
  ny = 10
[]

[Functions]
  [./v_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]

  [./dts]
    type = PiecewiseLinear
    x = &#x27;0.1  10&#x27;
    y = &#x27;0.1  10&#x27;
  [../]
[]

[AuxVariables]
  [./v]
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./ufn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = v_fn
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-10
  picard_max_its = 2
  start_time = 0
  num_steps = 3
  [./TimeStepper]
    type = FunctionDT
    function = dts
  [../]
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./sub_app]
    app_type = MooseTestApp
    type = TransientMultiApp
    input_files = &#x27;function_dt_sub.i&#x27;
    execute_on = timestep_end
    positions = &#x27;0 -1 0&#x27;
  [../]
[]

[Transfers]
  [./from_sub]
    type = MultiAppNearestNodeTransfer
    direction = from_multiapp
    multi_app = sub_app
    source_variable = u
    variable = v
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dccd91f7-6658-49dc-b921-bf8bbd7a4d08"><div class="modal-content"><h4>test/tests/materials/material/exception_material.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./mat]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./time_derivative]
    type = TimeDerivative
    variable = u
  [../]
  [./diff]
    type = MatDiffusionTest
    variable = u
    prop_name = matp
  [../]
  [./f]
    type = BodyForce
    variable = u
    function = &#x27;20&#x27;
  [../]
[]

[AuxKernels]
  [./mat]
    # Sequence of events:
    # 1.) MaterialRealAux is re-evaluated every linear iteration
    # 2.) MaterialRealAux calls ExceptionMaterial::computeQpProperties()
    # 3.) ExceptionMaterial throws a MooseException.
    # 4.) The MooseException is caught and handled by MOOSE.
    # 5.) The next solve is automatically failed.
    # 6.) Time timestep is cut and we try again.
    #
    # The idea is to test that MOOSE can recover when exceptions are
    # thrown during AuxKernel evaluation, and not just nonlinear
    # residual/jacobian evaluation.
    type = MaterialRealAux
    variable = mat
    property = matp
  [../]
[]

[BCs]
  [./all]
    type = DirichletBC
    variable = u
    boundary = &#x27;left top bottom right&#x27;
    value = 0
  [../]
[]

[Materials]
  [./mat]
    type = ExceptionMaterial
    block = 0
    rank = 0
    coupled_var = u
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.1
  end_time = .5
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4c7e96c4-18ba-4d82-b974-6ca1adac14a5"><div class="modal-content"><h4>test/tests/interfacekernels/3d_interface/coupled_value_coupled_flux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
    nz = 2
    zmax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 1&#x27;
    block_id = 1
  [../]
  [./break_boundary]
    input = subdomain1
    type = BreakBoundaryOnSubdomainGenerator
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = break_boundary
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 back_to_0 right top front&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1 back_to_1&#x27;
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b508e250-b768-4ab6-a600-8584a41726a7"><div class="modal-content"><h4>test/tests/multiapps/grid-sequencing/vi-coarse.i</h4><pre class="moose-pre"><code class="language-text">l=10
nx=40
num_steps=2

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = ${l}
  nx = ${nx}
[]

[Variables]
  [u]
  []
[]

[AuxVariables]
  [bounds][]
[]

[Bounds]
  [./u_upper_bound]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = upper
    bound_value = ${l}
  [../]
  [./u_lower_bound]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = lower
    bound_value = 0
  [../]
[]

[ICs]
  [u]
    type = FunctionIC
    variable = u
    function = &#x27;x&#x27;
  []
[]

[Kernels]
  [time]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = &#x27;if(x&lt;5,-1,1)&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    boundary = left
    value = 0
    variable = u
  []
  [right]
    type = DirichletBC
    boundary = right
    value = ${l}
    variable = u
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  num_steps = ${num_steps}
  solve_type = NEWTON
  dtmin = 1
  petsc_options = &#x27;-snes_vi_monitor&#x27;
  petsc_options_iname = &#x27;-snes_max_linear_solve_fail -ksp_max_it -pc_type -sub_pc_factor_levels -snes_linesearch_type -snes_type&#x27;
  petsc_options_value = &#x27;0                           30          asm      16                    basic                 vinewtonrsls&#x27;
[]

[Outputs]
  exodus = true
  [csv]
    type = CSV
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  active = &#x27;upper_violations lower_violations&#x27;
  [upper_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = ${fparse 10+1e-8}
    comparator = &#x27;greater&#x27;
  []
  [lower_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = -1e-8
    comparator = &#x27;less&#x27;
  []
  [nls]
    type = NumNonlinearIterations
  []
  [cum_nls]
    type = CumulativeValuePostprocessor
    postprocessor = nls
  []
[]

[MultiApps]
  [./coarser]
    type = TransientMultiApp
    app_type = MooseTestApp
    execute_on = timestep_begin
    positions = &#x27;0 0 0&#x27;
    input_files = vi-coarser.i
  [../]
[]

[Transfers]
  [./mesh_function_begin]
    type = MultiAppMeshFunctionTransfer
    direction = from_multiapp
    multi_app = coarser
    source_variable = u
    variable = u
    execute_on = timestep_begin
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ff94fb96-156e-44cf-b596-41ead7ba20a5"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-1-3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  zmin = -1
  zmax = 1
  nx = 5
  ny = 5

  elem_type = HEX8
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 1
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -1
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 1
  [../]
  [./bc_fnf]
    type = ParsedFunction
    value = 1
  [../]
  [./bc_fnk]
    type = ParsedFunction
    value = -1
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x+y+z
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x+y+z
    grad_x = 1
    grad_y = 1
    grad_z = 1
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
  [./bc_front]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;front&#x27;
    function = bc_fnf
  [../]
  [./bc_back]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;back&#x27;
    function = bc_fnk
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="017cfffb-177d-4b76-9152-066958809f88"><div class="modal-content"><h4>test/tests/multiapps/grid-sequencing/vi-coarser.i</h4><pre class="moose-pre"><code class="language-text">l=10
nx=20
num_steps=2

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = ${l}
  nx = ${nx}
[]

[Variables]
  [u]
  []
[]

[AuxVariables]
  [bounds][]
[]

[Bounds]
  [./u_upper_bounds]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = upper
    bound_value = ${l}
  [../]
  [./u_lower_bounds]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = lower
    bound_value = 0
  [../]
[]

[ICs]
  [u]
    type = FunctionIC
    variable = u
    function = &#x27;x&#x27;
  []
[]

[Kernels]
  [time]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = &#x27;if(x&lt;5,-1,1)&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    boundary = left
    value = 0
    variable = u
  []
  [right]
    type = DirichletBC
    boundary = right
    value = ${l}
    variable = u
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  num_steps = ${num_steps}
  solve_type = NEWTON
  dtmin = 1
  petsc_options = &#x27;-snes_vi_monitor&#x27;
  petsc_options_iname = &#x27;-snes_max_linear_solve_fail -ksp_max_it -pc_type -sub_pc_factor_levels -snes_linesearch_type -snes_type&#x27;
  petsc_options_value = &#x27;0                           30          asm      16                    basic                 vinewtonrsls&#x27;
[]

[Outputs]
  exodus = true
  [csv]
    type = CSV
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  active = &#x27;upper_violations lower_violations&#x27;
  [upper_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = ${fparse 10+1e-8}
    comparator = &#x27;greater&#x27;
  []
  [lower_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = -1e-8
    comparator = &#x27;less&#x27;
  []
  [nls]
    type = NumNonlinearIterations
  []
  [cum_nls]
    type = CumulativeValuePostprocessor
    postprocessor = nls
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c6e9f8df-5c8e-4dab-a1f7-51f8a095bfee"><div class="modal-content"><h4>test/tests/mesh/custom_partitioner/custom_linear_partitioner_restart_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2

  nx = 10
  ny = 10

  xmin = 0.0
  xmax = 1.0

  ymin = 0.0
  ymax = 10.0

  [./Partitioner]
    type = LibmeshPartitioner
    partitioner = linear
  [../]
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;bodyforce ie&#x27;

  [./bodyforce]
    type = BodyForce
    variable = u
    value = 10.0
  [../]

  [./ie]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 10
  dt = .1
[]

[Outputs]
  file_base =  custom_linear_partitioner_restart_test_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="165e27d2-9794-4994-95d4-13f8bc03d7e0"><div class="modal-content"><h4>test/tests/variables/fe_hier/hier-2-2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Functions]
  [./bc_fnt]
    type = ParsedFunction
    value = 2*y
  [../]
  [./bc_fnb]
    type = ParsedFunction
    value = -2*y
  [../]
  [./bc_fnl]
    type = ParsedFunction
    value = -2*x
  [../]
  [./bc_fnr]
    type = ParsedFunction
    value = 2*x
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = -4+x*x+y*y
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./bc_top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = bc_fnt
  [../]
  [./bc_bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bc_fnb
  [../]
  [./bc_left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fnl
  [../]
  [./bc_right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = bc_fnr
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2df4047d-83ef-476b-9bf2-9f603430736b"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/pod_rb/internal/sub.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  type = FEProblem
  extra_tag_vectors  = &#x27;diff react bodyf&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 15
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = k
    extra_vector_tags = &#x27;diff&#x27;
  []
  [reaction]
    type = MaterialReaction
    variable = u
    coefficient = alpha
    extra_vector_tags = &#x27;react&#x27;
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
    extra_vector_tags = &#x27;bodyf&#x27;
  []
[]

[Materials]
  [k]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 1.0
  []
  [alpha]
    type = GenericConstantMaterial
    prop_names = alpha
    prop_values = 1.0
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="52603590-559e-4898-ad3f-77bc73cf60ec"><div class="modal-content"><h4>test/tests/multiapps/restart/sub2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 1
  nx = 10
[]

[Functions]
  [./u_fn]
    type = ParsedFunction
    value = t*x
  [../]
  [./ffn]
    type = ParsedFunction
    value = x
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./td]
    type = TimeDerivative
    variable = u
  [../]
  [./fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = right
    function = u_fn
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3c7f6404-ae24-4d7e-b779-47ff2b9c68f2"><div class="modal-content"><h4>test/tests/problems/reference_residual_problem/reference_residual.i</h4><pre class="moose-pre"><code class="language-text">coef=1

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 2
[]

[Problem]
  type = ReferenceResidualProblem
  extra_tag_vectors = &#x27;ref&#x27;
  reference_vector = &#x27;ref&#x27;
[]

[Variables]
  [u][]
  [v][]
[]

[Kernels]
  [u_diff]
    type = CoefDiffusion
    variable = u
    coef = ${coef}
  []
  [u_rxn]
    type = PReaction
    variable = u
    coefficient = ${coef}
    power = 2
  []
  [u_f]
    type = BodyForce
    variable = u
    value = ${coef}
  []
  [v_diff]
    type = Diffusion
    variable = v
  []
  [v_rxn]
    type = PReaction
    variable = v
    coefficient = 1
    power = 2
  []
  [v_f]
    type = BodyForce
    variable = v
    value = 1
  []
[]

[BCs]
  [u]
    type = RobinBC
    boundary = &#x27;left right&#x27;
    coef = ${coef}
    variable = u
    extra_vector_tags = &#x27;ref&#x27;
  []
  [v]
    type = RobinBC
    boundary = &#x27;left right&#x27;
    coef = 1
    variable = v
    extra_vector_tags = &#x27;ref&#x27;
  []
[]


[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9976fd03-49bf-4dd1-b9ac-38a0cf3e8f5a"><div class="modal-content"><h4>modules/porous_flow/test/tests/mass_conservation/mass03.i</h4><pre class="moose-pre"><code class="language-text"># checking that the mass postprocessor correctly calculates the mass
# 1phase, 1component, constant porosity, with a constant fluid source
[Mesh]
  type = GeneratedMesh
  dim = 3
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Variables]
  [./pp]
    initial_condition = -0.5
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = pp
  [../]
  [./source]
    type = BodyForce
    variable = pp
    value = 0.1 # kg/m^3/s
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;pp&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.5
    alpha = 1
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 1
      density0 = 1
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = pp
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.1
  [../]
[]

[Postprocessors]
  [./porepressure]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    variable = pp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./total_mass]
    type = PorousFlowFluidMass
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres bjacobi 1E-12 1E-20 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 1
  end_time = 10
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  file_base = mass03
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="24e213e2-308a-4cea-962e-189bec874e86"><div class="modal-content"><h4>test/tests/executioners/executioner/steady.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 5
  ny = 5
  elem_type = QUAD9
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = -4
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ffn&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_steady
  exodus = true
[]

</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="be5ff980-aa79-4e06-b56a-d786aca152d7"><div class="modal-content"><h4>modules/combined/examples/thermomechanics/circle_thermal_expansion_stress.i</h4><pre class="moose-pre"><code class="language-text"># This example problem demonstrates coupling heat conduction with mechanics.
# A circular domain has as uniform heat source that increases with time
# and a fixed temperature on the outer boundary, resulting in a temperature gradient.
# This results in heterogeneous thermal expansion, where it is pinned in the center.
# Looking at the hoop stress demonstrates why fuel pellets have radial cracks
# that extend from the outer boundary to about halfway through the radius.
# The problem is run with length units of microns.

[Mesh]
  #Circle mesh has a radius of 1000 units
  type = FileMesh
  file = circle.e
  uniform_refine = 1
[]

[Variables]
  # We solve for the temperature and the displacements
  [./T]
    initial_condition = 800
    scaling = 1e7
  [../]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./radial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./hoop_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  active = &#x27;TensorMechanics htcond Q_function&#x27;
  [./htcond] #Heat conduction equation
    type = HeatConduction
    variable = T
  [../]
  [./TensorMechanics] #Action that creates equations for disp_x and disp_y
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./Q_function] #Heat generation term
    type = BodyForce
    variable = T
    value = 1
    function = 0.8e-9*t
  [../]
[]

[AuxKernels]
  [./radial_stress] #Calculates radial stress from cartesian
    type = CylindricalRankTwoAux
    variable = radial_stress
    rank_two_tensor = stress
    index_j = 0
    index_i = 0
    center_point = &#x27;0 0 0&#x27;
  [../]
  [./hoop_stress] #Calculates hoop stress from cartesian
    type = CylindricalRankTwoAux
    variable = hoop_stress
    rank_two_tensor = stress
    index_j = 1
    index_i = 1
    center_point = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./outer_T] #Temperature on outer edge is fixed at 800K
    type = DirichletBC
    variable = T
    boundary = 1
    value = 800
  [../]
  [./outer_x] #Displacements in the x-direction are fixed in the center
    type = DirichletBC
    variable = disp_x
    boundary = 2
    value = 0
  [../]
  [./outer_y] #Displacements in the y-direction are fixed in the center
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0
  [../]
[]

[Materials]
  [./thcond] #Thermal conductivity is set to 5 W/mK
    type = GenericConstantMaterial
    block = 1
    prop_names = &#x27;thermal_conductivity&#x27;
    prop_values = &#x27;5e-6&#x27;
  [../]
  [./iso_C] #Sets isotropic elastic constants
    type = ComputeElasticityTensor
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;2.15e5 0.74e5&#x27;
    block = 1
  [../]
  [./strain] #We use small deformation mechanics
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y&#x27;
    block = 1
    eigenstrain_names = eigenstrain
  [../]
  [./stress] #We use linear elasticity
    type = ComputeLinearElasticStress
    block = 1
  [../]
  [./thermal_strain]
    type= ComputeThermalExpansionEigenstrain
    thermal_expansion_coeff = 1e-6
    temperature = T
    stress_free_temperature = 273
    block = 1
    eigenstrain_name = eigenstrain
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  num_steps = 10
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre boomeramg 101&#x27;
  l_max_its = 30
  nl_max_its = 10
  nl_abs_tol = 1e-9
  l_tol = 1e-04
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7a8ee3e6-e35b-4ef9-b619-a6a14a424628"><div class="modal-content"><h4>test/tests/interfacekernels/adaptivity/adaptivity.i</h4><pre class="moose-pre"><code class="language-text"># This input file is used for two tests:
# 1) Check that InterfaceKernels work with mesh adaptivity
# 2) Error out when InterfaceKernels are used with adaptivity
#    and stateful material prpoerties

[Mesh]
  parallel_type = &#x27;replicated&#x27;
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    ny = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
    block = 0
  [../]
  [./u_neighbor]
    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
    block = 1
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = (x*x*x)-6.0*x
  [../]

  [./bc_fn]
    type = ParsedFunction
    value = (x*x*x)
  [../]
[]

[Kernels]
  [./diff]
    type = MatDiffusionTest
    variable = u
    prop_name = diffusivity
    block = 0
  [../]
  [./abs]
    type = Reaction
    variable = u
    block = 0
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
    block = 0
  [../]
  [./diffn]
    type = MatDiffusionTest
    variable = u_neighbor
    prop_name = diffusivity
    block = 1
  [../]
  [./absn]
    type = Reaction
    variable = u_neighbor
    block = 1
  [../]
  [./forcingn]
    type = BodyForce
    variable = u_neighbor
    function = forcing_fn
    block = 1
  [../]
[]

[InterfaceKernels]
  [./flux_match]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = u_neighbor
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    function = bc_fn
  [../]
  [./u_neighbor]
    type = FunctionDirichletBC
    variable = u_neighbor
    boundary = &#x27;right&#x27;
    function = bc_fn
  [../]
[]

[Materials]
  active = &#x27;constant&#x27;
  [./stateful]
    type = StatefulTest
    prop_names = &#x27;diffusivity&#x27;
    prop_values = &#x27;1&#x27;
    block = &#x27;0 1&#x27;
  [../]
  [./constant]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusivity&#x27;
    prop_values = &#x27;1&#x27;
    block = &#x27;0 1&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;NEWTON&#x27;
[]

[Adaptivity]
  marker = &#x27;marker&#x27;
  steps = 1
  [./Markers]
    [./marker]
      type = BoxMarker
      bottom_left = &#x27;0 0 0&#x27;
      top_right = &#x27;1 1 0&#x27;
      inside = refine
      outside = coarsen
    [../]
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e161bd6f-56b8-48d5-92e9-93cd98458c94"><div class="modal-content"><h4>test/tests/vectorpostprocessors/dynamic_point_sampler/dynamic_point_sampler.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  nx = 5
  ny = 5
  dim = 2
[]

[Variables]
  [u]
  []
[]

[Functions]
  [forcing_func]
    type = ParsedFunction
    value = alpha*alpha*pi*pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;4&#x27;
  []

  [u_func]
    type = ParsedGradFunction
    value = sin(alpha*pi*x)
    grad_x   = alpha*pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;4&#x27;
  []
[]

[Kernels]
  [diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  []

  [forcing]
    type = BodyForce
    variable = u
    function = forcing_func
  []

  [time]
    type = TimeDerivative
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = &#x27;u&#x27;
    boundary = &#x27;left&#x27;
    value = 0
  []

  [right]
    type = DirichletBC
    variable = &#x27;u&#x27;
    boundary = &#x27;right&#x27;
    value = 0
  []
[]

[Executioner]
  type = Transient
  num_steps = 7
  dt = 0.1

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [l2_error]
    type = ElementL2Error
    variable = u
    function = u_func
  []

  [dofs]
    type = NumDOFs
  []
[]

[Adaptivity]
  max_h_level = 3
  marker = error
  [Indicators]
    [jump]
      type = GradientJumpIndicator
      variable = u
    []
  []
  [Markers]
    [error]
      type = ErrorFractionMarker
      indicator = jump
      coarsen = 0.1
      refine = 0.3
    []
  []
[]

[VectorPostprocessors]
  [dynamic_line_sampler]
    type = DynamicPointValueSampler
    variable = u
    start_point = &#x27;0 0.5 0&#x27;
    end_point = &#x27;1 0.5 0&#x27;
    num_points = 6
    sort_by = x
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c141ee76-0f43-4b4c-b30f-ee8914c6806c"><div class="modal-content"><h4>test/tests/postprocessors/avg_nodal_var_value/avg_nodal_var_value_ts_begin.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = AverageNodalVariableValue
    variable = u
    boundary = 10
    execute_on = TIMESTEP_BEGIN
  [../]

  [./node4]
    type = AverageNodalVariableValue
    variable = v
    boundary = 13
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_avg_nodal_var_value_ts_begin
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4d68d5e0-0d55-4581-8573-20f8abe6302f"><div class="modal-content"><h4>modules/stochastic_tools/examples/surrogates/polynomial_regression/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 1
  elem_type = EDGE3
[]

[Variables]
  [T]
    order = SECOND
    family = LAGRANGE
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = T
    diffusivity = k
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[Materials]
  [conductivity]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 2.0
  []
[]

[BCs]
  [right]
    type = DirichletBC
    variable = T
    boundary = right
    value = 300
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [max]
    type = NodalExtremeValue
    variable = T
    value_type = max
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="00f2f0be-e07a-403a-8492-a77bda481cd2"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_rz_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      rz
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in cylindrical coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with thermal conductivity
#   dependent upon the transient level set function. This problem can be
#   exactly evaluated by FEM/Moose without the moving interface. Both the
#   temperature and level set function are designed to be linear to attempt to
#   minimize the error between the Moose/exact solution and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=1, y=1) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time   Expected Temperature   XFEM Calculated Temperature
#      0.2                 440        440
#      0.4                 480        479.9998717
#      0.6                 520        519.9994963
#      0.8                 560        559.9989217
#      1.0                 600        599.9986735
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 1.0
  xmax = 2.0
  ymin = 1.0
  ymax = 2.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
    [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+400) + t*(-2.5*y/(2.04*x) + 155/x - t/(2.04*x)
            - 7.5/2.04)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.01/2.04)*(-2.5*x-2.5*y-t)+1.55)*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+200)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+200)*t+400&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.01/2.04)*(-2.5*x-2.5*y-t) + 1.55&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 2.04 -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="749d1885-437d-4a0a-82ba-852abfeb5467"><div class="modal-content"><h4>modules/level_set/test/tests/verification/1d_level_set_supg_mms/1d_level_set_supg_mms.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 32
  nx = 64
[]

[Variables]
  [./phi]
  [../]
[]

[AuxVariables]
  [./velocity]
    family = LAGRANGE_VEC
  [../]
[]

[ICs]
  [./phi_ic]
    function = phi_exact
    variable = phi
    type = FunctionIC
  [../]
  [./vel_ic]
    type = VectorFunctionIC
    variable = velocity
    function = velocity_func
  []
[]

[Functions]
  [./phi_exact]
    type = ParsedFunction
    value = &#x27;a*exp(1/(10*t))*sin(2*pi*x/b) + 1&#x27;
    vars = &#x27;a b&#x27;
    vals = &#x27;1 8&#x27;
  [../]
  [./phi_mms]
    type = ParsedFunction
    value = &#x27;-a*exp(1/(10*t))*sin(2*pi*x/b)/(10*t^2) + 2*pi*a*exp(1/(10*t))*cos(2*pi*x/b)/b&#x27;
    vars = &#x27;a b&#x27;
    vals = &#x27;1 8&#x27;
  [../]
  [./velocity_func]
    type = ParsedVectorFunction
    value_x = &#x27;1&#x27;
    value_y = &#x27;1&#x27;
  [../]
[]

[Kernels]
  [./time]
    type = TimeDerivative
    variable = phi
  [../]
  [./time_supg]
    type = LevelSetTimeDerivativeSUPG
    variable = phi
    velocity = velocity
  [../]
  [./phi_advection]
    type = LevelSetAdvection
    variable = phi
    velocity = velocity
  [../]
  [./phi_forcing]
    type = BodyForce
    variable = phi
    function = phi_mms
  [../]
  [./phi_advection_supg]
    type = LevelSetAdvectionSUPG
    variable = phi
    velocity = velocity
  [../]
  [./phi_forcing_supg]
    type = LevelSetForcingFunctionSUPG
    velocity = velocity
    variable = phi
    function = phi_mms
  [../]
[]

[Postprocessors]
  [./error]
    type = ElementL2Error
    function = phi_exact
    variable = phi
  [../]
  [./h]
    type = AverageElementSize
  [../]
  [./point]
    type = PointValue
    point = &#x27;0.1 0 0&#x27;
    variable = phi
  [../]
[]

[Executioner]
  type = Transient
  start_time = 1
  dt = 0.01
  end_time = 1.25
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_sub_type&#x27;
  petsc_options_value = &#x27;asm      ilu&#x27;
  scheme = bdf2
  nl_rel_tol = 1e-12
[]

[Outputs]
  interval = 10
  execute_on = &#x27;timestep_end&#x27;
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="378b2f6f-20d8-4f27-857b-170448ccf8ce"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_discrete2mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types:discrete homog 2 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description
#   A transient heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance in the presence of a moving interface separating two
#   discrete material regions for linear element models. Both the temperature
#   solution and level set function are designed to be linear to attempt to
#   minimize error between the exact solution and XFEM results. Thermal
#   conductivity, density, and heat capacity are homogeneous in each material
#   region with a discontinuous jump in thermal flux between the two material
#   regions.
# Results:
#   The temperature at the left boundary is determined by the analytical
#   solution, so temperature at the right boundary (x=1) should exhibit the
#   largest difference between the analytical solution and XFEM results. We
#   present the analytical and XFEM results at the material interface position
#   and right side boundary at various times.
#  Interface:
#     Time    Expected Temperature    XFEM Calculated Temperature
#       20       746.75                  746.7235521
#       40       893.05                  893.0379081
#       60      1040.15                 1040.1527530
#
#  Right Boundary (x=1):
#     Time    Expected Temperature    XFEM Calculated Temperature
#       20       720                     719.9708681
#       40       840                     839.9913293
#       60       960                     960.0100886
#
# IMPORTANT NOTE:
#   When running this input file, add the --allow-test-objects tag!!!
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = phi
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./phi]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = &#x27;diffusion_coefficient&#x27;
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = phi
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    jump_flux = jump_flux_func
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;phi:=(0.75-x-0.001*t);
        i:=(0.75-0.001*t);
        if (phi&gt;=0,
            10*(8-x),
            (7/(1-i))*((i-2)*x + (8-7*i)) )&#x27;
  [../]
  [./right_du_func]
    type = ParsedFunction
    value = &#x27;i:=(0.75-0.001*t);
        (2.0/(1-i))*(-5+5*i+i*t-2*t)&#x27;
  [../]
  [./exact_u_func]
    type = ParsedFunction
    value = &#x27;phi:=(0.75-x-0.001*t);
        i:=(0.75-0.001*t);
        if (phi&gt;=0,
            605 - 5*x + t*(8-x),
            (1/(1-i))*((-5+5*i+i*t-2*t)*x + (605-605*i+8*t-7*t*i)) )&#x27;
  [../]
  [./jump_flux_func]
    type = ParsedFunction
    value = &#x27;i:=(0.75-0.001*t);
        k_1:=(20.0);
        k_2:=(2.0);
        k_1*(5+t) + (k_2/(1-i))*(-5+5*i+i*t-2*t)&#x27;
  [../]

  [./ls_func]
    type = ParsedFunction
    value = &#x27;0.75 - x - 0.001*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;A_rhoCp B_rhoCp&#x27;
    prop_values = &#x27;10 7&#x27;
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;A_diffusion_coefficient B_diffusion_coefficient&#x27;
    prop_values = &#x27;20.0 2.0&#x27;
  [../]

  [./combined_rhoCp]
    type = LevelSetBiMaterialReal
    levelset_positive_base = &#x27;A&#x27;
    levelset_negative_base = &#x27;B&#x27;
    level_set_var = phi
    prop_name = rhoCp
  [../]
  [./combined_diffusion_coefficient]
    type = LevelSetBiMaterialReal
    levelset_positive_base = &#x27;A&#x27;
    levelset_negative_base = &#x27;B&#x27;
    level_set_var = phi
    prop_name = diffusion_coefficient
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    function = exact_u_func
  [../]
  [./right_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_du_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 600
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  # petsc_options_value = &#x27;hypre boomeramg&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 20
  end_time = 60.0
  max_xfem_update = 2
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d7440d0a-9f70-4c22-b743-5f79d2899ddc"><div class="modal-content"><h4>test/tests/time_integrators/rk-2/2d-quadratic.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 20
  ny = 20
  elem_type = QUAD9
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*((x*x)+(y*y))-(4*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*((x*x)+(y*y))
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  [./TimeIntegrator]
    type = ExplicitMidpoint
  [../]
  solve_type = &#x27;LINEAR&#x27;

  start_time = 0.0
  num_steps = 10
  dt = 0.0001
  l_tol = 1e-8
[]

[Outputs]
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f250280e-060d-4c7c-a418-ab5bc7076c5e"><div class="modal-content"><h4>test/tests/interfacekernels/3d_interface/coupled_value_coupled_flux_with_jump_material.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
    nz = 2
    zmax = 2
  []
  [./subdomain1]
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 1&#x27;
    block_id = 1
    input = gen
  [../]
  [./break_boundary]
    input = subdomain1
    type = BreakBoundaryOnSubdomainGenerator
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = break_boundary
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]



[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[AuxVariables]
  [./jump_var]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [jump_aux]
    type = MaterialRealAux
    boundary = primary0_interface
    property = jump
    variable = jump_var
  []
[]


[InterfaceKernels]
  [./interface]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
    jump_prop_name = jump
  [../]
[]

[Materials]
  [./jump]
    type = JumpInterfaceMaterial
    var = u
    neighbor_var = v
    boundary = primary0_interface
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 back_to_0 right top front&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1 back_to_1&#x27;
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
  [interface_var_jump]
    type = InterfaceAverageVariableValuePostprocessor
    interface_value_type = jump_abs
    variable = u
    neighbor_variable = v
    execute_on = TIMESTEP_END
    boundary = primary0_interface
  []
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bf1ed327-5da7-44ca-abf5-b09a70deb1d8"><div class="modal-content"><h4>test/tests/outputs/residual/output_residual_elem.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = sq-2blk.e
  uniform_refine = 3
[]

[Variables]
  # variable in the whole domain
  [./u]
    order = CONSTANT
    family = MONOMIAL

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]

  # subdomain restricted variable
  [./v]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;1&#x27;
  [../]
[]

[Functions]
  [./forcing_fn_u]
    type = ParsedFunction
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./forcing_fn_v]
    type = ParsedFunction
    value = t
  [../]

  # [./exact_fn]
  #   type = ParsedFunction
  #   value = t*t*t*((x*x)+(y*y))
  # [../]

  # [./exact_fn_v]
  #   type = ParsedFunction
  #   value = t+1
  # [../]
[]

[Kernels]
  [./ie_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = forcing_fn_u
  [../]


  [./ie_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]

  [./ffn_v]
    type = BodyForce
    variable = v
    function = forcing_fn_v
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_elem
  exodus = true
[]

[Debug]
  show_var_residual = &#x27;u v&#x27;
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ee016b0a-0fb2-407e-be3b-a66a979f1a73"><div class="modal-content"><h4>test/tests/kernels/2d_diffusion/2d_diffusion_bodyforce_test.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test of the Kernel System.
# It solves the Laplacian equation on a small 2x2 grid.
# The &quot;Diffusion&quot; kernel is used to calculate the
# residuals of the weak form of this operator. The
# &quot;BodyForce&quot; kernel is used to apply a time-dependent
# volumetric source.
###########################################################

[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./bf]
    type = BodyForce
    variable = u
    postprocessor = ramp
  [../]
[]

[Functions]
  [./ramp]
    type = ParsedFunction
    value = &#x27;t&#x27;
  [../]
[]

[Postprocessors]
  [./ramp]
    type = FunctionValuePostprocessor
    function = ramp
    execute_on = linear
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  dt = 1.0
  end_time = 1.0

  solve_type = &#x27;NEWTON&#x27;
[]

[Outputs]
  file_base = bodyforce_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cc776563-3366-49f6-b9b0-e24527565290"><div class="modal-content"><h4>test/tests/time_integrators/convergence/explicit_convergence.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim  = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx   = 4
  ny   = 4
  elem_type = QUAD9
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  # We are solving only mass matrices in this problem.  The Jacobi
  # preconditioner is a bit faster than ILU or AMG for this.
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;jacobi&#x27;

  start_time = 0.0
  end_time = 0.03125
  dt = 0.00390625

  [./TimeIntegrator]
    type = Heun
  [../]

   # For explicit methods, we use the LINEAR solve type.
   solve_type = &#x27;LINEAR&#x27;
   l_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="afb4a858-de87-40cb-8487-6c1e9f4946d5"><div class="modal-content"><h4>test/tests/outputs/oversample/adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t*t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1
  solve_type = PJFNK
[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  [./oversample]
    type = Exodus
    refinements = 2
    file_base = adapt_out_oversample
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="58412743-7a5f-4e56-b8c3-bc363edb1a41"><div class="modal-content"><h4>test/tests/executioners/executioner/steady_state_check_test.i</h4><pre class="moose-pre"><code class="language-text">#
# Run transient simulation into steady state
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
#    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
    value = -4
  [../]

  [./exact_fn]
    type = ParsedFunction
#    value = t*t*t*((x*x)+(y*y))
    value = ((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  solve_type = &#x27;PJFNK&#x27;

  nl_abs_tol = 1e-14

  start_time = 0.0
  num_steps = 12
  dt = 1

  steady_state_detection = true
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_ss_check
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d16d1d3e-6b33-4950-b22d-1960dbda0531"><div class="modal-content"><h4>python/peacock/tests/common/transient_big.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of a &quot;Transient&quot; Executioner.
#
# @Requirement F1.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
  uniform_refine = 2
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./dt]
    type = TimestepSize
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  # Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  file_base = out_transient
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="26d5613e-b9fa-4601-a299-92686746415c"><div class="modal-content"><h4>modules/geochemistry/test/tests/kernels/time_deriv_1.i</h4><pre class="moose-pre"><code class="language-text"># An initial concentration field in a material with constant porosity is subjected to a constant source
# porosity * d(concentration)/dt = source
# The result is checked vs the expected solution, which is conc = conc_old + dt * source / porosity
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 2
  ny = 4
  nz = 2
[]

[Variables]
  [./conc]
  [../]
[]

[Kernels]
  [./dot]
    type = GeochemistryTimeDerivative
    porosity = porosity
    variable = conc
  [../]
  [./source]
    type = BodyForce
    function = 3.0
    variable = conc
  [../]
[]

[ICs]
  [./conc]
    type = FunctionIC
    function = &#x27;z * z + 4 * x * x * x + y&#x27;
    variable = conc
  [../]
[]

[AuxVariables]
  [./porosity]
  [../]
  [./expected]
  [../]
  [./should_be_zero]
  [../]
[]

[AuxKernels]
  [./porosity]
    type = FunctionAux
    function = &#x27;6.0&#x27;
    variable = porosity
  [../]
  [./expected]
    type = FunctionAux
    function = &#x27;z * z + 4 * x * x * x + y + 2.0 * 3.0 / 6.0&#x27;
    variable = expected
  [../]
  [./should_be_zero]
    type = ParsedAux
    args = &#x27;expected conc&#x27;
    function = &#x27;expected - conc&#x27;
    variable = should_be_zero
  [../]
[]

[Postprocessors]
  [./error]
    type = NodalL2Norm
    variable = should_be_zero
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  dt = 2
  end_time = 2
[]

[Outputs]
  csv = true
[]

</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a0b5aefc-012a-4105-8d01-b3f6c6f323e5"><div class="modal-content"><h4>test/tests/dampers/min_damping/min_elem_damping.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./u_dt]
    type = TimeDerivative
    variable = u
  [../]
  [./u_source]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[BCs]
  [./u_left]
    type = DirichletBC
    boundary = left
    variable = u
    value = 0.0
  [../]
[]

[Dampers]
  [./limit]
    type = BoundingValueElementDamper
    variable = u
    max_value = 1.5
    min_value = -1.5
    min_damping = 0.001
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 2
[]

[Postprocessors]
  [./u_avg]
    type = ElementAverageValue
    variable = u
  [../]
  [./dt]
    type = TimestepSize
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e5b0205f-e8cc-4994-92e4-694cc6000630"><div class="modal-content"><h4>test/tests/time_integrators/implicit-euler/ie-monomials.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    variable = u
    value = 1
  [../]
[]

[Functions]
  active = &#x27;forcing_fn exact_fn&#x27;

  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]

  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))
  [../]
[]

[Kernels]
  [./time]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]          # u * v
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
  [../]
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Transient
  nl_rel_tol = 1e-10
  num_steps = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  console = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7d5270bf-7cc2-46ac-87e1-58aa2efee11f"><div class="modal-content"><h4>test/tests/time_integrators/actually_explicit_euler_verification/ee-2d-linear.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = (x+y)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*(x+y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  start_time = 0.0
  num_steps = 20
  dt = 0.00005
  l_tol = 1e-12

  [./TimeIntegrator]
    type = ActuallyExplicitEuler
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="656b6610-0fd2-4905-a2ee-44baec4ff3ce"><div class="modal-content"><h4>test/tests/nodalkernels/penalty_dirichlet/nodal_penalty_dirichlet.i</h4><pre class="moose-pre"><code class="language-text">#In order to compare the solution generated using preset BC, the penalty was set to 1e10.
#Large penalty number should be used with caution.

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = -2*(x*x+y*y-2)
  [../]

  [./solution]
    type = ParsedGradFunction
    value = (1-x*x)*(1-y*y)
    grad_x = 2*(x*y*y-x)
    grad_y = 2*(x*x*y-y)
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[NodalKernels]
  [./bc_all]
    type = PenaltyDirichletNodalKernel
    variable = u
    value = 0
    boundary = &#x27;top left right bottom&#x27;
    penalty = 1e10
  [../]
[]

# [BCs]
#   [./fix]
#     type = DirichletBC
#     preset = true
#     variable = u
#     value = 0
#     boundary = &#x27;top left right bottom&#x27;
#   [../]
# []

[Postprocessors]
  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-14
[]

[Outputs]
  file_base = nodal_preset_bc_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3e3fafa9-43f5-4d4d-87f0-d291eb87b6c0"><div class="modal-content"><h4>test/tests/time_integrators/crank-nicolson/cranic_adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 4
  ny = 4
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = sin(pi*x)*sin(pi*y)+2*t*pi*pi*sin(pi*x)*sin(pi*y)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*sin(pi*x)*sin(pi*y)
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  # Use the block format instead of the scheme parameter
  [./TimeIntegrator]
    type = CrankNicolson
  [../]

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1

  [./Adaptivity]
    refine_fraction = 0.2
    coarsen_fraction = 0.3
    max_h_level = 4
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8b6c7ee5-196f-4341-bbf1-e17095b490ae"><div class="modal-content"><h4>test/tests/executioners/transient_sync_time/transient_time_interval_output_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./bc_func]
    type = ParsedFunction
    value = sin(pi*0.1*x*t)
  [../]

  # Laplacian of the function above
  [./interior_func]
    type = ParsedFunction
    value = 0.01*pi*pi*t*t*sin(0.1*pi*x*t)
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = interior_func
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = bc_func
  [../]
[]

[Executioner]
  type = Transient

  dt = 1
  start_time = 0
  num_steps = 10

  # These times will be sync&#x27;d in the output
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_tio
  interval = 3
  csv = true
  [./exodus]
    type = Exodus
    execute_on = &#x27;final timestep_end&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d86a7adc-8631-438c-b03b-6ee1eaf96b6d"><div class="modal-content"><h4>test/tests/time_integrators/bdf2/bdf2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 20
  ny = 20
  elem_type = QUAD9
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.25

#  [./Adaptivity]
#    refine_fraction = 0.2
#    coarsen_fraction = 0.3
#    max_h_level = 4
#  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="84cbf912-d5fd-4bec-9a05-e142da82320b"><div class="modal-content"><h4>test/tests/time_integrators/explicit-euler/ee-2d-linear-adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = (x+y)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*(x+y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    lumping = true
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    implicit = true
  [../]
[]

[Adaptivity]
  steps = 1
  marker = box
  max_h_level = 2
  [./Markers]
    [./box]
      bottom_left = &#x27;-0.4 -0.4 0&#x27;
      inside = refine
      top_right = &#x27;0.4 0.4 0&#x27;
      outside = do_nothing
      type = BoxMarker
    [../]
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;explicit-euler&#x27;

  start_time = 0.0
  num_steps = 4
  dt = 0.005
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="838664a0-a6b9-4623-a97d-32903fda9c86"><div class="modal-content"><h4>test/tests/auxkernels/mesh_integer/mesh_integer.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = MeshGeneratorMesh

  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = 0
    ymax = 1
    nx = 5
    ny = 5
    extra_element_integers = &#x27;material_id&#x27;
  []
  [set_material_id0]
    type = SubdomainBoundingBoxGenerator
    input = gmg
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;0.8 0.6 0&#x27;
    block_id = 0
    location = INSIDE
    integer_name = material_id
  []
  [set_material_id1]
    type = SubdomainBoundingBoxGenerator
    input = set_material_id0
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;0.8 0.6 0&#x27;
    block_id = 1
    location = OUTSIDE
    integer_name = material_id
  []
[]

[Variables]
  [u][]
[]

[Kernels]
  [diff]
    type = MatDiffusion
    variable = u
    diffusivity = dc
  []
  [timederivative]
    type = TimeDerivative
    variable = u
  []
  [sourceterm]
    type = BodyForce
    variable = u
    function = 1
  []
[]

[AuxVariables]
  [id]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[AuxKernels]
  [id]
    type = ElementIntegerAux
    variable = id
    integer_names = material_id
  []
[]

[BCs]
  [vacuum]
    type = VacuumBC
    variable = u
    boundary = &#x27;right left top bottom&#x27;
 []
[]

[Materials]
  [dc]
    type = ConstantIDMaterial
    prop_name = dc
    prop_values = &#x27;1 2&#x27;
    id_name = material_id
  []
[]

[Postprocessors]
  [unorm]
    type = ElementL2Norm
    variable = u
  []
[]

[Executioner]
  type = Transient

  end_time = 0.1
  dt = 0.01
  nl_abs_tol = 1.e-15
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b6bed4fc-c09b-42f7-b528-6c2dd137d90c"><div class="modal-content"><h4>test/tests/mesh/adapt/initial_adaptivity_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE
    [./InitialCondition]
      type = BoundingBoxIC
      x1 = -2
      y1 = -2
      x2 =  0
      y2 =  2
      inside = 1
      outside = 0
    [../]
  [../]
[]

[Kernels]
  [./udiff]
    type = Diffusion
    variable = u
  [../]

  [./forcing_fn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;

  [./Adaptivity]
    initial_adaptivity = 5
    refine_fraction = 0.2
    coarsen_fraction = 0.3
    max_h_level = 4
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="af4c60a5-333f-442b-8b70-146a3aa01b73"><div class="modal-content"><h4>test/tests/kernels/vector_fe/electromagnetic_coulomb_gauge.i</h4><pre class="moose-pre"><code class="language-text"># This is an MMS problem that demonstrates solution of Maxwell&#x27;s equations in the
# Coulomb gauge potential form. The equations solved are:
# -\nabla^2 V = f_{V,mms}
# -\nabla^2 A - \omega^2 A + \nabla \frac{\partial V}{\partial t} = f_{A,mms}
# This tests the value and gradient of a VectorMooseVariable as well as the time
# derivative of the gradient of a standard MooseVariable
#
# This input file is subject to two tests:
# 1) An exodiff test of the physics
# 2) A Jacobian test to verify accuracy of hand-coded Jacobian routines

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  xmin = -1
  ymin = -1
[]

[Variables]
  [./V]
  [../]
  [./A]
    family = LAGRANGE_VEC
    order = FIRST
    scaling = 1e-10
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = V
    coef = 5
  [../]
  [./V_frc]
    type = BodyForce
    function = &#x27;V_forcing_function&#x27;
    variable = V
  [../]
  [./A_diff]
    type = VectorCoefDiffusion
    variable = A
    coef = 5
  [../]
  [./A_coeff_reaction]
    type = VectorCoeffReaction
    variable = A
    coefficient = -.09
  [../]
  [./A_coupled_grad_td]
    type = VectorCoupledGradientTimeDerivative
    variable = A
    v = V
  [../]
  [./A_frc]
    type = VectorBodyForce
    variable = A
    function_x = &#x27;Ax_forcing_function&#x27;
    function_y = &#x27;Ay_forcing_function&#x27;
    function_z = &#x27;0&#x27;
  [../]
[]

[BCs]
  [./bnd_V]
    type = FunctionDirichletBC
    variable = V
    boundary = &#x27;left right top bottom&#x27;
    function = &#x27;V_exact_sln&#x27;
  [../]
  [./bnd_A]
    type = VectorPenaltyDirichletBC
    variable = A
    x_exact_sln = &#x27;Ax_exact_sln&#x27;
    y_exact_sln = &#x27;Ay_exact_sln&#x27;
    z_exact_sln = &#x27;0&#x27;
    penalty = 1e10
    boundary = &#x27;left right top bottom&#x27;
  [../]
[]

[Functions]
  [./V_exact_sln]
    type = ParsedFunction
    value = &#x27;cos(0.3*t)*cos(1.1*x)*cos(1.2*y)&#x27;
  [../]
  [./Ax_exact_sln]
    type = ParsedFunction
    value = &#x27;cos(0.3*t)*cos(0.4*x)*cos(0.5*y)&#x27;
  [../]
  [./Ay_exact_sln]
    type = ParsedFunction
    value = &#x27;cos(0.3*t)*cos(0.6*x)*cos(0.7*y)&#x27;
  [../]
  [./V_forcing_function]
    type = ParsedFunction
    value = &#x27;0.33*sin(0.3*t)*sin(1.1*x)*cos(1.2*y) + 13.25*cos(0.3*t)*cos(1.1*x)*cos(1.2*y)&#x27;
  [../]
  [./Ax_forcing_function]
    type = ParsedFunction
    value = &#x27;0.33*sin(0.3*t)*sin(1.1*x)*cos(1.2*y) + 1.96*cos(0.3*t)*cos(0.4*x)*cos(0.5*y)&#x27;
  [../]
  [./Ay_forcing_function]
    type = ParsedFunction
    value = &#x27;0.36*sin(0.3*t)*sin(1.2*y)*cos(1.1*x) + 4.16*cos(0.3*t)*cos(0.6*x)*cos(0.7*y)&#x27;
  [../]
[]

[Preconditioning]
  [./pre]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  end_time = 3
  l_max_its = 100
  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;asm 100&#x27;
  petsc_options = &#x27;-ksp_converged_reason -ksp_monitor_true_residual -ksp_monitor_singular_value -snes_linesearch_monitor&#x27;
  line_search = &#x27;bt&#x27;
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2e96f6d5-6534-488f-9944-c9a4f8c995de"><div class="modal-content"><h4>test/tests/userobjects/internal_side_user_object/internal_side_user_object_two_materials.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
  type = GeneratedMeshGenerator
    dim = 2
    xmin = -1
    ymin = -1
    xmax = 1
    ymax = 1
    nx = 2
    ny = 2
    elem_type = QUAD4
  []
  [./subdomain_id]
    input = gen
    type = ElementSubdomainIDGenerator
    subdomain_ids = &#x27;0 1
                     1 1&#x27;
  [../]
[]

[Functions]
  [./fn_exact]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]
[]

[UserObjects]
  [./isuo]
    type = InsideUserObject
    variable = u
    diffusivity = diffusivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = fn_exact
  [../]
[]

[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 1
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
  [../]
[]

[Postprocessors]
  [./value]
    type = InsideValuePPS
    user_object = isuo
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c66ac292-4a9f-4916-903e-044b21ae55ca"><div class="modal-content"><h4>test/tests/materials/stateful_internal_side_uo/internal_side_uo_stateful.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  ymin = -1
  xmax = 1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD4
[]

[Functions]
  [./fn_exact]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]
[]

[UserObjects]
  [./isuo]
    type = InsideUserObject
    variable = u
    diffusivity = diffusivity
    execute_on = &#x27;initial timestep_end&#x27;
#    use_old_prop = true # Access a stateful material on an internal side
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]

  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = fn_exact
  [../]
[]

[Postprocessors]
  [./value]
    type = InsideValuePPS
    user_object = isuo
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.1
  num_steps = 5
[]

[Materials]
  [./stateful]
    type = StatefulMaterial
    block = 0
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7d03b2eb-f85f-46b1-a658-b403374fc53c"><div class="modal-content"><h4>test/tests/tag/tag_interface_kernels.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
    nz = 2
    zmax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 1&#x27;
    block_id = 1
  [../]
  [./break_boundary]
    input = subdomain1
    type = BreakBoundaryOnSubdomainGenerator
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = break_boundary
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1&#x27;
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1&#x27;
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1 vec_tag2&#x27;
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1 vec_tag2&#x27;
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 back_to_0 right top front&#x27;
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1 back_to_1&#x27;
    extra_matrix_tags = &#x27;mat_tag1 mat_tag2&#x27;
    extra_vector_tags = &#x27;vec_tag1&#x27;
  [../]
[]

[AuxVariables]
  [./tag_variable1]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./tag_variable2]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[AuxKernels]
  [./TagVectorAux1]
    type = TagVectorAux
    variable = tag_variable1
    v = u
    block = 0
    vector_tag = vec_tag2
    execute_on = timestep_end
  [../]

  [./TagVectorAux2]
    type = TagMatrixAux
    variable = tag_variable2
    v = v
    block = 1
    matrix_tag = mat_tag2
    execute_on = timestep_end
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Problem]
  type = TagTestProblem
  test_tag_vectors =  &#x27;nontime residual vec_tag1 vec_tag2&#x27;
  test_tag_matrices = &#x27;mat_tag1 mat_tag2&#x27;

  extra_tag_matrices = &#x27;mat_tag1 mat_tag2&#x27;
  extra_tag_vectors  = &#x27;vec_tag1 vec_tag2&#x27;
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6a3a5fca-7192-49bb-83f8-d85a135427d0"><div class="modal-content"><h4>test/tests/indicators/laplacian_jump_indicator/biharmonic_transient.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  # Parameters used by Functions.
  vars   = &#x27;c&#x27;
  vals   = &#x27;50&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -.5
  xmax = .5
  ymin = -.5
  ymax = .5
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
    order = THIRD
    family = HERMITE
  [../]
[]

[Kernels]
  [./biharmonic]
    type = Biharmonic
    variable = u
  [../]
  [./body_force]
    type = BodyForce
    variable = u
    function = forcing_func
  [../]
[]

[BCs]
  [./all_value]
    type = FunctionPenaltyDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = u_func
    penalty = 1e10
  [../]
  [./all_flux]
    type = FunctionPenaltyFluxBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = u_func
    penalty = 1e10
  [../]
[]

[Adaptivity]
  [./Indicators]
    [./error]
      type = LaplacianJumpIndicator
      variable = u
      scale_by_flux_faces = true
    [../]
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 0.1

  # Note: the unusually tight tolerances here are due to the penalty
  # BCs (currently the only way of accurately Dirichlet boundary
  # conditions on Hermite elements in MOOSE).
  nl_rel_tol = 1.e-15
  l_tol = 1.e-15

  # We have exact Jacobians
  solve_type = &#x27;NEWTON&#x27;

  # Use 6x6 quadrature to ensure the forcing function is integrated
  # accurately.
  [./Quadrature]
    type = GAUSS
    order = ELEVENTH
  [../]
[]

[Functions]
  [./u_func]
    type   = ParsedGradFunction
    value  = &#x27;exp(-c*(x^2+y^2))*exp(-t)&#x27;
    grad_x = &#x27;-2*c*exp(-c*(x^2+y^2))*x*exp(-t)&#x27;
    grad_y = &#x27;-2*c*exp(-c*(x^2+y^2))*y*exp(-t)&#x27;
  [../]
  [./forcing_func]
    type   = ParsedFunction
    value  = &#x27;16*c^2*(c^2*(x^2+y^2)^2 - 4*c*(x^2+y^2) + 2)*exp(-c*(x^2+y^2))*exp(-t)&#x27;
  [../]
[]

[ICs]
  [./u_ic]
    type = FunctionIC
    function = u_func
    variable = u
  [../]
[]

[Postprocessors]
  [./l2_error]
    type = ElementL2Error
    variable = u
    function = u_func
  [../]
  [./h1_error]
    type = ElementH1Error
    variable = u
    function = u_func
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2b960944-6000-474c-960d-df3122abcc99"><div class="modal-content"><h4>test/tests/restart/restart_diffusion/restart_diffusion_test_transient_new_name.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = steady_out.e
[]

[Variables]
  [./u_new]
    order = FIRST
    family = LAGRANGE

    # Testing that we can load a solution from a different variable name
    initial_from_file_var = u
    initial_from_file_timestep = 2
  [../]
[]

[Kernels]
  active = &#x27;bodyforce ie&#x27;

  [./bodyforce]
    type = BodyForce
    variable = u_new
    value = 10.0
  [../]

  [./ie]
    type = TimeDerivative
    variable = u_new
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u_new
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u_new
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 10
  dt = .1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="19e024f5-590a-4e4c-bc5c-3be1fa88a9e2"><div class="modal-content"><h4>test/tests/dgkernels/adaptivity/adaptivity.i</h4><pre class="moose-pre"><code class="language-text"># This input file is used for two tests:
# 1) Check that DGKernels work with mesh adaptivity
# 2) Error out when DGKernels are used with adaptivity
#    and stateful material prpoerties

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 2
  ny = 2
  nz = 2
  parallel_type = &#x27;replicated&#x27;
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL

    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = (x*x*x)-6.0*x
  [../]

  [./bc_fn]
    type = ParsedFunction
    value = (x*x*x)
  [../]
[]

[Kernels]
  [./diff]
    type = MatDiffusionTest
    variable = u
    prop_name = diffusivity
  [../]
  [./abs]
    type = Reaction
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  [./dgdiff]
    type = DGDiffusion
    variable = u
    sigma = 6
    epsilon = -1.0
    diff = diffusivity
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = DGMDDBC
    variable = u
    boundary = &#x27;1 2 3 4&#x27;
    function = bc_fn
    prop_name = diffusivity
    sigma = 6
    epsilon = -1.0
  [../]
[]

[Materials]
  active = &#x27;constant&#x27;
  [./stateful]
    type = StatefulTest
    prop_names = &#x27;diffusivity&#x27;
    prop_values = &#x27;1&#x27;
  [../]
  [./constant]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusivity&#x27;
    prop_values = &#x27;1&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Adaptivity]
  marker = &#x27;marker&#x27;
  steps = 1
  [./Indicators]
    [./error]
      type = GradientJumpIndicator
      variable = u
    [../]
  [../]
  [./Markers]
    [./marker]
      type = ErrorFractionMarker
      coarsen = 0.5
      indicator = error
      refine = 0.5
    [../]
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4942156a-76fe-4677-8cbb-7f8e02401b80"><div class="modal-content"><h4>test/tests/time_steppers/timesequence_stepper/exodustimesequence.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  end_time = 4.0
  [./TimeStepper]
    type = ExodusTimeSequenceStepper
    mesh = timesequence_no_start_time.e
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e87ad266-7614-4573-9cc5-4f686b5233ee"><div class="modal-content"><h4>test/tests/restart/restart_transient_from_steady/restart_trans_with_sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Problem]
  restart_file_base = steady_with_sub_out_cp/LATEST
  skip_additional_restart_data = true
[]

[AuxVariables]
  [Tf]
  []
[]

[Variables]
  [power_density]
  []
[]

[Functions]
  [pwr_func]
    type = ParsedFunction
    value = &#x27;1e3*x*(1-x)+5e2&#x27; # increase this function to drive transient
  []
[]

[Kernels]
  [timedt]
    type = TimeDerivative
    variable = power_density
  []

  [diff]
    type = Diffusion
    variable = power_density
  []

  [coupledforce]
    type = BodyForce
    variable = power_density
    function = pwr_func
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = power_density
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = power_density
    boundary = right
    value = 1e3
  []
[]

[Postprocessors]
  [pwr_avg]
    type = ElementAverageValue
    block = &#x27;0&#x27;
    variable = power_density
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_avg]
    type = ElementAverageValue
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_max]
    type = ElementExtremeValue
    value_type = max
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [temp_min]
    type = ElementExtremeValue
    value_type = min
    variable = Tf
    block = &#x27;0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 3
  dt = 1.0

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart &#x27;
  petsc_options_value = &#x27;hypre boomeramg 100&#x27;

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-7

  picard_rel_tol = 1e-7
  picard_abs_tol = 1e-07
  picard_max_its = 4

  line_search = none
[]

[MultiApps]
  [./sub]
    type = TransientMultiApp
    app_type = MooseTestApp
    positions = &#x27;0 0 0&#x27;
    input_files  = restart_trans_with_sub_sub.i
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[Transfers]
  [p_to_sub]
    type = MultiAppMeshFunctionTransfer
    direction = to_multiapp
    source_variable = power_density
    variable = power_density
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
  [t_from_sub]
    type = MultiAppMeshFunctionTransfer
    direction = from_multiapp
    source_variable = temp
    variable = Tf
    multi_app = sub
    execute_on = &#x27;timestep_end&#x27;
  []
[]

[Outputs]
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="beb6f548-2c24-44bb-93b8-d1baf56f5d91"><div class="modal-content"><h4>test/tests/interfacekernels/1d_interface/reaction_1D_transient.i</h4><pre class="moose-pre"><code class="language-text"># Transient-state test for the InterfaceReaction kernel.
#
# Same to steady-state, except the following
#
# Natural BCs are applied (i.e. NewmannBC h=0 at left and right)

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 10
    xmax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;1.0 0 0&#x27;
    block_id = 1
    top_right = &#x27;2.0 1.0 0&#x27;
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = &#x27;subdomain1&#x27;
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;0&#x27;
  [../]
  [./v]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
  [../]
[]

[Kernels]
  [./diff_u]
    type = MatDiffusion
    diffusivity = D
    variable = u
    block = &#x27;0&#x27;
  [../]
  [./diff_v]
    type = MatDiffusion
    diffusivity = D
    variable = v
    block = &#x27;1&#x27;
  [../]
  [./diff_u_dt]
    type = TimeDerivative
    variable = u
    block = &#x27;0&#x27;
  [../]
  [./diff_v_dt]
    type = TimeDerivative
    variable = v
    block = &#x27;1&#x27;
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    block = &#x27;0&#x27;
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = InterfaceDiffusion
    variable = u
    neighbor_var = &#x27;v&#x27;
    boundary = &#x27;primary0_interface&#x27;
    D = D
    D_neighbor = D
  [../]
  [./interface_reaction]
    type = InterfaceReaction
    variable = u
    neighbor_var = &#x27;v&#x27;
    boundary = &#x27;primary0_interface&#x27;
    kf = 1 # Forward reaction rate coefficient
    kb = 2 # Backward reaction rate coefficient
  [../]
[]

[Materials]
  [./block0]
    type = GenericConstantMaterial
    block = &#x27;0&#x27;
    prop_names = &#x27;D&#x27;
    prop_values = &#x27;4&#x27;
  [../]
  [./block1]
    type = GenericConstantMaterial
    block = &#x27;1&#x27;
    prop_names = &#x27;D&#x27;
    prop_values = &#x27;2&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 0.1
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e6ca5f92-984e-4b57-a4d0-8943cc203351"><div class="modal-content"><h4>modules/functional_expansion_tools/examples/2D_interface_no_material/main.i</h4><pre class="moose-pre"><code class="language-text"># Derived from the example &#x27;2D_interface&#x27; with the following differences:
#
#   1) No materials are used
[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 0.4
  nx = 6
  ymin = 0.0
  ymax = 10.0
  ny = 20
[]

[Variables]
  [./m]
  [../]
[]

[Kernels]
  [./diff_m]
    type = Diffusion
    variable = m
  [../]
  [./time_diff_m]
    type = TimeDerivative
    variable = m
  [../]
  [./source_m]
    type = BodyForce
    variable = m
    value = 100
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    value = 2
    variable = m
  [../]
[]

[BCs]
  [./interface_value]
    type = FXValueBC
    variable = m
    boundary = right
    function = FX_Basis_Value_Main
  [../]
  [./interface_flux]
    type = FXFluxBC
    boundary = right
    variable = m
    function = FX_Basis_Flux_Main
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;4&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
  [./FX_Basis_Flux_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;5&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
[]

[UserObjects]
  [./FX_Flux_UserObject_Main]
    type = FXBoundaryFluxUserObject
    function = FX_Basis_Flux_Main
    variable = m
    boundary = right
    diffusivity = 0.1
  [../]
[]

[Postprocessors]
  [./average_interface_value]
    type = SideAverageValue
    variable = m
    boundary = right
  [../]
  [./total_flux]
    type = SideFluxIntegral
    variable = m
    boundary = right
    diffusivity = 0.1
  [../]
  [./picard_iterations]
    type = NumPicardIterations
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 1.0
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = sub.i
    sub_cycling = true
  [../]
[]

[Transfers]
  [./FluxToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Flux_UserObject_Main
    multi_app_object_name = FX_Basis_Flux_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
  [./FluxToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Flux_Main
    multi_app_object_name = FX_Flux_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="52e64c45-0d0c-4e1d-853a-3444f8f715a1"><div class="modal-content"><h4>modules/navier_stokes/test/tests/ins/mms/supg/supg_adv_dominated_mms.i</h4><pre class="moose-pre"><code class="language-text">mu=1.5e-2
rho=2.5

[GlobalParams]
  gravity = &#x27;0 0 0&#x27;
  supg = true
  convective_term = true
  integrate_p_by_parts = false
  transient_term = true
  laplace = true
  u = vel_x
  v = vel_y
  p = p
  alpha = 1e0
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1.0
    ymin = 0
    ymax = 1.0
    elem_type = QUAD9
    nx = 4
    ny = 4
  []
  [./corner_node]
    type = ExtraNodesetGenerator
    new_boundary = &#x27;pinned_node&#x27;
    nodes = &#x27;0&#x27;
    input = gen
  [../]
[]

[Variables]
  [./vel_x]
  [../]

  [./vel_y]
  [../]

  [./p]
    order = FIRST
  [../]
[]

[Kernels]
  # mass
  [./mass]
    type = INSMass
    variable = p
  [../]

  [./x_time]
    type = INSMomentumTimeDerivative
    variable = vel_x
  [../]
  [./y_time]
    type = INSMomentumTimeDerivative
    variable = vel_y
  [../]

  # x-momentum, space
  [./x_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_x
    component = 0
    forcing_func = vel_x_source_func
  [../]

  # y-momentum, space
  [./y_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_y
    component = 1
    forcing_func = vel_y_source_func
  [../]

  [./p_source]
    type = BodyForce
    function = p_source_func
    variable = p
  [../]
[]

[BCs]
  [./vel_x]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = vel_x_func
    variable = vel_x
  [../]
  [./vel_y]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = vel_y_func
    variable = vel_y
  [../]
  [./p]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = p_func
    variable = p
  [../]
[]

[Functions]
  [./vel_x_source_func]
    type = ParsedFunction
    value = &#x27;-${mu}*(-0.028*pi^2*x^2*sin(0.2*pi*x*y) - 0.028*pi^2*y^2*sin(0.2*pi*x*y) - 0.1*pi^2*sin(0.5*pi*x) - 0.4*pi^2*sin(pi*y)) + ${rho}*(0.14*pi*x*cos(0.2*pi*x*y) + 0.4*pi*cos(pi*y))*(0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3) + ${rho}*(0.14*pi*y*cos(0.2*pi*x*y) + 0.2*pi*cos(0.5*pi*x))*(0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5) + 0.1*pi*y*cos(0.2*pi*x*y) + 0.25*pi*cos(0.5*pi*x)&#x27;
  [../]
  [./vel_y_source_func]
    type = ParsedFunction
    value = &#x27;-${mu}*(-0.018*pi^2*x^2*sin(0.3*pi*x*y) - 0.018*pi^2*y^2*sin(0.3*pi*x*y) - 0.384*pi^2*sin(0.8*pi*x) - 0.027*pi^2*sin(0.3*pi*y)) + ${rho}*(0.06*pi*x*cos(0.3*pi*x*y) + 0.09*pi*cos(0.3*pi*y))*(0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3) + ${rho}*(0.06*pi*y*cos(0.3*pi*x*y) + 0.48*pi*cos(0.8*pi*x))*(0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5) + 0.1*pi*x*cos(0.2*pi*x*y) + 0.3*pi*cos(0.3*pi*y)&#x27;
  [../]
  [./p_source_func]
    type = ParsedFunction
    value = &#x27;-0.06*pi*x*cos(0.3*pi*x*y) - 0.14*pi*y*cos(0.2*pi*x*y) - 0.2*pi*cos(0.5*pi*x) - 0.09*pi*cos(0.3*pi*y)&#x27;
  [../]
  [./vel_x_func]
    type = ParsedFunction
    value = &#x27;0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5&#x27;
  [../]
  [./vel_y_func]
    type = ParsedFunction
    value = &#x27;0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3&#x27;
  [../]
  [./p_func]
    type = ParsedFunction
    value = &#x27;0.5*sin(0.5*pi*x) + 1.0*sin(0.3*pi*y) + 0.5*sin(0.2*pi*x*y) + 0.5&#x27;
  [../]
  [./vxx_func]
    type = ParsedFunction
    value = &#x27;0.14*pi*y*cos(0.2*pi*x*y) + 0.2*pi*cos(0.5*pi*x)&#x27;
  [../]
[]

[Materials]
  [./const]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;rho mu&#x27;
    prop_values = &#x27;${rho}  ${mu}&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu NONZERO&#x27;
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-14
  nl_max_its = 10
  l_tol = 1e-6
  l_max_its = 10
  [./TimeStepper]
    dt = .05
    type = IterationAdaptiveDT
    cutback_factor = 0.4
    growth_factor = 1.2
    optimal_iterations = 20
  [../]
[]

[Outputs]
  execute_on = &#x27;final&#x27;
  [./exodus]
    type = Exodus
  [../]
  [./csv]
    type = CSV
  [../]
[]

[Postprocessors]
  [./L2vel_x]
    type = ElementL2Error
    variable = vel_x
    function = vel_x_func
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2vel_y]
    variable = vel_y
    function = vel_y_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2p]
    variable = p
    function = p_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2vxx]
    variable = vxx
    function = vxx_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[AuxVariables]
  [./vxx]
    family = MONOMIAL
    order = FIRST
  [../]
[]

[AuxKernels]
  [./vxx]
    type = VariableGradientComponent
    component = x
    variable = vxx
    gradient_variable = vel_x
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6c0d00ef-351f-4e5c-a1c3-d3d1e80496b5"><div class="modal-content"><h4>modules/combined/test/tests/poro_mechanics/pp_generation.i</h4><pre class="moose-pre"><code class="language-text"># A sample is constrained on all sides and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie m^3/second per cubic meter), and the
# rise in porepressure is observed.
#
# Source = s  (units = 1/second)
#
# Expect:
# porepressure = Biot-Modulus*s*t
# stress = 0 (remember this is effective stress)
#
# Parameters:
# Biot coefficient = 0.3
# Porosity = 0.1
# Bulk modulus = 2
# Shear modulus = 1.5
# fluid bulk modulus = 1/0.3 = 3.333333
# 1/Biot modulus = (1 - 0.3)*(0.3 - 0.1)/2 + 0.1*0.3 = 0.1. BiotModulus = 10
# s = 0.1
#
# Expect
# porepressure = t
# stress = 0


[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  porepressure = porepressure
  block = 0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
[]


[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PoroMechanicsCoupling
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PoroMechanicsCoupling
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PoroMechanicsCoupling
    variable = disp_z
    component = 2
  [../]
  [./poro_timederiv]
    type = PoroFullSatTimeDerivative
    variable = porepressure
  [../]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]



[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./poro_material]
    type = PoroFullSatMaterial
    porosity0 = 0.1
    biot_coefficient = 0.3
    solid_bulk_compliance = 0.5
    fluid_bulk_compliance = 0.3
    constant_porosity = true
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]

[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7fbe3659-a621-46b3-88c9-cbdc992e63ae"><div class="modal-content"><h4>test/tests/time_steppers/timesequence_stepper/timesequence_failed_solve.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  # This timestepper does not use dt to set the timestep, it uses the time_sequence.
  # dt = 250
  dtmin=250
  end_time = 3000.0
  [./TimeStepper]
    type = TimeSequenceStepperFailTest
    time_sequence  = &#x27;0  1000.0 2000.0&#x27;
  [../]
  nl_rel_tol=1.e-10
[]

[Outputs]
  file_base = timesequence_failed_solve
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b9d4aa01-35b1-4184-8eb1-3b1eee22adff"><div class="modal-content"><h4>test/tests/fvkernels/fv_adapt/transient-adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 10
    ny = 10
    elem_type = QUAD4
  []
[]

[Variables]
  [u]
    order = CONSTANT
    family = MONOMIAL
  []
  [v][]
[]

[Functions]
  [force]
    type = ParsedFunction
    value = t
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = v
  []
  [force]
    type = BodyForce
    variable = v
    function = force
  []
[]

[FVKernels]
  [diff]
    type = FVDiffusion
    variable = u
    coeff = coeff
  []
  [force]
    type = FVBodyForce
    variable = u
    function = force
  []
[]

[FVBCs]
  [right]
    type = FVDirichletBC
    variable = u
    boundary = right
    value = 1
  []
  [left]
    type = FVDirichletBC
    variable = u
    boundary = left
    value = 0
  []
[]

[BCs]
  [right]
    type = DirichletBC
    variable = v
    boundary = right
    value = 1
  []
  [left]
    type = DirichletBC
    variable = v
    boundary = left
    value = 0
  []
[]

[Materials]
  [diff]
    type = ADGenericConstantMaterial
    prop_names = &#x27;coeff&#x27;
    prop_values = &#x27;1&#x27;
  []
[]

[Executioner]
  type = Transient
  num_steps = 2
  dt = 1
  solve_type = &#x27;NEWTON&#x27;
[]

[Problem]
  kernel_coverage_check = false
[]

[Adaptivity]
  marker = box
  initial_steps = 1
  [Markers]
    [box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = do_nothing
      type = BoxMarker
    []
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="36b32f70-0d73-48ba-8fac-7fa823915251"><div class="modal-content"><h4>test/tests/multiapps/grid-sequencing/vi-fine.i</h4><pre class="moose-pre"><code class="language-text">l=10
nx=80
num_steps=2

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = ${l}
  nx = ${nx}
[]

[Variables]
  [u]
  []
[]

[AuxVariables]
  [bounds][]
[]

[Bounds]
  [./u_upper_bounds]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = upper
    bound_value = ${l}
  [../]
  [./u_lower_bounds]
    type = ConstantBoundsAux
    variable = bounds
    bounded_variable = u
    bound_type = lower
    bound_value = 0
  [../]
[]

[ICs]
  [u]
    type = FunctionIC
    variable = u
    function = &#x27;x&#x27;
  []
[]

[Kernels]
  [time]
    type = TimeDerivative
    variable = u
  []
  [diff]
    type = Diffusion
    variable = u
  []
  [ffn]
    type = BodyForce
    variable = u
    function = &#x27;if(x&lt;5,-1,1)&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    boundary = left
    value = 0
    variable = u
  []
  [right]
    type = DirichletBC
    boundary = right
    value = ${l}
    variable = u
  []
[]

[Preconditioning]
  [smp]
    type = SMP
    full = true
  []
[]

[Executioner]
  type = Transient
  num_steps = ${num_steps}
  solve_type = NEWTON
  dtmin = 1
  petsc_options = &#x27;-snes_vi_monitor&#x27;
  petsc_options_iname = &#x27;-snes_max_linear_solve_fail -ksp_max_it -pc_type -sub_pc_factor_levels -snes_linesearch_type -snes_type&#x27;
  petsc_options_value = &#x27;0                           30          asm      16                    basic                 vinewtonrsls&#x27;
[]

[Outputs]
  exodus = true
  [csv]
    type = CSV
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  active = &#x27;upper_violations lower_violations&#x27;
  [upper_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = ${fparse 10+1e-8}
    comparator = &#x27;greater&#x27;
  []
  [lower_violations]
    type = GreaterThanLessThanPostprocessor
    variable = u
    execute_on = &#x27;nonlinear timestep_end&#x27;
    value = -1e-8
    comparator = &#x27;less&#x27;
  []
  [nls]
    type = NumNonlinearIterations
  []
  [cum_nls]
    type = CumulativeValuePostprocessor
    postprocessor = nls
  []
[]

[MultiApps]
  [./coarse]
    type = TransientMultiApp
    app_type = MooseTestApp
    execute_on = timestep_begin
    positions = &#x27;0 0 0&#x27;
    input_files = vi-coarse.i
  [../]
[]

[Transfers]
  [./mesh_function_begin]
    type = MultiAppMeshFunctionTransfer
    direction = from_multiapp
    multi_app = coarse
    source_variable = u
    variable = u
    execute_on = timestep_begin
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5b35e667-5ee4-4e98-803f-b8bd4b4ba9ea"><div class="modal-content"><h4>test/tests/postprocessors/nodal_max_value/nodal_max_value_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 20
  ny = 20
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = (sin(pi*t))
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = sin(pi*t)
  [../]
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27; #ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  num_steps = 20
[]

[Postprocessors]
  [./max_nodal_val]
    type = NodalMaxValue
    variable = u
  [../]
[]

[Outputs]
  file_base = out_nodal_max
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="84a08292-890a-47ab-b1f0-ac8bbb4a9f43"><div class="modal-content"><h4>test/tests/dgkernels/2d_diffusion_dg/no_mallocs_with_action.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL
    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[AuxVariables]
  [v]
    order = FIRST
    family = MONOMIAL
  []
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]
  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))

  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./abs]          # u * v
    type = Reaction
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGDiffusionAction]
  variable = u
  epsilon = -1
  sigma = 6
  # We couple in an auxiliary variable in order to ensure that we&#x27;ve properly
  # ghosted  both non-linear and auxiliary solution vectors
  coupled_var = v
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
  csv = true
[]

[Problem]
  error_on_jacobian_nonzero_reallocation = true
[]

[Postprocessors]
  active = &#x27;num_rm&#x27;
  [num_rm]
    type = NumRelationshipManagers
  []
  [num_internal_sides]
    type = NumInternalSides
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5dea69c0-f009-4390-b8e3-11104998eadc"><div class="modal-content"><h4>test/tests/postprocessors/element_vec_l2_error_pps/element_vec_l2_error.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2

  nx = 5
  ny = 5

  xmin = 0.0
  xmax = 1.0

  ymin = 0.0
  ymax = 1.0
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;bc_u bc_v f_u f_v&#x27;

  # A ParsedFunction allows us to supply analytic expressions
  # directly in the input file
  [./bc_u]
    type = ParsedFunction
    value = sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;2&#x27;
  [../]

  [./bc_v]
    type = ParsedFunction
    value = sin(alpha*pi*y)
    vars = &#x27;alpha&#x27;
    vals = &#x27;2&#x27;
  [../]

  [./f_u]
    type = ParsedFunction
    value = alpha*alpha*pi*pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;2&#x27;
  [../]

  [./f_v]
    type = ParsedFunction
    value = alpha*alpha*pi*pi*sin(alpha*pi*y)
    vars = &#x27;alpha&#x27;
    vals = &#x27;2&#x27;
  [../]
[]

[Kernels]
  active = &#x27;diff_u diff_v forcing_u forcing_v&#x27;

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]

  # This Kernel can take a function name to use
  [./forcing_u]
    type = BodyForce
    variable = u
    function = f_u
  [../]

  [./forcing_v]
    type = BodyForce
    variable = v
    function = f_v
  [../]
[]

[BCs]
  active = &#x27;all_u all_v&#x27;

  # The BC can take a function name to use
  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;bottom right top left&#x27;
    function = bc_u
  [../]

  [./all_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;bottom right top left&#x27;
    function = bc_v
  [../]
[]

[Executioner]
  type = Steady

  [./Adaptivity]
    refine_fraction = 1.0
    coarsen_fraction = 0.0
    max_h_level = 10
    steps = 3
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./integral]
    type = ElementVectorL2Error
    var_x = u
    var_y = v
    function_x = bc_u
    function_y = bc_v
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  file_base = out
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="89590f8e-ecc2-459d-adf2-e00130b18875"><div class="modal-content"><h4>test/tests/outputs/exodus/exodus_discontinuous.i</h4><pre class="moose-pre"><code class="language-text">##
# \file exodus/exodus_discontinuous.i
# \example exodus/exodus_discontinuous.i
# Input file for testing discontinuous data output
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./disc_u]
    family = monomial
    order = first
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = disc_u
  [../]
  [./forcing]
    type = BodyForce
    variable = disc_u
    value = 7
  [../]
[]

[DGKernels]
  [./diff_dg]
  type = DGDiffusion
  variable = disc_u
  sigma = 1
  epsilon = 1
  [../]
[]

[Functions]
  [./zero_fn]
    type = ParsedFunction
    value = 0.0
  [../]
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = disc_u
    boundary = &#x27;left right top bottom&#x27;
    function = zero_fn
    sigma = 1
    epsilon = 1
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  [./exo_out]
    type = Exodus
    discontinuous = true
    file_base = &#x27;exodus_discontinuous_out&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bcb5186a-40b2-49ee-b76e-67db63bd315d"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/pp_generation_unconfined_constM.i</h4><pre class="moose-pre"><code class="language-text"># A sample is constrained on all sides, except its top
# and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie kg/second per cubic meter), and the
# rise in the top surface, porepressure, and stress are observed.
#
# In the standard poromechanics scenario, the Biot Modulus is held
# fixed and the source, s, has units m^3/second/m^3.  Then the expected result
# is
# strain_zz = disp_z = BiotCoefficient*BiotModulus*s*t/((bulk + 4*shear/3) + BiotCoefficient^2*BiotModulus)
# porepressure = BiotModulus*(s*t - BiotCoefficient*strain_zz)
# stress_xx = (bulk - 2*shear/3)*strain_zz   (remember this is effective stress)
# stress_zz = (bulk + 4*shear/3)*strain_zz   (remember this is effective stress)
#
# In porous_flow, however, the source has units kg/second/m^3.  The ratios remain
# fixed:
# stress_xx/strain_zz = (bulk - 2*shear/3) = 1 (for the parameters used here)
# stress_zz/strain_zz = (bulk + 4*shear/3) = 4 (for the parameters used here)
# porepressure/strain_zz = 13.3333333 (for the parameters used here)
#
# Expect
# disp_z = 0.3*10*s*t/((2 + 4*1.5/3) + 0.3^2*10) = 0.612245*s*t
# porepressure = 10*(s*t - 0.3*0.612245*s*t) = 8.163265*s*t
# stress_xx = (2 - 2*1.5/3)*0.612245*s*t = 0.612245*s*t
# stress_zz = (2 + 4*shear/3)*0.612245*s*t = 2.44898*s*t
# The relationship between the constant poroelastic source
# s (m^3/second/m^3) and the PorousFlow source, S (kg/second/m^3) is
# S = fluid_density * s = s * exp(porepressure/fluid_bulk)

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    m = 0.8
    alpha = 1e-5
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    component = 2
    variable = disp_z
  [../]
  [./poro_vol_exp]
    type = PorousFlowMassVolumetricExpansion
    variable = porepressure
    fluid_component = 0
  [../]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = porepressure
  [../]
  [./flux]
    type = PorousFlowAdvectiveFlux
    variable = porepressure
    gravity = &#x27;0 0 0&#x27;
    fluid_component = 0
  [../]
  [./source]
    type = BodyForce
    function = &#x27;0.1*exp(8.163265306*0.1*t/3.3333333333)&#x27;
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 3.3333333333
      density0 = 1
      thermal_expansion = 0
      viscosity = 1
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
  [../]
  [./ppss]
    type = PorousFlow1PhaseP
    porepressure = porepressure
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosityHMBiotModulus
    porosity_zero = 0.1
    biot_coefficient = 0.3
    solid_bulk = 2
    constant_fluid_bulk_modulus = 3.3333333333
    constant_biot_modulus = 10.0
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0   0 1 0   0 0 1&#x27; # unimportant
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityCorey
    n = 0 # unimportant in this fully-saturated situation
    phase = 0
  [../]
[]

[Postprocessors]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]
[]

[Functions]
  [./stress_xx_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_xx zdisp&#x27;
  [../]
  [./stress_zz_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;stress_zz zdisp&#x27;
  [../]
  [./p_over_strain_fcn]
    type = ParsedFunction
    value = a/b
    vars = &#x27;a b&#x27;
    vals = &#x27;p0 zdisp&#x27;
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 1E-14 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation_unconfined_constM
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="356ad4fe-9451-4860-9eb6-729f9bf21e78"><div class="modal-content"><h4>test/tests/time_steppers/timesequence_stepper/csvtimesequence.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  end_time = 10
  [./TimeStepper]
    type = CSVTimeSequenceStepper
    file_name = timesequence.csv
    column_name = time1
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="db0762ff-9892-4342-bfad-dd2fd9a55a36"><div class="modal-content"><h4>test/tests/materials/material/adv_mat_couple_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Materials]
  # This material is global and uses a coupled property
  [./mat_global]
    type = CoupledMaterial
    mat_prop = &#x27;some_prop&#x27;
    coupled_mat_prop = &#x27;mp1&#x27;
    block = &#x27;1 2&#x27;
  [../]

  # This material supplies a value for block 1 ONLY
  [./mat_0]
    type = GenericConstantMaterial
    block = 1
    prop_names = &#x27;mp1&#x27;
    prop_values = 2
  [../]

  # This material supplies a value for block 2 ONLY
  [./mat_1]
    type = GenericConstantMaterial
    block = 2
    prop_names = &#x27;mp1&#x27;
    prop_values = 200
  [../]
[]

[Executioner]
  type = Steady
#  solve_type = &#x27;PJFNK&#x27;
#  preconditioner = &#x27;ILU&#x27;

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
#  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  file_base = out_adv_coupled
  exodus = true
[]

[Debug]
  show_material_props = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8802f005-ced3-4e05-a087-9d6e8ad262d4"><div class="modal-content"><h4>modules/navier_stokes/test/tests/ins/mms/supg/supg_pspg_adv_dominated_mms.i</h4><pre class="moose-pre"><code class="language-text">mu=1.5e-4
rho=2.5

[GlobalParams]
  gravity = &#x27;0 0 0&#x27;
  supg = true
  pspg = true
  convective_term = true
  integrate_p_by_parts = false
  transient_term = true
  laplace = true
  u = vel_x
  v = vel_y
  p = p
  alpha = 1e0
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1.0
    ymin = 0
    ymax = 1.0
    elem_type = QUAD9
    nx = 4
    ny = 4
  []
  [./corner_node]
    type = ExtraNodesetGenerator
    new_boundary = &#x27;pinned_node&#x27;
    nodes = &#x27;0&#x27;
    input = gen
  [../]
[]

[Variables]
  [./vel_x]
  [../]

  [./vel_y]
  [../]

  [./p]
    order = FIRST
  [../]
[]

[Kernels]
  # mass
  [./mass]
    type = INSMass
    variable = p
    x_vel_forcing_func = vel_x_source_func
    y_vel_forcing_func = vel_y_source_func
  [../]

  [./x_time]
    type = INSMomentumTimeDerivative
    variable = vel_x
  [../]
  [./y_time]
    type = INSMomentumTimeDerivative
    variable = vel_y
  [../]

  # x-momentum, space
  [./x_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_x
    component = 0
    forcing_func = vel_x_source_func
  [../]

  # y-momentum, space
  [./y_momentum_space]
    type = INSMomentumLaplaceForm
    variable = vel_y
    component = 1
    forcing_func = vel_y_source_func
  [../]

  [./p_source]
    type = BodyForce
    function = p_source_func
    variable = p
  [../]
[]

[BCs]
  [./vel_x]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = vel_x_func
    variable = vel_x
  [../]
  [./vel_y]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = vel_y_func
    variable = vel_y
  [../]
  [./p]
    type = FunctionDirichletBC
    boundary = &#x27;left right top bottom&#x27;
    function = p_func
    variable = p
  [../]
[]

[Functions]
  [./vel_x_source_func]
    type = ParsedFunction
    value = &#x27;-${mu}*(-0.028*pi^2*x^2*sin(0.2*pi*x*y) - 0.028*pi^2*y^2*sin(0.2*pi*x*y) - 0.1*pi^2*sin(0.5*pi*x) - 0.4*pi^2*sin(pi*y)) + ${rho}*(0.14*pi*x*cos(0.2*pi*x*y) + 0.4*pi*cos(pi*y))*(0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3) + ${rho}*(0.14*pi*y*cos(0.2*pi*x*y) + 0.2*pi*cos(0.5*pi*x))*(0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5) + 0.1*pi*y*cos(0.2*pi*x*y) + 0.25*pi*cos(0.5*pi*x)&#x27;
  [../]
  [./vel_y_source_func]
    type = ParsedFunction
    value = &#x27;-${mu}*(-0.018*pi^2*x^2*sin(0.3*pi*x*y) - 0.018*pi^2*y^2*sin(0.3*pi*x*y) - 0.384*pi^2*sin(0.8*pi*x) - 0.027*pi^2*sin(0.3*pi*y)) + ${rho}*(0.06*pi*x*cos(0.3*pi*x*y) + 0.09*pi*cos(0.3*pi*y))*(0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3) + ${rho}*(0.06*pi*y*cos(0.3*pi*x*y) + 0.48*pi*cos(0.8*pi*x))*(0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5) + 0.1*pi*x*cos(0.2*pi*x*y) + 0.3*pi*cos(0.3*pi*y)&#x27;
  [../]
  [./p_source_func]
    type = ParsedFunction
    value = &#x27;-0.06*pi*x*cos(0.3*pi*x*y) - 0.14*pi*y*cos(0.2*pi*x*y) - 0.2*pi*cos(0.5*pi*x) - 0.09*pi*cos(0.3*pi*y)&#x27;
  [../]
  [./vel_x_func]
    type = ParsedFunction
    value = &#x27;0.4*sin(0.5*pi*x) + 0.4*sin(pi*y) + 0.7*sin(0.2*pi*x*y) + 0.5&#x27;
  [../]
  [./vel_y_func]
    type = ParsedFunction
    value = &#x27;0.6*sin(0.8*pi*x) + 0.3*sin(0.3*pi*y) + 0.2*sin(0.3*pi*x*y) + 0.3&#x27;
  [../]
  [./p_func]
    type = ParsedFunction
    value = &#x27;0.5*sin(0.5*pi*x) + 1.0*sin(0.3*pi*y) + 0.5*sin(0.2*pi*x*y) + 0.5&#x27;
  [../]
  [./vxx_func]
    type = ParsedFunction
    value = &#x27;0.14*pi*y*cos(0.2*pi*x*y) + 0.2*pi*cos(0.5*pi*x)&#x27;
  [../]
[]

[Materials]
  [./const]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;rho mu&#x27;
    prop_values = &#x27;${rho}  ${mu}&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  [../]
[]

[Executioner]
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -snes_view&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu NONZERO superlu_dist&#x27;
  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-12
  nl_max_its = 10
  l_tol = 1e-6
  l_max_its = 10
  # To run to steady-state, set num-steps to some large number (1000000 for example)
  type = Transient
  num_steps = 10
  steady_state_detection = true
  steady_state_tolerance = 1e-10
  [./TimeStepper]
    dt = .1
    type = IterationAdaptiveDT
    cutback_factor = 0.4
    growth_factor = 1.2
    optimal_iterations = 20
  [../]
[]

[Outputs]
  execute_on = &#x27;final&#x27;
  [./exodus]
    type = Exodus
  [../]
  [./csv]
    type = CSV
  [../]
[]

[Postprocessors]
  [./L2vel_x]
    type = ElementL2Error
    variable = vel_x
    function = vel_x_func
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2vel_y]
    variable = vel_y
    function = vel_y_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2p]
    variable = p
    function = p_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./L2vxx]
    variable = vxx
    function = vxx_func
    type = ElementL2Error
    outputs = &#x27;console csv&#x27;
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[AuxVariables]
  [./vxx]
    family = MONOMIAL
    order = FIRST
  [../]
[]

[AuxKernels]
  [./vxx]
    type = VariableGradientComponent
    component = x
    variable = vxx
    gradient_variable = vel_x
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1ad42386-65c5-469b-9531-b9e5f8871680"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/initial_stress/gravity.i</h4><pre class="moose-pre"><code class="language-text"># Apply an initial stress that should be
# exactly that caused by gravity, and then
# do a transient step to check that nothing
# happens

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 10
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -10
  zmax = 0
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./weight]
    type = BodyForce
    variable = disp_z
    value = -0.5 # this is density*gravity
  [../]
[]


[BCs]
  # back = zmin
  # front = zmax
  # bottom = ymin
  # top = ymax
  # left = xmin
  # right = xmax
  [./x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left right&#x27;
    value = 0
  [../]
  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom top&#x27;
    value = 0
  [../]
  [./z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;back&#x27;
    value = 0
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]


[Functions]
  [./weight]
    type = ParsedFunction
    value = &#x27;0.5*z&#x27; # initial stress that should result from the weight force
  [../]
  [./kxx]
    type = ParsedFunction
    value = &#x27;0.4*z&#x27; # some arbitrary xx and yy stress that should not affect the result
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.25
  [../]
  [./strain]
    type = ComputeSmallStrain
    eigenstrain_names = ini_stress
  [../]
  [./strain_from_initial_stress]
    type = ComputeEigenstrainFromInitialStress
    initial_stress = &#x27;kxx 0 0  0 kxx 0  0 0 weight&#x27;
    eigenstrain_name = ini_stress
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]


[Executioner]
  end_time = 1.0
  dt = 1.0
  solve_type = NEWTON
  type = Transient

  nl_abs_tol = 1E-8
  nl_rel_tol = 1E-12
  l_tol = 1E-3
  l_max_its = 200
  nl_max_its = 400

  petsc_options_iname = &#x27;-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27; asm      2              lu            gmres     200&#x27;
[]



[Outputs]
  file_base = gravity
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d28b010c-150f-49f1-8ff2-2ce2a5930f40"><div class="modal-content"><h4>modules/ray_tracing/test/tests/coord_type/rz_line_integral.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 2
    xmin = 0
    xmax = 2
    ymin = 0
    ymax = 1
  []
[]

[Variables/u]
[]

[BCs]
  [fixed]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Kernels]
  [diffusion]
    type = Diffusion
    variable = u
  []
  [source]
    type = BodyForce
    variable = u
    value = 10
  []
[]

[UserObjects]
  [study]
    type = RepeatableRayStudy
    names = &#x27;ray0 ray1&#x27;
    start_points = &#x27;0 0.5 0
                    0 0.1 0&#x27;
    end_points = &#x27;2.0 0.5 0
                  2.0 0.9 0&#x27;
  []
[]

[RayKernels]
  [variable_integral]
    type = VariableIntegralRayKernel
    study = study
    variable = u
    rays = &#x27;ray0 ray1&#x27;
  []
[]

[Postprocessors]
  [ray0_value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = ray0
  []
  [ray1_value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = ray1
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fcad3ede-5dc6-4d82-973a-88f46221038b"><div class="modal-content"><h4>test/tests/executioners/executioner/sln-time-adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./dt]
    type = TimestepSize
  [../]
[]

[Executioner]
  type = Transient
  [./TimeStepper]
    type = SolutionTimeAdaptiveDT
    dt = 0.1
  [../]
  scheme = &#x27;implicit-euler&#x27;

  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_sta
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="510caada-258b-4803-ab96-cdb912b14724"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/inertial_torque/simple.i</h4><pre class="moose-pre"><code class="language-text"># A single element is stretched.
#
# For all time:
# disp_x = 0
# disp_z = 3
#
# The velocities are initialised to zero
# The accelerations are initialised to
# accel_x = 0
# accel_y = 2
# accel_z = 0
#
# The only degree of freedom is disp_y.
# It is initialised to zero.
# The DE is the ZEROTH component of
# density * disp x accel = BodyForce
# (Choosing the zeroth component is unusual: this
# is to illustrate correct behaviour of the
# InertialTorque Kernel, rather than being
# relevant to any particular solid-mechanics problem.)
# The LHS = - density * disp_z * accel_y
# With density = 0.5 and BodyForce = -3 the solution is
# accel_y = 2, vel_y = 2 * t, and disp_y = t^2
[Mesh]
  type = GeneratedMesh
  dim = 3
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  velocities = &#x27;vel_x vel_y vel_z&#x27;
  accelerations = &#x27;accel_x accel_y accel_z&#x27;
  gamma = 0.5
  beta = 0.25
  alpha = 0.0
  eta = 0.0
[]

[Variables]
  [./disp_y]
  [../]
[]

[Kernels]
  [./icm_x]
    type = InertialTorque
    component = 0
    variable = disp_y
  [../]
  [./source_x]
    type = BodyForce
    variable = disp_y
    function = -3
  [../]
[]

[AuxVariables]
  [./disp_x]
  [../]
  [./disp_z]
    initial_condition = 3
  [../]
  [./vel_x]
  [../]
  [./vel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_x]
  [../]
  [./accel_y]
    initial_condition = 2
  [../]
  [./accel_z]
  [../]
[]

[AuxKernels]
  [./vel_x]
    type = NewmarkVelAux
    variable = vel_x
    acceleration = accel_x
    execute_on = timestep_end
  [../]
  [./vel_y]
    type = NewmarkVelAux
    variable = vel_y
    acceleration = accel_y
    execute_on = timestep_end
  [../]
  [./vel_z]
    type = NewmarkVelAux
    variable = vel_z
    acceleration = accel_z
    execute_on = timestep_end
  [../]
  [./accel_x]
    type = NewmarkAccelAux
    variable = accel_x
    displacement = disp_x
    velocity = vel_x
    execute_on = timestep_end
  [../]
  [./accel_y]
    type = NewmarkAccelAux
    variable = accel_y
    displacement = disp_y
    velocity = vel_y
    execute_on = timestep_end
  [../]
  [./accel_z]
    type = NewmarkAccelAux
    variable = accel_z
    displacement = disp_z
    velocity = vel_z
    execute_on = timestep_end
  [../]
[]

[BCs]
  # zmin is called back
  # zmax is called front
  # ymin is called bottom
  # ymax is called top
  # xmin is called left
  # xmax is called right
[]

[Materials]
  [./density]
    type = GenericConstantMaterial
    prop_names = density
    prop_values = 0.5
  [../]
[]

[Postprocessors]
  [./y_disp]
    type = PointValue
    point = &#x27;0 0 0&#x27;
    use_displaced_mesh = false
    variable = disp_y
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_atol -snes_rtol -snes_max_it&#x27;
    petsc_options_value = &#x27;gmres bjacobi 1E-15 1E-10 10000&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 1
  num_steps = 10
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="09651f64-e3ed-47a2-a8d8-e4fab838cd7f"><div class="modal-content"><h4>test/tests/bcs/nodal_normals/circle_tris.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = circle-tris.e
[]

[Functions]
  [./all_bc_fn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./f_fn]
    type = ParsedFunction
    value = -4
  [../]

  [./analytical_normal_x]
    type = ParsedFunction
    value = x
  [../]
  [./analytical_normal_y]
    type = ParsedFunction
    value = y
  [../]
[]

[NodalNormals]
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./ffn]
    type = BodyForce
    variable = u
    function = f_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = &#x27;all_bc_fn&#x27;
  [../]
[]

[Postprocessors]
  [./nx_pps]
    type = NodalL2Error
    variable = nodal_normal_x
    boundary = &#x27;1&#x27;
    function = analytical_normal_x
  [../]
  [./ny_pps]
    type = NodalL2Error
    variable = nodal_normal_y
    boundary = &#x27;1&#x27;
    function = analytical_normal_y
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-13
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aa754444-06c5-4568-b6aa-4c8feab25dc3"><div class="modal-content"><h4>test/tests/executioners/executioner/steady-adapt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 3
  ny = 3
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = -4
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = ((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ffn&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;

  [./Adaptivity]
    steps = 3
    coarsen_fraction = 0.1
    refine_fraction = 0.2
    max_h_level = 5
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_steady_adapt
  exodus = true
  print_mesh_changed_info = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b38857ce-70a7-4cb8-9b4b-552a8d272e01"><div class="modal-content"><h4>test/tests/time_steppers/timesequence_stepper/timesequence_restart1.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  end_time = 4.0
  [./TimeStepper]
    type = TimeSequenceStepper
    time_sequence  = &#x27;0   0.85 1.3 2 4&#x27;
  [../]
[]

[Outputs]
  exodus = true
  [./checkpoint]
    type = Checkpoint
    num_files = 4
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dc14693d-3751-4f8c-b2ee-3705610790e0"><div class="modal-content"><h4>test/tests/interfacekernels/2d_interface/coupled_value_coupled_flux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 4
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 2
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    value = 1
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Postprocessors]
  [./u_int]
    type = ElementIntegralVariablePostprocessor
    variable = u
    block = 0
  [../]
  [./v_int]
    type = ElementIntegralVariablePostprocessor
    variable = v
    block = 1
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9eb1914b-a376-4661-9ab8-1c2eeae097c6"><div class="modal-content"><h4>test/tests/postprocessors/interface_value/interface_integral_variable_value_postprocessor.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 6
    xmax = 3
    ny = 9
    ymax = 3
    elem_type = QUAD4
  []
  [./subdomain_id]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;2 1 0&#x27;
    block_id = 1
    [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain_id
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;interface&#x27;
  [../]
[]

[Functions]
  [./fn_exact]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  [../]

  [./ffn]
    type = ParsedFunction
    value = -4
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = FIRST
  [../]
[]


[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = fn_exact
  [../]
[]

[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 5
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
  [../]
[]

[AuxKernels]
  [./diffusivity_1]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_1
  []
  [./diffusivity_2]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_2
  []
[]

[AuxVariables]
  [./diffusivity_1]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_2]
    family = MONOMIAL
    order = CONSTANT
  []
[]



[Postprocessors]
  [./diffusivity_average]
    type = InterfaceIntegralVariableValuePostprocessor
    interface_value_type = average
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_jump_primary_secondary]
    type = InterfaceIntegralVariableValuePostprocessor
    interface_value_type = jump_primary_minus_secondary
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_jump_secondary_primary]
    type = InterfaceIntegralVariableValuePostprocessor
    interface_value_type = jump_secondary_minus_primary
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_jump_abs]
    type = InterfaceIntegralVariableValuePostprocessor
    interface_value_type = jump_abs
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_primary]
    type = InterfaceIntegralVariableValuePostprocessor
    interface_value_type = primary
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
  [./diffusivity_secondary]
    type = InterfaceIntegralVariableValuePostprocessor
    interface_value_type = secondary
    variable = diffusivity_1
    neighbor_variable = diffusivity_2
    execute_on = TIMESTEP_END
    boundary = &#x27;interface&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dddc4ef1-06fd-46a1-a046-6ffc74c2258c"><div class="modal-content"><h4>test/tests/time_integrators/explicit-euler/ee-2d-linear.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = (x+y)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*(x+y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    lumping = true
    implicit = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
    implicit = false
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
    implicit = false
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    implicit = true
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;explicit-euler&#x27;
  solve_type = &#x27;LINEAR&#x27;

  start_time = 0.0
  num_steps = 20
  dt = 0.00005
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="61aba623-0259-4696-829a-ee9b9d909da5"><div class="modal-content"><h4>test/tests/dampers/interactions/interacting_node_elem_dampers.i</h4><pre class="moose-pre"><code class="language-text"># This model tests interactions between nodal and element dampers.
# The test verifies that the minimum of the value of a nodal and
# element damper is always used.
# If run with the nodal1 and elem1 dampers active, the element damper
# will govern.  With nodal2 and elem2 dampers, the nodal damper governs.

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./source]
    type = BodyForce
    variable = u
    function = &#x27;t&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Dampers]
  active = &#x27;nodal1 elem1&#x27;
  [./nodal1]
    #gives a damping of 0.3333 on step 6
    type = BoundingValueNodalDamper
    min_value = 0.0
    max_value = 1.0
    variable = u
  [../]
  [./elem1]
    #gives a damping of 0.141536 on step 6
    type = BoundingValueElementDamper
    min_value = 0.0
    max_value = 1.012
    variable = u
  [../]
  [./nodal2]
    #gives a damping of 0.3333 on step 6
    type = BoundingValueNodalDamper
    min_value = 0.0
    max_value = 1.0
    variable = u
  [../]
  [./elem2]
    #gives a damping of 0.743318 on step 6
    type = BoundingValueElementDamper
    min_value = 0.0
    max_value = 1.02
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  end_time = 3.0
  dt = 0.5
  dtmin = 0.5
  nl_max_its = 5
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7c7d1325-93b5-4198-8d03-85a57f982bed"><div class="modal-content"><h4>test/tests/bcs/penalty_dirichlet_bc/function_penalty_dirichlet_bc_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD9
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = -4+x*x+y*y
  [../]

  [./solution]
    type = ParsedGradFunction
    value = x*x+y*y
    grad_x = 2*x
    grad_y = 2*y
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = HIERARCHIC
  [../]
[]

[Kernels]
  active = &#x27;diff forcing reaction&#x27;
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./reaction]
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;bc_all&#x27;
  [./bc_all]
    type = FunctionPenaltyDirichletBC
    variable = u
    function = solution
    boundary = &#x27;top left right bottom&#x27;
    penalty = 1e6
  [../]
[]

[Postprocessors]
  [./dofs]
    type = NumDOFs
  [../]

  [./h]
    type = AverageElementSize
  [../]

  [./L2error]
    type = ElementL2Error
    variable = u
    function = solution
  [../]
  [./H1error]
    type = ElementH1Error
    variable = u
    function = solution
  [../]
  [./H1Semierror]
    type = ElementH1SemiError
    variable = u
    function = solution
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-14
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="25b0c8a3-e124-41ed-8b99-175db17dcfa9"><div class="modal-content"><h4>test/tests/transfers/multiapp_conservative_transfer/sub_nearest_point.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0.01 # to make sure the meshes don&#x27;t align
    xmax = 0.49 # to make sure the meshes don&#x27;t align
    ymax = 1
    nx = 10
    ny = 10
  []
  [block1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    block_id = 1
    bottom_left = &#x27;0.2 0.2 0&#x27;
    top_right = &#x27;0.3 0.8 0&#x27;
  []
[]

[Variables]
  [sink]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[Functions]
  [sink_func]
    type = ParsedFunction
    value = &#x27;5e2*x*(0.5-x)+5e1&#x27;
  []
[]

[Kernels]
  [reaction]
    type = Reaction
    variable = sink
  []

  [coupledforce]
    type = BodyForce
    variable = sink
    function = sink_func
  []
[]

[AuxVariables]
  [from_master]
    block = 1
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [sink]
    type = ElementIntegralVariablePostprocessor
    block = 1
    variable = sink
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
  [from_master_pp]
    type = ElementIntegralVariablePostprocessor
    block = 1
    variable = from_master
    execute_on = &#x27;transfer nonlinear TIMESTEP_END&#x27;
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4b31cef6-b063-4699-981a-856da99a5ddd"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_xy_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      xy
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with thermal conductivity
#   dependent upon the transient level set function. This problem can be
#   exactly evaluated by FEM/Moose without the moving interface. Both the
#   temperature and level set function are designed to be linear to attempt to
#   minimize the error between the Moose/exact solution and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=0, y=0) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time   Expected Temperature   XFEM Calculated Temperature
#      0.2                 440        440
#      0.4                 480        479.9998738
#      0.6                 520        519.9995114
#      0.8                 560        559.9989360
#      1.0                 600        599.9983833
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+200)-(5*t/1.04)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.01/1.04)*(-2.5*x-2.5*y-t)+1.55)*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+100)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+100)*t+400&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.01/1.04)*(-2.5*x-2.5*y-t)+1.55&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 1.04 -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5a2b0bc9-11d3-4a7c-9972-7e83dcc5b268"><div class="modal-content"><h4>test/tests/postprocessors/num_adaptivity_cycles/num_adaptivity_cycles_toggle_adaptivity_wait.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  nz = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./force]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./force]
    type = BodyForce
    variable = u
    function = force
  [../]
[]

[BCs]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1

  solve_type = &#x27;PJFNK&#x27;

[]

[Adaptivity]
  cycles_per_step = 1
  marker = box
  max_h_level = 2
  initial_steps = 4
  initial_marker = initial_box
  [./Markers]
    [./box]
      bottom_left = &#x27;0.3 0.3 0&#x27;
      inside = refine
      top_right = &#x27;0.6 0.6 0&#x27;
      outside = dont_mark
      type = BoxMarker
    [../]
    [./initial_box]
      type = BoxMarker
      bottom_left = &#x27;0.8 0.1 0&#x27;
      top_right = &#x27;0.9 0.2 0&#x27;
      inside = refine
      outside = dont_mark
    [../]
  [../]
[]

[UserObjects]
  [./toggle_adaptivity]
    type = ToggleMeshAdaptivity
    mesh_adaptivity = &#x27;off&#x27;
    apply_after_timestep = 1
  [../]
[]

[Postprocessors]
  [./adaptivity_cycles]
    type = NumAdaptivityCycles
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8a4435b2-e526-4119-a79a-c3239af6aedc"><div class="modal-content"><h4>test/tests/controls/time_periods/dgkernels/dgkernels.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
[]

[Adaptivity]
  marker = uniform_marker
  [./Markers]
    [./uniform_marker]
      type = UniformMarker
      mark = REFINE
    [../]
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL
    initial_condition = 1
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]

  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]          # u * v
    type = Reaction
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
  [../]
  [./dg_diff2]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 4
  [../]
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
#  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
#  petsc_options_value = &#x27;hypre    boomeramg&#x27;
  num_steps = 4
  dt = 1
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
[]

[Controls]
  [./dg_problem]
    type = TimePeriod
    enable_objects = &#x27;DGKernels/dg_diff2&#x27;
    disable_objects = &#x27;DGKernel::dg_diff&#x27;
    start_time = &#x27;2&#x27;
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b2e94779-d1fd-411b-a776-1697b8b8a9e5"><div class="modal-content"><h4>modules/porous_flow/test/tests/poro_elasticity/pp_generation.i</h4><pre class="moose-pre"><code class="language-text"># A sample is constrained on all sides and its boundaries are
# also impermeable.  Fluid is pumped into the sample via a
# volumetric source (ie kg/second per cubic meter), and the
# rise in porepressure is observed.
#
# Source = s  (units = kg/m^3/second)
#
# Expect:
# fluid_mass = mass0 + s*t
# stress = 0 (remember this is effective stress)
# Porepressure = fluid_bulk*log(fluid_mass_density/density_P0), where fluid_mass_density = fluid_mass*porosity
# porosity = biot+(phi0-biot)*exp(pp(biot-1)/solid_bulk)
#
# Parameters:
# Biot coefficient = 0.3
# Phi0 = 0.1
# Solid Bulk modulus = 2
# fluid_bulk = 13
# density_P0 = 1


[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 1
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -0.5
  zmax = 0.5
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  PorousFlowDictator = dictator
  block = 0
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;porepressure disp_x disp_y disp_z&#x27;
    number_fluid_phases = 1
    number_fluid_components = 1
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./porepressure]
  [../]
[]

[BCs]
  [./confinex]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  [../]
  [./confiney]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom top&#x27;
  [../]
  [./confinez]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back front&#x27;
  [../]
[]

[Kernels]
  [./grad_stress_x]
    type = StressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./grad_stress_y]
    type = StressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./grad_stress_z]
    type = StressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./poro_x]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_x
    component = 0
  [../]
  [./poro_y]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    variable = disp_y
    component = 1
  [../]
  [./poro_z]
    type = PorousFlowEffectiveStressCoupling
    biot_coefficient = 0.3
    component = 2
    variable = disp_z
  [../]
  [./poro_vol_exp]
    type = PorousFlowMassVolumetricExpansion
    variable = porepressure
    fluid_component = 0
  [../]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    fluid_component = 0
    variable = porepressure
  [../]
  [./flux]
    type = PorousFlowAdvectiveFlux
    variable = porepressure
    gravity = &#x27;0 0 0&#x27;
    fluid_component = 0
  [../]
  [./source]
    type = BodyForce
    function = 0.1
    variable = porepressure
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./porosity]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
  [./porosity]
    type = PorousFlowPropertyAux
    variable = porosity
    property = porosity
  [../]
[]

[Modules]
  [./FluidProperties]
    [./simple_fluid]
      type = SimpleFluidProperties
      bulk_modulus = 13
      density0 = 1
      thermal_expansion = 0
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;1 1.5&#x27;
    # bulk modulus is lambda + 2*mu/3 = 1 + 2*1.5/3 = 2
    fill_method = symmetric_isotropic
  [../]
  [./strain]
    type = ComputeSmallStrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./eff_fluid_pressure]
    type = PorousFlowEffectiveFluidPressure
  [../]
  [./vol_strain]
    type = PorousFlowVolumetricStrain
  [../]
  [./ppss]
    type = PorousFlow1PhaseFullySaturated
    porepressure = porepressure
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
  [../]
  [./simple_fluid]
    type = PorousFlowSingleComponentFluid
    fp = simple_fluid
    phase = 0
  [../]
  [./porosity]
    type = PorousFlowPorosity
    fluid = true
    mechanical = true
    porosity_zero = 0.1
    biot_coefficient = 0.3
    solid_bulk = 2
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1 0 0   0 1 0   0 0 1&#x27; # unimportant
  [../]
  [./relperm]
    type = PorousFlowRelativePermeabilityCorey
    n = 0 # unimportant in this fully-saturated situation
    phase = 0
  [../]
[]

[Functions]
  [./porosity_analytic]
    type = ParsedFunction
    value = &#x27;biot+(phi0-biot)*exp(pp*(biot-1)/bulk)&#x27;
    vars = &#x27;biot phi0 pp bulk&#x27;
    vals = &#x27;0.3 0.1 p0 2&#x27;
  [../]
[]

[Postprocessors]
  [./fluid_mass]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;initial timestep_end&#x27;
    use_displaced_mesh = true
  [../]
  [./porosity]
    type = PointValue
    outputs = &#x27;console csv&#x27;
    point = &#x27;0 0 0&#x27;
    variable = porosity
  [../]
  [./p0]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = porepressure
  [../]
  [./porosity_analytic]
    type = FunctionValuePostprocessor
    function = porosity_analytic
  [../]
  [./zdisp]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0.5&#x27;
    variable = disp_z
  [../]
  [./stress_xx]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_xx
  [../]
  [./stress_yy]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_yy
  [../]
  [./stress_zz]
    type = PointValue
    outputs = csv
    point = &#x27;0 0 0&#x27;
    variable = stress_zz
  [../]

[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-ksp_type -pc_type -snes_max_it -snes_stol&#x27;
    petsc_options_value = &#x27;bcgs bjacobi 10000 1E-11&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  start_time = 0
  end_time = 10
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = pp_generation
  [./csv]
    type = CSV
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7ed7479a-19ff-4030-814d-dc531697fa60"><div class="modal-content"><h4>test/tests/materials/material/adv_mat_couple_test2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = rectangle.e
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = 1
    value = 10
  [../]
[]

[BCs]
  active = &#x27;right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Materials]
  [./mat_3]
    type = GenericConstantMaterial
    prop_names = &#x27;prop3&#x27;
    prop_values = &#x27;300&#x27;
    block = &#x27;1 2&#x27;
  [../]

  [./mat_2]
    type = CoupledMaterial
    mat_prop = &#x27;prop2&#x27;
    coupled_mat_prop = &#x27;prop3&#x27;
    block = &#x27;1 2&#x27;
  [../]

  [./mat_1]
    type = CoupledMaterial2
    mat_prop = &#x27;prop1&#x27;
    coupled_mat_prop1 = &#x27;prop2&#x27;
    coupled_mat_prop2 = &#x27;prop3&#x27;
    block = &#x27;1 2&#x27;
  [../]
[]

[Executioner]
  type = Steady
#  solve_type = &#x27;PJFNK&#x27;
#  preconditioner = &#x27;ILU&#x27;

  solve_type = &#x27;PJFNK&#x27;
#  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
#  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  file_base = out_adv_coupled2
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="66882c61-aae6-44fe-9cc8-0d086179edfe"><div class="modal-content"><h4>test/tests/auxkernels/element_var/element_var_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
  # This test uses ElementalVariableValue postprocessors on specific
  # elements, so element numbering needs to stay unchanged
  allow_renumbering = false
[]

[Functions]
  [./ffn]
    type = ParsedFunction
    value = -4
  [../]

  [./exactfn]
    type = ParsedFunction
    value = x*x+y*y
  [../]

  [./aux_exact_fn]
    type = ParsedFunction
    value = t*(x*x+y*y)
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  #Coupling of nonlinear to Aux
  [./force]
    type = BodyForce
    variable = u
    function = ffn
  [../]
[]

[AuxVariables]
  [./aux_u]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./a]
    type = FunctionAux
    variable = aux_u
    function = aux_exact_fn
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exactfn
  [../]
[]

[Postprocessors]
  [./elem_56]
    type = ElementalVariableValue
    variable = u
    elementid = 56
  [../]

  [./aux_elem_99]
    type = ElementalVariableValue
    variable = aux_u
    elementid = 99
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.01
  start_time = 0
  num_steps = 10
[]

[Outputs]
  exodus = true
  file_base = out
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7bfd0bf0-6e0a-4cfa-907a-e54ebbae59fb"><div class="modal-content"><h4>python/peacock/tests/common/transient.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of a &quot;Transient&quot; Executioner.
#
# @Requirement F1.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 10
  ny = 10
  elem_type = QUAD4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = ConstantIC
      value = 0
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    # dudt = 3*t^2*(x^2 + y^2)
    value = 3*t*t*((x*x)+(y*y))-(4*t*t*t)
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*t*t*((x*x)+(y*y))
  [../]
[]

[Kernels]
  active = &#x27;diff ie ffn&#x27;

  [./ie]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  active = &#x27;all&#x27;

  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./dt]
    type = TimestepSize
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;implicit-euler&#x27;

  # Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  start_time = 0.0
  num_steps = 5
  dt = 0.1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out_transient
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="907650b1-9e5a-4e05-a6ba-fdae8b2924e0"><div class="modal-content"><h4>test/tests/time_integrators/actually_explicit_euler_verification/ee-1d-linear.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 200
  elem_type = EDGE2
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./ie]
    type = TimeDerivative
    variable = u
    lumping = true
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = &#x27;0 1&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  start_time = 0.0
  num_steps = 20
  dt = 0.00005

  [./TimeIntegrator]
    type = ActuallyExplicitEuler
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4509e79a-bd3e-4151-9263-28c4738cd86b"><div class="modal-content"><h4>test/tests/postprocessors/element_l2_error_pps/element_l2_error_pp_test.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test of the Postprocessor System. This
# test uses a forcing function and the MMS to verify
# correctness of the implementation.
# Grid adaptivity is applied at successively finer grids
# to verify the correct slope of the measure of error
# against the analytical solution.
#
# @Requirement F6.10
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 3
  ny = 3

  xmin = 0
  xmax = 2

  ymin = 0
  ymax = 2
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;forcing_func u_func&#x27;

  [./forcing_func]
    type = ParsedFunction
    value = alpha*alpha*pi*pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;4&#x27;
  [../]

  [./u_func]
    type = ParsedFunction
    value = sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;4&#x27;
  [../]
[]

[Kernels]
  active = &#x27;diff forcing&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_func
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = &#x27;3&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = Steady

  [./Adaptivity]
    refine_fraction = 1.0
    coarsen_fraction = 0.0
    max_h_level = 10
    steps = 4
  [../]
[]

# Postprocessor System
[Postprocessors]
  [./integral]
    type = ElementL2Error
    variable = u
    function = u_func
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  file_base = out
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aa485e20-5f70-49e9-ba43-7f52f71140c8"><div class="modal-content"><h4>test/tests/dgkernels/2d_diffusion_dg/dg_stateful.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = MONOMIAL
    [./InitialCondition]
      type = ConstantIC
      value = 1
    [../]
  [../]
[]

[Functions]
  [./forcing_fn]
    type = ParsedFunction
    value = 2*pow(e,-x-(y*y))*(1-2*y*y)
  [../]
  [./exact_fn]
    type = ParsedGradFunction
    value = pow(e,-x-(y*y))
    grad_x = -pow(e,-x-(y*y))
    grad_y = -2*y*pow(e,-x-(y*y))
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./abs]
    type = Reaction
    variable = u
  [../]
  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[DGKernels]
  [./dg_diff]
    type = DGDiffusion
    variable = u
    epsilon = -1
    sigma = 6
  [../]
[]

[BCs]
  [./all]
    type = DGFunctionDiffusionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
    epsilon = -1
    sigma = 6
  [../]
[]

[Materials]
  [./stateful]
    type = StatefulMaterial
    initial_diffusivity = 1
    boundary = &#x27;left&#x27;
  [../]
  [./general]
    type = GenericConstantMaterial
    block = &#x27;0&#x27;
    prop_names = &#x27;dummy&#x27;
    prop_values = &#x27;1&#x27;
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-10
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aa805bf9-2bae-49a1-a4eb-97a250db0a5d"><div class="modal-content"><h4>test/tests/time_integrators/actually_explicit_euler_verification/ee-1d-quadratic-neumann.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = -1
  xmax = 1
  nx = 10
  elem_type = EDGE3
[]

[Functions]
  [./ic]
    type = ParsedFunction
    value = 0
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = x*x-2*t+t*x*x
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = t*x*x
  [../]

  [./left_bc_fn]
    type = ParsedFunction
    value = -t*2*x
  [../]
  [./right_bc_fn]
    type = ParsedFunction
    value = t*2*x
  [../]
[]

[Variables]
  [./u]
    order = SECOND
    family = LAGRANGE

    [./InitialCondition]
      type = FunctionIC
      function = ic
    [../]
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./abs]
    type = Reaction
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;0&#x27;
    function = left_bc_fn
  [../]

  [./right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;1&#x27;
    function = right_bc_fn
  [../]
[]

[Postprocessors]
  [./l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient

  l_tol = 1e-12
  start_time = 0.0
  num_steps = 10
  dt = 0.001

  [./TimeIntegrator]
    type = ActuallyExplicitEuler
  [../]
[]

[Outputs]
  exodus = true
  [./console]
    type = Console
    max_rows = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="567f88b7-8270-4cba-ba79-ea1236fa6e44"><div class="modal-content"><h4>test/tests/postprocessors/pps_interval/pps_bad_interval3.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = square-2x2-nodeids.e
  # This test can only be run with renumering disabled, so the
  # NodalVariableValue postprocessor&#x27;s node id is well-defined.
  allow_renumbering = false
[]

[Variables]
  active = &#x27;u v&#x27;

  [./u]
    order = SECOND
    family = LAGRANGE
  [../]

  [./v]
    order = SECOND
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;force_fn exact_fn left_bc&#x27;

  [./force_fn]
    type = ParsedFunction
    value = &#x27;1-x*x+2*t&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;(1-x*x)*t&#x27;
  [../]

  [./left_bc]
    type = ParsedFunction
    value = t
  [../]
[]

[Kernels]
  active = &#x27;
    time_u diff_u ffn_u
    time_v diff_v&#x27;

  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]

  [./time_v]
    type = TimeDerivative
    variable = v
  [../]

  [./diff_v]
    type = Diffusion
    variable = v
  [../]
[]

[BCs]
  active = &#x27;all_u left_v right_v&#x27;

  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    function = exact_fn
  [../]

  [./left_v]
    type = FunctionDirichletBC
    variable = v
    boundary = &#x27;3&#x27;
    function = left_bc
  [../]

  [./right_v]
    type = DirichletBC
    variable = v
    boundary = &#x27;2&#x27;
    value = 0
  [../]
[]

[Postprocessors]
  active = &#x27;l2 node1 node4&#x27;

  [./l2]
    type = ElementL2Error
    variable = u
    function = exact_fn
  [../]

  [./node1]
    type = NodalVariableValue
    variable = u
    nodeid = 15
  [../]

  [./node4]
    type = NodalVariableValue
    variable = v
    nodeid = 10
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 0.1
  start_time = 0
  end_time = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = ignore_bad
  interval = 2
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7142a787-5801-446e-a8d5-3afa24172c32"><div class="modal-content"><h4>test/tests/kernels/forcing_function/forcing_function_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
  uniform_refine = 4
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  active = &#x27;forcing_func&#x27;

  [./forcing_func]
    type = ParsedFunction
    value = alpha*alpha*pi*pi*sin(alpha*pi*x)
    vars = &#x27;alpha&#x27;
    vals = &#x27;16&#x27;
  [../]
[]

[Kernels]
  active = &#x27;diff forcing&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./forcing]
    type = BodyForce
    variable = u
    function = forcing_func
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ca584785-ddcc-4fd7-92fe-e5749210a71d"><div class="modal-content"><h4>test/tests/functions/parsed/mms_transient_coupled.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test of the Function System. This
# test uses forcing terms produced from analytical
# functions of space and time to verify a solution
# using MMS.
#
# @Requirement F6.20
###########################################################


[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 1.0
  nx = 10
  ymin = 0.0
  ymax = 1.0
  ny = 10
  uniform_refine = 2
  elem_type = QUAD4
[]

[Variables]
  [./u]
  [../]
  [./v]
  [../]
[]

[Functions]
  [./v_left_bc]
    # Left-side boundary condition for v equation, v(0,y,t) = u(0.5,y,t). This is accomplished using a PointValue postprocessor, which is what this input file was designed to test.
    type = ParsedFunction
    value = a
    vals = u_midpoint
    vars = a
  [../]
  [./u_mms_func]
    # MMS Forcing function for the u equation.
    type = ParsedFunction
    value = &#x27; 20*exp(20*t)*x*x*x-6*exp(20*t)*x-(2-0.125*exp(20*t))*sin(5/2*x*pi)-0.125*exp(20*t)-1
&#x27;
  [../]
  [./v_mms_func]
    # MMS forcing function for the v equation.
    type = ParsedFunction
    value = -2.5*exp(20*t)*sin(5/2*x*pi)+2.5*exp(20*t)+25/4*(2-0.125*exp(20*t))*sin(5/2*x*pi)*pi*pi
  [../]
  [./u_right_bc]
    type = ParsedFunction
    value = 3*exp(20*t) # \nabla{u}|_{x=1} = 3\exp(20*t)
  [../]
  [./u_exact]
    # Exact solution for the MMS function for the u variable.
    type = ParsedFunction
    value = exp(20*t)*pow(x,3)+1
  [../]
  [./v_exact]
    # Exact MMS solution for v.
    type = ParsedFunction
    value = (2-0.125*exp(20*t))*sin(5/2*pi*x)+0.125*exp(20*t)+1
  [../]
[]

[Kernels]
  # Strong Form:
  # \frac{\partial u}{\partial t} - \nabla \cdot 0.5 \nabla u - v = 0
  # \frac{\partial u}{\partial t} - \nabla \cdot \nabla v = 0
  #
  # BCs:
  # u(0,y,t) = 1
  # \nabla u |_{x=1} = 3\exp(20*t)
  # v(0,y,t) = u(0.5,y,t)
  # v(1,y,t) = 3
  # \nabla u |_{y=0,1} = 0
  # \nabla v |_{y=0,1} = 0
  #
  [./u_time]
    type = TimeDerivative
    variable = u
  [../]
  [./u_diff]
    type = Diffusion
    variable = u
  [../]
  [./u_source]
    type = CoupledForce
    variable = u
    v = v
  [../]
  [./v_diff]
    type = Diffusion
    variable = v
  [../]
  [./u_mms]
    type = BodyForce
    variable = u
    function = u_mms_func
  [../]
  [./v_mms]
    type = BodyForce
    variable = v
    function = v_mms_func
  [../]
  [./v_time]
    type = TimeDerivative
    variable = v
  [../]
[]

[BCs]
  [./u_left]
    type = DirichletBC
    variable = u
    boundary = left # x=0
    value = 1 # u(0,y,t)=1
  [../]
  [./u_right]
    type = FunctionNeumannBC
    variable = u
    boundary = right # x=1
    function = u_right_bc # \nabla{u}|_{x=1}=3\exp(20t)
  [../]
  [./v_left]
    type = FunctionDirichletBC
    variable = v
    boundary = left # x=0
    function = v_left_bc # v(0,y,t) = u(0.5,y,t)
  [../]
  [./v_right]
    type = DirichletBC
    variable = v
    boundary = right # x=1
    value = 3 # v(1,y,t) = 3
  [../]
[]

[Postprocessors]
  [./u_midpoint]
    type = PointValue
    variable = u
    point = &#x27;0.5 0.5 0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./u_midpoint_exact]
    type = FunctionValuePostprocessor
    function = u_exact
    point = &#x27;0.5 0.5 0.0&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./u_error]
    type = ElementL2Error
    variable = u
    function = u_exact
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./v_error]
    type = ElementL2Error
    variable = v
    function = v_exact
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.01

  solve_type = NEWTON

  end_time = 0.1
  scheme = crank-nicolson
[]

[Outputs]
  exodus = true
[]

[ICs]
  [./u_initial]
    # Use the MMS exact solution to compute the initial conditions.
    function = u_exact
    variable = u
    type = FunctionIC
  [../]
  [./v_exact]
    # Use the MMS exact solution to compute the initial condition.
    function = v_exact
    variable = v
    type = FunctionIC
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="76366fff-03c2-4bcf-9484-034925efadf7"><div class="modal-content"><h4>test/tests/time_integrators/aee/aee.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1

  nx = 10

  xmin = 0.0
  xmax = 1.0

[]

#still need BC for Energy, IC&#x27;s for both.
[Variables]
  active = &#x27;Time&#x27;

  [./Time]
    order =  FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[Functions]
  active = &#x27;func&#x27;

  [./func]
    type = ParsedFunction
    value = 2.0*t
  [../]
[]

[Kernels]
  active = &#x27;t_time func_time&#x27;

  [./t_time]
    type = TimeDerivative
    variable = Time
  [../]

  [./func_time]
    type = BodyForce
    variable = Time
    function = func
  [../]
[]

[BCs]
  active = &#x27;Top_Temperature&#x27;

  [./Top_Temperature]
    type = NeumannBC
    variable = Time
    boundary = &#x27;left right&#x27;
  [../]

[]

[Executioner]
  type = Transient
  scheme = &#x27;BDF2&#x27;
  #scheme = &#x27;crank-nicolson&#x27;
  start_time = 0
  num_steps = 4
  nl_abs_tol = 1e-15
  petsc_options = &#x27;-snes_converged_reason&#x27;
  abort_on_solve_fail = true
 [./TimeStepper]
    type = AB2PredictorCorrector
    dt = .01
    e_max = 10
    e_tol = 1
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cd99db0a-a1c3-4fb4-9b6c-878a9e92ad69"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/initial_stress/gravity_cosserat.i</h4><pre class="moose-pre"><code class="language-text"># Apply an initial stress that should be
# exactly that caused by gravity, and then
# do a transient step to check that nothing
# happens
# TODO: currently this has no div(moment_stress)
# contriution to the Kernels.  This is because
# there is no way in MOOSE of calculating
# moment stresses and applying initial stresses.
# This will become possible after issue #7243 is
# resolved.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 1
  nz = 10
  xmin = -0.5
  xmax = 0.5
  ymin = -0.5
  ymax = 0.5
  zmin = -10
  zmax = 0
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  Cosserat_rotations = &#x27;wc_x wc_y wc_z&#x27;
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./wc_x]
  [../]
  [./wc_y]
  [../]
  [./wc_z]
  [../]
[]

[Kernels]
  [./cx_elastic]
    type = CosseratStressDivergenceTensors
    variable = disp_x
    component = 0
  [../]
  [./cy_elastic]
    type = CosseratStressDivergenceTensors
    variable = disp_y
    component = 1
  [../]
  [./cz_elastic]
    type = CosseratStressDivergenceTensors
    variable = disp_z
    component = 2
  [../]
  [./x_moment]
    type = MomentBalancing
    variable = wc_x
    component = 0
  [../]
  [./y_moment]
    type = MomentBalancing
    variable = wc_y
    component = 1
  [../]
  [./z_moment]
    type = MomentBalancing
    variable = wc_z
    component = 2
  [../]
  [./weight]
    type = BodyForce
    variable = disp_z
    value = -0.5 # this is density*gravity
  [../]
[]


[BCs]
  # back = zmin
  # front = zmax
  # bottom = ymin
  # top = ymax
  # left = xmin
  # right = xmax
  [./x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;left right&#x27;
    value = 0
  [../]
  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom top&#x27;
    value = 0
  [../]
  [./z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;back&#x27;
    value = 0
  [../]
[]

[AuxVariables]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xx
    index_i = 0
    index_j = 0
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xy
    index_i = 0
    index_j = 1
  [../]
  [./stress_xz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_xz
    index_i = 0
    index_j = 2
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yy
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_yz
    index_i = 1
    index_j = 2
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    variable = stress_zz
    index_i = 2
    index_j = 2
  [../]
[]


[Functions]
  [./weight]
    type = ParsedFunction
    value = &#x27;0.5*z&#x27; # initial stress that should result from the weight force
  [../]
  [./kxx]
    type = ParsedFunction
    value = &#x27;0.4*z&#x27; # some arbitrary xx and yy stress that should not affect the result
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeCosseratElasticityTensor
    B_ijkl = &#x27;1.1 0.6 0.6&#x27; # In Forest notation this is alpha=1.1 (this is unimportant), beta=gamma=0.6.
    fill_method_bending = &#x27;general_isotropic&#x27;
    fill_method = symmetric_isotropic
    E_ijkl = &#x27;0.4 0.4&#x27; # young = 1, poisson = 0.25
  [../]
  [./strain]
    type = ComputeCosseratSmallStrain
    eigenstrain_names = ini_stress
  [../]
  [./ini_stress]
    type = ComputeEigenstrainFromInitialStress
    initial_stress = &#x27;kxx 0 0  0 kxx 0  0 0 weight&#x27;
    eigenstrain_name = ini_stress
  [../]
  [./stress]
    type = ComputeCosseratLinearElasticStress
  [../]
[]


[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]


[Executioner]
  end_time = 1.0
  dt = 1.0
  solve_type = NEWTON
  type = Transient

  nl_abs_tol = 1E-8
  nl_rel_tol = 1E-12
  l_tol = 1E-3
  l_max_its = 200
  nl_max_its = 400

  petsc_options_iname = &#x27;-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27; asm      2              lu            gmres     200&#x27;
[]



[Outputs]
  file_base = gravity_cosserat
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="604e8f61-4294-468d-990b-4f18b8c1d6c8"><div class="modal-content"><h4>test/tests/postprocessors/element_integral_var_pps/pps_old_value.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 4
  ny = 4
  elem_type = QUAD4
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 1
  [../]
[]

[Functions]
  [./force_fn]
    type = ParsedFunction
    value = &#x27;1&#x27;
  [../]

  [./exact_fn]
    type = ParsedFunction
    value = &#x27;t&#x27;
  [../]
[]

[Kernels]
  [./time_u]
    type = TimeDerivative
    variable = u
  [../]

  [./diff_u]
    type = Diffusion
    variable = u
  [../]

  [./ffn_u]
    type = BodyForce
    variable = u
    function = force_fn
  [../]
[]

[BCs]
  [./all_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;0 1 2 3&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./a]
    type = ElementIntegralVariablePostprocessor
    variable = u
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./total_a]
    type = TotalVariableValue
    value = a
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  dt = 1
  start_time = 1
  end_time = 3
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="21edde6d-07d6-44bc-b13c-5d45ef73d450"><div class="modal-content"><h4>test/tests/time_steppers/postprocessor_dt/postprocessor_dt.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax =  1
  ymin = -1
  ymax =  1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Postprocessors]
  [./l2_error]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  # Just use some postprocessor that gives values good enough for time stepping ;-)
  [./dt]
    type = ElementAverageValue
    variable = u
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;crank-nicolson&#x27;

  start_time = 1.0
  num_steps = 2
  [./TimeStepper]
    type = PostprocessorDT
    postprocessor = dt
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ad462a8e-7d07-49d0-922c-45f37c138e96"><div class="modal-content"><h4>test/tests/time_steppers/timesequence_stepper/timesequence_restart2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = timesequence_restart1_cp/0002_mesh.cpr
[]

[Problem]
  restart_file_base = timesequence_restart1_cp/0002
[]

[Functions]
  [./exact_fn]
    type = ParsedFunction
    value = t*t*(x*x+y*y)
  [../]

  [./forcing_fn]
    type = ParsedFunction
    value = 2*t*(x*x+y*y)-4*t*t
  [../]
[]

[Variables]
  [./u]
    family = LAGRANGE
    order = SECOND
  [../]
[]

[ICs]
  [./u_var]
    type = FunctionIC
    variable = u
    function = exact_fn
  [../]
[]

[Kernels]
  [./td]
    type = TimeDerivative
    variable = u
  [../]

  [./diff]
    type = Diffusion
    variable = u
  [../]

  [./ffn]
    type = BodyForce
    variable = u
    function = forcing_fn
  [../]
[]

[BCs]
  [./all]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left right top bottom&#x27;
    function = exact_fn
  [../]
[]

[Executioner]
  type = Transient
  end_time = 4.0
  [./TimeStepper]
    type = TimeSequenceStepper
    time_sequence  = &#x27;0   0.85 1.3 2 4&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="318a8adb-d3b7-412c-8dab-fcb5c4d06170" data-section-level="2" data-section-text="Child Objects"><h2 id="child-objects">Child Objects</h2><ul class="moose-list-children browser-default"><li><a href="#58fdd39f-9a0b-4854-89bb-e92744165dad" class="modal-trigger">framework/include/kernels/UserForcingFunction.h</a></li></ul><div class="modal moose-modal" id="58fdd39f-9a0b-4854-89bb-e92744165dad"><div class="modal-content"><h4>framework/include/kernels/UserForcingFunction.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;BodyForce.h&quot;

/**
 * Deprecated, use BodyForce.
 */
class UserForcingFunction : public BodyForce
{
public:
  static InputParameters validParams();

  UserForcingFunction(const InputParameters &amp; parameters);

protected:
  Real f();
};

template &lt;&gt;
InputParameters validParams&lt;UserForcingFunction&gt;();

</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#adca0a63-3ca7-4159-93db-b2156dbd54a2" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#1d872378-7f4e-434f-839a-6fb054cabbc5" class="tooltipped" data-position="left" data-tooltip="Example Syntax">Example Syntax</a></li><li><a href="#3379b3b6-04fa-4891-b719-23e26c01c8ce" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#5dcf1408-d321-46f0-96aa-ccfb61b4a5a5" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li><li><a href="#318a8adb-d3b7-412c-8dab-fcb5c4d06170" class="tooltipped" data-position="left" data-tooltip="Child Objects">Child Objects</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>