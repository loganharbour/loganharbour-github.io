<!DOCTYPE html><head><meta charset="UTF-8"><title>MatDiffusion.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="9b36278a-39e1-415b-b0d6-92f66aa58e12"><i class="material-icons">menu</i></a><ul class="sidenav" id="9b36278a-39e1-415b-b0d6-92f66aa58e12"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">kernels</span><a href="#" class="breadcrumb">MatDiffusion</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="d5c1c227-6794-4983-8bfd-9ac680269ed8" data-section-level="1" data-section-text="MatDiffusion"><h1 id="matdiffusion">MatDiffusion</h1><p>Diffusion equation Kernel that takes an isotropic Diffusivity from a material property</p><p>Implements the term <span class="moose-katex-block-equation"><span tex="\nabla\cdot D(c,a,b,\dots) \nabla u," bookmark="moose-equation-29c2da0c-b94c-4d50-8bd1-24a26d04ba1f" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-29c2da0c-b94c-4d50-8bd1-24a26d04ba1f"></span><script>var element = document.getElementById("moose-equation-29c2da0c-b94c-4d50-8bd1-24a26d04ba1f");katex.render("\\nabla\\cdot D(c,a,b,\\dots) \\nabla u,", element, {displayMode:true,throwOnError:false});</script></span> where the diffusion coefficient <span tex="D" bookmark="moose-equation-03e2df60-6187-4a47-8d9e-8b2f27cc0274" recursive="True" class="moose-katex-inline-equation" id="moose-equation-03e2df60-6187-4a47-8d9e-8b2f27cc0274"><script>var element = document.getElementById("moose-equation-03e2df60-6187-4a47-8d9e-8b2f27cc0274");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> (<code>diffusivity</code>) is provided by a <code>FunctionMaterial</code> function material (see <code>Phase Field Module</code> for more information), <span tex="u" bookmark="moose-equation-1a9f765c-1c33-4535-afc0-b52b3b2ab9a2" recursive="True" class="moose-katex-inline-equation" id="moose-equation-1a9f765c-1c33-4535-afc0-b52b3b2ab9a2"><script>var element = document.getElementById("moose-equation-1a9f765c-1c33-4535-afc0-b52b3b2ab9a2");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> is the non-linear variable the kernel is operating on.  </p><p>This kernel can be used in a coupled form if the optional <code>v</code> variable is specified. This allows applying the diffusion operator to a variable <span tex="u" bookmark="moose-equation-d2071fad-15f4-4506-9f5c-5af1c0432cba" recursive="True" class="moose-katex-inline-equation" id="moose-equation-d2071fad-15f4-4506-9f5c-5af1c0432cba"><script>var element = document.getElementById("moose-equation-d2071fad-15f4-4506-9f5c-5af1c0432cba");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> given by <code>v</code>, which is different from the kernel variable.</p><p><span tex="D" bookmark="moose-equation-25bc5451-e01e-45ff-ab10-726b893a8d00" recursive="True" class="moose-katex-inline-equation" id="moose-equation-25bc5451-e01e-45ff-ab10-726b893a8d00"><script>var element = document.getElementById("moose-equation-25bc5451-e01e-45ff-ab10-726b893a8d00");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> can depend on arbitrary non-linear variables <span tex="a,b,\dots" bookmark="moose-equation-e24f2803-8153-45dd-8f92-7e29bfcfad42" recursive="True" class="moose-katex-inline-equation" id="moose-equation-e24f2803-8153-45dd-8f92-7e29bfcfad42"><script>var element = document.getElementById("moose-equation-e24f2803-8153-45dd-8f92-7e29bfcfad42");katex.render("a,b,\\dots", element, {displayMode:false,throwOnError:false});</script></span> (<code>args</code>). The complete Jacobian contributions are provided by the kernel. To build the Jacobian the kernel uses all derivatives of <span tex="D" bookmark="moose-equation-eb1e7e8a-7f30-44cc-8ace-d4559b49418d" recursive="True" class="moose-katex-inline-equation" id="moose-equation-eb1e7e8a-7f30-44cc-8ace-d4559b49418d"><script>var element = document.getElementById("moose-equation-eb1e7e8a-7f30-44cc-8ace-d4559b49418d");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> with respect to the kernel variable and the variables specified in <code>args</code>.</p><section class="scrollspy" id="998ba5db-6d16-4f93-8840-58b6f4af480c" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="6eca9263-64cc-4c9e-8165-44a810d889da" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">The name of the variable that this Kernel operates on</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>NonlinearVariableName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the variable that this Kernel operates on</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="5f8eecd6-66e3-4170-9217-dadb0bb4819f" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">args</span><span class="moose-parameter-header-description">Optional vector of arguments for the diffusivity. If provided and diffusivity is a derivative parsed material, Jacobian contributions from the diffusivity will be automatically computed</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<VariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Optional vector of arguments for the diffusivity. If provided and diffusivity is a derivative parsed material, Jacobian contributions from the diffusivity will be automatically computed</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of block ids (SubdomainID) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<SubdomainName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The list of block ids (SubdomainID) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">conc</span><span class="moose-parameter-header-description">Deprecated! Use 'v' instead</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<VariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Deprecated! Use 'v' instead</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">diffusivity</span><span class="moose-parameter-header-default">D</span><span class="moose-parameter-header-description">The diffusivity value or material property</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>D</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The diffusivity value or material property</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">displacements</span><span class="moose-parameter-header-description">The displacements</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<VariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The displacements</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">v</span><span class="moose-parameter-header-description">Coupled concentration variable for kernel to operate on; if this is not specified, the kernel's nonlinear variable will be used as usual</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<VariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Coupled concentration variable for kernel to operate on; if this is not specified, the kernel's nonlinear variable will be used as usual</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="d606e9d7-e936-454d-8e0c-a90ea5601d49" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">diag_save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this Kernel's diagonal Jacobian contributions to. Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<AuxVariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this Kernel's diagonal Jacobian contributions to. Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this Kernel's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<AuxVariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this Kernel's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation. Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation. Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="087cba8f-369e-4c85-96f1-ff765fab11c0" data-section-level="3" data-section-text="Tagging Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">extra_matrix_tags</span><span class="moose-parameter-header-description">The extra tags for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<TagName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_vector_tags</span><span class="moose-parameter-header-description">The extra tags for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<TagName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the vectors this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_tags</span><span class="moose-parameter-header-default">system</span><span class="moose-parameter-header-description">The tag for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>system</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime system</p><p class="moose-parameter-description"><span>Description:</span>The tag for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">vector_tags</span><span class="moose-parameter-header-default">nontime</span><span class="moose-parameter-header-description">The tag for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nontime</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime time</p><p class="moose-parameter-description"><span>Description:</span>The tag for the vectors this Kernel should fill</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Tagging Parameters</h3></summary></details></section></section><section class="scrollspy" id="6fd3b291-1b1f-4d74-a1b6-f8f4c0e3e950" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#3cd251f8-2d3f-42f7-96f6-111bc066d3f6" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_discrete2mat.i</a></li><li><a href="#657b36c1-321f-442c-ade6-bbf9db48359a" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_xy_homog1mat.i</a></li><li><a href="#8cd11fb7-51ae-410d-8bb4-744f612dee76" class="modal-trigger">modules/phase_field/test/tests/GrandPotentialPFM/GrandPotentialMultiphase.i</a></li><li><a href="#50a24609-1456-41cf-b3c4-f639e5f4ed94" class="modal-trigger">modules/phase_field/test/tests/KKS_system/kks_multiphase.i</a></li><li><a href="#383d9d22-72a7-4847-8f13-203a9746e490" class="modal-trigger">modules/phase_field/test/tests/mobility_derivative/mobility_derivative_direct_coupled_test.i</a></li><li><a href="#e75ad0dc-ec97-4921-bba4-d7252011502b" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_rz_homog1mat.i</a></li><li><a href="#ca29162a-6c56-4451-b673-429bb1d591da" class="modal-trigger">modules/stochastic_tools/examples/surrogates/polynomial_regression/sub.i</a></li><li><a href="#0a5626d7-0d09-45de-b418-3c4d8913699d" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/pod_rb/errors/sub.i</a></li><li><a href="#f803c7c1-bcb5-4533-97ce-0a8776b8cfc0" class="modal-trigger">modules/phase_field/test/tests/GrandPotentialPFM/GrandPotentialPFM.i</a></li><li><a href="#0e15747e-20b9-4578-aa35-63dd95c228c1" class="modal-trigger">modules/phase_field/test/tests/GrandPotentialPFM/GrandPotentialAnisotropy.i</a></li><li><a href="#a65168c9-9ebe-4107-8df4-4949ad167652" class="modal-trigger">test/tests/materials/interface_material/interface_value_material.i</a></li><li><a href="#db34d09b-2594-452e-9b4c-b96df2fa0d0b" class="modal-trigger">modules/phase_field/test/tests/MultiSmoothCircleIC/latticesmoothcircleIC_test.i</a></li><li><a href="#29ea7921-ac29-40a4-aa7d-d893dbe6ec8a" class="modal-trigger">modules/phase_field/test/tests/MultiSmoothCircleIC/latticesmoothcircleIC_normal_test.i</a></li><li><a href="#4314f546-ea48-4bc1-bdce-dcd41413b64f" class="modal-trigger">modules/phase_field/test/tests/mobility_derivative/matdiffusion.i</a></li><li><a href="#34a6d466-3c67-4b0a-9493-eb24c1c34144" class="modal-trigger">test/tests/kernels/simple_transient_diffusion/ill_conditioned_simple_diffusion.i</a></li><li><a href="#85a4d2c3-2057-4d55-921b-ae180d8185ec" class="modal-trigger">test/tests/kernels/ad_mat_diffusion/1D_transient.i</a></li><li><a href="#ae817a88-6779-4a77-a7d4-0f40bde4a18d" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_homog1mat.i</a></li><li><a href="#e113c918-cd2e-400f-8033-a38270940e34" class="modal-trigger">test/tests/interfacekernels/1d_interface/reaction_1D_transient.i</a></li><li><a href="#0d9d1a18-d019-4ae8-82ed-01b33288d105" class="modal-trigger">test/tests/kernels/ad_mat_diffusion/2d_steady_state.i</a></li><li><a href="#fced774a-5034-4e61-be7d-df4a427ffe22" class="modal-trigger">modules/phase_field/examples/multiphase/GrandPotential3Phase.i</a></li><li><a href="#4e2a84f5-b506-4177-9d5b-251af12c916a" class="modal-trigger">modules/xfem/test/tests/moving_interface/moving_diffusion.i</a></li><li><a href="#08321c47-d26d-4dfa-8dc1-4e7e9e9020b3" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_xy_lsdep1mat.i</a></li><li><a href="#8987cb26-f3d6-43be-b997-f368772e3e54" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/gaussian_process/sub.i</a></li><li><a href="#2f1e21c3-2dac-4942-b4d2-cc1395d64c2c" class="modal-trigger">modules/stochastic_tools/examples/surrogates/combined/trans_diff_2d/trans_diff_sub.i</a></li><li><a href="#d961ad3a-2a88-4324-bb31-53f991fd217c" class="modal-trigger">modules/combined/test/tests/multiphase_mechanics/elasticenergymaterial.i</a></li><li><a href="#bf032228-0806-4480-865c-cb6d8f315220" class="modal-trigger">test/tests/materials/interface_material/interface_value_material_split_mesh.i</a></li><li><a href="#dbad1d36-2b31-4ea5-97f5-c6ba854d43fe" class="modal-trigger">modules/phase_field/examples/anisotropic_interfaces/GrandPotentialPlanarGrowth.i</a></li><li><a href="#ce048b87-5c48-4971-ad26-6dffa243d0eb" class="modal-trigger">modules/phase_field/test/tests/mobility_derivative/mobility_derivative_split_coupled_test.i</a></li><li><a href="#6af47168-2780-4f0e-b116-ff80ae868501" class="modal-trigger">modules/combined/examples/publications/rapid_dev/fig6.i</a></li><li><a href="#1a67cdd0-0050-4039-8f88-0fae4be547cb" class="modal-trigger">modules/phase_field/test/tests/phase_field_crystal/PFCEnergyDensity/auxkernel.i</a></li><li><a href="#4714c91c-03a6-4813-8047-0daa98d8f173" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/tied-nodes.i</a></li><li><a href="#34da1be0-288b-4545-aacf-f293caab6c0c" class="modal-trigger">test/tests/interfacekernels/1d_interface/reaction_1D_steady.i</a></li><li><a href="#bc213d67-e6f5-47d2-8919-92e7ed932dbc" class="modal-trigger">modules/phase_field/test/tests/mobility_derivative/coupledmatdiffusion.i</a></li><li><a href="#c5b5e101-fefb-4b8e-a5c1-45c48e779f05" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-min-lm-nodal-disp.i</a></li><li><a href="#6a05bbc2-519c-4219-b5a7-6ffeeac8be0a" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/grid-sequencing/grid-sequencing.i</a></li><li><a href="#8cf9ba45-18df-47aa-b873-c3026e3382bc" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictional-nodal-min-normal-lm-mortar-fb-tangential-lm-mortar-disp.i</a></li><li><a href="#f92e4636-d0e4-4039-8c1f-d5c0b6d775d7" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-fb-lm-nodal-disp.i</a></li><li><a href="#7ae8aa9d-8fd4-4f6a-8933-32eb77e39991" class="modal-trigger">modules/phase_field/test/tests/MultiSmoothCircleIC/specifiedsmoothcircleIC_test.i</a></li><li><a href="#efb8f447-c621-4d76-8c75-e3b0a303a377" class="modal-trigger">test/tests/materials/derivative_material_interface/bad_evaluation.i</a></li><li><a href="#9d996ad4-4c47-4c6c-8268-597832d5a5a7" class="modal-trigger">modules/heat_conduction/test/tests/sideset_heat_transfer/gap_thermal_1D.i</a></li><li><a href="#de660711-10e1-40f4-a3cc-01e8fbc060bb" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictional-mortar-min-lm-mortar-disp.i</a></li><li><a href="#d4109e07-4876-4d37-91ac-c094903c585f" class="modal-trigger">modules/phase_field/test/tests/phase_field_crystal/PFCTrad/PFCTrad_test.i</a></li><li><a href="#231a5093-1cf1-47ea-9d8e-4660025fbb23" class="modal-trigger">modules/heat_conduction/test/tests/sideset_heat_transfer/gap_thermal_ktemp_1D.i</a></li><li><a href="#2ebff155-5724-43c6-86f7-5e6658bb2f7f" class="modal-trigger">modules/phase_field/test/tests/mobility_derivative/AC_mobility_derivative_coupled_test.i</a></li><li><a href="#90b09653-9d95-4e2a-ac98-9af5cd4b3f60" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/1D_rz_lsdep1mat.i</a></li><li><a href="#221dc37f-6b16-43d4-8106-0281276574ea" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/poly_chaos/sub.i</a></li><li><a href="#0ca40c3c-d59f-49bc-9b88-de2eb1b6ca9b" class="modal-trigger">modules/phase_field/test/tests/MultiSmoothCircleIC/multismoothcircleIC_test.i</a></li><li><a href="#97a970c2-b9e7-4b63-9ab1-7cd81f8d2859" class="modal-trigger">modules/combined/test/tests/exception/nonad.i</a></li><li><a href="#cab53072-8e76-48ee-a1c4-4b2a15f9102d" class="modal-trigger">modules/stochastic_tools/examples/surrogates/pod_rb/2d_multireg/sub.i</a></li><li><a href="#a3f62a42-604f-4740-affa-04dc1e88b8e3" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictionless-mortar-fb-lm-mortar-disp.i</a></li><li><a href="#82585d22-6412-4a28-afd5-05fd5c80a468" class="modal-trigger">test/tests/kernels/2d_diffusion/matdiffusion.i</a></li><li><a href="#85d089f7-a097-48bb-ac31-3c0721c787c3" class="modal-trigger">modules/stochastic_tools/examples/surrogates/sub.i</a></li><li><a href="#466b8f46-5aa1-430b-806d-0f1f6e6d4fa9" class="modal-trigger">modules/heat_conduction/test/tests/sideset_heat_transfer/cfem_gap.i</a></li><li><a href="#23e64bcb-bfb2-49df-9bcc-5a84a830fadf" class="modal-trigger">test/tests/materials/interface_material/interface_value_material_noIK.i</a></li><li><a href="#8845b5a3-eba7-4ad2-9873-4e766b1b5cab" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/pod_rb/internal/sub.i</a></li><li><a href="#19426186-06d6-4ae1-a0d6-2e277e06526c" class="modal-trigger">modules/phase_field/test/tests/MultiSmoothCircleIC/multismoothcircleIC_normal_test.i</a></li><li><a href="#6797f174-9510-4019-ac40-bf86cc2ccddf" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_rz_homog1mat.i</a></li><li><a href="#c30f9b78-a267-452e-986d-ae3da03efa37" class="modal-trigger">modules/phase_field/test/tests/SoretDiffusion/direct_temp.i</a></li><li><a href="#a78911ae-33b6-4fbb-997d-f126cefa9c5a" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-fb-lm-mortar-disp.i</a></li><li><a href="#962fb1b5-e5f7-45ca-8505-f65eee384bfb" class="modal-trigger">modules/phase_field/test/tests/phase_field_crystal/PFCTrad/pfct_newton_split1_asm5.i</a></li><li><a href="#aec82183-ff43-46bc-ba8d-d608d77ee60d" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_rz_lsdep1mat.i</a></li><li><a href="#7ab5dc87-6959-4fa1-95b0-4c700fd0bd43" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/pod_rb/boundary/sub.i</a></li><li><a href="#f2313211-7081-45ec-8a77-9661d0d80d53" class="modal-trigger">modules/phase_field/examples/anisotropic_interfaces/GrandPotentialSolidification.i</a></li><li><a href="#2aae5d5a-bc28-4dae-b539-37e91364772e" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-reduced-active-set.i</a></li><li><a href="#2274a20e-275c-462a-bac4-41b92f33409c" class="modal-trigger">modules/xfem/test/tests/moving_interface/verification/2D_xy_lsdep1mat.i</a></li><li><a href="#aee68ae3-a980-4114-9349-4c2856f0b553" class="modal-trigger">modules/phase_field/test/tests/GrandPotentialPFM/GrandPotentialAnisotropyAntitrap.i</a></li><li><a href="#3019960a-4084-4233-9880-8b081267bffa" class="modal-trigger">modules/stochastic_tools/test/tests/surrogates/load_store/sub.i</a></li><li><a href="#7bfea24e-58fb-4455-84c4-836d4de52825" class="modal-trigger">modules/phase_field/test/tests/SoretDiffusion/split_temp.i</a></li><li><a href="#0e04e6df-aa10-433d-b34a-75e49e26d374" class="modal-trigger">modules/phase_field/test/tests/phase_field_crystal/PFCTrad/pfct_newton_split1_asm1_10.i</a></li><li><a href="#6cac40cf-a667-4faf-9547-353bba948374" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictionless-mortar-min-lm-mortar-disp.i</a></li><li><a href="#08a8f25f-c2a9-4246-aaae-f10324627ab8" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictional-nodal-min-lm-mortar-disp.i</a></li><li><a href="#1d78e432-c1a1-491e-901b-3d7435e96b5a" class="modal-trigger">test/tests/materials/interface_material/interface_value_material_split_mesh_stateful.i</a></li><li><a href="#1871013a-2f72-4066-b176-6b6cfed8ec87" class="modal-trigger">modules/phase_field/test/tests/initial_conditions/SmoothCircleIC_3D.i</a></li><li><a href="#ae704e61-0a5c-4518-9af2-658beb72575b" class="modal-trigger">modules/phase_field/examples/anisotropic_interfaces/GrandPotentialTwophaseAnisotropy.i</a></li><li><a href="#4d8a736f-6eba-4f4f-aa80-e7d151e2aac9" class="modal-trigger">test/tests/auxkernels/mesh_integer/mesh_integer.i</a></li><li><a href="#b1eea1fd-b3b2-484d-a670-bfef00afd123" class="modal-trigger">modules/phase_field/test/tests/initial_conditions/SmoothSuperellipsoidIC_3D.i</a></li><li><a href="#18b7329f-a6d0-48c3-9a16-e7bd98756ac6" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/bouncing-block-ranfs.i</a></li><li><a href="#070eca0e-f97f-4b54-9418-5b29f721c73b" class="modal-trigger">modules/phase_field/test/tests/SplitCH/forward_split_math_test.i</a></li><li><a href="#8a32ed6d-e2cc-42b8-9e16-bcebd3d18b3e" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-min-lm-mortar-disp.i</a></li><li><a href="#699b650a-a8f2-43d8-9657-ece9147cde27" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictional-nodal-min-normal-lm-mortar-fb-tangential-lm-mortar-action.i</a></li><li><a href="#6234b1d2-09ee-4c0e-baef-5bca06db7ba0" class="modal-trigger">modules/contact/test/tests/bouncing-block-contact/frictional-mortar-fb-lm-mortar-disp.i</a></li><li><a href="#5b1f25a4-3823-41da-bd34-e4500915680f" class="modal-trigger">modules/xfem/test/tests/moving_interface/phase_transition.i</a></li></ul><div class="modal moose-modal" id="3cd251f8-2d3f-42f7-96f6-111bc066d3f6"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_discrete2mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types:discrete homog 2 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description
#   A transient heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance in the presence of a moving interface separating two
#   discrete material regions for linear element models. Both the temperature
#   solution and level set function are designed to be linear to attempt to
#   minimize error between the exact solution and XFEM results. Thermal
#   conductivity, density, and heat capacity are homogeneous in each material
#   region with a discontinuous jump in thermal flux between the two material
#   regions.
# Results:
#   The temperature at the left boundary is determined by the analytical
#   solution, so temperature at the right boundary (x=1) should exhibit the
#   largest difference between the analytical solution and XFEM results. We
#   present the analytical and XFEM results at the material interface position
#   and right side boundary at various times.
#  Interface:
#     Time    Expected Temperature    XFEM Calculated Temperature
#       20       746.75                  746.7235521
#       40       893.05                  893.0379081
#       60      1040.15                 1040.1527530
#
#  Right Boundary (x=1):
#     Time    Expected Temperature    XFEM Calculated Temperature
#       20       720                     719.9708681
#       40       840                     839.9913293
#       60       960                     960.0100886
#
# IMPORTANT NOTE:
#   When running this input file, add the --allow-test-objects tag!!!
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = phi
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./phi]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = &#x27;diffusion_coefficient&#x27;
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = phi
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    jump_flux = jump_flux_func
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;phi:=(0.75-x-0.001*t);
        i:=(0.75-0.001*t);
        if (phi&gt;=0,
            10*(8-x),
            (7/(1-i))*((i-2)*x + (8-7*i)) )&#x27;
  [../]
  [./right_du_func]
    type = ParsedFunction
    value = &#x27;i:=(0.75-0.001*t);
        (2.0/(1-i))*(-5+5*i+i*t-2*t)&#x27;
  [../]
  [./exact_u_func]
    type = ParsedFunction
    value = &#x27;phi:=(0.75-x-0.001*t);
        i:=(0.75-0.001*t);
        if (phi&gt;=0,
            605 - 5*x + t*(8-x),
            (1/(1-i))*((-5+5*i+i*t-2*t)*x + (605-605*i+8*t-7*t*i)) )&#x27;
  [../]
  [./jump_flux_func]
    type = ParsedFunction
    value = &#x27;i:=(0.75-0.001*t);
        k_1:=(20.0);
        k_2:=(2.0);
        k_1*(5+t) + (k_2/(1-i))*(-5+5*i+i*t-2*t)&#x27;
  [../]

  [./ls_func]
    type = ParsedFunction
    value = &#x27;0.75 - x - 0.001*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;A_rhoCp B_rhoCp&#x27;
    prop_values = &#x27;10 7&#x27;
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;A_diffusion_coefficient B_diffusion_coefficient&#x27;
    prop_values = &#x27;20.0 2.0&#x27;
  [../]

  [./combined_rhoCp]
    type = LevelSetBiMaterialReal
    levelset_positive_base = &#x27;A&#x27;
    levelset_negative_base = &#x27;B&#x27;
    level_set_var = phi
    prop_name = rhoCp
  [../]
  [./combined_diffusion_coefficient]
    type = LevelSetBiMaterialReal
    levelset_positive_base = &#x27;A&#x27;
    levelset_negative_base = &#x27;B&#x27;
    level_set_var = phi
    prop_name = diffusion_coefficient
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    function = exact_u_func
  [../]
  [./right_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_du_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 600
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  # petsc_options_value = &#x27;hypre boomeramg&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 20
  end_time = 60.0
  max_xfem_update = 2
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="657b36c1-321f-442c-ade6-bbf9db48359a"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_xy_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      xy
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with homogeneous material
#   properties. This problem can be exactly evaluated by FEM/Moose without the
#   moving interface. Both the temperature and level set function are designed
#   to be linear to attempt to minimize error between the Moose/exact solution
#   and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=0, y=0) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9998791
#      0.6                  520         519.9995307
#      0.8                  560         559.9989724
#      1.0                  600         599.9984541
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+200)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+100)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+100)*t+400&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 1.04 - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8cd11fb7-51ae-410d-8bb4-744f612dee76"><div class="modal-content"><h4>modules/phase_field/test/tests/GrandPotentialPFM/GrandPotentialMultiphase.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  xmin = -20
  xmax = 20
  ymin = -20
  ymax = 20
[]

[GlobalParams]
  op_num = 2
  var_name_base = etab
[]

[Variables]
  [./w]
  [../]
  [./etaa0]
  [../]
  [./etab0]
  [../]
  [./etab1]
  [../]
[]

[AuxVariables]
  [./bnds]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]

  [./IC_etaa0]
    type = FunctionIC
    variable = etaa0
    function = ic_func_etaa0
  [../]
  [./IC_etab0]
    type = FunctionIC
    variable = etab0
    function = ic_func_etab0
  [../]
  [./IC_etab1]
    type = FunctionIC
    variable = etab1
    function = ic_func_etab1
  [../]
  [./IC_w]
    type = ConstantIC
    value = -0.05
    variable = w
  [../]
[]

[Functions]
  [./ic_func_etaa0]
    type = ParsedFunction
    value = &#x27;r:=sqrt(x^2+y^2);0.5*(1.0-tanh((r-10.0)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_etab0]
    type = ParsedFunction
    value = &#x27;r:=sqrt(x^2+y^2);0.5*(1.0+tanh((r-10)/sqrt(2.0)))*0.5*(1.0+tanh((y)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_etab1]
    type = ParsedFunction
    value = &#x27;r:=sqrt(x^2+y^2);0.5*(1.0+tanh((r-10)/sqrt(2.0)))*0.5*(1.0-tanh((y)/sqrt(2.0)))&#x27;
  [../]
[]


[BCs]
[]

[Kernels]
# Order parameter eta_alpha0
  [./ACa0_bulk]
    type = ACGrGrMulti
    variable = etaa0
    v =           &#x27;etab0 etab1&#x27;
    gamma_names = &#x27;gab   gab&#x27;
  [../]
  [./ACa0_sw]
    type = ACSwitching
    variable = etaa0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etab0 etab1 w&#x27;
  [../]
  [./ACa0_int]
    type = ACInterface
    variable = etaa0
    kappa_name = kappa
  [../]
  [./ea0_dot]
    type = TimeDerivative
    variable = etaa0
  [../]
# Order parameter eta_beta0
  [./ACb0_bulk]
    type = ACGrGrMulti
    variable = etab0
    v =           &#x27;etaa0 etab1&#x27;
    gamma_names = &#x27;gab   gbb&#x27;
  [../]
  [./ACb0_sw]
    type = ACSwitching
    variable = etab0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etaa0 etab1 w&#x27;
  [../]
  [./ACb0_int]
    type = ACInterface
    variable = etab0
    kappa_name = kappa
  [../]
  [./eb0_dot]
    type = TimeDerivative
    variable = etab0
  [../]
# Order parameter eta_beta1
  [./ACb1_bulk]
    type = ACGrGrMulti
    variable = etab1
    v =           &#x27;etaa0 etab0&#x27;
    gamma_names = &#x27;gab   gbb&#x27;
  [../]
  [./ACb1_sw]
    type = ACSwitching
    variable = etab1
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etaa0 etab0 w&#x27;
  [../]
  [./ACb1_int]
    type = ACInterface
    variable = etab1
    kappa_name = kappa
  [../]
  [./eb1_dot]
    type = TimeDerivative
    variable = etab1
  [../]
#Chemical potential
  [./w_dot]
    type = SusceptibilityTimeDerivative
    variable = w
    f_name = chi
    args = &#x27;&#x27; # in this case chi (the susceptibility) is simply a constant
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = w
    diffusivity = Dchi
    args = &#x27;&#x27;
  [../]
  [./coupled_etaa0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etaa0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0 etab1&#x27;
  [../]
  [./coupled_etab0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etab0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0 etab1&#x27;
  [../]
  [./coupled_etab1dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etab1
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0 etab1&#x27;
  [../]
[]

[AuxKernels]
  [./BndsCalc]
    type = BndsCalcAux
    variable = bnds
    execute_on = timestep_end
  [../]
[]

# enable_jit set to false in many materials to make this test start up faster.
# It is recommended to set enable_jit = true or just remove these lines for
# production runs with this model
[Materials]
  [./ha]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = ha
    all_etas = &#x27;etaa0 etab0 etab1&#x27;
    phase_etas = &#x27;etaa0&#x27;
  [../]
  [./hb]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = hb
    all_etas = &#x27;etaa0 etab0 etab1&#x27;
    phase_etas = &#x27;etab0 etab1&#x27;
  [../]
  [./omegaa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegaa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/ka-w/Vm*caeq&#x27;
    derivative_order = 2
    enable_jit = false
  [../]
  [./omegab]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegab
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/kb-w/Vm*cbeq&#x27;
    derivative_order = 2
    enable_jit = false
  [../]
  [./rhoa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhoa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;w/Vm^2/ka + caeq/Vm&#x27;
    derivative_order = 2
    enable_jit = false
  [../]
  [./rhob]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhob
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;w/Vm^2/kb + cbeq/Vm&#x27;
    derivative_order = 2
    enable_jit = false
  [../]
  [./const]
    type = GenericConstantMaterial
    prop_names =  &#x27;kappa_c  kappa   L   D    chi  Vm   ka    caeq kb    cbeq  gab gbb mu&#x27;
    prop_values = &#x27;0        1       1.0 1.0  1.0  1.0  10.0  0.1  10.0  0.9   4.5 1.5 1.0&#x27;
  [../]
  [./Mobility]
    type = DerivativeParsedMaterial
    f_name = Dchi
    material_property_names = &#x27;D chi&#x27;
    function = &#x27;D*chi&#x27;
    derivative_order = 2
    enable_jit = false
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm      31                  lu           1&#x27;
  l_tol = 1.0e-3
  nl_rel_tol = 1.0e-8
  nl_abs_tol = 1e-8
  num_steps = 2
  [./TimeStepper]
    type = SolutionTimeAdaptiveDT
    dt = 0.1
  [../]

[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="50a24609-1456-41cf-b3c4-f639e5f4ed94"><div class="modal-content"><h4>modules/phase_field/test/tests/KKS_system/kks_multiphase.i</h4><pre class="moose-pre"><code class="language-text">#
# This test is for the 3-phase KKS model
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 20
  nz = 0
  xmin = 0
  xmax = 40
  ymin = 0
  ymax = 40
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[AuxVariables]
  [./Energy]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Variables]
  # concentration
  [./c]
    order = FIRST
    family = LAGRANGE
  [../]

  # order parameter 1
  [./eta1]
    order = FIRST
    family = LAGRANGE
  [../]

  # order parameter 2
  [./eta2]
    order = FIRST
    family = LAGRANGE
  [../]

  # order parameter 3
  [./eta3]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]

  # phase concentration 1
  [./c1]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.2
  [../]

  # phase concentration 2
  [./c2]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.5
  [../]

  # phase concentration 3
  [./c3]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.8
  [../]

  # Lagrange multiplier
  [./lambda]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[ICs]
  [./eta1]
    variable = eta1
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.9
    outvalue = 0.1
    int_width = 4
  [../]
  [./eta2]
    variable = eta2
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.1
    outvalue = 0.9
    int_width = 4
  [../]
  [./c]
    variable = c
    type = SmoothCircleIC
    x1 = 20.0
    y1 = 20.0
    radius = 10
    invalue = 0.2
    outvalue = 0.5
    int_width = 2
  [../]
[]


[Materials]
  # simple toy free energies
  [./f1]
    type = DerivativeParsedMaterial
    f_name = F1
    args = &#x27;c1&#x27;
    function = &#x27;20*(c1-0.2)^2&#x27;
  [../]
  [./f2]
    type = DerivativeParsedMaterial
    f_name = F2
    args = &#x27;c2&#x27;
    function = &#x27;20*(c2-0.5)^2&#x27;
  [../]
  [./f3]
    type = DerivativeParsedMaterial
    f_name = F3
    args = &#x27;c3&#x27;
    function = &#x27;20*(c3-0.8)^2&#x27;
  [../]

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [./h1]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta1
    eta_j = eta2
    eta_k = eta3
    f_name = h1
  [../]
  # h2(eta1, eta2, eta3)
  [./h2]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta2
    eta_j = eta3
    eta_k = eta1
    f_name = h2
  [../]
  # h3(eta1, eta2, eta3)
  [./h3]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta3
    eta_j = eta1
    eta_k = eta2
    f_name = h3
  [../]

  # Coefficients for diffusion equation
  [./Dh1]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h1&#x27;
    function = D*h1
    f_name = Dh1
  [../]
  [./Dh2]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h2&#x27;
    function = D*h2
    f_name = Dh2
  [../]
  [./Dh3]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h3&#x27;
    function = D*h3
    f_name = Dh3
  [../]

  # Barrier functions for each phase
  [./g1]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta1
    function_name = g1
  [../]
  [./g2]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta2
    function_name = g2
  [../]
  [./g3]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta3
    function_name = g3
  [../]

  # constant properties
  [./constants]
    type = GenericConstantMaterial
    prop_names  = &#x27;L   kappa  D&#x27;
    prop_values = &#x27;0.7 1.0    1&#x27;
  [../]
[]

[Kernels]
  #Kernels for diffusion equation
  [./diff_time]
    type = TimeDerivative
    variable = c
  [../]
  [./diff_c1]
    type = MatDiffusion
    variable = c
    diffusivity = Dh1
    v = c1
  [../]
  [./diff_c2]
    type = MatDiffusion
    variable = c
    diffusivity = Dh2
    v = c2
  [../]
  [./diff_c3]
    type = MatDiffusion
    variable = c
    diffusivity = Dh3
    v = c3
  [../]

  # Kernels for Allen-Cahn equation for eta1
  [./deta1dt]
    type = TimeDerivative
    variable = eta1
  [../]
  [./ACBulkF1]
    type = KKSMultiACBulkF
    variable  = eta1
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g1
    eta_i     = eta1
    wi        = 1.0
    args      = &#x27;c1 c2 c3 eta2 eta3&#x27;
  [../]
  [./ACBulkC1]
    type = KKSMultiACBulkC
    variable  = eta1
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta1
    args      = &#x27;eta2 eta3&#x27;
  [../]
  [./ACInterface1]
    type = ACInterface
    variable = eta1
    kappa_name = kappa
  [../]
  [./multipler1]
    type = MatReaction
    variable = eta1
    v = lambda
    mob_name = L
  [../]

  # Kernels for Allen-Cahn equation for eta2
  [./deta2dt]
    type = TimeDerivative
    variable = eta2
  [../]
  [./ACBulkF2]
    type = KKSMultiACBulkF
    variable  = eta2
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g2
    eta_i     = eta2
    wi        = 1.0
    args      = &#x27;c1 c2 c3 eta1 eta3&#x27;
  [../]
  [./ACBulkC2]
    type = KKSMultiACBulkC
    variable  = eta2
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta2
    args      = &#x27;eta1 eta3&#x27;
  [../]
  [./ACInterface2]
    type = ACInterface
    variable = eta2
    kappa_name = kappa
  [../]
  [./multipler2]
    type = MatReaction
    variable = eta2
    v = lambda
    mob_name = L
  [../]

  # Kernels for the Lagrange multiplier equation
  [./mult_lambda]
    type = MatReaction
    variable = lambda
    mob_name = 3
  [../]
  [./mult_ACBulkF_1]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g1
    eta_i     = eta1
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta2 eta3&#x27;
  [../]
  [./mult_ACBulkC_1]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta1
    args      = &#x27;eta2 eta3&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_1]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta1
    kappa_name = kappa
    mob_name = 1
  [../]
  [./mult_ACBulkF_2]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g2
    eta_i     = eta2
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta1 eta3&#x27;
  [../]
  [./mult_ACBulkC_2]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta2
    args      = &#x27;eta1 eta3&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_2]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta2
    kappa_name = kappa
    mob_name = 1
  [../]
  [./mult_ACBulkF_3]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g3
    eta_i     = eta3
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta1 eta2&#x27;
  [../]
  [./mult_ACBulkC_3]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta3
    args      = &#x27;eta1 eta2&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_3]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta3
    kappa_name = kappa
    mob_name = 1
  [../]

  # Kernels for constraint equation eta1 + eta2 + eta3 = 1
  # eta3 is the nonlinear variable for the constraint equation
  [./eta3reaction]
    type = MatReaction
    variable = eta3
    mob_name = 1
  [../]
  [./eta1reaction]
    type = MatReaction
    variable = eta3
    v = eta1
    mob_name = 1
  [../]
  [./eta2reaction]
    type = MatReaction
    variable = eta3
    v = eta2
    mob_name = 1
  [../]
  [./one]
    type = BodyForce
    variable = eta3
    value = -1.0
  [../]

  # Phase concentration constraints
  [./chempot12]
    type = KKSPhaseChemicalPotential
    variable = c1
    cb       = c2
    fa_name  = F1
    fb_name  = F2
  [../]
  [./chempot23]
    type = KKSPhaseChemicalPotential
    variable = c2
    cb       = c3
    fa_name  = F2
    fb_name  = F3
  [../]
  [./phaseconcentration]
    type = KKSMultiPhaseConcentration
    variable = c3
    cj = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    etas = &#x27;eta1 eta2 eta3&#x27;
    c = c
  [../]
[]

[AuxKernels]
  [./Energy_total]
    type = KKSMultiFreeEnergy
    Fj_names = &#x27;F1 F2 F3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    gj_names = &#x27;g1 g2 g3&#x27;
    variable = Energy
    w = 1
    interfacial_vars =  &#x27;eta1  eta2  eta3&#x27;
    kappa_names =       &#x27;kappa kappa kappa&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;
  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-11

  num_steps = 2
  dt = 0.5
[]

[Preconditioning]
  active = &#x27;full&#x27;
  [./full]
    type = SMP
    full = true
  [../]
  [./mydebug]
    type = FDP
    full = true
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="383d9d22-72a7-4847-8f13-203a9746e490"><div class="modal-content"><h4>modules/phase_field/test/tests/mobility_derivative/mobility_derivative_direct_coupled_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmax = 30
  ymax = 30
  elem_type = QUAD4
[]

[Variables]
  [./c]
    family = HERMITE
    order = THIRD
  [../]
  [./d]
  [../]
[]

[ICs]
  [./c_IC]
    type = SmoothCircleIC
    x1 = 15
    y1 = 15
    radius = 12
    variable = c
    int_width = 3
    invalue = 1
    outvalue = 0
  [../]
  [./d_IC]
    type = BoundingBoxIC
    x1 = 0
    x2 = 15
    y1 = 0
    y2 = 30
    inside = 1.0
    outside = 0.0
    variable = d
  [../]
[]

[Kernels]
  [./c_bulk]
    type = CahnHilliard
    variable = c
    mob_name = M
    f_name = F
    args = d
  [../]
  [./c_int]
    type = CHInterface
    variable = c
    kappa_name = kappa_c
    mob_name = M
    args = d
  [../]
  [./c_dot]
    type = TimeDerivative
    variable = c
  [../]
  [./d_dot]
    type = TimeDerivative
    variable = d
  [../]
  [./d_diff]
    type = MatDiffusion
    variable = d
    diffusivity = diffusivity
  [../]
[]

[Materials]
  [./kappa]
    type = GenericConstantMaterial
    prop_names = kappa_c
    prop_values = 2.0
  [../]
  [./mob]
    type = DerivativeParsedMaterial
    f_name = M
    args = &#x27;c d&#x27;
    function = if(d&gt;0.001,d,0.001)*if(c&lt;0,0.5,if(c&gt;1,0.5,1-0.5*c^2))
    derivative_order = 2
  [../]
  [./free_energy]
    type = MathEBFreeEnergy
    f_name = F
    c = c
  [../]
  [./d_diff]
    type = GenericConstantMaterial
    prop_names = diffusivity
    prop_values = 1.0
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = BDF2

  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm         31      lu      1&#x27;

  l_max_its = 30
  l_tol = 1.0e-4
  nl_max_its = 50
  nl_rel_tol = 1.0e-10

  dt = 0.25
  num_steps = 2
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  [./oversample]
    refinements = 2
    type = Exodus
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e75ad0dc-ec97-4921-bba4-d7252011502b"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_rz_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      rz
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in cylindrical coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is a single, constant value at all points in the system.
# Results:
#   The temperature at the left boundary (x=1) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM results
#   at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0008118
#      0.6                  520         520.0038529
#      0.8                  560         560.0089177
#      1.0                  600         600.0133344
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 1.0
  xmax = 2.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+400) + 200*1.5*t/x&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*200*t&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;2.04 - x - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ca29162a-6c56-4451-b673-429bb1d591da"><div class="modal-content"><h4>modules/stochastic_tools/examples/surrogates/polynomial_regression/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 1
  elem_type = EDGE3
[]

[Variables]
  [T]
    order = SECOND
    family = LAGRANGE
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = T
    diffusivity = k
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[Materials]
  [conductivity]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 2.0
  []
[]

[BCs]
  [right]
    type = DirichletBC
    variable = T
    boundary = right
    value = 300
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [max]
    type = NodalExtremeValue
    variable = T
    value_type = max
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0a5626d7-0d09-45de-b418-3c4d8913699d"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/pod_rb/errors/sub.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  type = FEProblem
  extra_tag_vectors  = &#x27;diff react bodyf&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 15
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = k
    extra_vector_tags = &#x27;diff&#x27;
  []
  [reaction]
    type = MaterialReaction
    variable = u
    coefficient = alpha
    extra_vector_tags = &#x27;react&#x27;
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
    extra_vector_tags = &#x27;bodyf&#x27;
  []
[]

[Materials]
  [k]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 1.0
  []
  [alpha]
    type = GenericConstantMaterial
    prop_names = alpha
    prop_values = 1.0
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f803c7c1-bcb5-4533-97ce-0a8776b8cfc0"><div class="modal-content"><h4>modules/phase_field/test/tests/GrandPotentialPFM/GrandPotentialPFM.i</h4><pre class="moose-pre"><code class="language-text"># this input file test the implementation of the grand-potential phase-field model based on M.Plapp PRE 84,031601(2011)
# in this simple example, the liquid and solid free energies are parabola with the same curvature and the material properties are constant
# Note that this example also test The SusceptibilityTimeDerivative kernels
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 16
  ny = 16
  xmax = 32
  ymax = 32
[]

[GlobalParams]
  radius = 20.0
  int_width = 4.0
  x1 = 0
  y1 = 0
[]

[Variables]
  [./w]
  [../]
  [./eta]
  [../]
[]

[ICs]
  [./w]
    type = SmoothCircleIC
    variable = w
    # note w = A*(c-cleq), A = 1.0, cleq = 0.0 ,i.e., w = c (in the matrix/liquid phase)
    outvalue = -0.2
    invalue = 0.2
  [../]
  [./eta]
    type = SmoothCircleIC
    variable = eta
    outvalue = 0.0
    invalue = 1.0
  [../]
[]

[Kernels]
  [./w_dot]
    type = SusceptibilityTimeDerivative
    variable = w
    f_name = chi
    args = &#x27;&#x27; # in this case chi (the susceptibility) is simply a constant
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = w
    diffusivity = D
    args = &#x27;&#x27;
  [../]
  [./coupled_etadot]
    type = CoupledSusceptibilityTimeDerivative
    variable = w
    v = eta
    f_name = ft
    args = &#x27;eta&#x27;
  [../]
  [./AC_bulk]
    type = AllenCahn
    variable = eta
    f_name = F
    args = &#x27;w&#x27;
  [../]
  [./AC_int]
    type = ACInterface
    variable = eta
  [../]
  [./e_dot]
    type = TimeDerivative
    variable = eta
  [../]
[]

[Materials]
  [./constants]
    type = GenericConstantMaterial
    prop_names  = &#x27;kappa_op  D    L    chi  cs   cl   A&#x27;
    prop_values = &#x27;4.0       1.0  1.0  1.0  0.0  1.0  1.0&#x27;
  [../]

  [./liquid_GrandPotential]
    type = DerivativeParsedMaterial
    function = &#x27;-0.5 * w^2/A - cl * w&#x27;
    args = &#x27;w&#x27;
    f_name = f1
    material_property_names = &#x27;cl A&#x27;
  [../]
  [./solid_GrandPotential]
    type = DerivativeParsedMaterial
    function = &#x27;-0.5 * w^2/A - cs * w&#x27;
    args = &#x27;w&#x27;
    f_name = f2
    material_property_names = &#x27;cs A&#x27;
  [../]
  [./switching_function]
    type = SwitchingFunctionMaterial
    eta = eta
    h_order = HIGH
  [../]
  [./barrier_function]
    type = BarrierFunctionMaterial
    eta = eta
  [../]
  [./total_GrandPotential]
    type = DerivativeTwoPhaseMaterial
    args = &#x27;w&#x27;
    eta = eta
    fa_name = f1
    fb_name = f2
    derivative_order = 2
    W = 1.0
  [../]
  [./coupled_eta_function]
    type = DerivativeParsedMaterial
    function = &#x27;(cs - cl) * dh&#x27;
    args = &#x27;eta&#x27;
    f_name = ft
    material_property_names = &#x27;cs cl dh:=D[h,eta]&#x27;
    derivative_order = 1
    outputs = exodus
  [../]

  [./concentration]
    type = ParsedMaterial
    f_name = c
    material_property_names = &#x27;dF:=D[F,w]&#x27;
    function = &#x27;-dF&#x27;
    outputs = exodus
  [../]
[]

[Postprocessors]
  [./C]
    type = ElementIntegralMaterialProperty
    mat_prop = c
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = NEWTON

  l_max_its = 15
  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8

  num_steps = 5
  dt = 10.0
[]

[Outputs]
  exodus = true
  csv = true
  execute_on = &#x27;TIMESTEP_END&#x27;
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0e15747e-20b9-4578-aa35-63dd95c228c1"><div class="modal-content"><h4>modules/phase_field/test/tests/GrandPotentialPFM/GrandPotentialAnisotropy.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  xmin = -2
  xmax = 2
  ymin = -2
  ymax = 2
[]

# enable_jit set to false in many materials to make this test start up faster.
# It is recommended to set enable_jit = true or just remove these lines for
# production runs with this model
[GlobalParams]
  radius = 1.0
  int_width = 0.8
  x1 = 0
  y1 = 0
  derivative_order = 2
  enable_jit = false
[]

[Variables]
  [./w]
  [../]
  [./etaa0]
  [../]
  [./etab0]
  [../]
[]

[AuxVariables]
  [./bnds]
  [../]
[]

[AuxKernels]
  [./bnds]
    type = BndsCalcAux
    variable = bnds
    v = &#x27;etaa0 etab0&#x27;
  [../]
[]

[ICs]
  [./w]
    type = SmoothCircleIC
    variable = w
    # note w = A*(c-cleq), A = 1.0, cleq = 0.0 ,i.e., w = c (in the matrix/liquid phase)
    outvalue = -4.0
    invalue = 0.0
  [../]
  [./etaa0]
    type = SmoothCircleIC
    variable = etaa0
    #Solid phase
    outvalue = 0.0
    invalue = 1.0
  [../]
  [./etab0]
    type = SmoothCircleIC
    variable = etab0
    #Liquid phase
    outvalue = 1.0
    invalue = 0.0
  [../]
[]

[BCs]
  [./Periodic]
    [./w]
      variable = w
      auto_direction = &#x27;x y&#x27;
    [../]
    [./etaa0]
      variable = etaa0
      auto_direction = &#x27;x y&#x27;
    [../]
    [./etab0]
      variable = etab0
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[Kernels]
# Order parameter eta_alpha0
  [./ACa0_bulk]
    type = ACGrGrMulti
    variable = etaa0
    v =           &#x27;etab0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACa0_sw]
    type = ACSwitching
    variable = etaa0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etab0 w&#x27;
  [../]
  [./ACa0_int1]
    type = ACInterface2DMultiPhase1
    variable = etaa0
    etas = &#x27;etab0&#x27;
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
  [../]
  [./ACa0_int2]
    type = ACInterface2DMultiPhase2
    variable = etaa0
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
  [../]
  [./ea0_dot]
    type = TimeDerivative
    variable = etaa0
  [../]
# Order parameter eta_beta0
  [./ACb0_bulk]
    type = ACGrGrMulti
    variable = etab0
    v =           &#x27;etaa0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACb0_sw]
    type = ACSwitching
    variable = etab0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etaa0 w&#x27;
  [../]
  [./ACb0_int1]
    type = ACInterface2DMultiPhase1
    variable = etab0
    etas = &#x27;etaa0&#x27;
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
  [../]
  [./ACb0_int2]
    type = ACInterface2DMultiPhase2
    variable = etab0
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
  [../]
  [./eb0_dot]
    type = TimeDerivative
    variable = etab0
  [../]
#Chemical potential
  [./w_dot]
    type = SusceptibilityTimeDerivative
    variable = w
    f_name = chi
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = w
    diffusivity = Dchi
  [../]
  [./coupled_etaa0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etaa0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
  [./coupled_etab0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etab0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
[]

[Materials]
  [./ha]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = ha
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etaa0&#x27;
  [../]
  [./hb]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = hb
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etab0&#x27;
  [../]
  [./omegaa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegaa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/ka-w/Vm*caeq&#x27;
  [../]
  [./omegab]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegab
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/kb-w/Vm*cbeq&#x27;
  [../]
  [./rhoa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhoa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;w/Vm^2/ka + caeq/Vm&#x27;
  [../]
  [./rhob]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhob
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;w/Vm^2/kb + cbeq/Vm&#x27;
  [../]
  [./kappaa]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
    etaa = etaa0
    etab = etab0
    outputs = exodus
    output_properties = &#x27;kappaa dkappadgrad_etaa&#x27;
  [../]
  [./kappab]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
    etaa = etab0
    etab = etaa0
    outputs = exodus
    output_properties = &#x27;kappab dkappadgrad_etab&#x27;
  [../]
  [./const]
    type = GenericConstantMaterial
    prop_names =  &#x27;L   D    chi  Vm   ka    caeq kb    cbeq  gab mu&#x27;
    prop_values = &#x27;1.0 1.0  0.1  1.0  10.0  0.1  10.0  0.9   4.5 10.0&#x27;
  [../]
  [./Mobility]
    type = ParsedMaterial
    f_name = Dchi
    material_property_names = &#x27;D chi&#x27;
    function = &#x27;D*chi&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  l_tol = 1.0e-5
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1e-12
  num_steps = 2
  dt = 0.001
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a65168c9-9ebe-4107-8df4-4949ad167652"><div class="modal-content"><h4>test/tests/materials/interface_material/interface_value_material.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
    elem_type = QUAD4
  []
  [./subdomain_id]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 2 0&#x27;
    block_id = 1
  [../]

  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain_id
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;interface&#x27;
  [../]

[]

[Variables]
  [./u]
    block = 0
  [../]
  [./v]
    block = 1
  [../]
[]


[Kernels]
  [./diff]
    type = MatDiffusion
    variable = u
    diffusivity = &#x27;diffusivity&#x27;
    block = 0
  [../]

  [./diff_v]
    type = MatDiffusion
    variable = v
    diffusivity = &#x27;diffusivity&#x27;
    block = 1
  [../]
[]

[InterfaceKernels]
  [tied]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    jump_prop_name = &quot;average_jump&quot;
    penalty = 1e6
    boundary = &#x27;interface&#x27;
  []
[]

[BCs]
  [u_left]
    type = DirichletBC
    boundary = &#x27;left&#x27;
    variable = u
    value = 1
  []
  [v_right]
    type = DirichletBC
    boundary = &#x27;right&#x27;
    variable = v
    value = 0
  []
[]

[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 1
    # outputs = all
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
    # outputs = all
  [../]
  [./interface_material_avg]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = average
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_primary_minus_secondary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_primary_minus_secondary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_secondary_minus_primary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_secondary_minus_primary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_abs]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_abs
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_primary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = primary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_secondary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      mat_prop_var_out_basename = diff_var
      boundary = interface
      interface_value_type = secondary
      nl_var_primary = u
      nl_var_secondary = v
  [../]
[]

[AuxKernels]
  [./interface_material_avg]
    type = MaterialRealAux
    property = diff_average
    variable = diffusivity_average
    boundary = interface
  []
  [./interface_material_jump_primary_minus_secondary]
    type = MaterialRealAux
    property = diff_jump_primary_minus_secondary
    variable = diffusivity_jump_primary_minus_secondary
    boundary = interface
  []
  [./interface_material_jump_secondary_minus_primary]
    type = MaterialRealAux
    property = diff_jump_secondary_minus_primary
    variable = diffusivity_jump_secondary_minus_primary
    boundary = interface
  []
  [./interface_material_jump_abs]
    type = MaterialRealAux
    property = diff_jump_abs
    variable = diffusivity_jump_abs
    boundary = interface
  []
  [./interface_material_primary]
    type = MaterialRealAux
    property = diff_primary
    variable = diffusivity_primary
    boundary = interface
  []
  [./interface_material_secondary]
    type = MaterialRealAux
    property = diff_secondary
    variable = diffusivity_secondary
    boundary = interface
  []
  [diffusivity_var]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_var
  []
[]

[AuxVariables]
  [diffusivity_var]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_average]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_primary_minus_secondary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_secondary_minus_primary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_abs]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_primary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_secondary]
    family = MONOMIAL
    order = CONSTANT
  []
[]


[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="db34d09b-2594-452e-9b4c-b96df2fa0d0b"><div class="modal-content"><h4>modules/phase_field/test/tests/MultiSmoothCircleIC/latticesmoothcircleIC_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]

  type = GeneratedMesh
  dim = 3
  nx = 22
  ny = 22
  nz = 22
  xmin = 0
  xmax = 100
  ymin = 0
  ymax = 100
  zmin = 0
  zmax = 100
  elem_type = HEX8

[]

[Variables]

  [./c]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./c]
     type = LatticeSmoothCircleIC
     variable = c
     invalue = 1.0
     outvalue = 0.0001
     circles_per_side = &#x27;3 3 3&#x27;
     pos_variation = 0.0
     radius = 10.0
     int_width = 12.0
     radius_variation = 0.2
     radius_variation_type = uniform
  [../]
[]

[Kernels]
active = &#x27;ie_c diff&#x27;

  [./ie_c]
    type = TimeDerivative
    variable = c
  [../]

  [./diff]
    type = MatDiffusion
    variable = c
    diffusivity = D_v
  [../]
[]

[BCs]

[]

[Materials]
active = &#x27;Dv&#x27;

  [./Dv]
    type = GenericConstantMaterial
    prop_names = D_v
    prop_values = 0.074802
  [../]
[]

[Postprocessors]
  active = &#x27;bubbles&#x27;

  [./bubbles]
    type = FeatureFloodCount
    variable = c
    execute_on = &#x27;initial timestep_end&#x27;
    flood_entity_type = NODAL
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;




  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -mat_mffd_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg 101 ds&#x27;

  l_max_its = 20
  l_tol = 1e-4

  nl_max_its = 20
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-11

  start_time = 0.0
  num_steps =1
  dt = 100.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="29ea7921-ac29-40a4-aa7d-d893dbe6ec8a"><div class="modal-content"><h4>modules/phase_field/test/tests/MultiSmoothCircleIC/latticesmoothcircleIC_normal_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 22
  ny = 22
  nz = 22
  xmin = 0
  xmax = 100
  ymin = 0
  ymax = 100
  zmin = 0
  zmax = 100
  elem_type = HEX8

[]

[Variables]
  [./c]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./c]
     type = LatticeSmoothCircleIC
     variable = c
     invalue = 1.0
     outvalue = 0.0001
     circles_per_side = &#x27;3 3 3&#x27;
     pos_variation = 10.0
     radius = 10.0
     int_width = 12.0
     radius_variation = 2
     radius_variation_type = normal
  [../]
[]

[Kernels]
active = &#x27;ie_c diff&#x27;

  [./ie_c]
    type = TimeDerivative
    variable = c
  [../]

  [./diff]
    type = MatDiffusion
    variable = c
    diffusivity = D_v
  [../]
[]

[BCs]

[]

[Materials]
active = &#x27;Dv&#x27;

  [./Dv]
    type = GenericConstantMaterial
    prop_names = D_v
    prop_values = 0.074802
  [../]
[]

[Postprocessors]
  active = &#x27;bubbles&#x27;

  [./bubbles]
    type = FeatureFloodCount
    variable = c
    execute_on = &#x27;initial timestep_end&#x27;
    flood_entity_type = NODAL
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;




  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -mat_mffd_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg 101 ds&#x27;

  l_max_its = 20
  l_tol = 1e-4

  nl_max_its = 20
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-11

  start_time = 0.0
  num_steps =1
  dt = 100.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4314f546-ea48-4bc1-bdce-dcd41413b64f"><div class="modal-content"><h4>modules/phase_field/test/tests/mobility_derivative/matdiffusion.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  xmax = 15.0
  ymax = 15.0
  elem_type = QUAD4
[]

[Variables]
  [./c]
    [./InitialCondition]
      type = CrossIC
      x1 = 0.0
      x2 = 30.0
      y1 = 0.0
      y2 = 30.0
    [../]
  [../]
  [./d]
    [./InitialCondition]
      type = SmoothCircleIC
      x1 = 15
      y1 = 15
      radius = 8
      int_width = 3
      invalue = 2
      outvalue = 0
    [../]
  [../]
[]

[Kernels]
  [./cres]
    type = MatDiffusion
    variable = c
    diffusivity = Dc
    args = d
  [../]
  [./ctime]
    type = TimeDerivative
    variable = c
  [../]

  [./dres]
    type = MatDiffusion
    variable = d
    diffusivity = Dd
    args = c
  [../]
  [./dtime]
    type = TimeDerivative
    variable = d
  [../]
[]

[Materials]
  [./Dc]
    type = DerivativeParsedMaterial
    f_name = Dc
    function = &#x27;0.01+c^2+d&#x27;
    args = &#x27;c d&#x27;
    derivative_order = 1
  [../]
  [./Dd]
    type = DerivativeParsedMaterial
    f_name = Dd
    function = &#x27;d^2+c+1.5&#x27;
    args = &#x27;c d&#x27;
    derivative_order = 1
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;BDF2&#x27;

  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm      31                  lu           1&#x27;

  dt = 1
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="34a6d466-3c67-4b0a-9493-eb24c1c34144"><div class="modal-content"><h4>test/tests/kernels/simple_transient_diffusion/ill_conditioned_simple_diffusion.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 2
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = MatDiffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    preset = false
    boundary = left
    value = 0
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    preset = false
    boundary = right
    function = constant
  [../]
[]

[Functions]
  [constant]
    type = ParsedFunction
    value = &#x27;1&#x27;
  []
  [ramp]
    type = ParsedFunction
    value = &#x27;t&#x27;
  []
[]


[Materials]
  active = &#x27;constant&#x27;
  [constant]
    type = GenericConstantMaterial
    prop_names = &#x27;D&#x27;
    prop_values = &#x27;1e20&#x27;
  []
  [function]
    type = GenericFunctionMaterial
    prop_names = &#x27;D&#x27;
    prop_values = &#x27;10^(t-1)&#x27;
  []
[]

[Executioner]
  type = Transient
  num_steps = 1
  dt = 2
  dtmin = 2
  solve_type = NEWTON
  petsc_options = &#x27;-pc_svd_monitor -ksp_view_pmat -snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -snes_stol&#x27;
  petsc_options_value = &#x27;svd      0&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="85a4d2c3-2057-4d55-921b-ae180d8185ec"><div class="modal-content"><h4>test/tests/kernels/ad_mat_diffusion/1D_transient.i</h4><pre class="moose-pre"><code class="language-text"># This test solves a 1D transient heat equation
# The error is calculated by comparing to the analytical solution
# The problem setup and analytical solution are taken from &quot;Advanced Engineering
# Mathematics, 10th edition&quot; by Erwin Kreyszig.
# http://www.amazon.com/Advanced-Engineering-Mathematics-Erwin-Kreyszig/dp/0470458364
# It is Example 1 in section 12.6 on page 561

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 160
  xmax = 80
[]

[Variables]
  [./T]
  [../]
[]

[ICs]
  [./T_IC]
    type = FunctionIC
    variable = T
    function = &#x27;100*sin(pi*x/80)&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = MatDiffusion
    variable = T
    diffusivity = 0.95
  [../]
  [./dt]
    type = CoefTimeDerivative
    variable = T
    Coefficient = 0.82064
  [../]
[]

[BCs]
  [./sides]
    type = DirichletBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  dt = 1e-2
  end_time = 1
[]

[Postprocessors]
  [./error]
    type = NodalL2Error
    function = &#x27;100*sin(pi*x/80)*exp(-0.95/(0.092*8.92)*pi^2/80^2*t)&#x27;
    variable = T
    outputs = console
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ae817a88-6779-4a77-a7d4-0f40bde4a18d"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed linear level set function
# Description:
#   A simple transient heat transfer problem in Cartesian coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is a single, constant value at all points in the system.
# Results:
#   The temperature at the left boundary (x=0) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM results
#   at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0000064
#      0.6                  520         520.0000323
#      0.8                  560         560.0000896
#      1.0                  600         600.0001870
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+200)&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;1-(x-0.04)-0.2*t&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*200*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e113c918-cd2e-400f-8033-a38270940e34"><div class="modal-content"><h4>test/tests/interfacekernels/1d_interface/reaction_1D_transient.i</h4><pre class="moose-pre"><code class="language-text"># Transient-state test for the InterfaceReaction kernel.
#
# Same to steady-state, except the following
#
# Natural BCs are applied (i.e. NewmannBC h=0 at left and right)

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 10
    xmax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;1.0 0 0&#x27;
    block_id = 1
    top_right = &#x27;2.0 1.0 0&#x27;
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = &#x27;subdomain1&#x27;
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;0&#x27;
  [../]
  [./v]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
  [../]
[]

[Kernels]
  [./diff_u]
    type = MatDiffusion
    diffusivity = D
    variable = u
    block = &#x27;0&#x27;
  [../]
  [./diff_v]
    type = MatDiffusion
    diffusivity = D
    variable = v
    block = &#x27;1&#x27;
  [../]
  [./diff_u_dt]
    type = TimeDerivative
    variable = u
    block = &#x27;0&#x27;
  [../]
  [./diff_v_dt]
    type = TimeDerivative
    variable = v
    block = &#x27;1&#x27;
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    block = &#x27;0&#x27;
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = InterfaceDiffusion
    variable = u
    neighbor_var = &#x27;v&#x27;
    boundary = &#x27;primary0_interface&#x27;
    D = D
    D_neighbor = D
  [../]
  [./interface_reaction]
    type = InterfaceReaction
    variable = u
    neighbor_var = &#x27;v&#x27;
    boundary = &#x27;primary0_interface&#x27;
    kf = 1 # Forward reaction rate coefficient
    kb = 2 # Backward reaction rate coefficient
  [../]
[]

[Materials]
  [./block0]
    type = GenericConstantMaterial
    block = &#x27;0&#x27;
    prop_names = &#x27;D&#x27;
    prop_values = &#x27;4&#x27;
  [../]
  [./block1]
    type = GenericConstantMaterial
    block = &#x27;1&#x27;
    prop_names = &#x27;D&#x27;
    prop_values = &#x27;2&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 0.1
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
  print_linear_residuals = true
[]

[Debug]
  show_var_residual_norms = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0d9d1a18-d019-4ae8-82ed-01b33288d105"><div class="modal-content"><h4>test/tests/kernels/ad_mat_diffusion/2d_steady_state.i</h4><pre class="moose-pre"><code class="language-text"># This test solves a 2D steady state heat equation
# The error is found by comparing to the analytical solution

# Note that the thermal conductivity, specific heat, and density in this problem
# Are set to 1, and need to be changed to the constants of the material being
# Analyzed

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 30
  ny = 30
  xmax = 2
  ymax = 2
[]

[Variables]
  [./T]
  [../]
[]

[Kernels]
  [./diff]
    type = MatDiffusion
    variable = T
    diffusivity = 1
  [../]
[]

[BCs]
  [./zero]
    type = DirichletBC
    variable = T
    boundary = &#x27;left right bottom&#x27;
    value = 0
  [../]
  [./top]
    type = FunctionDirichletBC
    variable = T
    boundary = top
    function = &#x27;10*sin(pi*x*0.5)&#x27;
  [../]
[]

[Postprocessors]
  [./nodal_error]
    type = NodalL2Error
    function = &#x27;10/(sinh(pi))*sin(pi*x*0.5)*sinh(pi*y*0.5)&#x27;
    variable = T
    outputs = console
  [../]
  [./elemental_error]
    type = ElementL2Error
    function = &#x27;10/(sinh(pi))*sin(pi*x*0.5)*sinh(pi*y*0.5)&#x27;
    variable = T
    outputs = console
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fced774a-5034-4e61-be7d-df4a427ffe22"><div class="modal-content"><h4>modules/phase_field/examples/multiphase/GrandPotential3Phase.i</h4><pre class="moose-pre"><code class="language-text"># This is an example of implementation of the multi-phase, multi-order parameter
# grand potential based phase-field model described in Phys. Rev. E, 98, 023309
# (2019). It includes 3 phases with 1 grain of each phase. This example was used
# to generate the results shown in Fig. 3 of the paper.

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 60
  xmin = -15
  xmax = 15
[]

[Variables]
  [./w]
  [../]
  [./etaa0]
  [../]
  [./etab0]
  [../]
  [./etad0]
  [../]
[]

[ICs]
  [./IC_etaa0]
    type = FunctionIC
    variable = etaa0
    function = ic_func_etaa0
  [../]
  [./IC_etab0]
    type = FunctionIC
    variable = etab0
    function = ic_func_etab0
  [../]
  [./IC_etad0]
    type = ConstantIC
    variable = etad0
    value = 0.1
  [../]
  [./IC_w]
    type = FunctionIC
    variable = w
    function = ic_func_w
  [../]
[]

[Functions]
  [./ic_func_etaa0]
    type = ParsedFunction
    value = &#x27;0.9*0.5*(1.0-tanh((x)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_etab0]
    type = ParsedFunction
    value = &#x27;0.9*0.5*(1.0+tanh((x)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_w]
    type = ParsedFunction
    value = 0
  [../]
[]

[Kernels]
# Order parameter eta_alpha0
  [./ACa0_bulk]
    type = ACGrGrMulti
    variable = etaa0
    v =           &#x27;etab0 etad0&#x27;
    gamma_names = &#x27;gab   gad&#x27;
  [../]
  [./ACa0_sw]
    type = ACSwitching
    variable = etaa0
    Fj_names  = &#x27;omegaa omegab omegad&#x27;
    hj_names  = &#x27;ha     hb     hd&#x27;
    args = &#x27;etab0 etad0 w&#x27;
  [../]
  [./ACa0_int]
    type = ACInterface
    variable = etaa0
    kappa_name = kappa
  [../]
  [./ea0_dot]
    type = TimeDerivative
    variable = etaa0
  [../]
# Order parameter eta_beta0
  [./ACb0_bulk]
    type = ACGrGrMulti
    variable = etab0
    v =           &#x27;etaa0 etad0&#x27;
    gamma_names = &#x27;gab   gbd&#x27;
  [../]
  [./ACb0_sw]
    type = ACSwitching
    variable = etab0
    Fj_names  = &#x27;omegaa omegab omegad&#x27;
    hj_names  = &#x27;ha     hb     hd&#x27;
    args = &#x27;etaa0 etad0 w&#x27;
  [../]
  [./ACb0_int]
    type = ACInterface
    variable = etab0
    kappa_name = kappa
  [../]
  [./eb0_dot]
    type = TimeDerivative
    variable = etab0
  [../]
# Order parameter eta_delta0
  [./ACd0_bulk]
    type = ACGrGrMulti
    variable = etad0
    v =           &#x27;etaa0 etab0&#x27;
    gamma_names = &#x27;gad   gbd&#x27;
  [../]
  [./ACd0_sw]
    type = ACSwitching
    variable = etad0
    Fj_names  = &#x27;omegaa omegab omegad&#x27;
    hj_names  = &#x27;ha     hb     hd&#x27;
    args = &#x27;etaa0 etab0 w&#x27;
  [../]
  [./ACd0_int]
    type = ACInterface
    variable = etad0
    kappa_name = kappa
  [../]
  [./ed0_dot]
    type = TimeDerivative
    variable = etad0
  [../]
#Chemical potential
  [./w_dot]
    type = SusceptibilityTimeDerivative
    variable = w
    f_name = chi
    args = &#x27;etaa0 etab0 etad0&#x27;
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = w
    diffusivity = Dchi
    args = &#x27;&#x27;
  [../]
  [./coupled_etaa0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etaa0
    Fj_names = &#x27;rhoa rhob rhod&#x27;
    hj_names = &#x27;ha   hb   hd&#x27;
    args = &#x27;etaa0 etab0 etad0&#x27;
  [../]
  [./coupled_etab0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etab0
    Fj_names = &#x27;rhoa rhob rhod&#x27;
    hj_names = &#x27;ha   hb   hd&#x27;
    args = &#x27;etaa0 etab0 etad0&#x27;
  [../]
  [./coupled_etad0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etad0
    Fj_names = &#x27;rhoa rhob rhod&#x27;
    hj_names = &#x27;ha   hb   hd&#x27;
    args = &#x27;etaa0 etab0 etad0&#x27;
  [../]
[]

[Materials]
  [./ha_test]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = ha
    all_etas = &#x27;etaa0 etab0 etad0&#x27;
    phase_etas = &#x27;etaa0&#x27;
  [../]
  [./hb_test]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = hb
    all_etas = &#x27;etaa0 etab0 etad0&#x27;
    phase_etas = &#x27;etab0&#x27;
  [../]
  [./hd_test]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = hd
    all_etas = &#x27;etaa0 etab0 etad0&#x27;
    phase_etas = &#x27;etad0&#x27;
  [../]
  [./omegaa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegaa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/ka-w/Vm*caeq&#x27;
    derivative_order = 2
  [../]
  [./omegab]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegab
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/kb-w/Vm*cbeq&#x27;
    derivative_order = 2
  [../]
  [./omegad]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegad
    material_property_names = &#x27;Vm kd cdeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/kd-w/Vm*cdeq&#x27;
    derivative_order = 2
  [../]
  [./rhoa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhoa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;w/Vm^2/ka + caeq/Vm&#x27;
    derivative_order = 2
  [../]
  [./rhob]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhob
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;w/Vm^2/kb + cbeq/Vm&#x27;
    derivative_order = 2
  [../]
  [./rhod]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhod
    material_property_names = &#x27;Vm kd cdeq&#x27;
    function = &#x27;w/Vm^2/kd + cdeq/Vm&#x27;
    derivative_order = 2
  [../]
  [./c]
    type = ParsedMaterial
    material_property_names = &#x27;Vm rhoa rhob rhod ha hb hd&#x27;
    function = &#x27;Vm * (ha * rhoa + hb * rhob + hd * rhod)&#x27;
    f_name = c
  [../]
  [./const]
    type = GenericConstantMaterial
    prop_names =  &#x27;kappa_c  kappa   L   D    Vm   ka    caeq kb    cbeq  kd    cdeq  gab gad gbd  mu  tgrad_corr_mult&#x27;
    prop_values = &#x27;0        1       1.0 1.0  1.0  10.0  0.1  10.0  0.9   10.0  0.5   1.5 1.5 1.5  1.0 0.0&#x27;
  [../]
  [./Mobility]
    type = DerivativeParsedMaterial
    f_name = Dchi
    material_property_names = &#x27;D chi&#x27;
    function = &#x27;D*chi&#x27;
    derivative_order = 2
  [../]
  [./chi]
    type = DerivativeParsedMaterial
    f_name = chi
    material_property_names = &#x27;Vm ha(etaa0,etab0,etad0) ka hb(etaa0,etab0,etad0) kb hd(etaa0,etab0,etad0) kd&#x27;
    function = &#x27;(ha/ka + hb/kb + hd/kd) / Vm^2&#x27;
    args = &#x27;etaa0 etab0 etad0&#x27;
    derivative_order = 2
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[VectorPostprocessors]
  [./etaa0]
    type = LineValueSampler
    variable = etaa0
    start_point = &#x27;-15 0 0&#x27;
    end_point = &#x27;15 0 0&#x27;
    num_points = 61
    sort_by = x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./etab0]
    type = LineValueSampler
    variable = etab0
    start_point = &#x27;-15 0 0&#x27;
    end_point = &#x27;15 0 0&#x27;
    num_points = 61
    sort_by = x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./etad0]
    type = LineValueSampler
    variable = etad0
    start_point = &#x27;-15 0 0&#x27;
    end_point = &#x27;15 0 0&#x27;
    num_points = 61
    sort_by = x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
[]

[Executioner]
  type = Transient
  nl_max_its = 15
  scheme = bdf2
  solve_type = PJFNK
  petsc_options_iname = -pc_type
  petsc_options_value = asm
  l_max_its = 15
  l_tol = 1.0e-3
  nl_rel_tol = 1.0e-8
  start_time = 0.0
  num_steps = 20
  nl_abs_tol = 1e-10
  dt = 1.0
[]

[Outputs]
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial timestep_end final&#x27;
    interval = 1
  [../]
  [./csv]
    type = CSV
    execute_on = &#x27;initial timestep_end final&#x27;
    interval = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4e2a84f5-b506-4177-9d5b-251af12c916a"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/moving_diffusion.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 3
  xmin = 0.0
  xmax = 1
  ymin = 0.0
  ymax = 1
  elem_type = QUAD4
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[Functions]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;x-0.76+0.21*t&#x27;
  [../]
[]

[Kernels]
  [./diff]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./time_deriv]
    type = TimeDerivative
    variable = u
  [../]
[]

[Constraints]
  [./u_constraint]
    type = XFEMSingleVariableConstraint
    use_displaced_mesh = false
    variable = u
    jump = 0
    use_penalty = true
    alpha = 1e5
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
  [../]
[]

[BCs]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./left_u]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Materials]
  [./diffusivity_A]
    type = GenericConstantMaterial
    prop_names = A_diffusion_coefficient
    prop_values = 5
  [../]

  [./diffusivity_B]
    type = GenericConstantMaterial
    prop_names = B_diffusion_coefficient
    prop_values = 0.5
  [../]

  [./diff_combined]
    type = LevelSetBiMaterialReal
    levelset_positive_base = &#x27;A&#x27;
    levelset_negative_base = &#x27;B&#x27;
    level_set_var = ls
    prop_name = diffusion_coefficient
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      8&#x27;

  l_max_its = 20
  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-5

  start_time = 0.0
  dt = 1
  end_time = 2

  max_xfem_update = 1
[]

[Outputs]
  exodus = true
  execute_on = timestep_end
  csv = true
  perf_graph = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="08321c47-d26d-4dfa-8dc1-4e7e9e9020b3"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_xy_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      xy
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in Cartesian coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is dependent upon the value of the level set function
#   at each timestep.
# Results:
#   The temperature at the left boundary (x=0) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM
#   results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9999722
#      0.6                  520         519.9998726
#      0.8                  560         559.9997314
#      1.0                  600         599.9996885
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;rhoCp*(-200*x+200)-(0.05*200*t/1.04)&#x27;
    vars = &#x27;rhoCp&#x27;
    vals = 10
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.05/1.04)*(1-(x-0.04)-0.2*t) + 1.5)*200*t&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.05/1.04)*(1-(x-0.04)-0.2*t) + 1.5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;1.04 - x - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8987cb26-f3d6-43be-b997-f368772e3e54"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/gaussian_process/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 1
  elem_type = EDGE3
[]

[Variables]
  [T]
    order = SECOND
    family = LAGRANGE
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = T
    diffusivity = k
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[Materials]
  [conductivity]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 2.0
  []
[]

[BCs]
  [right]
    type = DirichletBC
    variable = T
    boundary = right
    value = 300
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [avg]
    type = AverageNodalVariableValue
    variable = T
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2f1e21c3-2dac-4942-b4d2-cc1395d64c2c"><div class="modal-content"><h4>modules/stochastic_tools/examples/surrogates/combined/trans_diff_2d/trans_diff_sub.i</h4><pre class="moose-pre"><code class="language-text">[Functions]
  [src_func]
    type = ParsedFunction
    value = &quot;1000*sin(f*t)&quot;
    vars = &#x27;f&#x27;
    vals = &#x27;20&#x27;
  []
[]

[Mesh]
  [msh]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 100
    xmin = -0.5
    xmax = 0.5
    ny = 100
    ymin = -0.5
    ymax = 0.5
  []
  [source_domain]
    type = ParsedSubdomainMeshGenerator
    input = msh
    combinatorial_geometry = &#x27;(x&lt;0.1 &amp; x&gt;-0.1) &amp; (y&lt;0.1 &amp; y&gt;-0.1)&#x27;
    block_id=1
  []
[]

[Variables]
  [T]
    initial_condition = 300
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = T
    diffusivity = diff_coeff
  []
  [source]
    type = BodyForce
    variable = T
    function = src_func
    block = 1
  []
  [time_deriv]
    type = TimeDerivative
    variable = T
  []
[]

[Materials]
  [diff_coeff]
    type = ParsedMaterial
    f_name = diff_coeff
    args = &#x27;T&#x27;
    constant_names = &#x27;C&#x27;
    constant_expressions = 0.02
    function = &#x27;C * pow(300/T, 2)&#x27;
  []
[]

[BCs]
  [neumann_all]
    type = NeumannBC
    variable = T
    boundary = &#x27;left right top bottom&#x27;
    value = 0
  []
[]

[Executioner]
  type = Transient
  num_steps = 100
  dt = 0.01
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  nl_rel_tol = 1e-6
  l_abs_tol = 1e-6
  timestep_tolerance = 1e-6
[]

[Postprocessors]
  [max]
    type = NodalExtremeValue
    variable = T
  []
  [min]
    type = NodalExtremeValue
    variable = T
    value_type = min
  []
  [time_max]
    type = TimeExtremeValue
    postprocessor = max
  []
  [time_min]
    type = TimeExtremeValue
    postprocessor = min
    value_type = min
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d961ad3a-2a88-4324-bb31-53f991fd217c"><div class="modal-content"><h4>modules/combined/test/tests/multiphase_mechanics/elasticenergymaterial.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 25
  ny = 25
  nz = 0
  xmax = 250
  ymax = 250
  zmax = 0
  elem_type = QUAD4
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./c]
    [./InitialCondition]
      type = SmoothCircleIC
      x1 = 125.0
      y1 = 125.0
      radius = 60.0
      invalue = 1.0
      outvalue = 0.1
      int_width = 50.0
    [../]
  [../]
[]

[BCs]
  [./bottom]
    type = DirichletBC
    boundary = bottom
    variable = disp_y
    value = 0.0
  [../]
  [./left]
    type = DirichletBC
    boundary = left
    variable = disp_x
    value = 0.0
  [../]
[]

[Kernels]
  [./TensorMechanics]
  [../]
  [./dummy]
    type = MatDiffusion
    variable = c
    diffusivity = 0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    fill_method = symmetric9
    C_ijkl = &#x27;3 1 1 3 1 3 1 1 1 &#x27;
  [../]
  [./strain]
    type = ComputeSmallStrain
    eigenstrain_names = eigenstrain
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./prefactor]
    type = DerivativeParsedMaterial
    args = c
    f_name = prefactor
    constant_names       = &#x27;epsilon0 c0&#x27;
    constant_expressions = &#x27;0.05     0&#x27;
    function = &#x27;(c - c0) * epsilon0&#x27;
  [../]
  [./eigenstrain]
    type = ComputeVariableEigenstrain
    eigen_base = &#x27;1&#x27;
    args = c
    prefactor = prefactor
    eigenstrain_name = eigenstrain
  [../]

  [./elasticenergy]
    type = ElasticEnergyMaterial
    args = &#x27;c&#x27;
    outputs = exodus
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  nl_abs_tol = 1e-10
  num_steps = 1

  petsc_options_iname = &#x27;-pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;nonzero&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bf032228-0806-4480-865c-cb6d8f315220"><div class="modal-content"><h4>test/tests/materials/interface_material/interface_value_material_split_mesh.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
    elem_type = QUAD4
  []
  [./subdomain_id]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 2 0&#x27;
    block_id = 1
  [../]
  [./split]
    type = BreakMeshByBlockGenerator
    input = subdomain_id
  [../]
[]



[Variables]
  [./u]
    block = 0
  [../]
  [./v]
    block = 1
  [../]
[]


[Kernels]
  [./diff]
    type = MatDiffusion
    variable = u
    diffusivity = &#x27;diffusivity&#x27;
    block = 0
  [../]

  [./diff_v]
    type = MatDiffusion
    variable = v
    diffusivity = &#x27;diffusivity&#x27;
    block = 1
  [../]
[]

[InterfaceKernels]
  [tied]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    jump_prop_name = &quot;average_jump&quot;
    penalty = 1e6
    boundary = &#x27;interface&#x27;
  []
[]

[BCs]
  [u_left]
    type = DirichletBC
    boundary = &#x27;left&#x27;
    variable = u
    value = 1
  []
  [v_right]
    type = DirichletBC
    boundary = &#x27;right&#x27;
    variable = v
    value = 0
  []
[]

[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 1
    # outputs = all
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
    # outputs = all
  [../]
  [./interface_material_avg]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = average
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_primary_minus_secondary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_primary_minus_secondary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_secondary_minus_primary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_secondary_minus_primary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_abs]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_abs
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_primary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = primary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_secondary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      mat_prop_var_out_basename = diff_var
      boundary = interface
      interface_value_type = secondary
      nl_var_primary = u
      nl_var_secondary = v
  [../]
[]

[AuxKernels]
  [./interface_material_avg]
    type = MaterialRealAux
    property = diff_average
    variable = diffusivity_average
    boundary = interface
  []
  [./interface_material_jump_primary_minus_secondary]
    type = MaterialRealAux
    property = diff_jump_primary_minus_secondary
    variable = diffusivity_jump_primary_minus_secondary
    boundary = interface
  []
  [./interface_material_jump_secondary_minus_primary]
    type = MaterialRealAux
    property = diff_jump_secondary_minus_primary
    variable = diffusivity_jump_secondary_minus_primary
    boundary = interface
  []
  [./interface_material_jump_abs]
    type = MaterialRealAux
    property = diff_jump_abs
    variable = diffusivity_jump_abs
    boundary = interface
  []
  [./interface_material_primary]
    type = MaterialRealAux
    property = diff_primary
    variable = diffusivity_primary
    boundary = interface
  []
  [./interface_material_secondary]
    type = MaterialRealAux
    property = diff_secondary
    variable = diffusivity_secondary
    boundary = interface
  []
  [diffusivity_var]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_var
  []
[]

[AuxVariables]
  [diffusivity_var]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_average]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_primary_minus_secondary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_secondary_minus_primary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_abs]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_primary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_secondary]
    family = MONOMIAL
    order = CONSTANT
  []
[]


[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dbad1d36-2b31-4ea5-97f5-c6ba854d43fe"><div class="modal-content"><h4>modules/phase_field/examples/anisotropic_interfaces/GrandPotentialPlanarGrowth.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = -2
  xmax = 2
  ymin = -2
  ymax = 2
  uniform_refine = 2
[]

[GlobalParams]
  x1 = -2
  y1 = -2
  x2 = 2
  y2 = -1.5
  derivative_order = 2
[]

[Variables]
  [./w]
  [../]
  [./etaa0]
  [../]
  [./etab0]
  [../]
[]

[AuxVariables]
  [./bnds]
  [../]
  #Temperature
  [./T]
  [../]
[]

[AuxKernels]
  [./bnds]
    type = BndsCalcAux
    variable = bnds
    v = &#x27;etaa0 etab0&#x27;
  [../]
  [./T]
    type = FunctionAux
    function = 95.0+2.0*(y-1.0*t)
    variable = T
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[ICs]
  [./w]
    type = BoundingBoxIC
    variable = w
    # note w = A*(c-cleq), A = 1.0, cleq = 0.0 ,i.e., w = c (in the matrix/liquid phase)
    outside = -4.0
    inside = 0.0
  [../]
  [./etaa0]
    type = BoundingBoxIC
    variable = etaa0
    #Solid phase
    outside = 0.0
    inside = 1.0
  [../]
  [./etab0]
    type = BoundingBoxIC
    variable = etab0
    #Liquid phase
    outside = 1.0
    inside = 0.0
  [../]
[]


[Kernels]
# Order parameter eta_alpha0
  [./ACa0_bulk]
    type = ACGrGrMulti
    variable = etaa0
    v =           &#x27;etab0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACa0_sw]
    type = ACSwitching
    variable = etaa0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etab0 w&#x27;
  [../]
  [./ACa0_int1]
    type = ACInterface2DMultiPhase1
    variable = etaa0
    etas = &#x27;etab0&#x27;
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
  [../]
  [./ACa0_int2]
    type = ACInterface2DMultiPhase2
    variable = etaa0
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
  [../]
  [./ea0_dot]
    type = TimeDerivative
    variable = etaa0
  [../]
# Order parameter eta_beta0
  [./ACb0_bulk]
    type = ACGrGrMulti
    variable = etab0
    v =           &#x27;etaa0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACb0_sw]
    type = ACSwitching
    variable = etab0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etaa0 w&#x27;
  [../]
  [./ACb0_int1]
    type = ACInterface2DMultiPhase1
    variable = etab0
    etas = &#x27;etaa0&#x27;
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
  [../]
  [./ACb0_int2]
    type = ACInterface2DMultiPhase2
    variable = etab0
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
  [../]
  [./eb0_dot]
    type = TimeDerivative
    variable = etab0
  [../]
#Chemical potential
  [./w_dot]
    type = SusceptibilityTimeDerivative
    variable = w
    f_name = chi
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = w
    diffusivity = Dchi
  [../]
  [./coupled_etaa0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etaa0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
  [./coupled_etab0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etab0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
[]


[Materials]
  [./ha]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = ha
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etaa0&#x27;
  [../]
  [./hb]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = hb
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etab0&#x27;
  [../]
  [./omegaa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegaa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/ka-w/Vm*caeq&#x27;
  [../]
  [./omegab]
    type = DerivativeParsedMaterial
    args = &#x27;w T&#x27;
    f_name = omegab
    material_property_names = &#x27;Vm kb cbeq S Tm&#x27;
    function = &#x27;-0.5*w^2/Vm^2/kb-w/Vm*cbeq-S*(T-Tm)&#x27;
  [../]
  [./rhoa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhoa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;w/Vm^2/ka + caeq/Vm&#x27;
  [../]
  [./rhob]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhob
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;w/Vm^2/kb + cbeq/Vm&#x27;
  [../]
  [./kappaa]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
    etaa = etaa0
    etab = etab0
    outputs = exodus
    output_properties = &#x27;kappaa&#x27;
  [../]
  [./kappab]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
    etaa = etab0
    etab = etaa0
    outputs = exodus
    output_properties = &#x27;kappab&#x27;
  [../]
  [./const]
    type = GenericConstantMaterial
    prop_names =  &#x27;L   D    chi  Vm   ka    caeq kb    cbeq  gab mu   S   Tm&#x27;
    prop_values = &#x27;1.0 1.0  0.1  1.0  10.0  0.1  10.0  0.9   4.5 10.0 1.0 100.0&#x27;
  [../]
  [./Mobility]
    type = ParsedMaterial
    f_name = Dchi
    material_property_names = &#x27;D chi&#x27;
    function = &#x27;D*chi&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      31&#x27;
  l_tol = 1.0e-3
  l_max_its = 30
  nl_max_its = 15
  nl_rel_tol = 1.0e-8
  nl_abs_tol = 1e-8
  end_time = 2.0
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.0005
    cutback_factor = 0.7
    growth_factor = 1.2
  [../]
[]

[Adaptivity]
 initial_steps = 3
 max_h_level = 3
 initial_marker = err_eta
 marker = err_bnds
[./Markers]
   [./err_eta]
     type = ErrorFractionMarker
     coarsen = 0.3
     refine = 0.95
     indicator = ind_eta
   [../]
   [./err_bnds]
     type = ErrorFractionMarker
     coarsen = 0.3
     refine = 0.95
     indicator = ind_bnds
   [../]
 [../]
 [./Indicators]
   [./ind_eta]
     type = GradientJumpIndicator
     variable = etaa0
    [../]
    [./ind_bnds]
      type = GradientJumpIndicator
      variable = bnds
   [../]
 [../]
[]

[Outputs]
  interval = 10
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ce048b87-5c48-4971-ad26-6dffa243d0eb"><div class="modal-content"><h4>modules/phase_field/test/tests/mobility_derivative/mobility_derivative_split_coupled_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 30
  ny = 30
  xmax = 30.0
  ymax = 30.0
  elem_type = QUAD4
[]

[Variables]
  [./c]
  [../]
  [./w]
  [../]
  [./d]
  [../]
[]

[ICs]
  [./c_IC]
    type = CrossIC
    x1 = 0.0
    x2 = 30.0
    y1 = 0.0
    y2 = 30.0
    variable = c
  [../]
  [./d_IC]
    type = BoundingBoxIC
    x1 = 0.0
    x2 = 15.0
    y1 = 0.0
    y2 = 30.0
    inside = 1.0
    outside = 0.0
    variable = d
  [../]
[]

[Kernels]
  [./cres]
    type = SplitCHParsed
    variable = c
    kappa_name = kappa_c
    w = w
    f_name = F
  [../]
  [./wres]
    type = SplitCHWRes
    variable = w
    mob_name = M
    args = &#x27;c d&#x27;
  [../]
  [./time]
    type = CoupledTimeDerivative
    variable = w
    v = c
  [../]
  [./d_dot]
    type = TimeDerivative
    variable = d
  [../]
  [./d_diff]
    type = MatDiffusion
    variable = d
    diffusivity = diffusivity
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[Materials]
  [./kappa]
    type = GenericConstantMaterial
    prop_names = &#x27;kappa_c&#x27;
    prop_values = &#x27;2.0&#x27;
  [../]
  [./mob]
    type = DerivativeParsedMaterial
    f_name = M
    args = &#x27;c d&#x27;
    function = &#x27;if(d&gt;0.001,d,0.001)*(1-0.5*c^2)&#x27;
    outputs = exodus
    derivative_order = 1
  [../]
  [./free_energy]
    type = MathEBFreeEnergy
    f_name = F
    c = c
  [../]
  [./d_diff]
    type = GenericConstantMaterial
    prop_names = diffusivity
    prop_values = 0.1
  [../]
[]

[Preconditioning]
  [./SMP]
   type = SMP
   full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;BDF2&#x27;

  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm         31      lu      1&#x27;

  l_max_its = 30
  l_tol = 1.0e-4
  nl_max_its = 50
  nl_rel_tol = 1.0e-10

  dt = 10.0
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6af47168-2780-4f0e-b116-ff80ae868501"><div class="modal-content"><h4>modules/combined/examples/publications/rapid_dev/fig6.i</h4><pre class="moose-pre"><code class="language-text">#
# Fig. 6 input for 10.1016/j.commatsci.2017.02.017
# D. Schwen et al./Computational Materials Science 132 (2017) 36-45
# Three phase interface simulation demonstrating the interfacial stability
# w.r.t. formation of a tspurious third phase
#

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 120
  ny = 120
  nz = 0
  xmin = 0
  xmax = 40
  ymin = 0
  ymax = 40
  zmin = 0
  zmax = 0
  elem_type = QUAD4
[]

[Variables]
  # concentration
  [./c]
  [../]

  # order parameter 1
  [./eta1]
  [../]

  # order parameter 2
  [./eta2]
  [../]

  # order parameter 3
  [./eta3]
  [../]

  # phase concentration 1
  [./c1]
    initial_condition = 0.4
  [../]

  # phase concentration 2
  [./c2]
    initial_condition = 0.5
  [../]

  # phase concentration 3
  [./c3]
    initial_condition = 0.8
  [../]

  # Lagrange multiplier
  [./lambda]
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./T]
    [./InitialCondition]
      type = FunctionIC
      function = &#x27;x-10&#x27;
    [../]
  [../]
[]


[Functions]
  [./ic_func_eta1]
    type = ParsedFunction
    value = &#x27;0.5*(1.0+tanh((x-10)/sqrt(2.0))) * 0.5*(1.0+tanh((y-10)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_eta2]
    type = ParsedFunction
    value = &#x27;0.5*(1.0-tanh((x-10)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_eta3]
    type = ParsedFunction
    value = &#x27;1 - 0.5*(1.0-tanh((x-10)/sqrt(2.0)))
              - 0.5*(1.0+tanh((x-10)/sqrt(2.0))) * 0.5*(1.0+tanh((y-10)/sqrt(2.0)))&#x27;
  [../]
  [./ic_func_c]
    type = ParsedFunction
    value = &#x27;0.5 * 0.5*(1.0-tanh((x-10)/sqrt(2.0)))
              + 0.4 * 0.5*(1.0+tanh((x-10)/sqrt(2.0))) * 0.5*(1.0+tanh((y-10)/sqrt(2.0)))
              + 0.8 * (1 - 0.5*(1.0-tanh((x-10)/sqrt(2.0)))
                        - 0.5*(1.0+tanh((x-10)/sqrt(2.0))) * 0.5*(1.0+tanh((y-10)/sqrt(2.0))))&#x27;
  [../]
[]

[ICs]
  [./eta1]
    variable = eta1
    type = FunctionIC
    function = ic_func_eta1
  [../]
  [./eta2]
    variable = eta2
    type = FunctionIC
    function = ic_func_eta2
  [../]
  [./eta3]
    variable = eta3
    type = FunctionIC
    function = ic_func_eta3
  [../]
  [./c]
    variable = c
    type = FunctionIC
    function = ic_func_c
  [../]
[]

[Materials]
  # simple toy free energies
  [./f1]
    type = DerivativeParsedMaterial
    f_name = F1
    args = &#x27;c1&#x27;
    function = &#x27;20*(c1-0.4)^2&#x27;
  [../]
  [./f2]
    type = DerivativeParsedMaterial
    f_name = F2
    args = &#x27;c2 T&#x27;
    function = &#x27;20*(c2-0.5)^2 + 0.01*T&#x27;
  [../]
  [./f3]
    type = DerivativeParsedMaterial
    f_name = F3
    args = &#x27;c3&#x27;
    function = &#x27;20*(c3-0.8)^2&#x27;
  [../]

  # Switching functions for each phase
  # h1(eta1, eta2, eta3)
  [./h1]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta1
    eta_j = eta2
    eta_k = eta3
    f_name = h1
  [../]
  # h2(eta1, eta2, eta3)
  [./h2]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta2
    eta_j = eta3
    eta_k = eta1
    f_name = h2
  [../]
  # h3(eta1, eta2, eta3)
  [./h3]
    type = SwitchingFunction3PhaseMaterial
    eta_i = eta3
    eta_j = eta1
    eta_k = eta2
    f_name = h3
  [../]

  # Coefficients for diffusion equation
  [./Dh1]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h1&#x27;
    function = D*h1
    f_name = Dh1
  [../]
  [./Dh2]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h2&#x27;
    function = D*h2
    f_name = Dh2
  [../]
  [./Dh3]
    type = DerivativeParsedMaterial
    material_property_names = &#x27;D h3&#x27;
    function = D*h3
    f_name = Dh3
  [../]

  # Barrier functions for each phase
  [./g1]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta1
    function_name = g1
  [../]
  [./g2]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta2
    function_name = g2
  [../]
  [./g3]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta3
    function_name = g3
  [../]

  # constant properties
  [./constants]
    type = GenericConstantMaterial
    prop_names  = &#x27;L   kappa  D&#x27;
    prop_values = &#x27;1.0 1.0    1&#x27;
  [../]
[]

[Kernels]
  #Kernels for diffusion equation
  [./diff_time]
    type = TimeDerivative
    variable = c
  [../]
  [./diff_c1]
    type = MatDiffusion
    variable = c
    diffusivity = Dh1
    v = c1
  [../]
  [./diff_c2]
    type = MatDiffusion
    variable = c
    diffusivity = Dh2
    v = c2
  [../]
  [./diff_c3]
    type = MatDiffusion
    variable = c
    diffusivity = Dh3
    v = c3
  [../]

  # Kernels for Allen-Cahn equation for eta1
  [./deta1dt]
    type = TimeDerivative
    variable = eta1
  [../]
  [./ACBulkF1]
    type = KKSMultiACBulkF
    variable  = eta1
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g1
    eta_i     = eta1
    wi        = 1.0
    args      = &#x27;c1 c2 c3 eta2 eta3&#x27;
  [../]
  [./ACBulkC1]
    type = KKSMultiACBulkC
    variable  = eta1
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta1
    args      = &#x27;eta2 eta3&#x27;
  [../]
  [./ACInterface1]
    type = ACInterface
    variable = eta1
    kappa_name = kappa
  [../]
  [./multipler1]
    type = MatReaction
    variable = eta1
    v = lambda
    mob_name = L
  [../]

  # Kernels for Allen-Cahn equation for eta2
  [./deta2dt]
    type = TimeDerivative
    variable = eta2
  [../]
  [./ACBulkF2]
    type = KKSMultiACBulkF
    variable  = eta2
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g2
    eta_i     = eta2
    wi        = 1.0
    args      = &#x27;c1 c2 c3 eta1 eta3&#x27;
  [../]
  [./ACBulkC2]
    type = KKSMultiACBulkC
    variable  = eta2
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta2
    args      = &#x27;eta1 eta3&#x27;
  [../]
  [./ACInterface2]
    type = ACInterface
    variable = eta2
    kappa_name = kappa
  [../]
  [./multipler2]
    type = MatReaction
    variable = eta2
    v = lambda
    mob_name = L
  [../]

  # Kernels for the Lagrange multiplier equation
  [./mult_lambda]
    type = MatReaction
    variable = lambda
    mob_name = 3
  [../]
  [./mult_ACBulkF_1]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g1
    eta_i     = eta1
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta2 eta3&#x27;
  [../]
  [./mult_ACBulkC_1]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta1
    args      = &#x27;eta2 eta3&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_1]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta1
    kappa_name = kappa
    mob_name = 1
  [../]
  [./mult_ACBulkF_2]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g2
    eta_i     = eta2
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta1 eta3&#x27;
  [../]
  [./mult_ACBulkC_2]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta2
    args      = &#x27;eta1 eta3&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_2]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta2
    kappa_name = kappa
    mob_name = 1
  [../]
  [./mult_ACBulkF_3]
    type = KKSMultiACBulkF
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    gi_name   = g3
    eta_i     = eta3
    wi        = 1.0
    mob_name  = 1
    args      = &#x27;c1 c2 c3 eta1 eta2&#x27;
  [../]
  [./mult_ACBulkC_3]
    type = KKSMultiACBulkC
    variable  = lambda
    Fj_names  = &#x27;F1 F2 F3&#x27;
    hj_names  = &#x27;h1 h2 h3&#x27;
    cj_names  = &#x27;c1 c2 c3&#x27;
    eta_i     = eta3
    args      = &#x27;eta1 eta2&#x27;
    mob_name  = 1
  [../]
  [./mult_CoupledACint_3]
    type = SimpleCoupledACInterface
    variable = lambda
    v = eta3
    kappa_name = kappa
    mob_name = 1
  [../]

  # Kernels for constraint equation eta1 + eta2 + eta3 = 1
  # eta3 is the nonlinear variable for the constraint equation
  [./eta3reaction]
    type = MatReaction
    variable = eta3
    mob_name = 1
  [../]
  [./eta1reaction]
    type = MatReaction
    variable = eta3
    v = eta1
    mob_name = 1
  [../]
  [./eta2reaction]
    type = MatReaction
    variable = eta3
    v = eta2
    mob_name = 1
  [../]
  [./one]
    type = BodyForce
    variable = eta3
    value = -1.0
  [../]

  # Phase concentration constraints
  [./chempot12]
    type = KKSPhaseChemicalPotential
    variable = c1
    cb       = c2
    fa_name  = F1
    fb_name  = F2
  [../]
  [./chempot23]
    type = KKSPhaseChemicalPotential
    variable = c2
    cb       = c3
    fa_name  = F2
    fb_name  = F3
  [../]
  [./phaseconcentration]
    type = KKSMultiPhaseConcentration
    variable = c3
    cj = &#x27;c1 c2 c3&#x27;
    hj_names = &#x27;h1 h2 h3&#x27;
    etas = &#x27;eta1 eta2 eta3&#x27;
    c = c
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;
  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-11

  num_steps = 1000
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.2
    optimal_iterations = 10
    iteration_window = 2
  [../]
[]

[Preconditioning]
  active = &#x27;full&#x27;
  [./full]
    type = SMP
    full = true
  [../]
  [./mydebug]
    type = FDP
    full = true
  [../]
[]

[Outputs]
  exodus = true
  checkpoint = true
  print_linear_residuals = false
  [./csv]
    type = CSV
    execute_on = &#x27;final&#x27;
  [../]
[]

#[VectorPostprocessors]
#  [./c]
#    type =  LineValueSampler
#    start_point = &#x27;-25 0 0&#x27;
#    end_point = &#x27;25 0 0&#x27;
#    variable = c
#    num_points = 151
#    sort_by =  id
#    execute_on = timestep_end
#  [../]
#  [./eta1]
#    type =  LineValueSampler
#    start_point = &#x27;-25 0 0&#x27;
#    end_point = &#x27;25 0 0&#x27;
#    variable = eta1
#    num_points = 151
#    sort_by =  id
#    execute_on = timestep_end
#  [../]
#  [./eta2]
#    type =  LineValueSampler
#    start_point = &#x27;-25 0 0&#x27;
#    end_point = &#x27;25 0 0&#x27;
#    variable = eta2
#    num_points = 151
#    sort_by =  id
#    execute_on = timestep_end
#  [../]
#  [./eta3]
#    type =  LineValueSampler
#    start_point = &#x27;-25 0 0&#x27;
#    end_point = &#x27;25 0 0&#x27;
#    variable = eta3
#    num_points = 151
#    sort_by =  id
#    execute_on = timestep_end
#  [../]
#[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1a67cdd0-0050-4039-8f88-0fae4be547cb"><div class="modal-content"><h4>modules/phase_field/test/tests/phase_field_crystal/PFCEnergyDensity/auxkernel.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  nz = 0
  xmax = 6
  ymax = 6
  zmax = 0
[]

[Variables]
  [./n]
    [./InitialCondition]
      type = RandomIC
      min = 0.0
      max = 0.1
    [../]
  [../]
  [./u]
    scaling = 1e2
  [../]
  [./v]
    scaling = 1e1
  [../]
[]

[AuxVariables]
  [./ed]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./edrff0]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./edrff1]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./edrff2]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./ndot]
    type = TimeDerivative
    variable = n
  [../]
  [./n_bulk]
    type = CHBulkPFCTrad
    variable = n
  [../]
  [./u_term]
    type = MatDiffusion
    variable = n
    v = u
    diffusivity = C2
  [../]
  [./v_term]
    type = MatDiffusion
    variable = n
    v = v
    diffusivity = C4
  [../]
  [./u_rctn]
    type = Reaction
    variable = u
  [../]
  [./u_gradn]
    type = LaplacianSplit
    variable = u
    c = n
  [../]
  [./v_rctn]
    type = Reaction
    variable = v
  [../]
  [./v_gradu]
    type = LaplacianSplit
    variable = v
    c = u
  [../]
[]

[AuxKernels]
  [./Energy_n]
    type = PFCEnergyDensity
    execute_on = &#x27;initial timestep_end&#x27;
    variable = ed
    v = &#x27;n u v&#x27;
  [../]

  [./Energy_rff0]
    type = PFCRFFEnergyDensity
    execute_on = &#x27;initial timestep_end&#x27;
    variable = edrff0
    log_approach = tolerance
    v = &#x27;n u v&#x27;
  [../]
  [./Energy_rff1]
    type = PFCRFFEnergyDensity
    execute_on = &#x27;initial timestep_end&#x27;
    variable = edrff1
    log_approach = cancelation
    v = &#x27;n u v&#x27;
  [../]
  [./Energy_rff2]
    type = PFCRFFEnergyDensity
    execute_on = &#x27;initial timestep_end&#x27;
    variable = edrff2
    log_approach = expansion
    v = &#x27;n u v&#x27;
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[Materials]
  [./PFCTrad]
    type = PFCTradMaterial
    order = FOURTH
  [../]
[]

[Postprocessors]
  [./Total_free_energy]
    type = PFCElementEnergyIntegral
    variable = ed
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Preconditioning]
  active = &#x27;SMP&#x27;
  [./SMP]
    type = SMP
    full = true
    off_diag_row = &#x27;u n n v&#x27;
    off_diag_column = &#x27;n u v u&#x27;
  [../]
  [./FDP]
    type = FDP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 101&#x27;
  # petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap&#x27;
  # petsc_options_value = &#x27;asm         101   preonly   lu      1&#x27;
  petsc_options_iname = &#x27;-pc_type &#x27;
  petsc_options_value = &#x27;lu &#x27;

  l_max_its = 100
  l_tol = 1e-04
  nl_rel_tol = 1e-09
  nl_abs_tol = 1e-11

  num_steps = 1
  dt = 0.1
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4714c91c-03a6-4813-8047-0daa98d8f173"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/tied-nodes.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
[]

[Mesh]
  file = long-bottom-block-symmetric-single-element.e
[]

[Variables]
  [./disp_x]
    scaling = 2
  [../]
  [./disp_y]
    scaling = 3
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [./disp_x]
    type = RANFSTieNode
    secondary = 10
    primary = 20
    variable = disp_x
    primary_variable = disp_x
    component = x
  [../]
  [./disp_y]
    type = RANFSTieNode
    secondary = 10
    primary = 20
    variable = disp_y
    primary_variable = disp_y
    component = y
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = DirichletBC
    variable = disp_y
    boundary = 30
    value = 0
  [../]
  [./topx]
    type = DirichletBC
    variable = disp_x
    boundary = 30
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  dtmin = 1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre    boomeramg&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  [exo]
    type = Exodus
  []
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="34da1be0-288b-4545-aacf-f293caab6c0c"><div class="modal-content"><h4>test/tests/interfacekernels/1d_interface/reaction_1D_steady.i</h4><pre class="moose-pre"><code class="language-text"># Steady-state test for the InterfaceReaction kernel.
#
# Specie M transport from domain 1 (0&lt;=x&lt;=1) to domain 2 (1&lt;x&lt;=2),
# u and v are concentrations in domain 1 and domain 2.
#
# Diffusion in both domains can be described by Ficks law and diffusion
# kernel is applied.
#
# Specie M has different diffusity in different domains, here set as D1=4, D2=2.
#
# Dirichlet boundary conditions are applied, i.e., u(0)=1, v(2)=0
#
# At the interface consider the following
#
# (a) Fluxes are matched from both domains (InterfaceDiffusion kernel)
#
# (b) First-order reaction is R = kf*u - kb*v
#
# Analytical solution is
# u = -0.2*u+1,    0&lt;=u&lt;=1
# v = -0.4*v+0.8,  1&lt;v&lt;=2

[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 10
    xmax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;1.0 0 0&#x27;
    block_id = 1
    top_right = &#x27;2.0 1.0 0&#x27;
  [../]
  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = &#x27;subdomain1&#x27;
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;0&#x27;
  [../]
  [./v]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
  [../]
[]

[Kernels]
  [./diff_u]
    type = MatDiffusion
    variable = u
    block = &#x27;0&#x27;
    diffusivity = D
  [../]
  [./diff_v]
    type = MatDiffusion
    variable = v
    block = &#x27;1&#x27;
    diffusivity = D
  [../]
[]

[InterfaceKernels]
  [./interface]
    type = InterfaceDiffusion
    variable = u
    neighbor_var = &#x27;v&#x27;
    boundary = &#x27;primary0_interface&#x27;
    D = D
    D_neighbor = D
  [../]
  [./interface_reaction]
    type = InterfaceReaction
    variable = u
    neighbor_var = &#x27;v&#x27;
    boundary = &#x27;primary0_interface&#x27;
    kf = 1 # Forward reaction rate coefficient
    kb = 2 # Backward reaction rate coefficient
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    value = 1
  [../]
  [./right]
    type = DirichletBC
    variable = v
    boundary = &#x27;right&#x27;
    value = 0
  [../]
[]

[Materials]
  [./block0]
    type = GenericConstantMaterial
    block = &#x27;0&#x27;
    prop_names = &#x27;D&#x27;
    prop_values = &#x27;4&#x27;
  [../]
  [./block1]
    type = GenericConstantMaterial
    block = &#x27;1&#x27;
    prop_names = &#x27;D&#x27;
    prop_values = &#x27;2&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  nl_rel_tol = 1e-10
[]

[Outputs]
  print_linear_residuals = true
  execute_on = &#x27;FINAL&#x27;
  exodus = true
  csv = true
[]

[Debug]
  show_var_residual_norms = true
[]

[Postprocessors]
  [./elemental_error_u]
    type = ElementL2Error
    function = -0.2*x+1
    variable = &#x27;u&#x27;
    block = &#x27;0&#x27;
  [../]
  [./elemental_error_v]
    type = ElementL2Error
    function = -0.4*x+0.8
    variable = &#x27;v&#x27;
    block = &#x27;1&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bc213d67-e6f5-47d2-8919-92e7ed932dbc"><div class="modal-content"><h4>modules/phase_field/test/tests/mobility_derivative/coupledmatdiffusion.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  xmax = 15.0
  ymax = 15.0
  elem_type = QUAD4
[]

[Variables]
  [./c]
    [./InitialCondition]
      type = CrossIC
      x1 = 0.0
      x2 = 30.0
      y1 = 0.0
      y2 = 30.0
    [../]
  [../]
  [./d]
    [./InitialCondition]
      type = SmoothCircleIC
      x1 = 15
      y1 = 15
      radius = 8
      int_width = 3
      invalue = 2
      outvalue = 0
    [../]
  [../]
  [./u]
  [../]
  [./w]
  [../]
[]

[Kernels]
  [./ctime]
    type = TimeDerivative
    variable = c
  [../]
  [./umat]
    type = MatReaction
    variable = c
    v = u
    mob_name = 1
  [../]
  [./urxn]
    type = Reaction
    variable = u
  [../]
  [./cres]
    type = MatDiffusion
    variable = u
    diffusivity = Dc
    args = d
    v = c
  [../]

  [./dtime]
    type = TimeDerivative
    variable = d
  [../]
  [./wmat]
    type = MatReaction
    variable = d
    v = w
    mob_name = 1
  [../]
  [./wrxn]
    type = Reaction
    variable = w
  [../]
  [./dres]
    type = MatDiffusion
    variable = w
    diffusivity = Dd
    args = c
    v = d
  [../]
[]

[Materials]
  [./Dc]
    type = DerivativeParsedMaterial
    f_name = Dc
    function = &#x27;0.01+c^2+d&#x27;
    args = &#x27;c d&#x27;
    derivative_order = 1
  [../]
  [./Dd]
    type = DerivativeParsedMaterial
    f_name = Dd
    function = &#x27;d^2+c+1.5&#x27;
    args = &#x27;c d&#x27;
    derivative_order = 1
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;BDF2&#x27;

  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm      31                  lu           1&#x27;

  dt = 1
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c5b5e101-fefb-4b8e-a5c1-45c48e779f05"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-min-lm-nodal-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Problem]
  kernel_coverage_check = false
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
  [../]
  [./normal_lm]
    block = 3
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [./lm]
    type = NormalNodalLMMechanicalContact
    secondary = 10
    primary = 20
    variable = normal_lm
    primary_variable = disp_x
    disp_y = disp_y
  [../]
  [./disp_x]
    type = NormalNodalMechanicalContact
    secondary = 10
    primary = 20
    variable = disp_x
    primary_variable = disp_x
    lambda = normal_lm
    component = x
  [../]
  [./disp_y]
    type = NormalNodalMechanicalContact
    secondary = 10
    primary = 20
    variable = disp_y
    primary_variable = disp_y
    lambda = normal_lm
    component = y
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active = &#x27;num_nl cumulative contact&#x27;
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6a05bbc2-519c-4219-b5a7-6ffeeac8be0a"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/grid-sequencing/grid-sequencing.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1

# We offset slightly so we avoid the case where the bottom of the secondary block and the top of the
# primary block are perfectly vertically aligned which can cause the backtracking line search some
# issues for a coarsest mesh (basic line search handles that fine)
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
[]

[Mesh]
  file = level0.e
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
  [../]
  [./normal_lm]
    block = 3
  [../]
  [./tangential_lm]
    block = 3
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [normal_lm]
    type = NormalNodalLMMechanicalContact
    secondary = 10
    primary = 20
    variable = normal_lm
    primary_variable = disp_x
    disp_y = disp_y
    ncp_function_type = min
  [../]
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_lm]
    type = TangentialMortarLMMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_x
    secondary_disp_y = disp_y
    use_displaced_mesh = true
    compute_primal_residuals = false
    contact_pressure = normal_lm
    friction_coefficient = .1
    ncp_function_type = fb
  []
  [tangential_x]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_y]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  num_steps = 3
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  nl_abs_tol = 1e-10
  num_grids = 5
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  [exo]
    type = Exodus
    sync_times = &#x27;15&#x27;
    sync_only = true
  []
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8cf9ba45-18df-47aa-b873-c3026e3382bc"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictional-nodal-min-normal-lm-mortar-fb-tangential-lm-mortar-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1

# We offset slightly so we avoid the case where the bottom of the secondary block and the top of the
# primary block are perfectly vertically aligned which can cause the backtracking line search some
# issues for a coarse mesh (basic line search handles that fine)
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  [./file_mesh]
    type = FileMeshGenerator
    file = long-bottom-block-1elem-blocks-coarse.e
  [../]
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
    # order = SECOND
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
    # order = SECOND
  [../]
  [./frictional_normal_lm]
    block = 3
    # family = MONOMIAL
    # order = CONSTANT
  [../]
  [./frictional_tangential_lm]
    block = 3
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [frictional_normal_lm]
    type = NormalNodalLMMechanicalContact
    secondary = 10
    primary = 20
    variable = frictional_normal_lm
    primary_variable = disp_x
    disp_y = disp_y
    ncp_function_type = min
  [../]
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = frictional_normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = frictional_normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [frictional_tangential_lm]
    type = TangentialMortarLMMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = frictional_tangential_lm
    secondary_variable = disp_x
    secondary_disp_y = disp_y
    use_displaced_mesh = true
    compute_primal_residuals = false
    contact_pressure = frictional_normal_lm
    friction_coefficient = .1
    ncp_function_type = fb
  []
  [tangential_x]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = frictional_tangential_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_y]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = frictional_tangential_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor -snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false

  # [./Predictor]
  #   type = SimplePredictor
  #   scale = 1.0
  # [../]
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
  # checkpoint = true
  # [./dofmap]
  #   type = DOFMap
  #   execute_on = &#x27;initial&#x27;
  # [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = frictional_normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f92e4636-d0e4-4039-8c1f-d5c0b6d775d7"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-fb-lm-nodal-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Problem]
  kernel_coverage_check = false
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
  [../]
  [./normal_lm]
    block = 3
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [./lm]
    type = NormalNodalLMMechanicalContact
    secondary = 10
    primary = 20
    variable = normal_lm
    primary_variable = disp_x
    disp_y = disp_y
    ncp_function_type = &#x27;fb&#x27;
  [../]
  [./disp_x]
    type = NormalNodalMechanicalContact
    secondary = 10
    primary = 20
    variable = disp_x
    primary_variable = disp_x
    lambda = normal_lm
    component = x
  [../]
  [./disp_y]
    type = NormalNodalMechanicalContact
    secondary = 10
    primary = 20
    variable = disp_y
    primary_variable = disp_y
    lambda = normal_lm
    component = y
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active = &#x27;num_nl cumulative contact&#x27;
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7ae8aa9d-8fd4-4f6a-8933-32eb77e39991"><div class="modal-content"><h4>modules/phase_field/test/tests/MultiSmoothCircleIC/specifiedsmoothcircleIC_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 5
  ny = 5
  nz = 5
  xmin = 0
  xmax = 100
  ymin = 0
  ymax = 100
  zmin = 0
  zmax = 100
  elem_type = HEX8
[]

[Variables]
  [./c]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./ie_c]
    type = TimeDerivative
    variable = c
  [../]
  [./diff]
    type = MatDiffusion
    variable = c
    diffusivity = D_v
  [../]
[]

[ICs]
  [./c]
    type = SpecifiedSmoothCircleIC
    variable = c
    x_positions = &#x27;10 50 90&#x27;
    y_positions = &#x27;30 20 80&#x27;
    z_positions = &#x27;30 50 75&#x27;
    radii = &#x27;21 25 16&#x27;
    invalue = 1.0
    outvalue = 0.0001
    int_width = 4
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[Materials]
  [./Dv]
    type = GenericConstantMaterial
    prop_names = D_v
    prop_values = 0.074802
  [../]
[]

[Postprocessors]
  [./bubbles]
    type = FeatureFloodCount
    variable = c
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -mat_mffd_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg 101 ds&#x27;
  l_max_its = 20
  l_tol = 1e-4
  nl_max_its = 20
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-11
  start_time = 0.0
  num_steps = 1
  dt = 100.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="efb8f447-c621-4d76-8c75-e3b0a303a377"><div class="modal-content"><h4>test/tests/materials/derivative_material_interface/bad_evaluation.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = MatDiffusion
    variable = u
    diffusivity = F
  [../]
[]

[Materials]
  [./time]
    type = GenericFunctionMaterial
    prop_names = &#x27;time&#x27;
    prop_values = &#x27;t&#x27;
    outputs = all
  [../]

  [./F]
    type = DerivativeParsedMaterial
    f_name = F
    material_property_names = &#x27;time&#x27;
    function = &#x27;if (time &lt; 1.9, 1, log(-1))&#x27;
    disable_fpoptimizer = true
    enable_jit = false
    evalerror_behavior = nan
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 2
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9d996ad4-4c47-4c6c-8268-597832d5a5a7"><div class="modal-content"><h4>modules/heat_conduction/test/tests/sideset_heat_transfer/gap_thermal_1D.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [mesh]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 2
    xmax = 2
  []
  [split]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    block_id = 1
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 0 0&#x27;
  []
  [interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = split
    primary_block = 1
    paired_block = 0
    new_boundary = &#x27;interface0&#x27;
  []
  uniform_refine = 4
[]

[Variables]
  # Defining a DFEM variable to handle gap discontinuity
  [T]
    order = FIRST
    family = MONOMIAL
  []
[]

[AuxVariables]
  # Auxvariable containing bulk temperature of gap
  [Tbulk]
    order = FIRST
    family = LAGRANGE
    initial_condition = 300 # K
  []
[]

[Kernels]
  [diff]
    type = MatDiffusion
    variable = T
    diffusivity = conductivity
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[DGKernels]
  # DG kernel to represent diffusion accross element faces
  [./dg_diff]
    type = DGDiffusion
    variable = T
    epsilon = -1
    sigma = 6
    diff = conductivity
    # Ignoring gap side set because no diffusion accross there
    exclude_boundary = &#x27;interface0&#x27;
  [../]
[]

[InterfaceKernels]
  active = &#x27;gap&#x27;
  # Heat transfer kernel using Tbulk as material
  [gap]
    type = SideSetHeatTransferKernel
    variable = T
    neighbor_var = T
    boundary = &#x27;interface0&#x27;
  []
  # Heat transfer kernel using Tbulk as auxvariable
  [gap_var]
    type = SideSetHeatTransferKernel
    variable = T
    neighbor_var = T
    boundary = &#x27;interface0&#x27;
    Tbulk_var = Tbulk
  []
[]

[Functions]
  [bc_func]
    type = ConstantFunction
    value = 300
  []
  [exact]
    type = ParsedFunction
    value = &#x27;
            A := if(x &lt; 1, -0.5, -0.25);
            B := if(x &lt; 1, -0.293209850655001, 0.0545267662299068);
            C := if(x &lt; 1, 300.206790149345, 300.19547323377);
            d := -1;
            A * (x+d) * (x+d) + B * (x+d) + C&#x27;
  []
[]

[BCs]
  [bc_left]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;left&#x27;
    variable = T
    diff = &#x27;conductivity&#x27;
    epsilon = -1
    sigma = 6
    function = bc_func
  []
  [bc_right]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;right&#x27;
    variable = T
    diff = &#x27;conductivity&#x27;
    epsilon = -1
    sigma = 6
    function = bc_func
  []
[]

[Materials]
  [k0]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 1.0
    block = 0
  []
  [k1]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 2.0
    block = 1
  []
  [gap_mat]
    type = SideSetHeatTransferMaterial
    boundary = &#x27;interface0&#x27;
    conductivity = 1.5
    gap_length = 1.0
    h_primary = 1
    h_neighbor = 1
    Tbulk = 300
    emissivity_primary = 1
    emissivity_neighbor = 1
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    variable = T
    function = exact
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="de660711-10e1-40f4-a3cc-01e8fbc060bb"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictional-mortar-min-lm-mortar-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1

# We offset slightly so we avoid the case where the bottom of the secondary block and the top of the
# primary block are perfectly vertically aligned which can cause the backtracking line search some
# issues for a coarse mesh (basic line search handles that fine)
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
    # order = SECOND
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
    # order = SECOND
  [../]
  [./normal_lm]
    block = 3
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./tangential_lm]
    block = 3
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [normal_lm]
    type = NormalMortarLMMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    secondary_disp_y = disp_y
    use_displaced_mesh = true
    compute_primal_residuals = false
    ncp_function_type = min
  []
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_lm]
    type = TangentialMortarLMMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_x
    secondary_disp_y = disp_y
    use_displaced_mesh = true
    compute_primal_residuals = false
    contact_pressure = normal_lm
    friction_coefficient = .1
    ncp_function_type = min
  []
  [tangential_x]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_y]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor -snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d4109e07-4876-4d37-91ac-c094903c585f"><div class="modal-content"><h4>modules/phase_field/test/tests/phase_field_crystal/PFCTrad/PFCTrad_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 50
  ny = 50
  xmax = 8
  ymax = 8
[]

[Variables]
  [./n]
    [./InitialCondition]
      type = RandomIC
      min = -1
      max = 4
    [../]
  [../]
  [./u]
    scaling = 1e2
  [../]
  [./v]
    scaling = 1e1
  [../]
[]

[Kernels]
  [./ndot]
    type = TimeDerivative
    variable = n
  [../]
  [./n_bulk]
    type = CHBulkPFCTrad
    variable = n
  [../]
  [./u_term]
    type = MatDiffusion
    variable = n
    v = u
    diffusivity = C2
  [../]
  [./v_term]
    type = MatDiffusion
    variable = n
    v = v
    diffusivity = C4
  [../]
  [./u_rctn]
    type = Reaction
    variable = u
  [../]
  [./u_gradn]
    type = LaplacianSplit
    variable = u
    c = n
  [../]
  [./v_rctn]
    type = Reaction
    variable = v
  [../]
  [./v_gradu]
    type = LaplacianSplit
    variable = v
    c = u
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[Materials]
  [./PFCTrad]
    type = PFCTradMaterial
    order = FOURTH
  [../]
[]

[Preconditioning]
  active = &#x27;SMP&#x27;
  [./SMP]
    type = SMP
    full = true
    off_diag_row    = &#x27;u n n v&#x27;
    off_diag_column = &#x27;n u v u&#x27;
  [../]
  [./FDP]
    type = FDP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 101&#x27;
  # petsc_options_iname = -pc_type
  # petsc_options_value = lu
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm         101   preonly   lu      5&#x27;

  l_max_its = 100
  l_tol = 1e-04
  nl_rel_tol = 1e-09
  nl_abs_tol = 1e-11

  num_steps = 2
  dt = 0.1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="231a5093-1cf1-47ea-9d8e-4660025fbb23"><div class="modal-content"><h4>modules/heat_conduction/test/tests/sideset_heat_transfer/gap_thermal_ktemp_1D.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [mesh]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 2
    xmax = 2
  []
  [split]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    block_id = 1
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 0 0&#x27;
  []
  [interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = split
    primary_block = 1
    paired_block = 0
    new_boundary = &#x27;interface0&#x27;
  []
  uniform_refine = 4
[]

[Variables]
  [T]
    order = FIRST
    family = MONOMIAL
  []
[]

[AuxVariables]
  [Tbulk]
    order = FIRST
    family = LAGRANGE
    initial_condition = 300 # K
  []
[]

[Kernels]
  [diff]
    type = MatDiffusion
    variable = T
    diffusivity = conductivity
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[DGKernels]
  [dg_diff]
    type = DGDiffusion
    variable = T
    epsilon = -1
    sigma = 6
    diff = conductivity
    exclude_boundary = &#x27;interface0&#x27;
  []
[]

[InterfaceKernels]
  [gap_var]
    type = SideSetHeatTransferKernel
    variable = T
    neighbor_var = T
    boundary = &#x27;interface0&#x27;
    Tbulk_var = Tbulk
  []
[]

[Functions]
  # Defining temperature dependent fucntion for conductivity across side set
  [kgap]
    type = ParsedFunction
    value = &#x27;t / 200&#x27;
  []
  [bc_func]
    type = ConstantFunction
    value = 300
  []
  [exact]
    type = ParsedFunction
    value = &#x27;
            A := if(x &lt; 1, -0.5, -0.25);
            B := if(x &lt; 1, -0.293209850655001, 0.0545267662299068);
            C := if(x &lt; 1, 300.206790149345, 300.19547323377);
            d := -1;
            A * (x+d) * (x+d) + B * (x+d) + C&#x27;
  []
[]

[BCs]
  [bc_left]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;left&#x27;
    variable = T
    diff = &#x27;conductivity&#x27;
    epsilon = -1
    sigma = 6
    function = bc_func
  []
  [bc_right]
    type = DGFunctionDiffusionDirichletBC
    boundary = &#x27;right&#x27;
    variable = T
    diff = &#x27;conductivity&#x27;
    epsilon = -1
    sigma = 6
    function = bc_func
  []
[]

[Materials]
  [k0]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 1.0
    block = 0
  []
  [k1]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 2.0
    block = 1
  []
  [gap_mat]
    type = SideSetHeatTransferMaterial
    boundary = &#x27;interface0&#x27;
    # Using temperature dependent function for gap conductivity
    conductivity_temperature_function = kgap
    # Variable to evaluate conductivity with
    gap_temperature = Tbulk
    gap_length = 1.0
    h_primary = 1
    h_neighbor = 1
    emissivity_primary = 1
    emissivity_neighbor = 1
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    variable = T
    function = exact
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2ebff155-5724-43c6-86f7-5e6658bb2f7f"><div class="modal-content"><h4>modules/phase_field/test/tests/mobility_derivative/AC_mobility_derivative_coupled_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 20
  ny = 10
  xmax = 50
  ymin = 25
  ymax = 50
[]

[Variables]
  [./op]
  [../]
  [./v]
  [../]
[]

[ICs]
  [./op_IC]
    type = SmoothCircleIC
    x1 = 25.0
    y1 = 25.0
    radius = 15.0
    invalue = 0.9
    outvalue = 0.1
    int_width = 3.0
    variable = op
  [../]
  [./v_IC]
    type = BoundingBoxIC
    x1 = 0.0
    x2 = 25.0
    y1 = 0.0
    y2 = 50.0
    inside = 1.0
    outside = 0.0
    variable = v
  [../]
[]

[Kernels]
  [./op_dot]
    type = TimeDerivative
    variable = op
  [../]
  [./op_bulk]
    type = AllenCahn
    variable = op
    f_name = F
    mob_name = L
    args = v
  [../]
  [./op_interface]
    type = ACInterface
    variable = op
    kappa_name = 1
    mob_name = L
    args = v
  [../]
  [./v_dot]
    type = TimeDerivative
    variable = v
  [../]
  [./v_diff]
    type = MatDiffusion
    variable = v
    diffusivity = 50.0
  [../]
[]

[Materials]
  [./consts]
    type = DerivativeParsedMaterial
    f_name  = L
    function = &#x27;l:=0.1+1*(v+op)^2; if(l&lt;0.01, 0.01, l)&#x27;
    args = &#x27;op v&#x27;
    outputs = exodus
    output_properties = &#x27;L dL/dop dL/dv&#x27;
    derivative_order = 2
  [../]
  [./free_energy]
    type = DerivativeParsedMaterial
    f_name = F
    args = &#x27;op&#x27;
    function = &#x27;2*op^2*(1-op)^2 - 0.2*op&#x27;
    derivative_order = 2
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;

  l_max_its = 15
  l_tol = 1.0e-4

  nl_max_its = 15
  nl_rel_tol = 1.0e-9

  start_time = 0.0
  num_steps = 10
  dt = 0.2
[]

[Outputs]
  interval = 5
  print_linear_residuals = false
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="90b09653-9d95-4e2a-ac98-9af5cd4b3f60"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/1D_rz_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                   quasi-1D
# Coordinate System:                                      rz
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   A simple transient heat transfer problem in cylindrical coordinates designed
#   with the Method of Manufactured Solutions. This problem was developed to
#   verify XFEM performance in the presence of a moving interface for linear
#   element models that can be exactly evaluated by FEM/Moose. Both the
#   temperature solution and level set function are designed to be linear to
#   attempt to minimize error between the Moose/exact solution and XFEM results.
#   Thermal conductivity is dependent upon the value of the level set function
#   at each timestep.
# Results:
#   The temperature at the left boundary (x=1) exhibits the largest difference
#   between the FEM/Moose solution and XFEM results. We present the XFEM
#   results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         480.0008131
#      0.6                  520         520.0038333
#      0.8                  560         560.0088286
#      1.0                  600         600.0131612
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 1
  xmin = 1.0
  xmax = 2.0
  ymin = 0.0
  ymax = 0.5
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-200*x+400) + (1/x)*(310*t - (10/1.02)*x*t - (1/1.02)*t^2)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.05/2.04)*(2.04-x-0.2*t) + 1.5)*200*t&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.05/2.04)*(2.04-x-0.2*t) + 1.5&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;2.04 - x -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_u]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 400
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="221dc37f-6b16-43d4-8106-0281276574ea"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/poly_chaos/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = D
  []
  [absorption]
    type = MaterialReaction
    variable = u
    coefficient = sig
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
  []
[]

[Materials]
  [diffusivity]
    type = GenericConstantMaterial
    prop_names = D
    prop_values = 2.0
  []
  [xs]
    type = GenericConstantMaterial
    prop_names = sig
    prop_values = 2.0
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Postprocessors]
  [avg]
    type = AverageNodalVariableValue
    variable = u
  []
  [max]
    type = NodalExtremeValue
    variable = u
    value_type = max
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0ca40c3c-d59f-49bc-9b88-de2eb1b6ca9b"><div class="modal-content"><h4>modules/phase_field/test/tests/MultiSmoothCircleIC/multismoothcircleIC_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 15
  ny = 15
  nz = 15
  xmin = 0
  xmax = 100
  ymin = 0
  ymax = 100
  zmin = 0
  zmax = 100
  elem_type = HEX8
[]

[Variables]
  [./c]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./c]
    type = MultiSmoothCircleIC
    variable = c
    invalue = 1.0
    outvalue = 0.0001
    bubspac = 30.0 # This spacing is from bubble center to bubble center
    numbub = 6
    radius = 10.0
    int_width = 12.0
    radius_variation = 0.2
    radius_variation_type = uniform
  [../]
[]

[Kernels]
  [./ie_c]
    type = TimeDerivative
    variable = c
  [../]
  [./diff]
    type = MatDiffusion
    variable = c
    diffusivity = D_v
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y z&#x27;
    [../]
  [../]
[]

[Materials]
  [./Dv]
    type = GenericConstantMaterial
    prop_names = D_v
    prop_values = 0.074802
  [../]
[]

[Postprocessors]
  [./bubbles]
    type = FeatureFloodCount
    variable = c
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -mat_mffd_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg 101 ds&#x27;
  l_max_its = 20
  l_tol = 1e-4
  nl_max_its = 20
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-11
  start_time = 0.0
  num_steps = 1
  dt = 100.0
  [./Adaptivity]
    refine_fraction = .5
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="97a970c2-b9e7-4b63-9ab1-7cd81f8d2859"><div class="modal-content"><h4>modules/combined/test/tests/exception/nonad.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  patch_update_strategy = iteration
  [./gen]
    type = FileMeshGenerator
    file = mesh.e
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./temp]
    initial_condition = 501
  [../]
[]

[AuxVariables]
  [./density_aux]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Modules/TensorMechanics/Master]
  [./finite]
    strain = FINITE
  [../]
[]

[Kernels]
  [./gravity]
    type = Gravity
    variable = disp_y
    value = -9.81
  [../]
  [./heat]
    type = MatDiffusion
    variable = temp
    diffusivity = 1
  [../]
  [./heat_ie]
    type = TimeDerivative
    variable = temp
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = density
    variable = density_aux
    boundary = inner_surface
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = outer_interior
    secondary = inner_surface
    emissivity_primary = 0
    emissivity_secondary = 0
    quadrature = true
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;centerline&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;centerline outer_exterior&#x27;
    value = 0.0
  [../]
  [./temp]
    type = FunctionDirichletBC
    boundary = outer_exterior
    variable = temp
    function = &#x27;500 + t&#x27;
  [../]
[]

[Materials]
  [./density]
    type = GenericConstantMaterial
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1&#x27;
  [../]

  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e11
    poissons_ratio = 0.3
  [../]

  [./inner_elastic_stress]
    type = ComputeMultipleInelasticStress
    inelastic_models = &#x27;inner_creep&#x27;
    block = inner
    outputs = all
  [../]

  [./inner_creep]
    type = PowerLawCreepExceptionTest
    coefficient = 10e-22
    n_exponent = 2
    activation_energy = 0
    block = inner
  [../]

  [./outer_stressstress]
    type = ComputeFiniteStrainElasticStress
    block = outer
  [../]
[]

[Executioner]
  type = Transient
  petsc_options = &#x27; -snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  line_search = none

  nl_abs_tol = 1e-7
  l_max_its = 20

  num_steps = 1
  dt = 1
  dtmin = .1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cab53072-8e76-48ee-a1c4-4b2a15f9102d"><div class="modal-content"><h4>modules/stochastic_tools/examples/surrogates/pod_rb/2d_multireg/sub.i</h4><pre class="moose-pre"><code class="language-text">halfa = 10
fulla = 20

[Problem]
  type = FEProblem
  extra_tag_vectors  = &#x27;diff0 diff1 diff2 diff3 abs0 abs1 abs2 abs3 src0 src1 src2&#x27;
[]

[Mesh]
  [msh]
    type = CartesianMeshGenerator
    dim = 2
    dx = &#x27;10 20 20 20 20 20 20 20 20&#x27;
    dy = &#x27;10 20 20 20 20 20 20 20 20&#x27;
    ix = &#x27;${halfa} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla}&#x27;
    iy = &#x27;${halfa} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla} ${fulla}&#x27;
    subdomain_id = &#x27;1 0 0 0 1 0 0 2 3
                    0 0 0 0 0 0 0 2 3
                    0 0 1 0 0 0 2 2 3
                    0 0 0 0 0 0 2 3 3
                    1 0 0 0 1 2 2 3 3
                    0 0 0 0 2 2 3 3 3
                    0 0 2 2 2 3 3 3 3
                    2 2 2 3 3 3 3 3 3
                    3 3 3 3 3 3 3 3 3&#x27;
  []
[]

[Variables]
  [psi]
  []
[]

[Kernels]
  [diff0]
    type = MatDiffusion
    variable = psi
    diffusivity = D0
    extra_vector_tags = &#x27;diff0&#x27;
    block = 0
  []
  [diff1]
    type = MatDiffusion
    variable = psi
    diffusivity = D1
    extra_vector_tags = &#x27;diff1&#x27;
    block = 1
  []
  [diff2]
    type = MatDiffusion
    variable = psi
    diffusivity = D2
    extra_vector_tags = &#x27;diff2&#x27;
    block = 2
  []
  [diff3]
    type = MatDiffusion
    variable = psi
    diffusivity = D3
    extra_vector_tags = &#x27;diff3&#x27;
    block = 3
  []
  [abs0]
    type = MaterialReaction
    variable = psi
    coefficient = absxs0
    extra_vector_tags = &#x27;abs0&#x27;
    block = 0
  []
  [abs1]
    type = MaterialReaction
    variable = psi
    coefficient = absxs1
    extra_vector_tags = &#x27;abs1&#x27;
    block = 1
  []
  [abs2]
    type = MaterialReaction
    variable = psi
    coefficient = absxs2
    extra_vector_tags = &#x27;abs2&#x27;
    block = 2
  []
  [abs3]
    type = MaterialReaction
    variable = psi
    coefficient = absxs3
    extra_vector_tags = &#x27;abs3&#x27;
    block = 3
  []
  [src0]
    type = BodyForce
    variable = psi
    value = 1
    extra_vector_tags = &#x27;src0&#x27;
    block = 0
  []
  [src1]
    type = BodyForce
    variable = psi
    value = 1
    extra_vector_tags = &#x27;src1&#x27;
    block = 1
  []
  [src2]
    type = BodyForce
    variable = psi
    value = 1
    extra_vector_tags = &#x27;src2&#x27;
    block = 2
  []
[]

[Materials]
  [D0]
    type = GenericConstantMaterial
    prop_names = D0
    prop_values = 1
    block = 0
  []
  [D1]
    type = GenericConstantMaterial
    prop_names = D1
    prop_values = 1
    block = 1
  []
  [D2]
    type = GenericConstantMaterial
    prop_names = D2
    prop_values = 1
    block = 2
  []
  [D3]
    type = GenericConstantMaterial
    prop_names = D3
    prop_values = 1
    block = 3
  []
  [absxs0]
    type = GenericConstantMaterial
    prop_names = absxs0
    prop_values = 1
    block = 0
  []
  [absxs1]
    type = GenericConstantMaterial
    prop_names = absxs1
    prop_values = 1
    block = 1
  []
  [absxs2]
    type = GenericConstantMaterial
    prop_names = absxs2
    prop_values = 1
    block = 2
  []
  [absxs3]
    type = GenericConstantMaterial
    prop_names = absxs3
    prop_values = 1
    block = 3
  []
[]

[BCs]
  [left]
    type = NeumannBC
    variable = psi
    boundary = left
    value = 0
  []
  [bottom]
    type = NeumannBC
    variable = psi
    boundary = bottom
    value = 0
  []
  [top]
    type = DirichletBC
    variable = psi
    boundary = top
    value = 0
  []
  [right]
    type = DirichletBC
    variable = psi
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = linear
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Postprocessors]
  [nodal_l2]
    type = NodalL2Norm
    variable = psi
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a3f62a42-604f-4740-affa-04dc1e88b8e3"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictionless-mortar-fb-lm-mortar-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
  [../]
  [./normal_lm]
    block = 3
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [normal_lm]
    type = NormalMortarLMMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    secondary_disp_y = disp_y
    use_displaced_mesh = true
    compute_primal_residuals = false
    ncp_function_type = &#x27;fb&#x27;
  []
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active = &#x27;num_nl cumulative contact&#x27;
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="82585d22-6412-4a28-afd5-05fd5c80a468"><div class="modal-content"><h4>test/tests/kernels/2d_diffusion/matdiffusion.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmax = 1.0
  ymax = 1.0
  elem_type = QUAD4
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./cres]
    type = MatDiffusion
    variable = u
    diffusivity = Du
  [../]
  [./ctime]
    type = TimeDerivative
    variable = u
  [../]
[]

[Materials]
  [./Dc]
    type = DerivativeParsedMaterial
    f_name = Du
    function = &#x27;0.01+u^2&#x27;
    args = &#x27;u&#x27;
    derivative_order = 1
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]

  [./right]
    type = NeumannBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  scheme = &#x27;BDF2&#x27;
  dt = 1
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="85d089f7-a097-48bb-ac31-3c0721c787c3"><div class="modal-content"><h4>modules/stochastic_tools/examples/surrogates/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 1
  elem_type = EDGE3
[]

[Variables]
  [T]
    order = SECOND
    family = LAGRANGE
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = T
    diffusivity = k
  []
  [source]
    type = BodyForce
    variable = T
    value = 1.0
  []
[]

[Materials]
  [conductivity]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 2.0
  []
[]

[BCs]
  [right]
    type = DirichletBC
    variable = T
    boundary = right
    value = 300
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Postprocessors]
  [avg]
    type = AverageNodalVariableValue
    variable = T
  []
  [max]
    type = NodalExtremeValue
    variable = T
    value_type = max
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="466b8f46-5aa1-430b-806d-0f1f6e6d4fa9"><div class="modal-content"><h4>modules/heat_conduction/test/tests/sideset_heat_transfer/cfem_gap.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # Build 2-by-2 mesh
  [mesh]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []

  # Create blocs 0, 1, 2, 3
  [block_1]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    block_id = 1
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 1 0&#x27;
  []
  [block_2]
    type = SubdomainBoundingBoxGenerator
    input = block_1
    block_id = 2
    bottom_left = &#x27;0 1 0&#x27;
    top_right = &#x27;1 2 0&#x27;
  []
  [block_3]
    type = SubdomainBoundingBoxGenerator
    input = block_2
    block_id = 3
    bottom_left = &#x27;1 1 0&#x27;
    top_right = &#x27;2 2 0&#x27;
  []

  # Create inner sidesets
  [interface_01]
    type = SideSetsBetweenSubdomainsGenerator
    input = block_3
    primary_block = 0
    paired_block = 1
    new_boundary = &#x27;interface_01&#x27;
  []
  [interface_13]
    type = SideSetsBetweenSubdomainsGenerator
    input = interface_01
    primary_block = 1
    paired_block = 3
    new_boundary = &#x27;interface_13&#x27;
  []
  [interface_32]
    type = SideSetsBetweenSubdomainsGenerator
    input = interface_13
    primary_block = 3
    paired_block = 2
    new_boundary = &#x27;interface_32&#x27;
  []
  [interface_20]
    type = SideSetsBetweenSubdomainsGenerator
    input = interface_32
    primary_block = 2
    paired_block = 0
    new_boundary = &#x27;interface_20&#x27;
  []

  # Create outer boundaries
  [boundary_left_0]
    type = SideSetsAroundSubdomainGenerator
    input = interface_20
    block = 0
    normal = &#x27;-1 0 0&#x27;
    new_boundary = &#x27;left_0&#x27;
  []
  [boundary_bot_0]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_left_0
    block = 0
    normal = &#x27;0 -1 0&#x27;
    new_boundary = &#x27;bot_0&#x27;
  []
  [boundary_bot_1]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_bot_0
    block = 1
    normal = &#x27;0 -1 0&#x27;
    new_boundary = &#x27;bot_1&#x27;
  []
  [boundary_right_1]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_bot_1
    block = 1
    normal = &#x27;1 0 0&#x27;
    new_boundary = &#x27;right_1&#x27;
  []
  [boundary_right_3]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_right_1
    block = 3
    normal = &#x27;1 0 0&#x27;
    new_boundary = &#x27;right_3&#x27;
  []
  [boundary_top_3]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_right_3
    block = 3
    normal = &#x27;0 1 0&#x27;
    new_boundary = &#x27;top_3&#x27;
  []
  [boundary_top_2]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_top_3
    block = 2
    normal = &#x27;0 1 0&#x27;
    new_boundary = &#x27;top_2&#x27;
  []
  [boundary_left_2]
    type = SideSetsAroundSubdomainGenerator
    input = boundary_top_2
    block = 2
    normal = &#x27;-1 0 0&#x27;
    new_boundary = &#x27;left_2&#x27;
  []
  uniform_refine = 4
[]

[Variables]
  # Need to have variable for each block to allow discontinuity
  [T0]
    block = 0
  []
  [T1]
    block = 1
  []
  [T2]
    block = 2
  []
  [T3]
    block = 3
  []
[]

[Kernels]
  # Diffusion kernel for each block&#x27;s variable
  [diff_0]
    type = MatDiffusion
    variable = T0
    diffusivity = conductivity
    block = 0
  []
  [diff_1]
    type = MatDiffusion
    variable = T1
    diffusivity = conductivity
    block = 1
  []
  [diff_2]
    type = MatDiffusion
    variable = T2
    diffusivity = conductivity
    block = 2
  []
  [diff_3]
    type = MatDiffusion
    variable = T3
    diffusivity = conductivity
    block = 3
  []

  # Source for two of the blocks
  [source_0]
    type = BodyForce
    variable = T0
    value = 5e5
    block = &#x27;0&#x27;
  []
  [source_3]
    type = BodyForce
    variable = T3
    value = 5e5
    block = &#x27;3&#x27;
  []
[]

[InterfaceKernels]
  # Side set kernel to represent heat transfer across blocks
  # Automatically uses the materials defined in SideSetHeatTransferMaterial
  [gap_01]
    type = SideSetHeatTransferKernel
    # This variable defined on a given block must match the primary_block given when the side set was generated
    variable = T0
    # This variable defined on a given block must match the paired_block given when the side set was generated
    neighbor_var = T1
    boundary = &#x27;interface_01&#x27;
  []
  [gap_13]
    type = SideSetHeatTransferKernel
    variable = T1
    neighbor_var = T3
    boundary = &#x27;interface_13&#x27;
  []
  [gap_32]
    type = SideSetHeatTransferKernel
    variable = T3
    neighbor_var = T2
    boundary = &#x27;interface_32&#x27;
  []
  [gap_20]
    type = SideSetHeatTransferKernel
    variable = T2
    neighbor_var = T0
    boundary = &#x27;interface_20&#x27;
  []
[]

# Creating auxiliary variable to combine block restricted solutions
# Ignores discontinuity though
[AuxVariables]
  [T]
  []
[]

[AuxKernels]
  [temp_0]
    type = NormalizationAux
    variable = T
    source_variable = T0
    block = 0
  []
  [temp_1]
    type = NormalizationAux
    variable = T
    source_variable = T1
    block = 1
  []
  [temp_2]
    type = NormalizationAux
    variable = T
    source_variable = T2
    block = 2
  []
  [temp_3]
    type = NormalizationAux
    variable = T
    source_variable = T3
    block = 3
  []
[]

[BCs]
  # Boundary condition for each block&#x27;s outer surface
  [bc_left_2]
    type = DirichletBC
    boundary = &#x27;left_2&#x27;
    variable = T2
    value = 300.0
  []
  [bc_left_0]
    type = DirichletBC
    boundary = &#x27;left_0&#x27;
    variable = T0
    value = 300.0
  []

  [bc_bot_0]
    type = DirichletBC
    boundary = &#x27;bot_0&#x27;
    variable = T0
    value = 300.0
  []
  [bc_bot_1]
    type = DirichletBC
    boundary = &#x27;bot_1&#x27;
    variable = T1
    value = 300.0
  []

  [./bc_top_2]
    type = ConvectiveFluxFunction # (Robin BC)
    variable = T2
    boundary = &#x27;top_2&#x27;
    coefficient = 1e3 # W/K/m^2
    T_infinity = 600.0
  [../]
  [./bc_top_3]
    type = ConvectiveFluxFunction # (Robin BC)
    variable = T3
    boundary = &#x27;top_3&#x27;
    coefficient = 1e3 # W/K/m^2
    T_infinity = 600.0
  [../]

  [./bc_right_3]
    type = ConvectiveFluxFunction # (Robin BC)
    variable = T3
    boundary = &#x27;right_3&#x27;
    coefficient = 1e3 # W/K/m^2
    T_infinity = 600.0
  [../]
  [./bc_right_1]
    type = ConvectiveFluxFunction # (Robin BC)
    variable = T1
    boundary = &#x27;right_1&#x27;
    coefficient = 1e3 # W/K/m^2
    T_infinity = 600.0
  [../]
[]

[Materials]
  [fuel]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 75
    block = &#x27;0 3&#x27;
  []
  [mod]
    type = GenericConstantMaterial
    prop_names = &#x27;conductivity&#x27;
    prop_values = 7.5
    block = &#x27;1 2&#x27;
  []
  # Interface material used for SideSetHeatTransferKernel
  # Heat transfer meachnisms ignored if certain properties are not supplied
  [gap_mat]
    type = SideSetHeatTransferMaterial
    boundary = &#x27;interface_01 interface_13 interface_32 interface_20&#x27;
    conductivity = 0.41
    gap_length = 0.002
    Tbulk = 750
    h_primary = 3000
    h_neighbor = 3000
    emissivity_primary = 0.85
    emissivity_neighbor = 0.85
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-12
  l_tol = 1e-8
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;lu       superlu_dist                  50&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="23e64bcb-bfb2-49df-9bcc-5a84a830fadf"><div class="modal-content"><h4>test/tests/materials/interface_material/interface_value_material_noIK.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
    elem_type = QUAD4
  []
  [./subdomain_id]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 2 0&#x27;
    block_id = 1
  [../]

  [./interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain_id
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;interface&#x27;
  [../]

[]

[Variables]
  [./u]
    block = 0
  [../]
  [./v]
    block = 1
  [../]
[]


[Kernels]
  [./diff]
    type = MatDiffusion
    variable = u
    diffusivity = &#x27;diffusivity&#x27;
    block = 0
  [../]

  [./diff_v]
    type = MatDiffusion
    variable = v
    diffusivity = &#x27;diffusivity&#x27;
    block = 1
  [../]
[]

[BCs]
  [u_left]
    type = DirichletBC
    boundary = &#x27;left&#x27;
    variable = u
    value = 1
  []
  [v_right]
    type = DirichletBC
    boundary = &#x27;right&#x27;
    variable = v
    value = 0
  []
[]

[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 1
    # outputs = all
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
    # outputs = all
  [../]
  [./interface_material_avg]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = average
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_primary_minus_secondary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_primary_minus_secondary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_secondary_minus_primary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_secondary_minus_primary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_jump_abs]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_abs
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_primary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = primary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
  [../]
  [./interface_material_secondary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      mat_prop_var_out_basename = diff_var
      boundary = interface
      interface_value_type = secondary
      nl_var_primary = u
      nl_var_secondary = v
  [../]
[]

[AuxKernels]
  [./interface_material_avg]
    type = MaterialRealAux
    property = diff_average
    variable = diffusivity_average
    boundary = interface
  []
  [./interface_material_jump_primary_minus_secondary]
    type = MaterialRealAux
    property = diff_jump_primary_minus_secondary
    variable = diffusivity_jump_primary_minus_secondary
    boundary = interface
  []
  [./interface_material_jump_secondary_minus_primary]
    type = MaterialRealAux
    property = diff_jump_secondary_minus_primary
    variable = diffusivity_jump_secondary_minus_primary
    boundary = interface
  []
  [./interface_material_jump_abs]
    type = MaterialRealAux
    property = diff_jump_abs
    variable = diffusivity_jump_abs
    boundary = interface
  []
  [./interface_material_primary]
    type = MaterialRealAux
    property = diff_primary
    variable = diffusivity_primary
    boundary = interface
  []
  [./interface_material_secondary]
    type = MaterialRealAux
    property = diff_secondary
    variable = diffusivity_secondary
    boundary = interface
  []
  [diffusivity_var]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_var
  []
[]

[AuxVariables]
  [diffusivity_var]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_average]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_primary_minus_secondary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_secondary_minus_primary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_abs]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_primary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_secondary]
    family = MONOMIAL
    order = CONSTANT
  []
[]


[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8845b5a3-eba7-4ad2-9873-4e766b1b5cab"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/pod_rb/internal/sub.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  type = FEProblem
  extra_tag_vectors  = &#x27;diff react bodyf&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 15
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = k
    extra_vector_tags = &#x27;diff&#x27;
  []
  [reaction]
    type = MaterialReaction
    variable = u
    coefficient = alpha
    extra_vector_tags = &#x27;react&#x27;
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
    extra_vector_tags = &#x27;bodyf&#x27;
  []
[]

[Materials]
  [k]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 1.0
  []
  [alpha]
    type = GenericConstantMaterial
    prop_names = alpha
    prop_values = 1.0
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="19426186-06d6-4ae1-a0d6-2e277e06526c"><div class="modal-content"><h4>modules/phase_field/test/tests/MultiSmoothCircleIC/multismoothcircleIC_normal_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 15
  ny = 15
  nz = 15
  xmin = 0
  xmax = 100
  ymin = 0
  ymax = 100
  zmin = 0
  zmax = 100
  elem_type = HEX8
[]

[Variables]
  [./c]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./c]
    type = MultiSmoothCircleIC
    variable = c
    invalue = 1.0
    outvalue = 0.0001
    bubspac = 30.0 # This spacing is from bubble center to bubble center
    numbub = 10
    radius = 10.0
    int_width = 12.0
    rand_seed = 2000
    radius_variation = 2 #This is the standard deviation
    radius_variation_type = normal
  [../]
[]

[Kernels]
  [./ie_c]
    type = TimeDerivative
    variable = c
  [../]
  [./diff]
    type = MatDiffusion
    variable = c
    diffusivity = D_v
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y z&#x27;
    [../]
  [../]
[]

[Materials]
  [./Dv]
    type = GenericConstantMaterial
    prop_names = D_v
    prop_values = 0.074802
  [../]
[]

[Postprocessors]
  [./bubbles]
    type = FeatureFloodCount
    variable = c
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -mat_mffd_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg 101 ds&#x27;
  l_max_its = 20
  l_tol = 1e-4
  nl_max_its = 20
  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-11
  start_time = 0.0
  num_steps = 1
  dt = 100.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6797f174-9510-4019-ac40-bf86cc2ccddf"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_rz_homog1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      rz
# Material Numbers/Types:   homogeneous 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in cylindrical coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with homogeneous material
#   properties. This problem can be exactly evaluated by FEM/Moose without the
#   moving interface. Both the temperature and level set function are designed
#   to be linear to attempt to minimize error between the Moose/exact solution
#   and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=1, y=1) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time    Expected Temperature    XFEM Calculated Temperature
#      0.2                  440         440
#      0.4                  480         479.9998745
#      0.6                  520         519.9995067
#      0.8                  560         559.9989409
#      1.0                  600         599.9987054
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 1.0
  xmax = 2.0
  ymin = 1.0
  ymax = 2.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+400) + 100*1.5*t/x&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;1.5*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+200)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+200)*t+400&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 2.04 - 0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = 1.5
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c30f9b78-a267-452e-986d-ae3da03efa37"><div class="modal-content"><h4>modules/phase_field/test/tests/SoretDiffusion/direct_temp.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 30
  xmax = 500
  elem_type = EDGE
[]

[GlobalParams]
  polynomial_order = 8
[]

[Variables]
  [./c]
    family = HERMITE
    order = THIRD
  [../]
  [./T]
    initial_condition = 1000.0
    scaling = 1.0e5
  [../]
[]

[ICs]
  [./c_IC]
    type = SmoothCircleIC
    x1 = 125.0
    y1 = 0.0
    radius = 60.0
    invalue = 1.0
    outvalue = 0.1
    int_width = 100.0
    variable = c
  [../]
[]

[Kernels]
  [./c_int]
    type = CHInterface
    variable = c
    kappa_name = kappa
    mob_name = M
  [../]
  [./c_bulk]
    type = CahnHilliard
    variable = c
    mob_name = M
    f_name = F
  [../]
  [./c_soret]
    type = SoretDiffusion
    variable = c
    T = T
    diff_name = D
    Q_name = Qstar
  [../]
  [./c_dot]
    type = TimeDerivative
    variable = c
  [../]
  [./HtCond]
    type = MatDiffusion
    variable = T
    diffusivity = thermal_conductivity
  [../]
[]

[BCs]
  [./Left_T]
    type = DirichletBC
    variable = T
    boundary = left
    value = 1000.0
  [../]

  [./Right_T]
    type = DirichletBC
    variable = T
    boundary = right
    value = 1015.0
  [../]
[]

[Materials]
  [./Copper]
    type = PFParamsPolyFreeEnergy
    c = c
    T = T # K
    int_width = 60.0
    length_scale = 1.0e-9
    time_scale = 1.0e-9
    D0 = 3.1e-5 # m^2/s, from Brown1980
    Em = 0.71 # in eV, from Balluffi1978 Table 2
    Ef = 1.28 # in eV, from Balluffi1978 Table 2
    surface_energy = 0.708 # Total guess
  [../]
  [./thcond]
    type = ParsedMaterial
    args = &#x27;c&#x27;
    function = &#x27;if(c&gt;0.7,1e-8,4e-8)&#x27;
    f_name = thermal_conductivity
    outputs = exodus
  [../]
  [./free_energy]
    type = PolynomialFreeEnergy
    c = c
    derivative_order = 3
  [../]
[]

[Preconditioning]
  [./SMP]
   type = SMP
   full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;
  solve_type = &#x27;PJFNK&#x27;

  l_max_its = 30
  l_tol = 1.0e-4
  nl_max_its = 25
  nl_rel_tol = 1.0e-9

  num_steps = 60
  dt = 8.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a78911ae-33b6-4fbb-997d-f126cefa9c5a"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-fb-lm-mortar-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
  [../]
  [./normal_lm]
    block = 3
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [./lm]
    type = NormalNodalLMMechanicalContact
    secondary = 10
    primary = 20
    variable = normal_lm
    primary_variable = disp_x
    disp_y = disp_y
    ncp_function_type = &#x27;fb&#x27;
  [../]
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active = &#x27;num_nl cumulative contact&#x27;
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="962fb1b5-e5f7-45ca-8505-f65eee384bfb"><div class="modal-content"><h4>modules/phase_field/test/tests/phase_field_crystal/PFCTrad/pfct_newton_split1_asm5.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 50
  ny = 50
  xmax = 8
  ymax = 8
[]

[Variables]
  [./n]
    [./InitialCondition]
      type = RandomIC
      min = -1
      max = 4
    [../]
  [../]
  [./u]
    scaling = 1e2
  [../]
  [./v]
    scaling = 1e1
  [../]
[]

[Kernels]
  [./ndot]
    type = TimeDerivative
    variable = n
  [../]
  [./n_bulk]
    type = CHBulkPFCTrad
    variable = n
  [../]
  [./u_term]
    type = MatDiffusion
    variable = n
    v = u
    diffusivity = C2
  [../]
  [./v_term]
    type = MatDiffusion
    variable = n
    v = v
    diffusivity = C4
  [../]
  [./u_rctn]
    type = Reaction
    variable = u
  [../]
  [./u_gradn]
    type = LaplacianSplit
    variable = u
    c = n
  [../]
  [./v_rctn]
    type = Reaction
    variable = v
  [../]
  [./v_gradu]
    type = LaplacianSplit
    variable = v
    c = u
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[Materials]
  [./PFCTrad]
    type = PFCTradMaterial
    order = 4
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 100
  l_tol = 1e-04
  nl_rel_tol = 1e-09
  nl_abs_tol = 1e-11

  splitting = &#x27;nuv&#x27;
  petsc_options = &#x27;-snes_view&#x27;

  num_steps = 2
  dt = 0.1
[]

[Splits]
  [./nuv]
    splitting       = &#x27;v nu&#x27;
    splitting_type  = schur
    schur_type      = full
    schur_pre       = Sp
    #petsc_options = &#x27;-dm_view&#x27;
  [../]
  [./nu]
    vars = &#x27;n u&#x27;
    petsc_options = &#x27;-ksp_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_asm_overlap  -sub_pc_type&#x27;
    petsc_options_value =  &#x27;              101      asm               5            lu&#x27;
  [../]
  [./v]
    vars = &#x27;v&#x27;
    #petsc_options = &#x27;-ksp_monitor&#x27;
    petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap&#x27;
    petsc_options_value =  &#x27;asm         101   preonly   lu      0&#x27;
    #full = true
  [../]
[]

[Outputs]
  execute_on = &#x27;initial timestep_end linear&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aec82183-ff43-46bc-ba8d-d608d77ee60d"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_rz_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      rz
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in cylindrical coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with thermal conductivity
#   dependent upon the transient level set function. This problem can be
#   exactly evaluated by FEM/Moose without the moving interface. Both the
#   temperature and level set function are designed to be linear to attempt to
#   minimize the error between the Moose/exact solution and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=1, y=1) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time   Expected Temperature   XFEM Calculated Temperature
#      0.2                 440        440
#      0.4                 480        479.9998717
#      0.6                 520        519.9994963
#      0.8                 560        559.9989217
#      1.0                 600        599.9986735
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 1.0
  xmax = 2.0
  ymin = 1.0
  ymax = 2.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
    [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraint]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+400) + t*(-2.5*y/(2.04*x) + 155/x - t/(2.04*x)
            - 7.5/2.04)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.01/2.04)*(-2.5*x-2.5*y-t)+1.55)*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+200)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+200)*t+400&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.01/2.04)*(-2.5*x-2.5*y-t) + 1.55&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 2.04 -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7ab5dc87-6959-4fa1-95b0-4c700fd0bd43"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/pod_rb/boundary/sub.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  type = FEProblem
  extra_tag_vectors  = &#x27;diff react bodyf dir_src dir_imp&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 15
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = k
    extra_vector_tags = &#x27;diff&#x27;
  []
  [reaction]
    type = MaterialReaction
    variable = u
    coefficient = alpha
    extra_vector_tags = &#x27;react&#x27;
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
    extra_vector_tags = &#x27;bodyf&#x27;
  []
[]

[Materials]
  [k]
    type = GenericConstantMaterial
    prop_names = k
    prop_values = 1.0
  []
  [alpha]
    type = GenericConstantMaterial
    prop_names = alpha
    prop_values = 1.0
  []
[]

[BCs]
  [dummy_1]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
    extra_vector_tags = &#x27;dir_imp&#x27;
  []
  [dummy_2]
    type = DirichletBCModifier
    variable = u
    boundary = left
    value = 1
    extra_vector_tags = &#x27;dir_src&#x27;
  []
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 1
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f2313211-7081-45ec-8a77-9661d0d80d53"><div class="modal-content"><h4>modules/phase_field/examples/anisotropic_interfaces/GrandPotentialSolidification.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 28
  ny = 28
  xmin = -7
  xmax = 7
  ymin = -7
  ymax = 7
  uniform_refine = 2
[]

[GlobalParams]
  radius = 0.2
  int_width = 0.1
  x1 = 0.0
  y1 = 0.0
  derivative_order = 2
[]

[Variables]
  [./w]
  [../]
  [./etaa0]
  [../]
  [./etab0]
  [../]
  [./T]
  [../]
[]

[AuxVariables]
  [./bnds]
  [../]
[]

[AuxKernels]
  [./bnds]
    type = BndsCalcAux
    variable = bnds
    v = &#x27;etaa0 etab0&#x27;
  [../]
[]

[ICs]
  [./w]
    type = SmoothCircleIC
    variable = w
    # note w = A*(c-cleq), A = 1.0, cleq = 0.0 ,i.e., w = c (in the matrix/liquid phase)
    outvalue = -4.0
    invalue = 0.0
  [../]
  [./etaa0]
    type = SmoothCircleIC
    variable = etaa0
    #Solid phase
    outvalue = 0.0
    invalue = 1.0
  [../]
  [./etab0]
    type = SmoothCircleIC
    variable = etab0
    #Liquid phase
    outvalue = 1.0
    invalue = 0.0
  [../]
[]

[Kernels]
# Order parameter eta_alpha0
  [./ACa0_bulk]
    type = ACGrGrMulti
    variable = etaa0
    v =           &#x27;etab0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACa0_sw]
    type = ACSwitching
    variable = etaa0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etab0 w T&#x27;
  [../]
  [./ACa0_int1]
    type = ACInterface2DMultiPhase1
    variable = etaa0
    etas = &#x27;etab0&#x27;
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
  [../]
  [./ACa0_int2]
    type = ACInterface2DMultiPhase2
    variable = etaa0
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
  [../]
  [./ea0_dot]
    type = TimeDerivative
    variable = etaa0
  [../]
# Order parameter eta_beta0
  [./ACb0_bulk]
    type = ACGrGrMulti
    variable = etab0
    v =           &#x27;etaa0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACb0_sw]
    type = ACSwitching
    variable = etab0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etaa0 w T&#x27;
  [../]
  [./ACb0_int1]
    type = ACInterface2DMultiPhase1
    variable = etab0
    etas = &#x27;etaa0&#x27;
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
  [../]
  [./ACb0_int2]
    type = ACInterface2DMultiPhase2
    variable = etab0
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
  [../]
  [./eb0_dot]
    type = TimeDerivative
    variable = etab0
  [../]
#Chemical potential
  [./w_dot]
    type = SusceptibilityTimeDerivative
    variable = w
    f_name = chi
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = w
    diffusivity = Dchi
  [../]
  [./coupled_etaa0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etaa0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
  [./coupled_etab0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etab0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
  [./T_dot]
    type = TimeDerivative
    variable = T
  [../]
  [./CoefDiffusion]
    type = Diffusion
    variable = T
  [../]
  [./etaa0_dot_T]
    type = CoefCoupledTimeDerivative
    variable = T
    v = etaa0
    coef = -5.0
  [../]
[]

[Materials]
  [./ha]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = ha
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etaa0&#x27;
  [../]
  [./hb]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = hb
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etab0&#x27;
  [../]
  [./omegaa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegaa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/ka-w/Vm*caeq&#x27;
  [../]
  [./omegab]
    type = DerivativeParsedMaterial
    args = &#x27;w T&#x27;
    f_name = omegab
    material_property_names = &#x27;Vm kb cbeq S Tm&#x27;
    function = &#x27;-0.5*w^2/Vm^2/kb-w/Vm*cbeq-S*(T-Tm)&#x27;
  [../]
  [./rhoa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhoa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;w/Vm^2/ka + caeq/Vm&#x27;
  [../]
  [./rhob]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhob
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;w/Vm^2/kb + cbeq/Vm&#x27;
  [../]
  [./kappaa]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
    etaa = etaa0
    etab = etab0
    anisotropy_strength = 0.05
    kappa_bar = 0.05
    outputs = exodus
    output_properties = &#x27;kappaa&#x27;
  [../]
  [./kappab]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
    etaa = etab0
    etab = etaa0
    anisotropy_strength = 0.05
    kappa_bar = 0.05
    outputs = exodus
    output_properties = &#x27;kappab&#x27;
  [../]
  [./const]
    type = GenericConstantMaterial
    prop_names =  &#x27;L     D    chi  Vm   ka    caeq kb    cbeq  gab mu   S   Tm&#x27;
    prop_values = &#x27;33.33 1.0  0.1  1.0  10.0  0.1  10.0  0.9   4.5 10.0 1.0 5.0&#x27;
  [../]
  [./Mobility]
    type = ParsedMaterial
    f_name = Dchi
    material_property_names = &#x27;D chi&#x27;
    function = &#x27;D*chi&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      31&#x27;
   l_tol = 1.0e-3
  l_max_its = 30
  nl_max_its = 15
  nl_rel_tol = 1.0e-8
  nl_abs_tol = 1e-10
  end_time = 2.0
  dtmax = 0.05
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.0005
    cutback_factor = 0.7
    growth_factor = 1.2
  [../]
[]

[Adaptivity]
 initial_steps = 5
 max_h_level = 3
 initial_marker = err_eta
 marker = err_bnds
[./Markers]
   [./err_eta]
     type = ErrorFractionMarker
     coarsen = 0.3
     refine = 0.95
     indicator = ind_eta
   [../]
   [./err_bnds]
     type = ErrorFractionMarker
     coarsen = 0.3
     refine = 0.95
     indicator = ind_bnds
   [../]
 [../]
 [./Indicators]
   [./ind_eta]
     type = GradientJumpIndicator
     variable = etaa0
    [../]
    [./ind_bnds]
      type = GradientJumpIndicator
      variable = bnds
   [../]
 [../]
[]

[Outputs]
  interval = 5
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2aae5d5a-bc28-4dae-b539-37e91364772e"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-reduced-active-set.i</h4><pre class="moose-pre"><code class="language-text">starting_point = .5

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1
[]

[Mesh]
  file = square-blocks-no-offset.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${starting_point}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [./disp_x]
    type = RANFSNormalMechanicalContact
    secondary = 10
    primary = 20
    variable = disp_x
    primary_variable = disp_x
    component = x
  [../]
  [./disp_y]
    type = RANFSNormalMechanicalContact
    secondary = 10
    primary = 20
    variable = disp_y
    primary_variable = disp_y
    component = y
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 40
    value = 0.0
  [../]
  [./topx]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 30
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 30
    function = &#x27;${starting_point} - t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 1
  dt = 1
  dtmin = 1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -ksp_monitor_true_residual -snes_view&#x27;
  petsc_options_iname = &#x27;-mat_mffd_err -pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;1e-5          hypre    boomeramg&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;project&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  [exo]
    type = Exodus
    execute_on = &#x27;nonlinear&#x27;
  []
  print_linear_residuals = false
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2274a20e-275c-462a-bac4-41b92f33409c"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/verification/2D_xy_lsdep1mat.i</h4><pre class="moose-pre"><code class="language-text"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# XFEM Moving Interface Verification Problem
# Dimensionality:                                         2D
# Coordinate System:                                      xy
# Material Numbers/Types: level set dep 1 material, 2 region
# Element Order:                                         1st
# Interface Characteristics: u independent, prescribed level set function
# Description:
#   Transient 2D heat transfer problem in Cartesian coordinates designed with
#   the Method of Manufactured Solutions. This problem was developed to verify
#   XFEM performance on linear elements in the presence of a moving interface
#   sweeping across the x-y coordinates of a system with thermal conductivity
#   dependent upon the transient level set function. This problem can be
#   exactly evaluated by FEM/Moose without the moving interface. Both the
#   temperature and level set function are designed to be linear to attempt to
#   minimize the error between the Moose/exact solution and XFEM results.
# Results:
#   The temperature at the bottom left boundary (x=0, y=0) exhibits the largest
#   difference between the FEM/Moose solution and XFEM results. We present the
#   XFEM results at this location with 10 digits of precision:
#     Time   Expected Temperature   XFEM Calculated Temperature
#      0.2                 440        440
#      0.4                 480        479.9998738
#      0.6                 520        519.9995114
#      0.8                 560        559.9989360
#      1.0                 600        599.9983833
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 4
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  elem_type = QUAD4
[]

[XFEM]
  qrule = moment_fitting
  output_cut_plane = true
[]

[UserObjects]
  [./level_set_cut_uo]
    type = LevelSetCutUserObject
    level_set_var = ls
    heal_always = true
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./heat_cond]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./vol_heat_src]
    type = BodyForce
    variable = u
    function = src_func
  [../]
  [./mat_time_deriv]
    type = TestMatTimeDerivative
    variable = u
    mat_prop_value = rhoCp
  [../]
[]

[AuxKernels]
  [./ls_function]
    type = FunctionAux
    variable = ls
    function = ls_func
  [../]
[]

[Constraints]
  [./xfem_constraints]
    type = XFEMSingleVariableConstraint
    variable = u
    geometric_cut_userobject = &#x27;level_set_cut_uo&#x27;
    use_penalty = true
    alpha = 1e5
  [../]
[]

[Functions]
  [./src_func]
    type = ParsedFunction
    value = &#x27;10*(-100*x-100*y+200)-(5*t/1.04)&#x27;
  [../]
  [./neumann_func]
    type = ParsedFunction
    value = &#x27;((0.01/1.04)*(-2.5*x-2.5*y-t)+1.55)*100*t&#x27;
  [../]
  [./dirichlet_right_func]
    type = ParsedFunction
    value = &#x27;(-100*y+100)*t+400&#x27;
  [../]
  [./dirichlet_top_func]
    type = ParsedFunction
    value = &#x27;(-100*x+100)*t+400&#x27;
  [../]
  [./k_func]
    type = ParsedFunction
    value = &#x27;(0.01/1.04)*(-2.5*x-2.5*y-t)+1.55&#x27;
  [../]
  [./ls_func]
    type = ParsedFunction
    value = &#x27;-0.5*(x+y) + 1.04 -0.2*t&#x27;
  [../]
[]

[Materials]
  [./mat_time_deriv_prop]
    type = GenericConstantMaterial
    prop_names = &#x27;rhoCp&#x27;
    prop_values = 10
  [../]
  [./therm_cond_prop]
    type = GenericFunctionMaterial
    prop_names = &#x27;diffusion_coefficient&#x27;
    prop_values = &#x27;k_func&#x27;
  [../]
[]

[BCs]
  [./left_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = neumann_func
  [../]
  [./right_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = dirichlet_right_func
  [../]
  [./bottom_du]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = neumann_func
  [../]
  [./top_u]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;top&#x27;
    function = dirichlet_top_func
  [../]
[]

[ICs]
  [./u_ic]
    type = ConstantIC
    value = 400
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1.0e-6
  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-9

  start_time = 0.0
  dt = 0.2
  end_time = 1.0
  max_xfem_update = 1
[]

[Outputs]
  interval = 1
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  [./console]
    type = Console
    output_linear = true
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aee68ae3-a980-4114-9349-4c2856f0b553"><div class="modal-content"><h4>modules/phase_field/test/tests/GrandPotentialPFM/GrandPotentialAnisotropyAntitrap.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 15
  ny = 15
  xmin = -2
  xmax = 2
  ymin = -2
  ymax = 2
[]

[GlobalParams]
  radius = 1.0
  int_width = 0.8
  x1 = 0
  y1 = 0
  enable_jit = true
  derivative_order = 2
[]

[Variables]
  [./w]
  [../]
  [./etaa0]
  [../]
  [./etab0]
  [../]
[]

[AuxVariables]
  [./bnds]
  [../]
[]

[AuxKernels]
  [./bnds]
    type = BndsCalcAux
    variable = bnds
    v = &#x27;etaa0 etab0&#x27;
  [../]
[]

[ICs]
  [./w]
    type = SmoothCircleIC
    variable = w
    outvalue = -4.0
    invalue = 0.0
  [../]
  [./etaa0]
    type = SmoothCircleIC
    variable = etaa0
    #Solid phase
    outvalue = 0.0
    invalue = 1.0
  [../]
  [./etab0]
    type = SmoothCircleIC
    variable = etab0
    #Liquid phase
    outvalue = 1.0
    invalue = 0.0
  [../]
[]

[Kernels]
# Order parameter eta_alpha0
  [./ACa0_bulk]
    type = ACGrGrMulti
    variable = etaa0
    v =           &#x27;etab0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACa0_sw]
    type = ACSwitching
    variable = etaa0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etab0 w&#x27;
  [../]
  [./ACa0_int1]
    type = ACInterface2DMultiPhase1
    variable = etaa0
    etas = &#x27;etab0&#x27;
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
  [../]
  [./ACa0_int2]
    type = ACInterface2DMultiPhase2
    variable = etaa0
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
  [../]
  [./ea0_dot]
    type = TimeDerivative
    variable = etaa0
  [../]
# Order parameter eta_beta0
  [./ACb0_bulk]
    type = ACGrGrMulti
    variable = etab0
    v =           &#x27;etaa0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACb0_sw]
    type = ACSwitching
    variable = etab0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etaa0 w&#x27;
  [../]
  [./ACb0_int1]
    type = ACInterface2DMultiPhase1
    variable = etab0
    etas = &#x27;etaa0&#x27;
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
  [../]
  [./ACb0_int2]
    type = ACInterface2DMultiPhase2
    variable = etab0
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
  [../]
  [./eb0_dot]
    type = TimeDerivative
    variable = etab0
  [../]
#Chemical potential
  [./w_dot]
    type = SusceptibilityTimeDerivative
    variable = w
    f_name = chi
    args = &#x27;&#x27; # in this case chi (the susceptibility) is simply a constant
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = w
    diffusivity = Dchi
    args = &#x27;&#x27;
  [../]
  [./coupled_etaa0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etaa0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
  [./coupled_etab0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etab0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
  [./coupled_etaa0dot_int]
    type = AntitrappingCurrent
    variable = w
    v = etaa0
    f_name = rhodiff
  [../]
  [./coupled_etab0dot_int]
    type = AntitrappingCurrent
    variable = w
    v = etab0
    f_name = rhodiff
  [../]
[]

[Materials]
  [./ha]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = ha
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etaa0&#x27;
  [../]
  [./hb]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = hb
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etab0&#x27;
  [../]
  [./omegaa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegaa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/ka-w/Vm*caeq&#x27;
  [../]
  [./omegab]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegab
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/kb-w/Vm*cbeq&#x27;
  [../]
  [./rhoa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhoa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;w/Vm^2/ka + caeq/Vm&#x27;
  [../]
  [./rhob]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhob
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;w/Vm^2/kb + cbeq/Vm&#x27;
  [../]
  [./int]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhodiff
    material_property_names = &#x27;rhoa rhob&#x27;
    constant_names = &#x27;int_width&#x27;
    constant_expressions = &#x27;0.8&#x27;
    function = &#x27;int_width*(rhob-rhoa)&#x27;
  [../]
  [./kappaa]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
    etaa = etaa0
    etab = etab0
  [../]
  [./kappab]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
    etaa = etab0
    etab = etaa0
  [../]
  [./const]
    type = GenericConstantMaterial
    prop_names =  &#x27;L   D    chi  Vm   ka    caeq kb    cbeq  gab mu&#x27;
    prop_values = &#x27;1.0 1.0  0.1  1.0  10.0  0.1  10.0  0.9   4.5 10.0&#x27;
  [../]
  [./Mobility]
    type = ParsedMaterial
    f_name = Dchi
    material_property_names = &#x27;D chi&#x27;
    function = &#x27;D*chi&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_pc_type -pc_asm_overlap&#x27;
  petsc_options_value = &#x27;asm      31                  lu           1&#x27;
  l_tol = 1.0e-3
  nl_rel_tol = 1.0e-8
  nl_abs_tol = 1e-8
  num_steps = 3
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.001
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3019960a-4084-4233-9880-8b081267bffa"><div class="modal-content"><h4>modules/stochastic_tools/test/tests/surrogates/load_store/sub.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diffusion]
    type = MatDiffusion
    variable = u
    diffusivity = D
  []
  [absorption]
    type = MaterialReaction
    variable = u
    coefficient = sig
  []
  [source]
    type = BodyForce
    variable = u
    value = 1.0
  []
[]

[Materials]
  [diffusivity]
    type = GenericConstantMaterial
    prop_names = D
    prop_values = 2.0
  []
  [xs]
    type = GenericConstantMaterial
    prop_names = sig
    prop_values = 2.0
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Controls]
  [stochastic]
    type = SamplerReceiver
  []
[]

[Postprocessors]
  [avg]
    type = AverageNodalVariableValue
    variable = u
  []
  [max]
    type = NodalExtremeValue
    variable = u
    value_type = max
  []
[]

[Outputs]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7bfea24e-58fb-4455-84c4-836d4de52825"><div class="modal-content"><h4>modules/phase_field/test/tests/SoretDiffusion/split_temp.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 60
  xmax = 500
  elem_type = EDGE
[]

[GlobalParams]
  polynomial_order = 8
[]

[Variables]
  [./c]
  [../]
  [./w]
    scaling = 1.0e2
  [../]
  [./T]
    initial_condition = 1000.0
    scaling = 1.0e5
  [../]
[]

[ICs]
  [./c_IC]
    type = SmoothCircleIC
    x1 = 125.0
    y1 = 0.0
    radius = 60.0
    invalue = 1.0
    outvalue = 0.1
    int_width = 100.0
    variable = c
  [../]
[]

[Kernels]
  [./c_res]
    type = SplitCHParsed
    variable = c
    kappa_name = kappa
    w = w
    f_name = F
  [../]
  [./w_res]
    type = SplitCHWRes
    variable = w
    mob_name = M
  [../]
  [./w_res_soret]
    type = SoretDiffusion
    variable = w
    c = c
    T = T
    diff_name = D
    Q_name = Qstar
  [../]
  [./time]
    type = CoupledTimeDerivative
    variable = w
    v = c
  [../]
  [./HtCond]
    type = MatDiffusion
    variable = T
    diffusivity = thermal_conductivity
  [../]
[]

[BCs]
  [./Left_T]
    type = DirichletBC
    variable = T
    boundary = left
    value = 1000.0
  [../]

  [./Right_T]
    type = DirichletBC
    variable = T
    boundary = right
    value = 1015.0
  [../]
[]

[Materials]
  [./Copper]
    type = PFParamsPolyFreeEnergy
    block = 0
    c = c
    T = T # K
    int_width = 60.0
    length_scale = 1.0e-9
    time_scale = 1.0e-9
    D0 = 3.1e-5 # m^2/s, from Brown1980
    Em = 0.71 # in eV, from Balluffi1978 Table 2
    Ef = 1.28 # in eV, from Balluffi1978 Table 2
    surface_energy = 0.708 # Total guess
  [../]
  [./thcond]
    type = ParsedMaterial
    block = 0
    args = &#x27;c&#x27;
    function = &#x27;if(c&gt;0.7,1e-8,4e-8)&#x27;
    f_name = thermal_conductivity
    outputs = exodus
  [../]
  [./free_energy]
    type = PolynomialFreeEnergy
    block = 0
    c = c
    derivative_order = 2
  [../]
[]

[Preconditioning]
  [./SMP]
   type = SMP
   full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;
  solve_type = &#x27;PJFNK&#x27;

  l_max_its = 30
  l_tol = 1.0e-4
  nl_max_its = 25
  nl_rel_tol = 1.0e-9

  num_steps = 60
  dt = 20.0
[]

[Outputs]
   exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0e04e6df-aa10-433d-b34a-75e49e26d374"><div class="modal-content"><h4>modules/phase_field/test/tests/phase_field_crystal/PFCTrad/pfct_newton_split1_asm1_10.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 50
  ny = 50
  xmax = 8
  ymax = 8
[]

[Variables]
  [./n]
    [./InitialCondition]
      type = RandomIC
      min = -1
      max = 4
    [../]
  [../]
  [./u]
    scaling = 1e2
  [../]
  [./v]
    scaling = 1e1
  [../]
[]

[Kernels]
  [./ndot]
    type = TimeDerivative
    variable = n
  [../]
  [./n_bulk]
    type = CHBulkPFCTrad
    variable = n
  [../]
  [./u_term]
    type = MatDiffusion
    variable = n
    v = u
    diffusivity = C2
  [../]
  [./v_term]
    type = MatDiffusion
    variable = n
    v = v
    diffusivity = C4
  [../]
  [./u_rctn]
    type = Reaction
    variable = u
  [../]
  [./u_gradn]
    type = LaplacianSplit
    variable = u
    c = n
  [../]
  [./v_rctn]
    type = Reaction
    variable = v
  [../]
  [./v_gradu]
    type = LaplacianSplit
    variable = v
    c = u
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[Materials]
  [./PFCTrad]
    type = PFCTradMaterial
    order = 4
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 100
  l_tol = 1e-04
  nl_rel_tol = 1e-09
  nl_abs_tol = 1e-11

  splitting = &#x27;nuv&#x27;
  petsc_options = &#x27;-snes_view&#x27;

  num_steps = 2
  dt = 0.1
[]

[Splits]
  [./nuv]
    splitting       = &#x27;v nu&#x27;
    splitting_type  = schur
    schur_type      = full
    schur_pre       = Sp
    #petsc_options = &#x27;-dm_view&#x27;
  [../]
  [./nu]
    vars = &#x27;n u&#x27;
    petsc_options = &#x27;-ksp_monitor&#x27;
    petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_asm_nblocks -pc_asm_overlap  -sub_pc_type&#x27;
    petsc_options_value =  &#x27;              101      asm              10               1            lu&#x27;
  [../]
  [./v]
    vars = &#x27;v&#x27;
    #petsc_options = &#x27;-ksp_monitor&#x27;
    petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap&#x27;
    petsc_options_value =  &#x27;asm         101   preonly   lu      0&#x27;
    #full = true
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6cac40cf-a667-4faf-9547-353bba948374"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictionless-mortar-min-lm-mortar-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
  [../]
  [./normal_lm]
    block = 3
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [normal_lm]
    type = NormalMortarLMMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    secondary_disp_y = disp_y
    use_displaced_mesh = true
    compute_primal_residuals = false
    ncp_function_type = &#x27;min&#x27;
  []
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active = &#x27;num_nl cumulative contact&#x27;
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="08a8f25f-c2a9-4246-aaae-f10324627ab8"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictional-nodal-min-lm-mortar-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
  [../]
  [./normal_lm]
    block = 3
  [../]
  [./tangential_lm]
    block = 3
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [normal_lm]
    type = NormalNodalLMMechanicalContact
    primary = 20
    secondary = 10
    variable = normal_lm
    primary_variable = disp_x
    disp_y = disp_y
    ncp_function_type = min
  []
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_lm]
    type = TangentialNodalLMMechanicalContact
    primary = 20
    secondary = 10
    variable = tangential_lm
    primary_variable = disp_x
    disp_y = disp_y
    contact_pressure = normal_lm
    ncp_function_type = min
    mu = .1
  []
  [tangential_x]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_y]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor -snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  [exodus]
    type = Exodus
    sync_times = &#x27;0 5 10 15 20 25 30 35 40 45 50&#x27;
    file_base = frictional-nodal-min-lm-mortar-disp_out
  []
  [dof]
    type = DOFMap
    execute_on = &#x27;initial&#x27;
  []
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1d78e432-c1a1-491e-901b-3d7435e96b5a"><div class="modal-content"><h4>test/tests/materials/interface_material/interface_value_material_split_mesh_stateful.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
    elem_type = QUAD4
  []
  [./subdomain_id]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;1 0 0&#x27;
    top_right = &#x27;2 2 0&#x27;
    block_id = 1
  [../]
  [./split]
    type = BreakMeshByBlockGenerator
    input = subdomain_id
  [../]
[]



[Variables]
  [./u]
    block = 0
  [../]
  [./v]
    block = 1
  [../]
[]


[Kernels]
  [./diff]
    type = MatDiffusion
    variable = u
    diffusivity = &#x27;diffusivity&#x27;
    block = 0
  [../]

  [./diff_v]
    type = MatDiffusion
    variable = v
    diffusivity = &#x27;diffusivity&#x27;
    block = 1
  [../]
[]

[InterfaceKernels]
  [tied]
    type = PenaltyInterfaceDiffusion
    variable = u
    neighbor_var = v
    penalty = 1e6
    jump_prop_name = &quot;average_jump&quot;
    boundary = &#x27;interface&#x27;
  []
[]

[BCs]
  [u_left]
    type = DirichletBC
    boundary = &#x27;left&#x27;
    variable = u
    value = 1
  []
  [v_right]
    type = DirichletBC
    boundary = &#x27;right&#x27;
    variable = v
    value = 0
  []
[]

[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 1
    # outputs = all
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
    # outputs = all
  [../]
  [./interface_material_avg]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = average
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
      couple_old_values_and_properties = true
  [../]
  [./interface_material_jump_primary_minus_secondary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_primary_minus_secondary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
      couple_old_values_and_properties = true
  [../]
  [./interface_material_jump_secondary_minus_primary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_secondary_minus_primary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
      couple_old_values_and_properties = true
  [../]
  [./interface_material_jump_abs]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = jump_abs
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
      couple_old_values_and_properties = true
  [../]
  [./interface_material_primary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      boundary = interface
      interface_value_type = primary
      mat_prop_var_out_basename = diff_var
      nl_var_primary = u
      nl_var_secondary = v
      couple_old_values_and_properties = true
  [../]
  [./interface_material_secondary]
      type = InterfaceValueMaterial
      mat_prop_primary = diffusivity
      mat_prop_secondary = diffusivity
      var_primary = diffusivity_var
      var_secondary = diffusivity_var
      mat_prop_out_basename = diff
      mat_prop_var_out_basename = diff_var
      boundary = interface
      interface_value_type = secondary
      nl_var_primary = u
      nl_var_secondary = v
      couple_old_values_and_properties = true
  [../]
[]

[AuxKernels]
  [./interface_material_avg]
    type = MaterialRealAux
    property = diff_average
    variable = diffusivity_average
    boundary = interface
  []
  [./interface_material_jump_primary_minus_secondary]
    type = MaterialRealAux
    property = diff_jump_primary_minus_secondary
    variable = diffusivity_jump_primary_minus_secondary
    boundary = interface
  []
  [./interface_material_jump_secondary_minus_primary]
    type = MaterialRealAux
    property = diff_jump_secondary_minus_primary
    variable = diffusivity_jump_secondary_minus_primary
    boundary = interface
  []
  [./interface_material_jump_abs]
    type = MaterialRealAux
    property = diff_jump_abs
    variable = diffusivity_jump_abs
    boundary = interface
  []
  [./interface_material_primary]
    type = MaterialRealAux
    property = diff_primary
    variable = diffusivity_primary
    boundary = interface
  []
  [./interface_material_secondary]
    type = MaterialRealAux
    property = diff_secondary
    variable = diffusivity_secondary
    boundary = interface
  []
  [./interface_material_avg_prev]
    type = MaterialRealAux
    property = diff_average_prev
    variable = diffusivity_average_prev
    boundary = interface
  []
  [./interface_material_jump_primary_minus_secondary_prev]
    type = MaterialRealAux
    property = diff_jump_primary_minus_secondary_prev
    variable = diffusivity_jump_primary_minus_secondary_prev
    boundary = interface
  []
  [./interface_material_jump_secondary_minus_primary_prev]
    type = MaterialRealAux
    property = diff_jump_secondary_minus_primary_prev
    variable = diffusivity_jump_secondary_minus_primary_prev
    boundary = interface
  []
  [./interface_material_jump_abs_prev]
    type = MaterialRealAux
    property = diff_jump_abs_prev
    variable = diffusivity_jump_abs_prev
    boundary = interface
  []
  [./interface_material_primary_prev]
    type = MaterialRealAux
    property = diff_primary_prev
    variable = diffusivity_primary_prev
    boundary = interface
  []
  [./interface_material_secondary_prev]
    type = MaterialRealAux
    property = diff_secondary_prev
    variable = diffusivity_secondary_prev
    boundary = interface
  []
  [diffusivity_var]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_var
  []
[]

[AuxVariables]
  [diffusivity_var]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_average]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_primary_minus_secondary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_secondary_minus_primary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_abs]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_primary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_secondary]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_average_prev]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_primary_minus_secondary_prev]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_secondary_minus_primary_prev]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_jump_abs_prev]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_primary_prev]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_secondary_prev]
    family = MONOMIAL
    order = CONSTANT
  []
[]


[Executioner]
  type = Transient
  solve_type = NEWTON
  num_steps = 3
  dt = 0.5
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1871013a-2f72-4066-b176-6b6cfed8ec87"><div class="modal-content"><h4>modules/phase_field/test/tests/initial_conditions/SmoothCircleIC_3D.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 15
  ny = 15
  nz = 15
  xmax = 50
  ymax = 50
  zmax = 50
  elem_type = HEX8
[]

[Variables]
  [./c]
  [../]
[]

[ICs]
  [./c]
    type = SmoothCircleIC
    variable = c
    x1 = 25.0
    y1 = 25.0
    radius = 12
    invalue = 1.0
    outvalue = 0
    int_width = 12
    3D_spheres = false
    z1 = 25
  [../]
[]

[Kernels]
  [./ie_c]
    type = TimeDerivative
    variable = c
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = c
  [../]
[]

[BCs]
  [./Periodic]
    [./All]
      auto_direction = &#x27;x y z&#x27;
    [../]
  [../]
[]

[Materials]
  [./Diffusivity]
    type = GenericConstantMaterial
    prop_names = D
    prop_values = 1.0
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2

  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre boomeramg 31&#x27;

  l_max_its = 20
  l_tol = 1.0e-5
  nl_max_its = 40
  nl_rel_tol = 5.0e-14

  start_time = 0.0
  num_steps = 1
  dt = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ae704e61-0a5c-4518-9af2-658beb72575b"><div class="modal-content"><h4>modules/phase_field/examples/anisotropic_interfaces/GrandPotentialTwophaseAnisotropy.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = -4
  xmax = 4
  ymin = -4
  ymax = 4
  uniform_refine = 2
[]

[GlobalParams]
  radius = 0.5
  int_width = 0.3
  x1 = 0
  y1 = 0
  derivative_order = 2
[]

[Variables]
  [./w]
  [../]
  [./etaa0]
  [../]
  [./etab0]
  [../]
[]

[AuxVariables]
  [./bnds]
  [../]
[]

[AuxKernels]
  [./bnds]
    type = BndsCalcAux
    variable = bnds
    v = &#x27;etaa0 etab0&#x27;
  [../]
[]

[ICs]
  [./w]
    type = SmoothCircleIC
    variable = w
    # note w = A*(c-cleq), A = 1.0, cleq = 0.0 ,i.e., w = c (in the matrix/liquid phase)
    outvalue = -4.0
    invalue = 0.0
  [../]
  [./etaa0]
    type = SmoothCircleIC
    variable = etaa0
    #Solid phase
    outvalue = 0.0
    invalue = 1.0
  [../]
  [./etab0]
    type = SmoothCircleIC
    variable = etab0
    #Liquid phase
    outvalue = 1.0
    invalue = 0.0
  [../]
[]

[BCs]
  [./Periodic]
    [./w]
      variable = w
      auto_direction = &#x27;x y&#x27;
    [../]
    [./etaa0]
      variable = etaa0
      auto_direction = &#x27;x y&#x27;
    [../]
    [./etab0]
      variable = etab0
      auto_direction = &#x27;x y&#x27;
    [../]
  [../]
[]

[Kernels]
# Order parameter eta_alpha0
  [./ACa0_bulk]
    type = ACGrGrMulti
    variable = etaa0
    v =           &#x27;etab0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACa0_sw]
    type = ACSwitching
    variable = etaa0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etab0 w&#x27;
  [../]
  [./ACa0_int1]
    type = ACInterface2DMultiPhase1
    variable = etaa0
    etas = &#x27;etab0&#x27;
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
  [../]
  [./ACa0_int2]
    type = ACInterface2DMultiPhase2
    variable = etaa0
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
  [../]
  [./ea0_dot]
    type = TimeDerivative
    variable = etaa0
  [../]
# Order parameter eta_beta0
  [./ACb0_bulk]
    type = ACGrGrMulti
    variable = etab0
    v =           &#x27;etaa0&#x27;
    gamma_names = &#x27;gab&#x27;
  [../]
  [./ACb0_sw]
    type = ACSwitching
    variable = etab0
    Fj_names  = &#x27;omegaa omegab&#x27;
    hj_names  = &#x27;ha     hb&#x27;
    args = &#x27;etaa0 w&#x27;
  [../]
  [./ACb0_int1]
    type = ACInterface2DMultiPhase1
    variable = etab0
    etas = &#x27;etaa0&#x27;
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
  [../]
  [./ACb0_int2]
    type = ACInterface2DMultiPhase2
    variable = etab0
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
  [../]
  [./eb0_dot]
    type = TimeDerivative
    variable = etab0
  [../]
#Chemical potential
  [./w_dot]
    type = SusceptibilityTimeDerivative
    variable = w
    f_name = chi
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = w
    diffusivity = Dchi
  [../]
  [./coupled_etaa0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etaa0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
  [./coupled_etab0dot]
    type = CoupledSwitchingTimeDerivative
    variable = w
    v = etab0
    Fj_names = &#x27;rhoa rhob&#x27;
    hj_names = &#x27;ha   hb&#x27;
    args = &#x27;etaa0 etab0&#x27;
  [../]
[]

[Materials]
  [./ha]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = ha
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etaa0&#x27;
  [../]
  [./hb]
    type = SwitchingFunctionMultiPhaseMaterial
    h_name = hb
    all_etas = &#x27;etaa0 etab0&#x27;
    phase_etas = &#x27;etab0&#x27;
  [../]
  [./omegaa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegaa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/ka-w/Vm*caeq&#x27;
  [../]
  [./omegab]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = omegab
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;-0.5*w^2/Vm^2/kb-w/Vm*cbeq&#x27;
  [../]
  [./rhoa]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhoa
    material_property_names = &#x27;Vm ka caeq&#x27;
    function = &#x27;w/Vm^2/ka + caeq/Vm&#x27;
  [../]
  [./rhob]
    type = DerivativeParsedMaterial
    args = &#x27;w&#x27;
    f_name = rhob
    material_property_names = &#x27;Vm kb cbeq&#x27;
    function = &#x27;w/Vm^2/kb + cbeq/Vm&#x27;
  [../]
  [./kappaa]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappaa
    dkappadgrad_etaa_name = dkappadgrad_etaa
    d2kappadgrad_etaa_name = d2kappadgrad_etaa
    etaa = etaa0
    etab = etab0
    outputs = exodus
    output_properties = &#x27;kappaa&#x27;
  [../]
  [./kappab]
    type = InterfaceOrientationMultiphaseMaterial
    kappa_name = kappab
    dkappadgrad_etaa_name = dkappadgrad_etab
    d2kappadgrad_etaa_name = d2kappadgrad_etab
    etaa = etab0
    etab = etaa0
    outputs = exodus
    output_properties = &#x27;kappab&#x27;
  [../]
  [./const]
    type = GenericConstantMaterial
    prop_names =  &#x27;L   D    chi  Vm   ka    caeq kb    cbeq  gab mu&#x27;
    prop_values = &#x27;1.0 1.0  0.1  1.0  10.0  0.1  10.0  0.9   4.5 10.0&#x27;
  [../]
  [./Mobility]
    type = ParsedMaterial
    f_name = Dchi
    material_property_names = &#x27;D chi&#x27;
    function = &#x27;D*chi&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      31&#x27;
  l_tol = 1.0e-3
  l_max_its = 30
  nl_max_its = 15
  nl_rel_tol = 1.0e-8
  nl_abs_tol = 1e-8
  end_time = 10.0
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.0005
    cutback_factor = 0.7
    growth_factor = 1.2
  [../]
[]

[Adaptivity]
 initial_steps = 5
 max_h_level = 3
 initial_marker = err_eta
 marker = err_bnds
[./Markers]
   [./err_eta]
     type = ErrorFractionMarker
     coarsen = 0.3
     refine = 0.95
     indicator = ind_eta
   [../]
   [./err_bnds]
     type = ErrorFractionMarker
     coarsen = 0.3
     refine = 0.95
     indicator = ind_bnds
   [../]
 [../]
 [./Indicators]
   [./ind_eta]
     type = GradientJumpIndicator
     variable = etaa0
    [../]
    [./ind_bnds]
      type = GradientJumpIndicator
      variable = bnds
   [../]
 [../]
[]

[Outputs]
  interval = 10
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4d8a736f-6eba-4f4f-aa80-e7d151e2aac9"><div class="modal-content"><h4>test/tests/auxkernels/mesh_integer/mesh_integer.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = MeshGeneratorMesh

  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = 0
    ymax = 1
    nx = 5
    ny = 5
    extra_element_integers = &#x27;material_id&#x27;
  []
  [set_material_id0]
    type = SubdomainBoundingBoxGenerator
    input = gmg
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;0.8 0.6 0&#x27;
    block_id = 0
    location = INSIDE
    integer_name = material_id
  []
  [set_material_id1]
    type = SubdomainBoundingBoxGenerator
    input = set_material_id0
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;0.8 0.6 0&#x27;
    block_id = 1
    location = OUTSIDE
    integer_name = material_id
  []
[]

[Variables]
  [u][]
[]

[Kernels]
  [diff]
    type = MatDiffusion
    variable = u
    diffusivity = dc
  []
  [timederivative]
    type = TimeDerivative
    variable = u
  []
  [sourceterm]
    type = BodyForce
    variable = u
    function = 1
  []
[]

[AuxVariables]
  [id]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[AuxKernels]
  [id]
    type = ElementIntegerAux
    variable = id
    integer_names = material_id
  []
[]

[BCs]
  [vacuum]
    type = VacuumBC
    variable = u
    boundary = &#x27;right left top bottom&#x27;
 []
[]

[Materials]
  [dc]
    type = ConstantIDMaterial
    prop_name = dc
    prop_values = &#x27;1 2&#x27;
    id_name = material_id
  []
[]

[Postprocessors]
  [unorm]
    type = ElementL2Norm
    variable = u
  []
[]

[Executioner]
  type = Transient

  end_time = 0.1
  dt = 0.01
  nl_abs_tol = 1.e-15
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b1eea1fd-b3b2-484d-a670-bfef00afd123"><div class="modal-content"><h4>modules/phase_field/test/tests/initial_conditions/SmoothSuperellipsoidIC_3D.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 15
  ny = 15
  nz = 15
  xmax = 50
  ymax = 50
  zmax = 50
  elem_type = HEX8
[]

[Variables]
  [./c]
  [../]
[]

[ICs]
  [./c]
    type = SmoothSuperellipsoidIC
    variable = c
    x1 = 25.0
    y1 = 25.0
    z1 = 25.0
    a = 8
    b = 12
    c = 16
    n = 3.5
    invalue = 1.0
    outvalue = 0
    int_width = 4.0
  [../]
[]

[Kernels]
  [./ie_c]
    type = TimeDerivative
    variable = c
  [../]
  [./Diffusion]
    type = MatDiffusion
    variable = c
  [../]
[]

[BCs]
  [./Periodic]
    [./All]
      auto_direction = &#x27;x y z&#x27;
    [../]
  [../]
[]

[Materials]
  [./Diffusivity]
    type = GenericConstantMaterial
    prop_names = D
    prop_values = 1.0
  [../]
[]

[Executioner]
  type = Transient
  scheme = bdf2

  solve_type = &#x27;NEWTON&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;hypre boomeramg 31&#x27;

  l_max_its = 20
  l_tol = 1.0e-5
  nl_max_its = 40
  nl_rel_tol = 5.0e-14

  start_time = 0.0
  num_steps = 1
  dt = 2.0
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="18b7329f-a6d0-48c3-9a16-e7bd98756ac6"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/bouncing-block-ranfs.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  ping_pong_protection = true
[]

[Mesh]
  file = long-bottom-block-no-lower-d.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]

[Contact]
  [./top_bottom]
    mesh = file
    secondary = 10
    primary = 20

    model = frictionless
    formulation = ranfs
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = 2.5
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -mat_mffd_err&#x27;
  petsc_options_value = &#x27;hypre    boomeramg      1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  [exo]
    type = Exodus
  []
  checkpoint = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="070eca0e-f97f-4b54-9418-5b29f721c73b"><div class="modal-content"><h4>modules/phase_field/test/tests/SplitCH/forward_split_math_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 30
  ny = 30
  xmax = 25.0
  ymax = 25.0
  elem_type = QUAD
[]

[Variables]
  [./c]
  [../]
  [./w]
  [../]
[]

[ICs]
  [./c_IC]
    type = CrossIC
    variable = c
    x1 = 0
    x2 = 25
    y1 = 0
    y2 = 25
  [../]
[]

[Kernels]
  [./cdot]
    type = TimeDerivative
    variable = c
  [../]
  [./grad_w]
    type = MatDiffusion
    variable = c
    v = w
    diffusivity = 1.0
  [../]
  [./grad_c]
    type = MatDiffusion
    variable = w
    v = c
    diffusivity = 2.0
  [../]
  [./w2]
    type = CoupledMaterialDerivative
    variable = w
    v = c
    f_name = F
  [../]
  [./w3]
    type = CoefReaction
    variable = w
    coefficient = -1.0
  [../]
[]

[AuxVariables]
  [./local_energy]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[AuxKernels]
  [./local_energy]
    type = TotalFreeEnergy
    variable = local_energy
    f_name = F
    kappa_names = kappa_c
    interfacial_vars = c
  [../]
[]

[Materials]
  [./kappa_c]
    type = GenericConstantMaterial
    prop_names = kappa_c
    prop_values = 2.0
  [../]
  [./free_energy]
    type = DerivativeParsedMaterial
    args = c
    function = &#x27;(1 - c)^2 * (1 + c)^2&#x27;
    f_name = F
  [../]
[]

[Postprocessors]
  [./total_free_energy]
    type = ElementIntegralVariablePostprocessor
    variable = local_energy
  [../]
  [./total_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    execute_on = &#x27;initial TIMESTEP_END&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
   type = SMP
   full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 30
  l_tol = 1.0e-4
  nl_max_its = 10
  nl_rel_tol = 1.0e-10

  start_time = 0.0
  num_steps = 5
  dt = 0.7
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8a32ed6d-e2cc-42b8-9e16-bcebd3d18b3e"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictionless-nodal-min-lm-mortar-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
  [../]
  [./normal_lm]
    block = 3
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [./lm]
    type = NormalNodalLMMechanicalContact
    secondary = 10
    primary = 20
    variable = normal_lm
    primary_variable = disp_x
    disp_y = disp_y
  [../]
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  active = &#x27;num_nl cumulative contact&#x27;
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="699b650a-a8f2-43d8-9657-ece9147cde27"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictional-nodal-min-normal-lm-mortar-fb-tangential-lm-mortar-action.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1

# We offset slightly so we avoid the case where the bottom of the secondary block and the top of the
# primary block are perfectly vertically aligned which can cause the backtracking line search some
# issues for a coarse mesh (basic line search handles that fine)
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  [./original_file_mesh]
    type = FileMeshGenerator
    file = long-bottom-block-1elem-blocks-coarse.e
  [../]
  # These sidesets need to be deleted because the contact action adds them automatically. For this
  # particular mesh, the new IDs will be identical to the deleted ones and will conflict if we don&#x27;t
  # remove the original ones.
  [./delete_3]
    type = BlockDeletionGenerator
    input = original_file_mesh
    block_id = 3
  [../]
  [./revised_file_mesh]
    type = BlockDeletionGenerator
    input = delete_3
    block_id = 4
  [../]
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
    # order = SECOND
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
    # order = SECOND
  [../]
[]

[Contact]
  [frictional]
    mesh = revised_file_mesh
    primary = 20
    secondary = 10
    formulation = mortar
    model = coulomb
    friction_coefficient = 0.1
  []
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor -snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
  hide = &#x27;contact_pressure nodal_area_frictional penetration&#x27;
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = frictional_normal_lm
    subdomain = frictional_secondary_subdomain
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6234b1d2-09ee-4c0e-baef-5bca06db7ba0"><div class="modal-content"><h4>modules/contact/test/tests/bouncing-block-contact/frictional-mortar-fb-lm-mortar-disp.i</h4><pre class="moose-pre"><code class="language-text">starting_point = 2e-1

# We offset slightly so we avoid the case where the bottom of the secondary block and the top of the
# primary block are perfectly vertically aligned which can cause the backtracking line search some
# issues for a coarse mesh (basic line search handles that fine)
offset = 1e-2

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  diffusivity = 1e0
  scaling = 1e0
[]

[Mesh]
  file = long-bottom-block-1elem-blocks.e
[]

[Variables]
  [./disp_x]
    block = &#x27;1 2&#x27;
    # order = SECOND
  [../]
  [./disp_y]
    block = &#x27;1 2&#x27;
    # order = SECOND
  [../]
  [./normal_lm]
    block = 3
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./tangential_lm]
    block = 3
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[ICs]
  [./disp_y]
    block = 2
    variable = disp_y
    value = ${fparse starting_point + offset}
    type = ConstantIC
  [../]
[]

[Kernels]
  [./disp_x]
    type = MatDiffusion
    variable = disp_x
  [../]
  [./disp_y]
    type = MatDiffusion
    variable = disp_y
  [../]
[]


[Constraints]
  [normal_lm]
    type = NormalMortarLMMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    secondary_disp_y = disp_y
    use_displaced_mesh = true
    compute_primal_residuals = false
    ncp_function_type = fb
  []
  [normal_x]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [normal_y]
    type = NormalMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = normal_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_lm]
    type = TangentialMortarLMMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_x
    secondary_disp_y = disp_y
    use_displaced_mesh = true
    compute_primal_residuals = false
    contact_pressure = normal_lm
    friction_coefficient = .1
    ncp_function_type = fb
  []
  [tangential_x]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_x
    component = x
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
  [tangential_y]
    type = TangentialMortarMechanicalContact
    primary_boundary = 20
    secondary_boundary = 10
    primary_subdomain = 4
    secondary_subdomain = 3
    variable = tangential_lm
    secondary_variable = disp_y
    component = y
    use_displaced_mesh = true
    compute_lm_residuals = false
  []
[]

[BCs]
  [./botx]
    type = DirichletBC
    variable = disp_x
    boundary = 40
    value = 0.0
  [../]
  [./boty]
    type = DirichletBC
    variable = disp_y
    boundary = 40
    value = 0.0
  [../]
  [./topy]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = 30
    function = &#x27;${starting_point} * cos(2 * pi / 40 * t) + ${offset}&#x27;
  [../]
  [./leftx]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 50
    function = &#x27;1e-2 * t&#x27;
  [../]
[]

[Executioner]
  type = Transient
  end_time = 200
  dt = 5
  dtmin = .1
  solve_type = &#x27;PJFNK&#x27;
  petsc_options = &#x27;-snes_converged_reason -ksp_converged_reason -pc_svd_monitor -snes_linesearch_monitor -snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -mat_mffd_err&#x27;
  petsc_options_value = &#x27;lu       NONZERO               1e-15                   1e-5&#x27;
  l_max_its = 30
  nl_max_its = 20
  line_search = &#x27;none&#x27;
  snesmf_reuse_base = false

  # [./Predictor]
  #   type = SimplePredictor
  #   scale = 1.0
  # [../]
[]

[Debug]
  show_var_residual_norms = true
[]

[Outputs]
  exodus = true
  # checkpoint = true
  # [./dofmap]
  #   type = DOFMap
  #   execute_on = &#x27;initial&#x27;
  # [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Postprocessors]
  [./num_nl]
    type = NumNonlinearIterations
  [../]
  [./cumulative]
    type = CumulativeValuePostprocessor
    postprocessor = num_nl
  [../]
  [contact]
    type = ContactDOFSetSize
    variable = normal_lm
    subdomain = &#x27;3&#x27;
    execute_on = &#x27;nonlinear timestep_end&#x27;
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5b1f25a4-3823-41da-bd34-e4500915680f"><div class="modal-content"><h4>modules/xfem/test/tests/moving_interface/phase_transition.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 11
  ny = 1
  xmin = 0
  xmax = 2
  ymin = 0
  ymax = 1
  elem_type = QUAD4
[]

[XFEM]
  qrule = volfrac
  output_cut_plane = true
[]

[UserObjects]
  [./velocity]
    type = XFEMPhaseTransitionMovingInterfaceVelocity
    diffusivity_at_positive_level_set = 5
    diffusivity_at_negative_level_set = 1
    equilibrium_concentration_jump = 1
    value_at_interface_uo = value_uo
  [../]
  [./value_uo]
    type = PointValueAtXFEMInterface
    variable = &#x27;u&#x27;
    geometric_cut_userobject = &#x27;moving_line_segments&#x27;
    execute_on = &#x27;nonlinear&#x27;
    level_set_var = ls
  [../]
  [./moving_line_segments]
    type = MovingLineSegmentCutSetUserObject
    cut_data = &#x27;0.5 0 0.5 1.0 0 0&#x27;
    heal_always = true
    interface_velocity = velocity
  [../]
[]

[Variables]
  [./u]
  [../]
[]

[ICs]
  [./ic_u]
    type = FunctionIC
    variable = u
    function = &#x27;if(x&lt;0.51, 2, 1)&#x27;
  [../]
[]

[AuxVariables]
  [./ls]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Constraints]
  [./u_constraint]
    type = XFEMEqualValueAtInterface
    geometric_cut_userobject = &#x27;moving_line_segments&#x27;
    use_displaced_mesh = false
    variable = u
    value = 2
    alpha = 1e5
  [../]
[]

[Kernels]
  [./diff]
    type = MatDiffusion
    variable = u
    diffusivity = diffusion_coefficient
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[AuxKernels]
  [./ls]
    type = LineSegmentLevelSetAux
    line_segment_cut_set_user_object = &#x27;moving_line_segments&#x27;
    variable = ls
  [../]
[]

[Materials]
  [./diffusivity_A]
    type = GenericConstantMaterial
    prop_names = A_diffusion_coefficient
    prop_values = 5
  [../]
  [./diffusivity_B]
    type = GenericConstantMaterial
    prop_names = B_diffusion_coefficient
    prop_values = 1
  [../]
  [./diff_combined]
    type = LevelSetBiMaterialReal
    levelset_positive_base = &#x27;A&#x27;
    levelset_negative_base = &#x27;B&#x27;
    level_set_var = ls
    prop_name = diffusion_coefficient
  [../]
[]

[BCs]
# Define boundary conditions
  [./left_u]
    type = DirichletBC
    variable = u
    value = 2
    boundary = 3
  [../]

  [./right_u]
    type = NeumannBC
    variable = u
    boundary = 1
    value = 0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  line_search = &#x27;none&#x27;

  l_tol = 1e-3
  nl_max_its = 15
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-11

  start_time = 0.0
  dt = 0.01
  num_steps = 4
  max_xfem_update = 1
[]


[Outputs]
  execute_on = timestep_end
  exodus = true
  perf_graph = true
  [./console]
    type = Console
    output_linear = true
  [../]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#998ba5db-6d16-4f93-8840-58b6f4af480c" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#6fd3b291-1b1f-4d74-a1b6-f8f4c0e3e950" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>