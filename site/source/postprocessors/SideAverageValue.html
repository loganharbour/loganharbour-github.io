<!DOCTYPE html><head><meta charset="UTF-8"><title>SideAverageValue.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="ed17e569-1a66-4c16-9881-e3f7c5708dcf"><i class="material-icons">menu</i></a><ul class="sidenav" id="ed17e569-1a66-4c16-9881-e3f7c5708dcf"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">postprocessors</span><a href="#" class="breadcrumb">SideAverageValue</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="c1ca2c7c-8b71-4c43-b1a1-3ae2cb0dfbbd" data-section-level="1" data-section-text="SideAverageValue"><h1 id="sideaveragevalue">SideAverageValue</h1><p>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</p><section class="scrollspy" id="e5d0db47-06b4-4447-8ccd-425382322820" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p><code>SideAverageValue</code> computes the area- or volume-weighted average of the integral of the specified variable. It may be used, for example, to calculate the average temperature over a side set.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><span class="moose-alert-title-brand">note:</span>SideAverageValue requires nonzero coordinate values</div><div class="card-content"><div class="moose-alert-content"><p><p><code>SideAverageValue</code> is not suitable for use when computing the average integral value of a variable when one of the coordinates in the sideset has a value of zero.  In those cases, such as when computing the value of a variable on the centerline of an axisymmetric simulation, use <a href="AxisymmetricCenterlineAverageValue.html">AxisymmetricCenterlineAverageValue</a></p></p></div></div></div></section><section class="scrollspy" id="9789b99b-2100-48ee-b805-898450114fe6" data-section-level="2" data-section-text="Example Input Syntax"><h2 id="example-input-syntax">Example Input Syntax</h2><pre class="moose-pre"><code class="language-text">[Postprocessors]
  [./ave_stress_bottom]
    type = SideAverageValue
    variable = stress_yy
    boundary = bottom
  [../]
  [./ave_strain_bottom]
    type = SideAverageValue
    variable = strain_yy
    boundary = bottom
  [../]
[]
</code></pre><a href="#9146f993-f7a6-49df-aaf0-b91505cfdd64" class="modal-trigger">(modules/tensor_mechanics/tutorials/basics/part_2.3.i)</a><div class="modal moose-modal" id="9146f993-f7a6-49df-aaf0-b91505cfdd64"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/modules/tensor_mechanics/tutorials/basics/part_2.3.i</h4><pre class="moose-pre"><code class="language-text">#Tensor Mechanics tutorial: the basics
#Step 2, part 3
#2D axisymmetric RZ simulation of uniaxial tension with J2 plasticity with no
#hardening

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = necking_quad4.e
  uniform_refine = 0
  second_order = true
[]

[Modules/TensorMechanics/Master]
  [./block1]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_yy strain_yy&#x27; #use the yy option to get the zz component in axisymmetric coords
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeMultiPlasticityStress
    ep_plastic_tolerance = 1e-9
    plastic_models = J2
  [../]
[]

[UserObjects]
  [./str]
    type = TensorMechanicsHardeningConstant
    value = 2.4e2
  [../]
  [./J2]
    type = TensorMechanicsPlasticJ2
    yield_strength = str
    yield_function_tolerance = 1E-3
    internal_constraint_tolerance = 1E-9
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_r
    boundary = left
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]
  [./top]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = top
    function = &#x27;0.0007*t&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.25
  end_time = 20

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;asm lu 1 101&#x27;
[]

[Postprocessors]
  [./ave_stress_bottom]
    type = SideAverageValue
    variable = stress_yy
    boundary = bottom
  [../]
  [./ave_strain_bottom]
    type = SideAverageValue
    variable = strain_yy
    boundary = bottom
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
  csv = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="c09df2aa-57b3-49d1-a26a-2fdb9d8187a5" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="441fdf5b-c33a-4d38-a10e-bdbdc89d4550" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundary IDs from the mesh where this boundary condition applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<BoundaryName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The list of boundary IDs from the mesh where this boundary condition applies</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">The name of the variable that this boundary condition applies to</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<VariableName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the variable that this boundary condition applies to</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="9d670622-e553-43ff-b721-86ef2c646edc" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">execute_on</span><span class="moose-parameter-header-default">TIMESTEP_END</span><span class="moose-parameter-header-description">The list of flag(s) indicating when this object should be executed, the available options include NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, FINAL, CUSTOM.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>TIMESTEP_END</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>ExecFlagEnum</p><p class="moose-parameter-description-options"><span>Options:</span>NONE INITIAL LINEAR NONLINEAR TIMESTEP_END TIMESTEP_BEGIN FINAL CUSTOM TRANSFER</p><p class="moose-parameter-description"><span>Description:</span>The list of flag(s) indicating when this object should be executed, the available options include NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, FINAL, CUSTOM.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="89616f13-9b16-4fd9-9bc3-f550208bd7d0" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">allow_duplicate_execution_on_initial</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">outputs</span><span class="moose-parameter-header-description">Vector of output names were you would like to restrict the output of variables(s) associated with this object</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<OutputName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Vector of output names were you would like to restrict the output of variables(s) associated with this object</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section class="scrollspy" id="0d86d01f-15bf-4133-b45a-a4caedbe3573" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#648e7a60-3999-4e50-b062-987496c2aa61" class="modal-trigger">modules/combined/test/tests/phase_field_fracture/crack2d_computeCrackedStress_finitestrain_plastic.i</a></li><li><a href="#2b358ef6-2e76-40f4-8e2b-be6da972377b" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/sphere3D.i</a></li><li><a href="#fbbc01aa-d91b-4e0e-a0a0-5c4f6dad6e98" class="modal-trigger">modules/heat_conduction/test/tests/recover/ad_recover.i</a></li><li><a href="#081b9b45-f703-432b-8b64-be2fb9a82a25" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/rz.i</a></li><li><a href="#e0037026-1a34-49eb-8fb2-6a2f31e0e46a" class="modal-trigger">test/tests/userobjects/side_user_object_no_boundary_error/side_no_boundary.i</a></li><li><a href="#88307cf1-a6b7-44aa-beeb-57acb7046641" class="modal-trigger">modules/combined/test/tests/phase_field_fracture/crack2d_computeCrackedStress_smallstrain.i</a></li><li><a href="#e9856807-62ca-46d9-b604-20db2e320be4" class="modal-trigger">modules/heat_conduction/test/tests/ad_convective_heat_flux/equilibrium.i</a></li><li><a href="#d60f4c8d-0a5b-49c4-9b80-b4bddf8fb56b" class="modal-trigger">modules/combined/test/tests/cavity_pressure/additional_volume.i</a></li><li><a href="#4488050e-aa6f-4bb4-9927-6a9573b26ae7" class="modal-trigger">test/tests/postprocessors/side_average_value/side_average_value_test.i</a></li><li><a href="#1e346a17-ffc2-477e-bf0e-2189a14c0549" class="modal-trigger">modules/combined/test/tests/phase_field_fracture/crack2d_aniso_hist_false.i</a></li><li><a href="#8bd9ce30-fe7e-4a0f-9b55-f0e320ff4966" class="modal-trigger">test/tests/userobjects/interface_user_object/interface_value_user_object_QP.i</a></li><li><a href="#168e686c-5c1f-4684-91b9-95735913f2ce" class="modal-trigger">modules/tensor_mechanics/tutorials/basics/part_2.4.i</a></li><li><a href="#71ed71c6-ad7c-4d21-b166-c3d50faa871d" class="modal-trigger">tutorials/darcy_thermo_mech/step10_multiapps/problems/step10_micro.i</a></li><li><a href="#51793287-d0a2-474c-b9d0-d7c0f40b6da1" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/gtn_single.i</a></li><li><a href="#c87dc999-7531-4c5d-b163-323a49beb26b" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_dual.i</a></li><li><a href="#822e4a78-3a77-499e-b64b-c75ab46ea77c" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/planar_xy.i</a></li><li><a href="#4709ef71-fbc3-40ae-9a9f-f0508a564bdb" class="modal-trigger">modules/tensor_mechanics/test/tests/radial_disp_aux/cylinder_2d_cartesian.i</a></li><li><a href="#6bd37da7-96b2-4267-b2fe-a67ca0957305" class="modal-trigger">modules/tensor_mechanics/test/tests/thermal_expansion_function/dilatation.i</a></li><li><a href="#d9ef1cc0-dea4-44cc-a9d8-90fa44f2601b" class="modal-trigger">modules/heat_conduction/test/tests/convective_heat_flux/coupled.i</a></li><li><a href="#43caccd2-5dfc-4e17-8b38-d46a2f4b549a" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/cyl3D.i</a></li><li><a href="#34155176-fa7c-4fa9-b107-aa0c9af94bc6" class="modal-trigger">modules/combined/examples/phase_field-mechanics/kks_mechanics_VTS.i</a></li><li><a href="#185ece16-4937-4c24-a83c-06411bc5cb25" class="modal-trigger">modules/tensor_mechanics/test/tests/thermal_expansion_function/mean.i</a></li><li><a href="#39e3896e-687e-43f7-b726-6054c8409da9" class="modal-trigger">modules/heat_conduction/test/tests/heat_source_bar/ad_heat_source_bar.i</a></li><li><a href="#7f8a05e4-ea02-4388-b815-83e63fde5772" class="modal-trigger">modules/functional_expansion_tools/test/tests/standard_use/interface_coupled.i</a></li><li><a href="#a6f305ec-a91c-4b46-b401-c39ab44f90b9" class="modal-trigger">modules/tensor_mechanics/test/tests/radial_disp_aux/cylinder_2d_axisymmetric.i</a></li><li><a href="#1f6b6594-4625-4a0e-b09a-81b47ff5c71a" class="modal-trigger">modules/tensor_mechanics/tutorials/basics/part_2.3.i</a></li><li><a href="#b5778c3d-6645-48dd-92aa-0622948e20f4" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D.i</a></li><li><a href="#7cc5fa64-217f-4799-8a78-88ab55e67894" class="modal-trigger">modules/combined/test/tests/phase_field_fracture/crack2d_aniso_cleavage_plane.i</a></li><li><a href="#f63c4644-8e15-483b-ac97-c1f50b07605d" class="modal-trigger">test/tests/functions/parsed/steady.i</a></li><li><a href="#f14766a1-42e5-459a-9817-92f76aff645b" class="modal-trigger">modules/combined/test/tests/cavity_pressure/multiple_postprocessors.i</a></li><li><a href="#c939b67a-580b-45b1-99ef-474a8276c2c1" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/initial_temperature.i</a></li><li><a href="#bdb03661-c8d1-4609-a3f8-60934d2d7aaa" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D_xz.i</a></li><li><a href="#c74b59a0-a8cb-4289-868f-60e1562c707f" class="modal-trigger">modules/tensor_mechanics/test/tests/czm/czm_3DC_3D_base_input.i</a></li><li><a href="#fe4132b9-027f-4fde-bd29-2940d9671178" class="modal-trigger">modules/heat_conduction/test/tests/convective_heat_flux/t_inf.i</a></li><li><a href="#2644c018-4c08-4611-94f3-6f0a92f92b61" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_test.i</a></li><li><a href="#f10f0ec8-3061-496e-b93e-3b0d91837848" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/mean.i</a></li><li><a href="#82760684-26a7-48dd-b19e-55502855afec" class="modal-trigger">modules/tensor_mechanics/tutorials/basics/part_3_1.i</a></li><li><a href="#b5858c48-d40d-4262-84c9-f665e41d8cbe" class="modal-trigger">modules/tensor_mechanics/test/tests/radial_disp_aux/sphere_3d_cartesian.i</a></li><li><a href="#f60684b5-897e-45cb-bb57-cedce9754e09" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/planar_yz.i</a></li><li><a href="#d2238b4c-8b32-4f70-88ad-fb581c24dc75" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/dilatation.i</a></li><li><a href="#bd0c2e69-923d-47a0-b3c7-27624aaed8b2" class="modal-trigger">modules/porous_flow/test/tests/sinks/PorousFlowPiecewiseLinearSink_BC_eg1.i</a></li><li><a href="#1b95a348-295d-444c-9890-b6c8c3fbb564" class="modal-trigger">modules/tensor_mechanics/test/tests/radial_disp_aux/cylinder_3d_cartesian.i</a></li><li><a href="#cfa48c1a-cd47-4fee-b9e8-b86320b335d7" class="modal-trigger">modules/heat_conduction/test/tests/heat_source_bar/heat_source_bar.i</a></li><li><a href="#e392a2cd-7f19-46cf-9909-c219a4fbd409" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D_yz.i</a></li><li><a href="#5cd4e37c-53ec-473e-aa78-ded77677c869" class="modal-trigger">modules/heat_conduction/test/tests/convective_heat_flux/equilibrium.i</a></li><li><a href="#4c2d29d5-abcb-466f-a725-6ec0b8037c87" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_rz_test.i</a></li><li><a href="#4f93577d-c3e4-4fa4-9e7f-5861226bb829" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_it_plot_test.i</a></li><li><a href="#ff0af589-85fe-4648-b4df-10cb0e8f5201" class="modal-trigger">modules/tensor_mechanics/test/tests/thermal_expansion_function/instantaneous.i</a></li><li><a href="#5811fc8e-9ab7-4dd9-8a3e-0acfc244d057" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_radiation/gap_heat_transfer_radiation_test.i</a></li><li><a href="#c6bef6ac-dc0c-4cfc-bb0b-33fea55d757e" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/additional_volume.i</a></li><li><a href="#3af5cda9-2654-4e13-9d39-8ef3a794ed73" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/creep.i</a></li><li><a href="#ee95995b-feeb-4286-ab02-2548466575db" class="modal-trigger">modules/heat_conduction/test/tests/ad_convective_heat_flux/coupled.i</a></li><li><a href="#3f95fc25-faae-41b6-9d10-f27faeb4e084" class="modal-trigger">modules/heat_conduction/test/tests/radiation_transfer_action/radiative_transfer_action.i</a></li><li><a href="#f7a0d77c-db52-4a9f-be06-804146342167" class="modal-trigger">modules/heat_conduction/test/tests/radiation_transfer_action/radiative_transfer_action_external_boundary.i</a></li><li><a href="#cab3c71b-4d28-4eb5-ae87-da098dbe7e92" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/instantaneous.i</a></li><li><a href="#0ae5197d-6101-47b7-a99d-10de0e25e11b" class="modal-trigger">modules/functional_expansion_tools/examples/2D_interface_no_material/main.i</a></li><li><a href="#838a0131-16b1-41c8-88bb-23415462c15f" class="modal-trigger">modules/heat_conduction/test/tests/recover/recover.i</a></li><li><a href="#4b42a6b6-ec0a-423d-8d98-55340544e26a" class="modal-trigger">modules/combined/test/tests/cavity_pressure/rz.i</a></li><li><a href="#2a77ba20-6ef1-4b9c-b386-430cb6ce2cd3" class="modal-trigger">modules/functional_expansion_tools/examples/2D_interface/main.i</a></li><li><a href="#dd85de5b-43fa-49c5-b9c1-4d57ced24384" class="modal-trigger">modules/functional_expansion_tools/examples/2D_interface_different_submesh/main.i</a></li><li><a href="#d44a8265-c1d8-4c34-b84e-904e87f47ea8" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/3d.i</a></li><li><a href="#56c17068-366b-4dc7-b837-08af34acf2fd" class="modal-trigger">modules/phase_field/examples/measure_interface_energy/1Dinterface_energy.i</a></li><li><a href="#2d688aaf-e610-4287-9af0-69e9a93bc6c8" class="modal-trigger">modules/combined/test/tests/phase_field_fracture/crack2d_aniso.i</a></li><li><a href="#43326b62-03b0-4c14-b5e7-3a896d54264a" class="modal-trigger">test/tests/mesh/named_entities/named_entities_test_xda.i</a></li><li><a href="#8da837ce-7476-4468-bd73-4d7eb2991f3c" class="modal-trigger">modules/combined/examples/effective_properties/effective_th_cond.i</a></li><li><a href="#1fab0db6-2baa-4290-9d34-fd2b5b0d882b" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/planar_xz.i</a></li><li><a href="#152dfc09-429f-4eb0-9c28-5fb6634d2290" class="modal-trigger">modules/combined/test/tests/phase_field_fracture/crack2d_computeCrackedStress_finitestrain_elastic.i</a></li><li><a href="#55850264-9ffc-47ab-a020-767ada23692c" class="modal-trigger">modules/combined/examples/phase_field-mechanics/kks_mechanics_KHS.i</a></li><li><a href="#fa8caf5a-b01c-4843-b1f9-cced97a86a60" class="modal-trigger">modules/tensor_mechanics/test/tests/radial_disp_aux/sphere_2d_axisymmetric.i</a></li><li><a href="#8ce69379-7f80-4a09-b002-d1001cd7ebd7" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_rspherical.i</a></li><li><a href="#1c99bef0-66d1-4b18-b19a-40dcf5b22e44" class="modal-trigger">test/tests/functions/pps_function/pp_function.i</a></li><li><a href="#db07b59c-86c4-4ef5-952a-da283c77138e" class="modal-trigger">test/tests/mesh/named_entities/named_entities_test.i</a></li><li><a href="#f8ea6f45-6088-4bce-b660-2b1cefd4e1d3" class="modal-trigger">modules/combined/test/tests/ad_cavity_pressure/multiple_postprocessors.i</a></li><li><a href="#f2a301d4-eab3-40dd-b023-0c9935ffe31d" class="modal-trigger">modules/combined/test/tests/cavity_pressure/initial_temperature.i</a></li><li><a href="#296f844d-ae13-4b1a-8076-810a18a080f6" class="modal-trigger">test/tests/controls/time_periods/user_objects/user_object.i</a></li><li><a href="#85bcb09f-9ec1-49f8-9a9f-2d8f16515944" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_single.i</a></li><li><a href="#d8f7956a-f128-40b3-980b-6590daed2cce" class="modal-trigger">modules/combined/test/tests/cavity_pressure/3d.i</a></li><li><a href="#49eb1c45-a01f-4395-98df-9fe9dcf6b69c" class="modal-trigger">modules/combined/test/tests/gap_heat_transfer_htonly/sphere2DRZ.i</a></li><li><a href="#2a222d9d-b9c9-4b56-8f07-f29e80356cda" class="modal-trigger">modules/heat_conduction/test/tests/radiation_transfer_action/radiative_transfer_no_action.i</a></li><li><a href="#b10ba510-e900-4035-9295-df9dc1c800b2" class="modal-trigger">modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_single_split.i</a></li></ul><div class="modal moose-modal" id="648e7a60-3999-4e50-b062-987496c2aa61"><div class="modal-content"><h4>modules/combined/test/tests/phase_field_fracture/crack2d_computeCrackedStress_finitestrain_plastic.i</h4><pre class="moose-pre"><code class="language-text">#This input uses PhaseField-Nonconserved Action to add phase field fracture bulk rate kernels
[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 40
    ny = 20
    ymax = 0.5
  []
  [./noncrack]
    type = BoundingBoxNodeSetGenerator
    new_boundary = noncrack
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 0 0&#x27;
    input = gen
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[AuxVariables]
  [./strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./elastic_strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./plastic_strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./uncracked_stress_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./All]
        add_variables = true
        strain = FINITE
        planar_formulation = PLANE_STRAIN
        additional_generate_output = &#x27;stress_yy vonmises_stress&#x27;
        strain_base_name = uncracked
      [../]
    [../]
  [../]
  [./PhaseField]
    [./Nonconserved]
      [./c]
        free_energy = E_el
        kappa = kappa_op
        mobility = L
      [../]
    [../]
  [../]
[]

[Kernels]
  [./solid_x]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_x
    component = 0
    c = c
  [../]
  [./solid_y]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_y
    component = 1
    c = c
  [../]
  [./off_disp]
    type = AllenCahnElasticEnergyOffDiag
    variable = c
    displacements = &#x27;disp_x disp_y&#x27;
    mob_name = L
  [../]
[]

[AuxKernels]
  [./strain_yy]
    type = RankTwoAux
    variable = strain_yy
    rank_two_tensor = uncracked_mechanical_strain
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
  [./elastic_strain_yy]
    type = RankTwoAux
    variable = elastic_strain_yy
    rank_two_tensor = uncracked_elastic_strain
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
  [./plastic_strain_yy]
    type = RankTwoAux
    variable = plastic_strain_yy
    rank_two_tensor = uncracked_plastic_strain
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
  [./uncracked_stress_yy]
    type = RankTwoAux
    variable = uncracked_stress_yy
    rank_two_tensor = uncracked_stress
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
[]

[BCs]
  [./ydisp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = &#x27;t&#x27;
  [../]
  [./yfix]
    type = DirichletBC
    variable = disp_y
    boundary = noncrack
    value = 0
  [../]
  [./xfix]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0
  [../]
[]

[Functions]
  [./hf]
    type = PiecewiseLinear
    x = &#x27;0    0.001 0.003 0.023&#x27;
    y = &#x27;0.85 1.0   1.25  1.5&#x27;
  [../]
[]

[Materials]
  [./pfbulkmat]
    type = GenericConstantMaterial
    prop_names = &#x27;gc_prop l visco&#x27;
    prop_values = &#x27;1e-3 0.05 5e-3&#x27;
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;120.0 80.0&#x27;
    fill_method = symmetric_isotropic
    base_name = uncracked
  [../]
  [./isotropic_plasticity]
    type = IsotropicPlasticityStressUpdate
    yield_stress = 0.85
    hardening_function = hf
    base_name = uncracked
  [../]
  [./radial_return_stress]
    type = ComputeMultipleInelasticStress
    tangent_operator = elastic
    inelastic_models = &#x27;isotropic_plasticity&#x27;
    base_name = uncracked
  [../]
  [./cracked_stress]
    type = ComputeCrackedStress
    c = c
    F_name = E_el
    use_current_history_variable = true
    uncracked_base_name = uncracked
    finite_strain_model = true
  [../]
[]

[Postprocessors]
  [./av_stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./av_strain_yy]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./av_uncracked_stress_yy]
    type = ElementAverageValue
    variable = uncracked_stress_yy
  [../]
  [./max_c]
    type = ElementExtremeValue
    variable = c
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solving_package&#x27;
  petsc_options_value = &#x27;lu superlu_dist&#x27;

  nl_rel_tol = 1e-8
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 10

  dt = 2.0e-5
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2b358ef6-2e76-40f4-8e2b-be6da972377b"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/sphere3D.i</h4><pre class="moose-pre"><code class="language-text">#
# 3D Spherical Gap Heat Transfer Test.
#
# This test exercises 3D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid sphere of radius = 1 unit, and outer
# hollow sphere with an inner radius of 2. In other words, the gap between
# them is 1 radial unit in length.
#
# The conductivity of both spheres is set very large to achieve a uniform
# temperature in each sphere. The temperature of the center node of the
# inner sphere is ramped from 100 to 200 over one time unit. The
# temperature of the outside of the outer, hollow sphere is held fixed
# at 100.
#
# A simple analytical solution is possible for the integrated heat flux
# between the inner and outer spheres:
#
#  Integrated Flux = (T_left - T_right) * (gapK/(r^2*((1/r1)-(1/r2)))) * Area
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 4 * pi * 1^2 (4*pi*r^2)
#
# The integrated heat flux across the gap at time 1 is then:
#
# 4*pi*k*delta_T/((1/r1)-(1/r2))
# 4*pi*1*100/((1/1) - (1/2)) =  2513.3 watts
#
# For comparison, see results from the integrated flux post processors.
# This simulation makes use of symmetry, so only 1/8 of the spheres is meshed
# As such, the integrated flux from the post processors is 1/8 of the total,
# or 314.159 watts... i.e. 100*pi.
# The value coming from the post processor is slightly less than this
# but converges as mesh refinement increases.
#
# Simulating contact is challenging. Regression tests that exercise
# contact features can be difficult to solve consistently across multiple
# platforms. While designing these tests, we felt it worth while to note
# some aspects of these tests. The following applies to:
# sphere3D.i, sphere2DRZ.i, cyl2D.i, and cyl3D.i.
# 1. We decided that to perform consistently across multiple platforms we
# would use very small convergence tolerance. In this test we chose an
# nl_rel_tol of 1e-12.
# 2. Due to such a high value for thermal conductivity (used here so that the
# domains come to a uniform temperature) the integrated flux at time = 0
# was relatively large (the value coming from SideIntegralFlux =
#  -_diffusion_coef[_qp]*_grad_u[_qp]*_normals[_qp] where the diffusion coefficient
# here is thermal conductivity).
# Even though _grad_u[_qp] is small, in this case the diffusion coefficient
# is large. The result is a number that isn&#x27;t exactly zero and tends to
# fail exodiff. For this reason the parameter execute_on = initial should not
# be used. That parameter is left to default settings in these regression tests.
#
[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  file = sphere3D.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]

[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]


[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = SPHERE
    sphere_origin = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 5
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
  [./Console]
    type = Console
  [../]
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fbbc01aa-d91b-4e0e-a0a0-5c4f6dad6e98"><div class="modal-content"><h4>modules/heat_conduction/test/tests/recover/ad_recover.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = recover_in.e
[]

[Variables]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = ADHeatConduction
    variable = temp
  [../]
  [./heat_source]
    type = ADMatHeatSource
    material_property = volumetric_heat
    variable = temp
    scalar = 1e3
    block = pellet_type_1
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 5
    secondary = 10
    emissivity_primary = 0
    emissivity_secondary = 0
    quadrature = true
  [../]
[]

[BCs]
  [./outside]
    type = DirichletBC
    value = 580
    boundary = &#x27;1 2 3&#x27;
    variable = temp
  [../]
  [./edge]
    type = DirichletBC
    value = 700
    boundary = 10
    variable = temp
  [../]
[]

[Materials]
  [./volumetric_heat]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;volumetric_heat&#x27;
    prop_values = &#x27;t&#x27;
  [../]
  [./thermal_3]
    type = ADHeatConductionMaterial
    block = 3
    thermal_conductivity = 5
    specific_heat = 12
  [../]
  [./thermal_1]
    type = ADHeatConductionMaterial
    block = 1
    thermal_conductivity = 16.0
    specific_heat = 330.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27; lu       superlu_dist&#x27;

  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-11

  start_time = -200
  n_startup_steps = 1
  end_time = 1.02e5
  num_steps = 10

  dtmax = 2e6
  dtmin = 1

  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 2.0e2
    optimal_iterations = 15
    iteration_window = 2
  [../]

  [./Quadrature]
    order = FIFTH
    side_order = SEVENTH
  [../]
[]

[Postprocessors]
  [./ave_temp_interior]
     type = SideAverageValue
     boundary = 9
     variable = temp
     execute_on = &#x27;initial linear&#x27;
  [../]
  [./avg_clad_temp]
    type = SideAverageValue
    boundary = 7
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./flux_from_clad]
    type = ADSideFluxIntegral
    variable = temp
    boundary = 5
    diffusivity = thermal_conductivity
  [../]
  [./_dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="081b9b45-f703-432b-8b64-be2fb9a82a25"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/rz.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (2) with an interior cavity of volume 8.
#   Block 1 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts T in the following way:
#   T =&gt; T0 + beta * t
# with
#   beta = T0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# At t = 1, p = 200.

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Mesh]
  file = rz.e
[]

[Functions]
  [./temperature]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 2&#x27;
    scale_factor = 240.54443866068704
  [../]
[]

[Variables]
  [./disp_r]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_r
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    preset = false
    boundary = 2
    function = temperature
    variable = temp
  [../]
  [./CavityPressure]
    [./1]
      boundary = 2
      initial_pressure = 100
      R = 8.314472
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elastic_tensor1]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 1
  [../]
  [./strain1]
    type = ADComputeAxisymmetricRZFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elastic_tensor2]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 2
  [../]
  [./strain2]
    type = ADComputeAxisymmetricRZFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_abs_tol = 1e-10

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 2
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = true
  [./checkpoint]
    type = Checkpoint
    num_files = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e0037026-1a34-49eb-8fb2-6a2f31e0e46a"><div class="modal-content"><h4>test/tests/userobjects/side_user_object_no_boundary_error/side_no_boundary.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Postprocessors]
  [./avg]
    type = SideAverageValue
    variable = u
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="88307cf1-a6b7-44aa-beeb-57acb7046641"><div class="modal-content"><h4>modules/combined/test/tests/phase_field_fracture/crack2d_computeCrackedStress_smallstrain.i</h4><pre class="moose-pre"><code class="language-text">#This input uses PhaseField-Nonconserved Action to add phase field fracture bulk rate kernels
[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 40
    ny = 20
    ymax = 0.5
  []
  [./noncrack]
    type = BoundingBoxNodeSetGenerator
    new_boundary = noncrack
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 0 0&#x27;
    input = gen
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[AuxVariables]
  [./strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./All]
        add_variables = true
        strain = SMALL
        planar_formulation = PLANE_STRAIN
        additional_generate_output = &#x27;stress_yy&#x27;
        strain_base_name = uncracked
      [../]
    [../]
  [../]
  [./PhaseField]
    [./Nonconserved]
      [./c]
        free_energy = E_el
        kappa = kappa_op
        mobility = L
      [../]
    [../]
  [../]
[]

[Kernels]
  [./solid_x]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_x
    component = 0
    c = c
  [../]
  [./solid_y]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_y
    component = 1
    c = c
  [../]
  [./off_disp]
    type = AllenCahnElasticEnergyOffDiag
    variable = c
    displacements = &#x27;disp_x disp_y&#x27;
    mob_name = L
  [../]
[]

[AuxKernels]
  [./strain_yy]
    type = RankTwoAux
    variable = strain_yy
    rank_two_tensor = uncracked_mechanical_strain
    index_i = 1
    index_j = 1
  [../]
[]

[BCs]
  [./ydisp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = &#x27;t&#x27;
  [../]
  [./yfix]
    type = DirichletBC
    variable = disp_y
    boundary = noncrack
    value = 0
  [../]
  [./xfix]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0
  [../]
[]

[Materials]
  [./pfbulkmat]
    type = GenericConstantMaterial
    prop_names = &#x27;gc_prop l visco&#x27;
    prop_values = &#x27;1e-3 0.05 1e-6&#x27;
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;127.0 70.8 70.8 127.0 70.8 127.0 73.55 73.55 73.55&#x27;
    fill_method = symmetric9
    base_name = uncracked
    euler_angle_1 = 30
    euler_angle_2 = 0
    euler_angle_3 = 0
  [../]
  [./elastic]
    type = ComputeLinearElasticStress
    base_name = uncracked
  [../]
  [./cracked_stress]
    type = ComputeCrackedStress
    c = c
    kdamage = 1e-6
    F_name = E_el
    use_current_history_variable = true
    uncracked_base_name = uncracked
  [../]
[]

[Postprocessors]
  [./av_stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./av_strain_yy]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solving_package&#x27;
  petsc_options_value = &#x27;lu superlu_dist&#x27;

  nl_rel_tol = 1e-8
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 10

  dt = 5e-5
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e9856807-62ca-46d9-b604-20db2e320be4"><div class="modal-content"><h4>modules/heat_conduction/test/tests/ad_convective_heat_flux/equilibrium.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
[]

[Variables]
  [./temp]
    initial_condition = 200.0
  [../]
[]

[Kernels]
  [./heat_dt]
    type = ADTimeDerivative
    variable = temp
  [../]
  [./heat_conduction]
    type = ADDiffusion
    variable = temp
  [../]
[]

[BCs]
  [./right]
    type = ADConvectiveHeatFluxBC
    variable = temp
    boundary = &#x27;right&#x27;
    T_infinity = 100.0
    heat_transfer_coefficient = 1
  [../]
[]

[Postprocessors]
  [./left_temp]
    type = SideAverageValue
    variable = temp
    boundary = left
    execute_on = &#x27;TIMESTEP_END initial&#x27;
  [../]
  [./right_temp]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./right_flux]
    type = SideFluxAverage
    variable = temp
    boundary = right
    diffusivity = 1
  [../]
[]

[Executioner]
  type = Transient

  num_steps = 10
  dt = 1e1

  nl_abs_tol = 1e-12
[]

[Outputs]
  [./out]
    type = CSV
    interval = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d60f4c8d-0a5b-49c4-9b80-b4bddf8fb56b"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/additional_volume.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
# p = n * R * / (V_cavity / T_cavity + V_add / T_add)
# where
#  p is the pressure
#  n is the amount of material in the volume (moles)
#  R is the universal gas constant
#  T_cavity is the temperature in the cavity
#  T_add is the temperature of the additional volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7. An additional volume of 2 is added.
#
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V_cavity0 + gamma * t + V_add
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = -(0.003322259...) * V0
#   T0 = 240.54443866068704
#   V_cavity0 = 7
#   V_add = 2
#   T_add = 100
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
#  An additional volume of 2 with a temperature of 100.0 is included.
#
# So, n0 = p0 * (V_cavity / T_cavity + V_add / T_add) / R
#        = 100 * (7 / 240.544439 + 2 / 100) / 8.314472
#        = 0.59054
#
# The parameters combined at t = 1 gives p = 249.647.
#
# This test sets the initial temperature to 500, but the CavityPressure
#   is told that that initial temperature is T0.  Thus, the final solution
#   is unchanged.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3d.e
[]

[GlobalParams]
  volumetric_locking_correction = true
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.59054&#x27;
  [../]
  [./additional_volume]
    type = ConstantFunction
    value = 2
  [../]
  [./temperature_of_additional_volume]
    type = ConstantFunction
    value = 100
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 500
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = Diffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = FunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      initial_temperature = 240.54443866068704
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      additional_volumes = volume1
      temperature_of_additional_volumes = temperature1
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 1
  [../]
  [./strain1]
    type = ComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 2
  [../]
  [./strain2]
    type = ComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0

  snesmf_reuse_base = false
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
  [./volume1]
    type = FunctionValuePostprocessor
    function = additional_volume
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./temperature1]
    type = FunctionValuePostprocessor
    function = temperature_of_additional_volume
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4488050e-aa6f-4bb4-9927-6a9573b26ae7"><div class="modal-content"><h4>test/tests/postprocessors/side_average_value/side_average_value_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = 0
  xmax = 2
  ymin = 0
  ymax = 1
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Postprocessors]
  [./average]
    type = SideAverageValue
    boundary = 0
    variable = u
  [../]
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1e346a17-ffc2-477e-bf0e-2189a14c0549"><div class="modal-content"><h4>modules/combined/test/tests/phase_field_fracture/crack2d_aniso_hist_false.i</h4><pre class="moose-pre"><code class="language-text">#This input uses PhaseField-Nonconserved Action to add phase field fracture bulk rate kernels
[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 40
    ny = 20
    ymax = 0.5
  []
  [./noncrack]
    type = BoundingBoxNodeSetGenerator
    new_boundary = noncrack
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 0 0&#x27;
    input = gen
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./All]
        add_variables = true
        strain = SMALL
        additional_generate_output = &#x27;strain_yy stress_yy&#x27;
        planar_formulation = PLANE_STRAIN
      [../]
    [../]
  [../]
  [./PhaseField]
    [./Nonconserved]
      [./c]
        free_energy = F
        kappa = kappa_op
        mobility = L
      [../]
    [../]
  [../]
[]

[Kernels]
  [./solid_x]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_x
    component = 0
    c = c
  [../]
  [./solid_y]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_y
    component = 1
    c = c
  [../]
[]

[BCs]
  [./ydisp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = &#x27;t&#x27;
  [../]
  [./yfix]
    type = DirichletBC
    variable = disp_y
    boundary = noncrack
    value = 0
  [../]
  [./xfix]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0
  [../]
[]

[Materials]
  [./pfbulkmat]
    type = GenericConstantMaterial
    prop_names = &#x27;gc_prop l visco&#x27;
    prop_values = &#x27;1e-3 0.05 1e-6&#x27;
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;127.0 70.8 70.8 127.0 70.8 127.0 73.55 73.55 73.55&#x27;
    fill_method = symmetric9
    euler_angle_1 = 30
    euler_angle_2 = 0
    euler_angle_3 = 0
  [../]
  [./define_mobility]
    type = ParsedMaterial
    material_property_names = &#x27;gc_prop visco&#x27;
    f_name = L
    function = &#x27;1.0/(gc_prop * visco)&#x27;
  [../]
  [./define_kappa]
    type = ParsedMaterial
    material_property_names = &#x27;gc_prop l&#x27;
    f_name = kappa_op
    function = &#x27;gc_prop * l&#x27;
  [../]
  [./damage_stress]
    type = ComputeLinearElasticPFFractureStress
    c = c
    E_name = &#x27;elastic_energy&#x27;
    D_name = &#x27;degradation&#x27;
    F_name = &#x27;local_fracture_energy&#x27;
    decomposition_type = stress_spectral
  [../]
  [./degradation]
    type = DerivativeParsedMaterial
    f_name = degradation
    args = &#x27;c&#x27;
    function = &#x27;(1.0-c)^2*(1.0 - eta) + eta&#x27;
    constant_names       = &#x27;eta&#x27;
    constant_expressions = &#x27;1.0e-6&#x27;
    derivative_order = 2
  [../]
  [./local_fracture_energy]
    type = DerivativeParsedMaterial
    f_name = local_fracture_energy
    args = &#x27;c&#x27;
    material_property_names = &#x27;gc_prop l&#x27;
    function = &#x27;c^2 * gc_prop / 2 / l&#x27;
    derivative_order = 2
  [../]
  [./fracture_driving_energy]
    type = DerivativeSumMaterial
    args = c
    sum_materials = &#x27;elastic_energy local_fracture_energy&#x27;
    derivative_order = 2
    f_name = F
  [../]
[]

[Postprocessors]
  [./av_stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./av_strain_yy]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solving_package&#x27;
  petsc_options_value = &#x27;lu superlu_dist&#x27;

  nl_rel_tol = 1e-8
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 10

  dt = 2e-6
  num_steps = 5
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8bd9ce30-fe7e-4a0f-9b55-f0e320ff4966"><div class="modal-content"><h4>test/tests/userobjects/interface_user_object/interface_value_user_object_QP.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 2
    xmax = 2
    ny = 2
    ymax = 2
  []
  [./subdomain1]
    input = gen
    type = SubdomainBoundingBoxGenerator
    bottom_left = &#x27;0 0 0&#x27;
    top_right = &#x27;1 1 0&#x27;
    block_id = 1
  [../]
  [./primary0_interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = subdomain1
    primary_block = &#x27;0&#x27;
    paired_block = &#x27;1&#x27;
    new_boundary = &#x27;primary0_interface&#x27;
  [../]
  [./break_boundary]
    input = primary0_interface
    type = BreakBoundaryOnSubdomainGenerator
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    block = 0
  [../]

  [./v]
    order = FIRST
    family = LAGRANGE
    block = 1
  [../]
[]

[Kernels]
  [./diff_u]
    type = CoeffParamDiffusion
    variable = u
    D = 2
    block = 0
  [../]
  [./diff_v]
    type = CoeffParamDiffusion
    variable = v
    D = 4
    block = 1
  [../]
  [./source_u]
    type = BodyForce
    variable = u
    function = 0.1*t
  [../]
[]

[InterfaceKernels]
  [./primary0_interface]
    type = PenaltyInterfaceDiffusionDot
    variable = u
    neighbor_var = v
    boundary = primary0_interface
    penalty = 1e6
  [../]
[]

[BCs]
  [./u]
    type = VacuumBC
    variable = u
    boundary = &#x27;left_to_0 bottom_to_0 right top&#x27;
  [../]
  [./v]
    type = VacuumBC
    variable = v
    boundary = &#x27;left_to_1 bottom_to_1&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = TRUE
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  dt = 0.1
  num_steps = 3
  dtmin = 0.1
  line_search = none
[]

[Outputs]
  [./out]
    type = Exodus
    sync_only = true
    sync_times = &#x27;0.1 0.2 0.3&#x27;
    execute_on = &#x27;TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [./interface_value_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = average
  [../]
  [./interface_primary_minus_secondary_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = jump_primary_minus_secondary
  [../]
  [./interface_secondary_minus_primary_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = jump_secondary_minus_primary
  [../]
  [./interface_absolute_jump_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = jump_abs
  [../]
  [./interface_primary_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = primary
  [../]
  [./interface_secondary_uo]
    type = InterfaceQpValueUserObject
    var = diffusivity_1
    var_neighbor = diffusivity_2
    boundary = &#x27;primary0_interface&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
    interface_value_type = secondary
  [../]
[]


[Materials]
  [./stateful1]
    type = StatefulMaterial
    block = 0
    initial_diffusivity = 5
  [../]
  [./stateful2]
    type = StatefulMaterial
    block = 1
    initial_diffusivity = 2
  [../]
[]

[AuxKernels]
  [./diffusivity_1]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_1
    execute_on = &#x27;INITIAL  NONLINEAR&#x27;
  []
  [./diffusivity_2]
    type = MaterialRealAux
    property = diffusivity
    variable = diffusivity_2
    execute_on = &#x27;INITIAL NONLINEAR&#x27;
  []
  [./interface_avg_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = avg_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_value_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [./interface_primary_minus_secondary_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = primary_minus_secondary_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_primary_minus_secondary_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./interface_secondary_minus_primary_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = secondary_minus_primary_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_secondary_minus_primary_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./interface_absolute_jump_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = abs_jump_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_absolute_jump_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./interface_primary_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = primary_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_primary_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./interface_secondary_qp_aux]
    type = InterfaceValueUserObjectAux
    variable = secondary_qp
    boundary = &#x27;primary0_interface&#x27;
    interface_uo_name = interface_secondary_uo
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]


[]

[AuxVariables]
  [./diffusivity_1]
    family = MONOMIAL
    order = CONSTANT
  []
  [./diffusivity_2]
    family = MONOMIAL
    order = CONSTANT
  []
  [./avg_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./primary_minus_secondary_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./secondary_minus_primary_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./abs_jump_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./primary_qp]
    family = MONOMIAL
    order = CONSTANT
  []
  [./secondary_qp]
    family = MONOMIAL
    order = CONSTANT
  []
[]



[Postprocessors]
  [./interface_average_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  avg_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./primary_minus_secondary_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  primary_minus_secondary_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./secondary_minus_primary_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  secondary_minus_primary_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./abs_jump_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  abs_jump_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./primary_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  primary_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
  [./secondary_qp_PP]
    type = SideAverageValue
    boundary = &#x27;primary0_interface&#x27;
    variable =  secondary_qp
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="168e686c-5c1f-4684-91b9-95735913f2ce"><div class="modal-content"><h4>modules/tensor_mechanics/tutorials/basics/part_2.4.i</h4><pre class="moose-pre"><code class="language-text">#Tensor Mechanics tutorial: the basics
#Step 2, part 4
#2D axisymmetric RZ simulation of uniaxial tension with J2 plasticity with
#hardening

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = necking_quad4.e
  uniform_refine = 0
  second_order = true
[]

[Modules/TensorMechanics/Master]
  [./block1]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_yy strain_yy vonmises_stress&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeMultiPlasticityStress
    ep_plastic_tolerance = 1e-9
    plastic_models = J2
  [../]
[]

[UserObjects]
  [./hardening]
    type = TensorMechanicsHardeningCubic
    value_0 = 2.4e2
    value_residual = 3.0e2
    internal_0 = 0
    internal_limit = 0.005
  [../]
  [./J2]
    type = TensorMechanicsPlasticJ2
    yield_strength = hardening
    yield_function_tolerance = 1E-9
    internal_constraint_tolerance = 1E-9
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_r
    boundary = left
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]
  [./top]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = top
    function = &#x27;0.0007*t&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.25
  end_time = 20

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;asm lu 1 101&#x27;
[]

[Postprocessors]
  [./ave_stress_bottom]
    type = SideAverageValue
    variable = stress_yy
    boundary = bottom
  [../]
  [./ave_strain_bottom]
    type = SideAverageValue
    variable = strain_yy
    boundary = bottom
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
  csv = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="71ed71c6-ad7c-4d21-b166-c3d50faa871d"><div class="modal-content"><h4>tutorials/darcy_thermo_mech/step10_multiapps/problems/step10_micro.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  ymax = 0.1
  xmax = 0.1
  uniform_refine = 0
[]

[Adaptivity]
  max_h_level = 4
  initial_steps = 6
  initial_marker = error_marker
  cycles_per_step = 2
  marker = error_marker
  [Indicators]
    [phi_jump]
      type = GradientJumpIndicator
      variable = phi
    []
  []
  [Markers]
    [error_marker]
      type = ErrorFractionMarker
      indicator = phi_jump
      refine = 0.8
      coarsen = 0.1
    []
  []
[]

[Variables]
  [temperature]
    initial_condition = 300
  []
[]

[AuxVariables]
  [phi]
  []
  [por_var]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[AuxKernels]
  [corrosion]
    type = RandomCorrosion
    variable = phi
    reference_temperature = 300
    temperature = temperature_in
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [por_var]
    type = ADMaterialRealAux
    variable = por_var
    property = porosity
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Kernels]
  [heat_conduction]
    type = ADHeatConduction
    variable = temperature
  []
[]

[BCs]
  [left]
    type = PostprocessorDirichletBC
    variable = temperature
    boundary = left
    postprocessor = temperature_in
  []
  [right]
    type = NeumannBC
    variable = temperature
    boundary = right
    value = 100 # prescribed flux
  []
[]

[Materials]
  [column]
    type = PackedColumn
    temperature = temperature
    radius = 1 # mm
    phase = phi
  []
[]

[Postprocessors]
  [temperature_in]
    type = Receiver
    default = 301
  []
  [k_eff]
    type = ThermalConductivity
    variable = temperature
    T_hot = temperature_in
    flux = 100
    dx = 0.1
    boundary = right
    length_scale = 1
    k0 = 12.05
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [por_var]
    type = ElementAverageValue
    variable = por_var
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [t_right]
    type = SideAverageValue
    boundary = right
    variable = temperature
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Transient
  end_time = 1000
  dt = 1
  steady_state_tolerance = 1e-9
  steady_state_detection = true
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  automatic_scaling = true
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
[]

[ICs]
  [close_pack]
    radius = 0.01 # meter
    outvalue = 0  # water
    variable = phi
    invalue = 1   # steel
    type = ClosePackIC
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="51793287-d0a2-474c-b9d0-d7c0f40b6da1"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/gtn_single.i</h4><pre class="moose-pre"><code class="language-text"># This test provides an example of an individual GTN viscoplasticity model

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmax = 0.002
  ymax = 0.002
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  base_name = &#x27;total&#x27;
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
    base_name = &#x27;total&#x27;
  [../]
  [./stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = gtn
    initial_porosity = 0.1
    outputs = all
    base_name = &#x27;total&#x27;
  [../]

  [./gtn]
    type = ADViscoplasticityStressUpdate
    total_strain_base_name = &#x27;total&#x27;
    coefficient = &#x27;coef&#x27;
    power = 3
    viscoplasticity_model = GTN
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./coef]
    type = ADParsedMaterial
    f_name = coef
    # Example of creep power law
    function = &#x27;1e-18 * exp(-4e4 / 1.987 / 1200)&#x27;
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = total_hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = total_vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./eff_creep_strain]
    type = ElementAverageValue
    variable = effective_viscoplasticity
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c87dc999-7531-4c5d-b163-323a49beb26b"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_dual.i</h4><pre class="moose-pre"><code class="language-text"># This test provides an example of combining two LPS viscoplasticity models with different stress
# exponents.

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmax = 0.002
  ymax = 0.002
[]

[Variables]
  [./temp]
    initial_condition = 1000
  [../]
[]

[Kernels]
  [./dt]
    type = ADTimeDerivative
    variable = temp
  [../]
  [./diff]
    type = ADDiffusion
    variable = temp
  [../]
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
  [./tot_effective_viscoplasticity]
    type = ParsedFunction
    vals = &#x27;lps_1_eff_creep_strain lps_3_eff_creep_strain&#x27;
    vars = &#x27;lps_1_eff_creep_strain lps_3_eff_creep_strain&#x27;
    value = &#x27;lps_1_eff_creep_strain+lps_3_eff_creep_strain&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = &#x27;one two&#x27;
    initial_porosity = 0.1
    outputs = all
  [../]

  [./one]
    type = ADViscoplasticityStressUpdate
    coefficient = &#x27;coef_3&#x27;
    power = 3
    base_name = &#x27;lps_1&#x27;
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./two]
    type = ADViscoplasticityStressUpdate
    coefficient = 1e-10
    power = 1
    base_name = &#x27;lps_3&#x27;
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./coef]
    type = ADParsedMaterial
    f_name = coef_3
    # Example of creep power law
    args = temp
    function = &#x27;0.5e-18 * exp(-4e4 / 1.987 / temp)&#x27;
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
  [./temp_ramp]
    type = ADFunctionDirichletBC
    boundary = right
    function = &#x27;1000 + 400 * t / 0.12&#x27;
    variable = temp
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./lps_1_eff_creep_strain]
    type = ElementAverageValue
    variable = lps_1_effective_viscoplasticity
  [../]
  [./lps_3_eff_creep_strain]
    type = ElementAverageValue
    variable = lps_3_effective_viscoplasticity
  [../]
  [./lps_1_gauge_stress]
    type = ElementAverageValue
    variable = lps_1_gauge_stress
  [../]
  [./lps_3_gauge_stress]
    type = ElementAverageValue
    variable = lps_3_gauge_stress
  [../]
  [./eff_creep_strain_tot]
    type = FunctionValuePostprocessor
    function = tot_effective_viscoplasticity
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="822e4a78-3a77-499e-b64b-c75ab46ea77c"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/planar_xy.i</h4><pre class="moose-pre"><code class="language-text"># 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks in the x-y plane.  Each element block
# is a square. They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
# across each block. The temperature of the far bottom boundary
# is ramped from 100 to 200 over one time unit.  The temperature of the far top
# boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
# Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
# gapK(Tavg) = 1.0*Tavg
#
# The heat flux across the gap at time = 1 is then:
#
# Flux = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors.  These results
# are the same as for the unit 1-D gap heat transfer between two unit cubes.



[Mesh]
  file = simple_2D.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_bottom]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_top]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-14
  l_tol = 1e-3
  l_max_its = 100

  dt = 1e-1
  end_time = 1.0
[]

[Postprocessors]
  [./temp_bottom]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_top]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_bottom]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_top]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4709ef71-fbc3-40ae-9a9f-f0508a564bdb"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/radial_disp_aux/cylinder_2d_cartesian.i</h4><pre class="moose-pre"><code class="language-text"># The purpose of this set of tests is to check the values computed
# by the RadialDisplacementAux AuxKernel. They should match the
# radial component of the displacment for a cylindrical or spherical
# model.
# This particular model is of a cylinder subjected to uniform thermal
# expansion represented using a 2D Cartesian model.

[Mesh]
  type = FileMesh
  file = circle_sector_2d.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  order = SECOND
  family = LAGRANGE
[]

[AuxVariables]
  [./temp]
  [../]
  [./rad_disp]
  [../]
[]

[Functions]
  [./temperature_load]
    type = ParsedFunction
    value = t+300.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = temperature_load
    use_displaced_mesh = false
  [../]
  [./raddispaux]
    type = RadialDisplacementCylinderAux
    variable = rad_disp
    origin = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    stress_free_temperature = 300
    thermal_expansion_coeff = 1.3e-5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;51&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 50
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  end_time = 1
  dt = 1
  dtmin = 1
[]

[Outputs]
 csv = true
 exodus = true
[]

#[Postprocessors]
#  [./strain_xx]
#    type = SideAverageValue
#    variable =
#    block = 0
#  [../]
#[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="6bd37da7-96b2-4267-b2fe-a67ca0957305"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/thermal_expansion_function/dilatation.i</h4><pre class="moose-pre"><code class="language-text"># This test checks the thermal expansion calculated via an dilatation function.
# The coefficient is selected so as to result in a 1e-4 strain in the x-axis, and to cross over
# from positive to negative strain.

[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = &#x27;1 + t&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ComputeDilatationThermalExpansionFunctionEigenstrain
    dilatation_function = cte_dilatation
    stress_free_temperature = 1.5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_dilatation]
    type = PiecewiseLinear
    x = &#x27;1 2&#x27;
    y = &#x27;-1e-4 1e-4&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x_max]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./temp_avg]
    type = ElementAverageValue
    variable = temp
  [../]
[]

[Executioner]
  type = Transient

  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d9ef1cc0-dea4-44cc-a9d8-90fa44f2601b"><div class="modal-content"><h4>modules/heat_conduction/test/tests/convective_heat_flux/coupled.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
[]

[Variables]
  [./temp]
    initial_condition = 200.0
  [../]
[]

[Kernels]
  [./heat_dt]
    type = TimeDerivative
    variable = temp
  [../]
  [./heat_conduction]
    type = Diffusion
    variable = temp
  [../]
  [./heat]
    type = BodyForce
    variable = temp
    value = 0
  [../]
[]

[BCs]
  [./right]
    type = ConvectiveHeatFluxBC
    variable = temp
    boundary = &#x27;right&#x27;
    T_infinity = T_inf
    heat_transfer_coefficient = htc
    heat_transfer_coefficient_dT = dhtc_dT
  [../]
[]

[Materials]
  [./T_inf]
    type = ParsedMaterial
    f_name = T_inf
    args = temp
    function = &#x27;temp + 1&#x27;
  [../]
  [./htc]
    type = ParsedMaterial
    f_name = htc
    args = temp
    function = &#x27;temp / 100 + 1&#x27;
  [../]
  [./dhtc_dT]
    type = ParsedMaterial
    f_name = dhtc_dT
    args = temp
    function = &#x27;1 / 100&#x27;
  [../]
[]

[Postprocessors]
  [./left_temp]
    type = SideAverageValue
    variable = temp
    boundary = left
    execute_on = &#x27;TIMESTEP_END initial&#x27;
  [../]
  [./right_temp]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./right_flux]
    type = SideFluxAverage
    variable = temp
    boundary = right
    diffusivity = 1
  [../]
[]

[Executioner]
  type = Transient

  num_steps = 10
  dt = 1

  nl_abs_tol = 1e-12
[]

[Outputs]
  [./out]
    type = CSV
    interval = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="43caccd2-5dfc-4e17-8b38-d46a2f4b549a"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/cyl3D.i</h4><pre class="moose-pre"><code class="language-text">#
# 3D Cylindrical Gap Heat Transfer Test.
#
# This test exercises 3D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid cylinder of radius = 1 unit, and outer
# hollow cylinder with an inner radius of 2. In other words, the gap between
# them is 1 radial unit in length.
#
# The conductivity of both cylinders is set very large to achieve a uniform
# temperature in each cylinder. The temperature of the center node of the
# inner cylinder is ramped from 100 to 200 over one time unit. The temperature
# of the outside of the outer, hollow cylinder is held fixed at 100.
#
# A simple analytical solution is possible for the integrated heat flux
# between the inner and outer cylinders:
#
#  Integrated Flux = (T_left - T_right) * (gapK/(r*ln(r2/r1))) * Area
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 2 * pi * h * r, where h is the height of the cylinder.
#
# The integrated heat flux across the gap at time 1 is then:
#
# 2*pi*h*k*delta_T/(ln(r2/r1))
# 2*pi*1*1*100/(ln(2/1)) = 906.5 watts
#
# For comparison, see results from the integrated flux post processors.
# This simulation makes use of symmetry, so only 1/4 of the cylinders is meshed
# As such, the integrated flux from the post processors is 1/4 of the total,
# or 226.6 watts.
# The value coming from the post processor is slightly less than this
# but converges as mesh refinement increases.
#
# Simulating contact is challenging. Regression tests that exercise
# contact features can be difficult to solve consistently across multiple
# platforms. While designing these tests, we felt it worth while to note
# some aspects of these tests. The following applies to:
# sphere3D.i, sphere2DRZ.i, cyl2D.i, and cyl3D.i.
# 1. We decided that to perform consistently across multiple platforms we
# would use very small convergence tolerance. In this test we chose an
# nl_rel_tol of 1e-12.
# 2. Due to such a high value for thermal conductivity (used here so that the
# domains come to a uniform temperature) the integrated flux at time = 0
# was relatively large (the value coming from SideIntegralFlux =
#  -_diffusion_coef[_qp]*_grad_u[_qp]*_normals[_qp] where the diffusion coefficient
# here is thermal conductivity).
# Even though _grad_u[_qp] is small, in this case the diffusion coefficient
# is large. The result is a number that isn&#x27;t exactly zero and tends to
# fail exodiff. For this reason the parameter execute_on = initial should not
# be used. That parameter is left to default settings in these regression tests.
#
 [GlobalParams]
  order = SECOND
  family = LAGRANGE
  []


[Mesh]
  file = cyl3D.e
[]

[Functions]

  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]

[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]


[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]

[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = CYLINDER
    cylinder_axis_point_1 = &#x27;0 0 0&#x27;
    cylinder_axis_point_2 = &#x27;0 1 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 5
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]

[]

[Outputs]
  exodus = true
   [./Console]
    type = Console
   [../]
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="34155176-fa7c-4fa9-b107-aa0c9af94bc6"><div class="modal-content"><h4>modules/combined/examples/phase_field-mechanics/kks_mechanics_VTS.i</h4><pre class="moose-pre"><code class="language-text"># KKS phase-field model coupled with elasticity using the Voigt-Taylor scheme as
# described in L.K. Aagesen et al., Computational Materials Science, 140, 10-21 (2017)
# Original run #170329e

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 640
  ny = 1
  nz = 1
  xmin = -10
  xmax = 10
  ymin = 0
  ymax = 0.03125
  zmin = 0
  zmax = 0.03125
  elem_type = HEX8
[]


[Variables]
  # order parameter
  [./eta]
    order = FIRST
    family = LAGRANGE
  [../]

  # solute concentration
  [./c]
    order = FIRST
    family = LAGRANGE
  [../]

  # chemical potential
  [./w]
    order = FIRST
    family = LAGRANGE
  [../]

  # solute phase concentration (matrix)
  [./cm]
    order = FIRST
    family = LAGRANGE
  [../]
  # solute phase concentration (precipitate)
  [./cp]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./eta_ic]
    variable = eta
    type = FunctionIC
    function = ic_func_eta
    block = 0
  [../]
  [./c_ic]
    variable = c
    type = FunctionIC
    function = ic_func_c
    block = 0
  [../]
  [./w_ic]
    variable = w
    type = ConstantIC
    value = 0.00991
    block = 0
  [../]
  [./cm_ic]
    variable = cm
    type = ConstantIC
    value = 0.131
    block = 0
  [../]
  [./cp_ic]
    variable = cp
    type = ConstantIC
    value = 0.236
    block = 0
  [../]
[]

[Functions]
  [./ic_func_eta]
    type = ParsedFunction
    value = &#x27;0.5*(1.0+tanh((x)/delta_eta/sqrt(2.0)))&#x27;
    vars = &#x27;delta_eta&#x27;
    vals = &#x27;0.8034&#x27;
  [../]
  [./ic_func_c]
    type = ParsedFunction
    value = &#x27;0.2388*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))^3*(6*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))^2-15*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))+10)+0.1338*(1-(0.5*(1.0+tanh(x/delta/sqrt(2.0))))^3*(6*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))^2-15*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))+10))&#x27;
    vars = &#x27;delta&#x27;
    vals = &#x27;0.8034&#x27;
  [../]
  [./psi_eq_int]
    type = ParsedFunction
    value = &#x27;volume*psi_alpha&#x27;
    vars = &#x27;volume psi_alpha&#x27;
    vals = &#x27;volume psi_alpha&#x27;
  [../]
  [./gamma]
    type = ParsedFunction
    value = &#x27;(psi_int - psi_eq_int) / dy / dz&#x27;
    vars = &#x27;psi_int psi_eq_int dy       dz&#x27;
    vals = &#x27;psi_int psi_eq_int 0.03125  0.03125&#x27;
  [../]
[]

[AuxVariables]
  [./sigma11]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./sigma22]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./sigma33]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e11]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e12]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e22]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e33]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_el11]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_el12]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_el22]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./f_el]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./eigen_strain00]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./Fglobal]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./psi]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./matl_sigma11]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = sigma11
  [../]
  [./matl_sigma22]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = sigma22
  [../]
  [./matl_sigma33]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = sigma33
  [../]
  [./matl_e11]
    type = RankTwoAux
    rank_two_tensor = total_strain
    index_i = 0
    index_j = 0
    variable = e11
  [../]
  [./matl_e12]
    type = RankTwoAux
    rank_two_tensor = total_strain
    index_i = 0
    index_j = 1
    variable = e12
  [../]
  [./matl_e22]
    type = RankTwoAux
    rank_two_tensor = total_strain
    index_i = 1
    index_j = 1
    variable = e22
  [../]
  [./matl_e33]
    type = RankTwoAux
    rank_two_tensor = total_strain
    index_i = 2
    index_j = 2
    variable = e33
  [../]
  [./f_el]
    type = MaterialRealAux
    variable = f_el
    property = f_el_mat
    execute_on = timestep_end
  [../]
  [./GlobalFreeEnergy]
    variable = Fglobal
    type = KKSGlobalFreeEnergy
    fa_name = fm
    fb_name = fp
    w = 0.0264
    kappa_names = kappa
    interfacial_vars = eta
  [../]
  [./psi_potential]
    variable = psi
    type = ParsedAux
    args = &#x27;Fglobal w c f_el sigma11 e11&#x27;
    function = &#x27;Fglobal - w*c + f_el - sigma11*e11&#x27;
  [../]
[]


[BCs]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0
  [../]
  [./front_y]
    type = DirichletBC
    variable = disp_y
    boundary = front
    value = 0
  [../]
  [./back_y]
    type = DirichletBC
    variable = disp_y
    boundary = back
    value = 0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value = 0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0
  [../]
[]

[Materials]
  # Chemical free energy of the matrix
  [./fm]
    type = DerivativeParsedMaterial
    f_name = fm
    args = &#x27;cm&#x27;
    function = &#x27;6.55*(cm-0.13)^2&#x27;
  [../]
# Elastic energy of the matrix
  [./elastic_free_energy_m]
    type = ElasticEnergyMaterial
    base_name = matrix
    f_name = fe_m
    args = &#x27; &#x27;
    outputs = exodus
  [../]
# Total free energy of the matrix
  [./Total_energy_matrix]
    type = DerivativeSumMaterial
    f_name = f_total_matrix
    sum_materials = &#x27;fm fe_m&#x27;
    args = &#x27;cm&#x27;
  [../]

  # Free energy of the precipitate phase
  [./fp]
    type = DerivativeParsedMaterial
    f_name = fp
    args = &#x27;cp&#x27;
    function = &#x27;6.55*(cp-0.235)^2&#x27;
  [../]

# Elastic energy of the precipitate
  [./elastic_free_energy_p]
    type = ElasticEnergyMaterial
    base_name = ppt
    f_name = fe_p
    args = &#x27; &#x27;
    outputs = exodus
  [../]

# Total free energy of the precipitate
  [./Total_energy_ppt]
    type = DerivativeSumMaterial
    f_name = f_total_ppt
    sum_materials = &#x27;fp fe_p&#x27;
    args = &#x27;cp&#x27;
  [../]

  # Total elastic energy
    [./Total_elastic_energy]
      type = DerivativeTwoPhaseMaterial
      eta = eta
      f_name = f_el_mat
      fa_name = fe_m
      fb_name = fe_p
      outputs = exodus
      W = 0
    [../]

  # h(eta)
  [./h_eta]
    type = SwitchingFunctionMaterial
    h_order = HIGH
    eta = eta
  [../]

  # g(eta)
  [./g_eta]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta
  [../]

  # constant properties
  [./constants]
    type = GenericConstantMaterial
    prop_names  = &#x27;M   L   kappa     misfit&#x27;
    prop_values = &#x27;0.7 0.7 0.01704   0.00377&#x27;
  [../]

  #Mechanical properties
  [./Stiffness_matrix]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;103.3 74.25 74.25 103.3 74.25 103.3 46.75 46.75 46.75&#x27;
    base_name = matrix
    fill_method = symmetric9
  [../]
  [./Stiffness_ppt]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;100.7 71.45 71.45 100.7 71.45 100.7 50.10 50.10 50.10&#x27;
    base_name = ppt
    fill_method = symmetric9
  [../]
  [./stress_matrix]
    type = ComputeLinearElasticStress
    base_name = matrix
  [../]
  [./stress_ppt]
    type = ComputeLinearElasticStress
    base_name = ppt
  [../]
  [./strain_matrix]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    base_name = matrix
  [../]
  [./strain_ppt]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    base_name = ppt
    eigenstrain_names = &#x27;eigenstrain_ppt&#x27;
  [../]
  [./eigen_strain]
    type = ComputeEigenstrain
    base_name = ppt
    eigen_base = &#x27;1 1 1 0 0 0&#x27;
    prefactor = misfit
    eigenstrain_name = &#x27;eigenstrain_ppt&#x27;
  [../]
  [./global_stress]
    type = TwoPhaseStressMaterial
    base_A = matrix
    base_B = ppt
  [../]
  [./global_strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  # enforce c = (1-h(eta))*cm + h(eta)*cp
  [./PhaseConc]
    type = KKSPhaseConcentration
    ca       = cm
    variable = cp
    c        = c
    eta      = eta
  [../]

  # enforce pointwise equality of chemical potentials
  [./ChemPotVacancies]
    type = KKSPhaseChemicalPotential
    variable = cm
    cb       = cp
    fa_name  = f_total_matrix
    fb_name  = f_total_ppt
  [../]

  #
  # Cahn-Hilliard Equation
  #
  [./CHBulk]
    type = KKSSplitCHCRes
    variable = c
    ca       = cm
    fa_name  = f_total_matrix
    w        = w
  [../]

  [./dcdt]
    type = CoupledTimeDerivative
    variable = w
    v = c
  [../]
  [./ckernel]
    type = SplitCHWRes
    mob_name = M
    variable = w
  [../]

  #
  # Allen-Cahn Equation
  #
  [./ACBulkF]
    type = KKSACBulkF
    variable = eta
    fa_name  = f_total_matrix
    fb_name  = f_total_ppt
    w        = 0.0264
    args = &#x27;cp cm&#x27;
  [../]
  [./ACBulkC]
    type = KKSACBulkC
    variable = eta
    ca       = cm
    cb       = cp
    fa_name  = f_total_matrix
  [../]
  [./ACInterface]
    type = ACInterface
    variable = eta
    kappa_name = kappa
  [../]
  [./detadt]
    type = TimeDerivative
    variable = eta
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;

  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-8
  nl_abs_tol = 1.0e-11
  num_steps = 200

  [./TimeStepper]
    type = SolutionTimeAdaptiveDT
    dt = 0.5
  [../]
[]

[VectorPostprocessors]
  #[./eta]
  #  type =  LineValueSampler
  #  start_point = &#x27;-10 0 0&#x27;
  #  end_point = &#x27;10 0 0&#x27;
  #  variable = eta
  #  num_points = 321
  #  sort_by =  id
  #[../]
  #[./eta_position]
  #  type = FindValueOnLineSample
  #  vectorpostprocessor = eta
  #  variable_name = eta
  #  search_value = 0.5
  #[../]
#  [./f_el]
#    type =  LineMaterialRealSampler
#    start = &#x27;-20 0 0&#x27;
#    end   = &#x27;20 0 0&#x27;
#    sort_by = id
#    property = f_el
#  [../]
#  [./f_el_a]
#    type =  LineMaterialRealSampler
#    start = &#x27;-20 0 0&#x27;
#    end   = &#x27;20 0 0&#x27;
#    sort_by = id
#    property = fe_m
#  [../]
#  [./f_el_b]
#    type =  LineMaterialRealSampler
#    start = &#x27;-20 0 0&#x27;
#    end   = &#x27;20 0 0&#x27;
#    sort_by = id
#    property = fe_p
#  [../]
#  [./h_out]
#    type =  LineMaterialRealSampler
#    start = &#x27;-20 0 0&#x27;
#    end   = &#x27;20 0 0&#x27;
#    sort_by = id
#    property = h
#  [../]
#  [./fm_out]
#    type =  LineMaterialRealSampler
#    start = &#x27;-20 0 0&#x27;
#    end   = &#x27;20 0 0&#x27;
#    sort_by = id
#    property = fm
#  [../]
[]

[Postprocessors]
  [./f_el_int]
    type = ElementIntegralMaterialProperty
    mat_prop = f_el_mat
  [../]
  [./c_alpha]
    type =  SideAverageValue
    boundary = left
    variable = c
  [../]
  [./c_beta]
    type =  SideAverageValue
    boundary = right
    variable = c
  [../]
  [./e11_alpha]
    type =  SideAverageValue
    boundary = left
    variable = e11
  [../]
  [./e11_beta]
    type =  SideAverageValue
    boundary = right
    variable = e11
  [../]
  [./s11_alpha]
    type =  SideAverageValue
    boundary = left
    variable = sigma11
  [../]
  [./s22_alpha]
    type =  SideAverageValue
    boundary = left
    variable = sigma22
  [../]
  [./s33_alpha]
    type =  SideAverageValue
    boundary = left
    variable = sigma33
  [../]
  [./s11_beta]
    type =  SideAverageValue
    boundary = right
    variable = sigma11
  [../]
  [./s22_beta]
    type =  SideAverageValue
    boundary = right
    variable = sigma22
  [../]
  [./s33_beta]
    type =  SideAverageValue
    boundary = right
    variable = sigma33
  [../]
  [./f_el_alpha]
    type =  SideAverageValue
    boundary = left
    variable = f_el
  [../]
  [./f_el_beta]
    type =  SideAverageValue
    boundary = right
    variable = f_el
  [../]
  [./f_c_alpha]
    type =  SideAverageValue
    boundary = left
    variable = Fglobal
  [../]
  [./f_c_beta]
    type =  SideAverageValue
    boundary = right
    variable = Fglobal
  [../]
  [./chem_pot_alpha]
    type =  SideAverageValue
    boundary = left
    variable = w
  [../]
  [./chem_pot_beta]
    type =  SideAverageValue
    boundary = right
    variable = w
  [../]
  [./psi_alpha]
    type =  SideAverageValue
    boundary = left
    variable = psi
  [../]
  [./psi_beta]
    type =  SideAverageValue
    boundary = right
    variable = psi
  [../]
  [./total_energy]
    type = ElementIntegralVariablePostprocessor
    variable = Fglobal
  [../]
  # Get simulation cell size from postprocessor
  [./volume]
    type = ElementIntegralMaterialProperty
    mat_prop = 1
  [../]
  [./psi_eq_int]
    type = FunctionValuePostprocessor
    function = psi_eq_int
  [../]
  [./psi_int]
    type = ElementIntegralVariablePostprocessor
    variable = psi
  [../]
  [./gamma]
    type = FunctionValuePostprocessor
    function = gamma
  [../]
[]

#
# Precondition using handcoded off-diagonal terms
#
[Preconditioning]
  [./full]
    type = SMP
    full = true
  [../]
[]


[Outputs]
  [./exodus]
    type = Exodus
    interval = 20
  [../]
  [./csv]
    type = CSV
    execute_on = &#x27;final&#x27;
  [../]
#[./console]
#    type = Console
#    output_file = true
#  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="185ece16-4937-4c24-a83c-06411bc5cb25"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/thermal_expansion_function/mean.i</h4><pre class="moose-pre"><code class="language-text"># This test checks the thermal expansion calculated via a mean thermal expansion coefficient.
# The coefficient is selected so as to result in a 1e-4 strain in the x-axis, and to cross over
# from positive to negative strain.

[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = &#x27;1 + t&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ComputeMeanThermalExpansionFunctionEigenstrain
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 1.2
    stress_free_temperature = 1.5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;T T_stress_free T_ref end_strain&#x27;
    vals = &#x27;2 1.5           1.2   1e-4&#x27;
    value = &#x27;end_strain / (T - T_stress_free - end_strain * (T_stress_free - T_ref))&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x_max]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./temp_avg]
    type = ElementAverageValue
    variable = temp
  [../]
[]

[Executioner]
  type = Transient

  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="39e3896e-687e-43f7-b726-6054c8409da9"><div class="modal-content"><h4>modules/heat_conduction/test/tests/heat_source_bar/ad_heat_source_bar.i</h4><pre class="moose-pre"><code class="language-text"># This is a simple 1D test of the volumetric heat source with material properties
# of a representative ceramic material.  A bar is uniformly heated, and a temperature
# boundary condition is applied to the left side of the bar.

# Important properties of problem:
# Length: 0.01 m
# Thermal conductivity = 3.0 W/(mK)
# Specific heat = 300.0 J/K
# density = 10431.0 kg/m^3
# Prescribed temperature on left side: 600 K

# When it has reached steady state, the temperature as a function of position is:
#  T = -q/(2*k) (x^2 - 2*x*length) + 600
#  or
#  T = -6.3333e+7 * (x^2 - 0.02*x) + 600
#  on left side: T=600, on right side, T=6933.3

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = 0.01
  nx = 20
[]

[Variables]
  [./temp]
    initial_condition = 300.0
  [../]
[]

[Kernels]
  [./heat]
    type = ADHeatConduction
    variable = temp
    thermal_conductivity = thermal_conductivity
  [../]
  [./heatsource]
    type = ADMatHeatSource
    material_property = volumetric_heat
    variable = temp
    scalar = 10
  [../]
[]

[BCs]
  [./lefttemp]
    type = DirichletBC
    boundary = left
    variable = temp
    value = 600
  [../]
[]

[Materials]
  [./density]
    type = ADGenericConstantMaterial
    prop_names = &#x27;density  thermal_conductivity volumetric_heat  &#x27;
    prop_values = &#x27;10431.0 3.0                  3.8e7&#x27;
  [../]
[]

[Preconditioning]
  [./full]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Steady
[]

[Postprocessors]
  [./right]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./error]
    type = NodalL2Error
    function = &#x27;-3.8e+8/(2*3) * (x^2 - 2*x*0.01) + 600&#x27;
    variable = temp
  [../]
[]

[Outputs]
  execute_on = FINAL
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7f8a05e4-ea02-4388-b815-83e63fde5772"><div class="modal-content"><h4>modules/functional_expansion_tools/test/tests/standard_use/interface_coupled.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 0.4
  nx = 6
  ymin = 0.0
  ymax = 10.0
  ny = 20
[]

[Variables]
  [./m]
  [../]
[]

[Kernels]
  [./diff_m]
    type = Diffusion
    variable = m
  [../]
  [./time_diff_m]
    type = TimeDerivative
    variable = m
  [../]
  [./source_m]
    type = BodyForce
    variable = m
    value = 100
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    value = 2
    variable = m
  [../]
[]

[BCs]
  [./interface_value]
    type = FXValueBC
    variable = m
    boundary = right
    function = FX_Basis_Value_Main
  [../]
  [./interface_flux]
    type = FXFluxBC
    boundary = right
    variable = m
    function = FX_Basis_Flux_Main
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;4&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
  [./FX_Basis_Flux_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;5&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
[]

[UserObjects]
  [./FX_Flux_UserObject_Main]
    type = FXBoundaryFluxUserObject
    function = FX_Basis_Flux_Main
    variable = m
    boundary = right
    diffusivity = 0.1
  [../]
[]

[Postprocessors]
  [./average_interface_value]
    type = SideAverageValue
    variable = m
    boundary = right
  [../]
  [./total_flux]
    type = SideFluxIntegral
    variable = m
    boundary = right
    diffusivity = 0.1
  [../]
  [./picard_iterations]
    type = NumPicardIterations
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 4
  dt = 1.0
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = interface_sub.i
    sub_cycling = true
  [../]
[]

[Transfers]
  [./FluxToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Flux_UserObject_Main
    multi_app_object_name = FX_Basis_Flux_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
  [./FluxToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Flux_Main
    multi_app_object_name = FX_Flux_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a6f305ec-a91c-4b46-b401-c39ab44f90b9"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/radial_disp_aux/cylinder_2d_axisymmetric.i</h4><pre class="moose-pre"><code class="language-text"># The purpose of this set of tests is to check the values computed
# by the RadialDisplacementAux AuxKernel. They should match the
# radial component of the displacment for a cylindrical or spherical
# model.
# This particular model is of a cylinder subjected to uniform thermal
# expansion represented using a 2D axisymmetric model.

[Mesh]
  type = GeneratedMesh
  dim = 2
  elem_type = QUAD8
  nx = 4
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  coord_type = RZ
[]

[AuxVariables]
  [./temp]
  [../]
  [./rad_disp]
  [../]
[]

[Functions]
  [./temperature_load]
    type = ParsedFunction
    value = t+300.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = temperature_load
    use_displaced_mesh = false
  [../]
  [./raddispaux]
    type = RadialDisplacementCylinderAux
    variable = rad_disp
  [../]
[]

[BCs]
  [./x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom top&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    stress_free_temperature = 300
    thermal_expansion_coeff = 1.3e-5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;51&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 50
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  end_time = 1
  dt = 1
  dtmin = 1
[]

[Outputs]
 csv = true
 exodus = true
[]

#[Postprocessors]
#  [./strain_xx]
#    type = SideAverageValue
#    variable =
#    block = 0
#  [../]
#[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1f6b6594-4625-4a0e-b09a-81b47ff5c71a"><div class="modal-content"><h4>modules/tensor_mechanics/tutorials/basics/part_2.3.i</h4><pre class="moose-pre"><code class="language-text">#Tensor Mechanics tutorial: the basics
#Step 2, part 3
#2D axisymmetric RZ simulation of uniaxial tension with J2 plasticity with no
#hardening

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = necking_quad4.e
  uniform_refine = 0
  second_order = true
[]

[Modules/TensorMechanics/Master]
  [./block1]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_yy strain_yy&#x27; #use the yy option to get the zz component in axisymmetric coords
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeMultiPlasticityStress
    ep_plastic_tolerance = 1e-9
    plastic_models = J2
  [../]
[]

[UserObjects]
  [./str]
    type = TensorMechanicsHardeningConstant
    value = 2.4e2
  [../]
  [./J2]
    type = TensorMechanicsPlasticJ2
    yield_strength = str
    yield_function_tolerance = 1E-3
    internal_constraint_tolerance = 1E-9
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_r
    boundary = left
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0.0
  [../]
  [./top]
    type = FunctionDirichletBC
    variable = disp_z
    boundary = top
    function = &#x27;0.0007*t&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.25
  end_time = 20

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;asm lu 1 101&#x27;
[]

[Postprocessors]
  [./ave_stress_bottom]
    type = SideAverageValue
    variable = stress_yy
    boundary = bottom
  [../]
  [./ave_strain_bottom]
    type = SideAverageValue
    variable = strain_yy
    boundary = bottom
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
  csv = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b5778c3d-6645-48dd-92aa-0622948e20f4"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D.i</h4><pre class="moose-pre"><code class="language-text">#
# 2D Cylindrical Gap Heat Transfer Test.
#
# This test exercises 2D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid cylinder of radius = 1 unit, and outer
# hollow cylinder with an inner radius of 2 in the x-y plane. In other words,
# the gap between them is 1 radial unit in length.
#
# The conductivity of both cylinders is set very large to achieve a uniform
# temperature in each cylinder. The temperature of the center node of the
# inner cylinder is ramped from 100 to 200 over one time unit. The temperature
# of the outside of the outer, hollow cylinder is held fixed at 100.
#
# A simple analytical solution is possible for the integrated heat flux
# between the inner and outer cylinders:
#
#  Integrated Flux = (T_left - T_right) * (gapK/(r*ln(r2/r1))) * Area
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 2 * pi * h * r, where h is the height of the cylinder.
#
# The integrated heat flux across the gap at time 1 is then:
#
# 2*pi*h*k*delta_T/(ln(r2/r1))
# 2*pi*1*1*100/(ln(2/1)) = 906.5 watts
#
# For comparison, see results from the integrated flux post processors.
# This simulation makes use of symmetry, so only 1/4 of the cylinders is meshed
# As such, the integrated flux from the post processors is 1/4 of the total,
# or 226.6 watts.
# The value coming from the post processor is slightly less than this
# but converges as mesh refinement increases.
# Note that the 2D and 3D results are the same.
#
# Simulating contact is challenging. Regression tests that exercise
# contact features can be difficult to solve consistently across multiple
# platforms. While designing these tests, we felt it worth while to note
# some aspects of these tests. The following applies to:
# sphere3D.i, sphere2DRZ.i, cyl2D.i, and cyl3D.i.
# 1. We decided that to perform consistently across multiple platforms we
# would use very small convergence tolerance. In this test we chose an
# nl_rel_tol of 1e-12.
# 2. Due to such a high value for thermal conductivity (used here so that the
# domains come to a uniform temperature) the integrated flux at time = 0
# was relatively large (the value coming from SideIntegralFlux =
#  -_diffusion_coef[_qp]*_grad_u[_qp]*_normals[_qp] where the diffusion coefficient
# here is thermal conductivity).
# Even though _grad_u[_qp] is small, in this case the diffusion coefficient
# is large. The result is a number that isn&#x27;t exactly zero and tends to
# fail exodiff. For this reason the parameter execute_on = initial should not
# be used. That parameter is left to default settings in these regression tests.
#
[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]


[Mesh]
  file = cyl2D.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]


[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]


[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]


[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = CYLINDER
    cylinder_axis_point_1 = &#x27;0 0 0&#x27;
    cylinder_axis_point_2 = &#x27;0 0 1&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
  [./Console]
    type = Console
  [../]
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7cc5fa64-217f-4799-8a78-88ab55e67894"><div class="modal-content"><h4>modules/combined/test/tests/phase_field_fracture/crack2d_aniso_cleavage_plane.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 40
    ny = 20
    ymax = 0.5
  []
  [./noncrack]
    type = BoundingBoxNodeSetGenerator
    new_boundary = noncrack
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 0 0&#x27;
    input = gen
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./c]
    family = LAGRANGE
    order = FIRST
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./All]
        add_variables = true
        strain = SMALL
        additional_generate_output = &#x27;strain_yy stress_yy&#x27;
        planar_formulation = PLANE_STRAIN
      [../]
    [../]
  [../]
[]

[Kernels]
  [./ACbulk]
    type = AllenCahn
    variable = c
    f_name = F
  [../]
  [./ACInterfaceCleavageFracture]
    type = ACInterfaceCleavageFracture
    variable = c
    beta_penalty = 1
    cleavage_plane_normal = &#x27;-0.707 0.707 0.0&#x27;
  [../]
  [./dcdt]
    type = TimeDerivative
    variable = c
  [../]
  [./solid_x]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_x
    component = 0
    c = c
  [../]
  [./solid_y]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_y
    component = 1
    c = c
  [../]
  [./off_disp]
    type = AllenCahnElasticEnergyOffDiag
    variable = c
    displacements = &#x27;disp_x disp_y&#x27;
    mob_name = L
  [../]
[]

[BCs]
  [./ydisp]
    type = FunctionDirichletBC
    preset = true
    variable = disp_y
    boundary = top
    function = &#x27;t&#x27;
  [../]
  [./yfix]
    type = DirichletBC
    preset = true
    variable = disp_y
    boundary = noncrack
    value = 0
  [../]
  [./xfix]
  type = DirichletBC
  preset = true
    variable = disp_x
    boundary = right
    value = 0
  [../]
[]

[Materials]
  [./pfbulkmat]
    type = GenericConstantMaterial
    prop_names = &#x27;gc_prop l visco&#x27;
    prop_values = &#x27;1e-3 0.05 1e-6&#x27;
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;127.0 70.8 70.8 127.0 70.8 127.0 73.55 73.55 73.55&#x27;
    fill_method = symmetric9
    euler_angle_1 = 30
    euler_angle_2 = 0
    euler_angle_3 = 0
  [../]
  [./define_mobility]
    type = ParsedMaterial
    material_property_names = &#x27;gc_prop visco&#x27;
    f_name = L
    function = &#x27;1.0/(gc_prop * visco)&#x27;
  [../]
  [./define_kappa]
    type = ParsedMaterial
    material_property_names = &#x27;gc_prop l&#x27;
    f_name = kappa_op
    function = &#x27;gc_prop * l&#x27;
  [../]
  [./damage_stress]
    type = ComputeLinearElasticPFFractureStress
    c = c
    E_name = &#x27;elastic_energy&#x27;
    D_name = &#x27;degradation&#x27;
    F_name = &#x27;local_fracture_energy&#x27;
    decomposition_type = stress_spectral
  [../]
  [./degradation]
    type = DerivativeParsedMaterial
    f_name = degradation
    args = &#x27;c&#x27;
    function = &#x27;(1.0-c)^2*(1.0 - eta) + eta&#x27;
    constant_names       = &#x27;eta&#x27;
    constant_expressions = &#x27;1.0e-6&#x27;
    derivative_order = 2
  [../]
  [./local_fracture_energy]
    type = DerivativeParsedMaterial
    f_name = local_fracture_energy
    args = &#x27;c&#x27;
    material_property_names = &#x27;gc_prop l&#x27;
    function = &#x27;c^2 * gc_prop / 2 / l&#x27;
    derivative_order = 2
  [../]
  [./fracture_driving_energy]
    type = DerivativeSumMaterial
    args = c
    sum_materials = &#x27;elastic_energy local_fracture_energy&#x27;
    derivative_order = 2
    f_name = F
  [../]
[]

[Postprocessors]
  [./av_stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./av_strain_yy]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solving_package&#x27;
  petsc_options_value = &#x27;lu superlu_dist&#x27;

  nl_rel_tol = 1e-8
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 10

  dt = 5e-5
  num_steps = 5
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f63c4644-8e15-483b-ac97-c1f50b07605d"><div class="modal-content"><h4>test/tests/functions/parsed/steady.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
    initial_condition = 2
  [../]
[]

[Functions]
  [./right_bc]
    type = ParsedFunction
    value = a+1
    vals = left_avg
    vars = a
  [../]
  [./left_bc]
    type = ParsedFunction
    value = a
    vals = left_avg
    vars = a
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = FunctionDirichletBC
    variable = u
    boundary = left
    function = left_bc
  [../]
  [./right]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right right&#x27;
    function = right_bc
  [../]
[]

[Postprocessors]
  [./left_avg]
    type = SideAverageValue
    variable = u
    execute_on = initial
    boundary = left
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f14766a1-42e5-459a-9817-92f76aff645b"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/multiple_postprocessors.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test (Volume input as a vector of postprocessors)
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = - (0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# In this test the internal volume is calculated as the sum of two Postprocessors
# internalVolumeInterior and internalVolumeExterior.  This sum equals the value
# reported by the internalVolume postprocessor.
#
# The parameters combined at t = 1 gives p = 301.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 3d.e
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = Diffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = FunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      volume = &#x27;internalVolumeInterior internalVolumeExterior&#x27;
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e1
    poissons_ratio = 0
    block = 1
  [../]
  [./strain1]
    type = ComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0
    block = 2
  [../]
  [./strain2]
    type = ComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./internalVolumeInterior]
    type = InternalVolume
    boundary = &#x27;1 2 3 4 5 6&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./internalVolumeExterior]
    type = InternalVolume
    boundary = &#x27;13 14 15 16 17 18&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c939b67a-580b-45b1-99ef-474a8276c2c1"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/initial_temperature.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = -(0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# The parameters combined at t = 1 gives p = 301.
#
# This test sets the initial temperature to 500, but the CavityPressure
#   is told that that initial temperature is T0.  Thus, the final solution
#   is unchanged.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3d.e
[]

[GlobalParams]
  volumetric_locking_correction = true
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 500
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = ADDiffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = ADFunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      initial_temperature = 240.54443866068704
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ADComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 1
  [../]
  [./strain1]
    type = ADComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ADComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 2
  [../]
  [./strain2]
    type = ADComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bdb03661-c8d1-4609-a3f8-60934d2d7aaa"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D_xz.i</h4><pre class="moose-pre"><code class="language-text">#
# 2D Cylindrical Gap Heat Transfer Test.
#
# This test exercises 2D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid cylinder of radius = 1 unit, and outer
# hollow cylinder with an inner radius of 2 in the x-z plane. In other words,
# the gap between them is 1 radial unit in length.
#
# The calculated results are the same as for the cyl2D.i case in the x-y plane.

[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  [file]
    type = FileMeshGenerator
    file = cyl2D.e
  []
  [./rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;0 90 0&#x27;
    input = file
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]

[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]

[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = CYLINDER
    cylinder_axis_point_1 = &#x27;0 0 0&#x27;
    cylinder_axis_point_2 = &#x27;0 1 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c74b59a0-a8cb-4289-868f-60e1562c707f"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/czm/czm_3DC_3D_base_input.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./msh]
    type = GeneratedMeshGenerator
  []
  [./subdomain_1]
    type = SubdomainBoundingBoxGenerator
    input = msh
    bottom_left = &#x27;0 0 0&#x27;
    block_id = 1
    top_right = &#x27;0.5 1 1&#x27;
  []
  [./subdomain_2]
    type = SubdomainBoundingBoxGenerator
    input = subdomain_1
    bottom_left = &#x27;0.5 0 0&#x27;
    block_id = 2
    top_right = &#x27;1 1 1&#x27;
  []
  [./breakmesh]
    input = subdomain_2
    type = BreakMeshByBlockGenerator
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    generate_output = &#x27;stress_xx stress_yy stress_zz stress_yz stress_xz stress_xy&#x27;
  [../]
[]

[Modules/TensorMechanics/CohesiveZoneMaster]
  [./czm1]
    boundary = &#x27;interface&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[BCs]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    preset = false
    boundary = left
    value = 0.0
  [../]
  [./left_y]
    type = DirichletBC
    variable = disp_y
    preset = false
    boundary = left
    value = 0.0
  [../]
  [./left_z]
    type = DirichletBC
    variable = disp_z
    preset = false
    boundary = left
    value = 0.0
  [../]
  [./right_x]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = right
  [../]
  [./right_y]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = right
  [../]
  [./right_z]
    type = FunctionDirichletBC
    variable = disp_z
    preset = false
    boundary = right
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = &#x27;1 2&#x27;
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;0.3 0.5e8&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
    block = &#x27;1 2&#x27;
  [../]
  [./czm_3dc]
    type = SalehaniIrani3DCTraction
    boundary = &#x27;interface&#x27;
    normal_gap_at_maximum_normal_traction = 1
    tangential_gap_at_maximum_shear_traction = 0.5
    maximum_normal_traction = 100
    maximum_shear_traction = 70
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  solve_type = NEWTON
  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-6
  nl_max_its = 5
  l_tol = 1e-10
  l_max_its = 50
  start_time = 0.0
  dt = 0.2
  end_time = 5
  dtmin = 0.2
  line_search = none
[]

[Outputs]
  [./out]
    type = Exodus
  [../]
[]

[Postprocessors]
  [./sxx]
    type = SideAverageValue
    variable = stress_xx
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;interface&#x27;
  [../]
  [./syy]
    type = SideAverageValue
    variable = stress_yy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;interface&#x27;
  [../]
  [./szz]
    type = SideAverageValue
    variable = stress_zz
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;interface&#x27;
  [../]
  [./syz]
    type = SideAverageValue
    variable = stress_yz
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;interface&#x27;
  [../]
  [./sxz]
    type = SideAverageValue
    variable = stress_xz
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;interface&#x27;
  [../]
  [./sxy]
    type = SideAverageValue
    variable = stress_xy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;interface&#x27;
  [../]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;right&#x27;
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;right&#x27;
  [../]
  [./disp_z]
    type = SideAverageValue
    variable = disp_z
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    boundary = &#x27;right&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fe4132b9-027f-4fde-bd29-2940d9671178"><div class="modal-content"><h4>modules/heat_conduction/test/tests/convective_heat_flux/t_inf.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
[]

[Variables]
  [./temp]
    initial_condition = 200.0
  [../]
[]

[Kernels]
  [./heat_dt]
    type = TimeDerivative
    variable = temp
  [../]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
    diffusion_coefficient = 1
  [../]
  [./heat]
    type = BodyForce
    variable = temp
    value = 0
  [../]
[]

[BCs]
  [./right]
    type = ConvectiveHeatFluxBC
    variable = temp
    boundary = &#x27;right&#x27;
    T_infinity = 100.0
    heat_transfer_coefficient = 1
    heat_transfer_coefficient_dT = 0
  [../]
[]

[Postprocessors]
  [./left_temp]
    type = SideAverageValue
    variable = temp
    boundary = left
    execute_on = &#x27;TIMESTEP_END initial&#x27;
  [../]
  [./right_temp]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./right_flux]
    type = SideFluxAverage
    variable = temp
    boundary = right
    diffusivity = 1
  [../]
[]

[Executioner]
  type = Transient

  num_steps = 10
  dt = 1e1

  nl_abs_tol = 1e-12
[]

[Outputs]
  # csv = true
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2644c018-4c08-4611-94f3-6f0a92f92b61"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_test.i</h4><pre class="moose-pre"><code class="language-text">#
# 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks containing one element each.  Each
#   element is a unit cube.  They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit.  The temperature of the far right
#  boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
#  Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
#  gapK(Tavg) = 1.0*Tavg
#
#
# The heat flux across the gap at time = 1 is then:
#
#  Flux(2) = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors
#
# This test has been augmented with a second scalar field that solves nearly
#   the same problem.  The conductivity has been changed to 10.  Thus, the
#   flux for the second field is 1000.
#


[Mesh]
  file = gap_heat_transfer_htonly_test.e
[]

[Functions]

  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
  [./awesomium_contact]
    type = GapHeatTransfer
    variable = awesomium
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 10
    appended_property_name = _awesomium
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
  [./awesomium]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./gap_cond_awesomium]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./awe]
    type = HeatConduction
    variable = awesomium
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
  [./awesomium_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = awesomium
    function = temp
  [../]
  [./awesomium_far_right]
    type = DirichletBC
    boundary = 4
    variable = awesomium
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
  [./conductance_awe]
    type = MaterialRealAux
    property = gap_conductance_awesomium
    variable = gap_cond_awesomium
    boundary = 2
  [../]
[]

[Materials]

  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  l_tol = 1e-3
  l_max_its = 100

  dt = 1e-1
  end_time = 1.0
[]

[Postprocessors]

  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./awe_left]
    type = SideAverageValue
    boundary = 2
    variable = awesomium
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./awe_right]
    type = SideAverageValue
    boundary = 3
    variable = awesomium
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./awe_flux_left]
    type = SideFluxIntegral
    variable = awesomium
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./awe_flux_right]
    type = SideFluxIntegral
    variable = awesomium
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f10f0ec8-3061-496e-b93e-3b0d91837848"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/mean.i</h4><pre class="moose-pre"><code class="language-text"># This test checks the thermal expansion calculated via a mean thermal expansion coefficient.
# The coefficient is selected so as to result in a 1e-4 strain in the x-axis, and to cross over
# from positive to negative strain.

[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = &#x27;1 + t&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ADComputeMeanThermalExpansionFunctionEigenstrain
    thermal_expansion_function = cte_func_mean
    thermal_expansion_function_reference_temperature = 1.2
    stress_free_temperature = 1.5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_func_mean]
    type = ParsedFunction
    vars = &#x27;T T_stress_free T_ref end_strain&#x27;
    vals = &#x27;2 1.5           1.2   1e-4&#x27;
    value = &#x27;end_strain / (T - T_stress_free - end_strain * (T_stress_free - T_ref))&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x_max]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./temp_avg]
    type = ElementAverageValue
    variable = temp
  [../]
[]

[Executioner]
  type = Transient

  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="82760684-26a7-48dd-b19e-55502855afec"><div class="modal-content"><h4>modules/tensor_mechanics/tutorials/basics/part_3_1.i</h4><pre class="moose-pre"><code class="language-text">#Tensor Mechanics tutorial: the basics
#Step 3, part 1
#3D simulation of uniaxial tension with J2 plasticity

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  [file_mesh]
    type = FileMeshGenerator
    file = necking_quad4.e
  []
  [extrude]
    type = MeshExtruderGenerator
    extrusion_vector = &#x27;0 0 0.5&#x27;
    num_layers = 2
    bottom_sideset = &#x27;back&#x27;
    top_sideset = &#x27;front&#x27;
    input = file_mesh
  []
  uniform_refine = 0
  second_order = true
[]

[Modules/TensorMechanics/Master]
  [./block1]
    strain = FINITE
    add_variables = true
    generate_output = &#x27;stress_yy strain_yy&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeMultiPlasticityStress
    ep_plastic_tolerance = 1e-9
    plastic_models = J2
  [../]
[]

[UserObjects]
  [./hardening]
    type = TensorMechanicsHardeningCubic
    value_0 = 2.4e2
    value_residual = 3.0e2
    internal_0 = 0
    internal_limit = 0.005
  [../]
  [./J2]
    type = TensorMechanicsPlasticJ2
    yield_strength = hardening
    yield_function_tolerance = 1E-3
    internal_constraint_tolerance = 1E-9
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x #change the variable to reflect the new displacement names
    boundary = 1
    value = 0.0
  [../]
  [./back]
    type = DirichletBC
    variable = disp_z #change the variable to reflect the new displacement names
    boundary = back
    value = 0.0
  [../]
  [./bottom]
    type = DirichletBC
    variable = disp_y #change the variable to reflect the new displacement names
    boundary = 3
    value = 0.0
  [../]
  [./top]
    type = FunctionDirichletBC
    variable = disp_y #change the variable to reflect the new displacement names
    boundary = 4
    function = &#x27;0.0007*t&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  dt = 0.25
  end_time = 16

  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;asm lu 1 101&#x27;
[]

[Postprocessors]
  [./ave_stress_bottom]
    type = SideAverageValue
    variable = stress_yy
    boundary = 3
  [../]
  [./ave_strain_bottom]
    type = SideAverageValue
    variable = strain_yy
    boundary = 3
  [../]
[]

[Outputs]
  exodus = true
  perf_graph = true
  csv = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b5858c48-d40d-4262-84c9-f665e41d8cbe"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/radial_disp_aux/sphere_3d_cartesian.i</h4><pre class="moose-pre"><code class="language-text"># The purpose of this set of tests is to check the values computed
# by the RadialDisplacementAux AuxKernel. They should match the
# radial component of the displacment for a cylindrical or spherical
# model.
# This particular model is of a sphere subjected to uniform thermal
# expansion represented using a 3D Cartesian model.

[Mesh]
  type = FileMesh
  file = sphere_sector_3d.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  order = SECOND
  family = LAGRANGE
[]

[AuxVariables]
  [./temp]
  [../]
  [./rad_disp]
  [../]
[]

[Functions]
  [./temperature_load]
    type = ParsedFunction
    value = t+300.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = temperature_load
    use_displaced_mesh = false
  [../]
  [./raddispaux]
    type = RadialDisplacementSphereAux
    variable = rad_disp
    origin = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
  [./z]
    type = DirichletBC
    variable = disp_z
    boundary = 3
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    stress_free_temperature = 300
    thermal_expansion_coeff = 1.3e-5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;51&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 50
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10

  start_time = 0.0
  end_time = 1
  dt = 1
  dtmin = 1
[]

[Outputs]
 csv = true
 exodus = true
[]

#[Postprocessors]
#  [./strain_xx]
#    type = SideAverageValue
#    variable =
#    block = 0
#  [../]
#[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f60684b5-897e-45cb-bb57-cedce9754e09"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/planar_yz.i</h4><pre class="moose-pre"><code class="language-text"># 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks in the y-z plane.  Each element block
# is a square. They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
# across each block. The temperature of the far bottom boundary
# is ramped from 100 to 200 over one time unit.  The temperature of the far top
# boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
# Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
# gapK(Tavg) = 1.0*Tavg
#
# The heat flux across the gap at time = 1 is then:
#
# Flux = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors.  These results
# are the same as for the unit 1-D gap heat transfer between two unit cubes.

[Mesh]
  [file]
    type = FileMeshGenerator
    file = simple_2D.e
  []
  [./rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;0 90 90&#x27;
    input = file
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_bottom]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_top]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  l_tol = 1e-3
  l_max_its = 100

  dt = 1e-1
  end_time = 1.0
[]

[Postprocessors]
  [./temp_bottom]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_top]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_bottom]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_top]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d2238b4c-8b32-4f70-88ad-fb581c24dc75"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/dilatation.i</h4><pre class="moose-pre"><code class="language-text"># This test checks the thermal expansion calculated via an dilatation function.
# The coefficient is selected so as to result in a 1e-4 strain in the x-axis, and to cross over
# from positive to negative strain.

[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = &#x27;1 + t&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ADComputeDilatationThermalExpansionFunctionEigenstrain
    dilatation_function = cte_dilatation
    stress_free_temperature = 1.5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Functions]
  [./cte_dilatation]
    type = PiecewiseLinear
    x = &#x27;1 2&#x27;
    y = &#x27;-1e-4 1e-4&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x_max]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./temp_avg]
    type = ElementAverageValue
    variable = temp
  [../]
[]

[Executioner]
  type = Transient

  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bd0c2e69-923d-47a0-b3c7-27624aaed8b2"><div class="modal-content"><h4>modules/porous_flow/test/tests/sinks/PorousFlowPiecewiseLinearSink_BC_eg1.i</h4><pre class="moose-pre"><code class="language-text">## This is an example input file showing how to set a Type I (Dirichlet) BC with PorousFlowPiecewiseLinearSink
##
## Problem setup:
##   - The boundaries are set to P(x = 0) = 2e6 Pa, P(x = 1) = 1e6 and run to steady state.
##   - The 2d domain is 1 m x 1 m
##   - The permeability is set to 1E-15 m2, fluid viscosity = 1E-3 Pa-s
##   - The steady state flux is calculated q = -k/mu*grad(P) = 1e-6 m/s
##
## Problem verification (in csv output):
##   - The flux in and out of the domain are 1e-6 m/s (matching steady state solution)
##   - The pressure at the left and right boundaries are set to 2e6 and 1e6 Pa, respectively

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  xmin = 0
  xmax = 1
  ny = 2
  ymin = 0
  ymax = 1
[]

[GlobalParams]
  PorousFlowDictator = dictator
[]

[Variables]
  [./porepressure]
    initial_condition = 1.5e6 # initial pressure in domain
  [../]
[]

[PorousFlowBasicTHM]
  porepressure = porepressure
  coupling_type = Hydro
  gravity = &#x27;0 0 0&#x27;
  fp = the_simple_fluid
[]

[AuxVariables]
  [./fluxes_out]
  [../]
  [./fluxes_in]
  [../]
[]

[BCs]
  [./in_left]
    type = PorousFlowPiecewiseLinearSink
    variable = porepressure
    boundary = &#x27;left&#x27;
    pt_vals = &#x27;-1e9 1e9&#x27; # x coordinates defining g
    multipliers = &#x27;-1e9 1e9&#x27; # y coordinates defining g
    PT_shift = 2.E6   # BC pressure
    flux_function = 1E-5 # Variable C
    fluid_phase = 0
    save_in = fluxes_out
  [../]
  [./out_right]
    type = PorousFlowPiecewiseLinearSink
    variable = porepressure
    boundary = &#x27;right&#x27;
    pt_vals = &#x27;-1e9 1e9&#x27; # x coordinates defining g
    multipliers = &#x27;-1e9 1e9&#x27; # y coordinates defining g
    PT_shift = 1.E6   # BC pressure
    flux_function = 1E-6 # Variable C
    fluid_phase = 0
    save_in = fluxes_in
  [../]
[]

[Postprocessors]
  [./left_flux]
    type = NodalSum
    boundary = &#x27;left&#x27;
    variable = fluxes_out
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./right_flux]
    type = NodalSum
    boundary = &#x27;right&#x27;
    variable = fluxes_in
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./left_pressure]
    type = SideAverageValue
    boundary = &#x27;left&#x27;
    variable = porepressure
    execute_on = &#x27;timestep_end&#x27;
  [../]
  [./right_pressure]
    type = SideAverageValue
    boundary = &#x27;right&#x27;
    variable = porepressure
    execute_on = &#x27;timestep_end&#x27;
  [../]
[]

[Modules]
  [./FluidProperties]
    [./the_simple_fluid]
      type = SimpleFluidProperties
      thermal_expansion = 0
      viscosity = 1.0E-3
      density0 = 1000.0
    [../]
  [../]
[]

[Materials]
  [./porosity]
    type = PorousFlowPorosity
    porosity_zero = 0.1
  [../]
  [./biot_modulus]
    type = PorousFlowConstantBiotModulus
    biot_coefficient = 0.8
    solid_bulk_compliance = 2E-7
    fluid_bulk_modulus = 1E7
  [../]
  [./permeability_aquifer]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1E-15 0 0   0 1E-15 0   0 0 1E-15&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1E6
  dt = 1E5
  nl_abs_tol = 1E-10
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1b95a348-295d-444c-9890-b6c8c3fbb564"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/radial_disp_aux/cylinder_3d_cartesian.i</h4><pre class="moose-pre"><code class="language-text"># The purpose of this set of tests is to check the values computed
# by the RadialDisplacementAux AuxKernel. They should match the
# radial component of the displacment for a cylindrical or spherical
# model.
# This particular model is of a cylinder subjected to uniform thermal
# expansion represented using a 3D Cartesian model.

[Mesh]
  type = FileMesh
  file = cylinder_sector_3d.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  order = SECOND
  family = LAGRANGE
[]

[AuxVariables]
  [./temp]
  [../]
  [./rad_disp]
  [../]
[]

[Functions]
  [./temperature_load]
    type = ParsedFunction
    value = t+300.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = temperature_load
    use_displaced_mesh = false
  [../]
  [./raddispaux]
    type = RadialDisplacementCylinderAux
    variable = rad_disp
    origin = &#x27;0 0 0&#x27;
    axis_vector = &#x27;0 0 1&#x27;
  [../]
[]

[BCs]
  [./x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
  [./z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    stress_free_temperature = 300
    thermal_expansion_coeff = 1.3e-5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;51&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 50
  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-10

  start_time = 0.0
  end_time = 1
  dt = 1
  dtmin = 1
[]

[Outputs]
 csv = true
 exodus = true
[]

#[Postprocessors]
#  [./strain_xx]
#    type = SideAverageValue
#    variable =
#    block = 0
#  [../]
#[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cfa48c1a-cd47-4fee-b9e8-b86320b335d7"><div class="modal-content"><h4>modules/heat_conduction/test/tests/heat_source_bar/heat_source_bar.i</h4><pre class="moose-pre"><code class="language-text"># This is a simple 1D test of the volumetric heat source with material properties
# of a representative ceramic material.  A bar is uniformly heated, and a temperature
# boundary condition is applied to the left side of the bar.

# Important properties of problem:
# Length: 0.01 m
# Thermal conductivity = 3.0 W/(mK)
# Specific heat = 300.0 J/K
# density = 10431.0 kg/m^3
# Prescribed temperature on left side: 600 K

# When it has reached steady state, the temperature as a function of position is:
#  T = -q/(2*k) (x^2 - 2*x*length) + 600
#  or
#  T = -6.3333e+7 * (x^2 - 0.02*x) + 600
#  on left side: T=600, on right side, T=6933.3

[Mesh]
  type = GeneratedMesh
  dim = 1
  xmax = 0.01
  nx = 20
[]

[Variables]
  [./temp]
    initial_condition = 300.0
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heatsource]
    type = HeatSource
    function = volumetric_heat
    variable = temp
  [../]
[]

[BCs]
  [./lefttemp]
    type = DirichletBC
    boundary = left
    variable = temp
    value = 600
  [../]
[]

[Materials]
  [./density]
    type = GenericConstantMaterial
    prop_names = &#x27;density  thermal_conductivity&#x27;
    prop_values = &#x27;10431.0 3.0&#x27;
  [../]
[]

[Functions]
  [./volumetric_heat]
     type = ParsedFunction
     value = 3.8e+8
  [../]
[]

[Executioner]
  type = Steady
[]

[Postprocessors]
  [./right]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./error]
    type = NodalL2Error
    function = &#x27;-3.8e+8/(2*3) * (x^2 - 2*x*0.01) + 600&#x27;
    variable = temp
  [../]
[]

[Outputs]
  execute_on = FINAL
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e392a2cd-7f19-46cf-9909-c219a4fbd409"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/cyl2D_yz.i</h4><pre class="moose-pre"><code class="language-text">#
# 2D Cylindrical Gap Heat Transfer Test.
#
# This test exercises 2D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid cylinder of radius = 1 unit, and outer
# hollow cylinder with an inner radius of 2 in the y-z plane. In other words,
# the gap between them is 1 radial unit in length.
#
# The calculated results are the same as for the cyl2D.i case in the x-y plane.

[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Mesh]
  [file]
    type = FileMeshGenerator
    file = cyl2D.e
  []
  [./rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;0 90 90&#x27;
    input = file
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]

[Variables]
  [./temp]
   initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]

[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = CYLINDER
    cylinder_axis_point_1 = &#x27;0 0 0&#x27;
    cylinder_axis_point_2 = &#x27;1 0 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
     order = fifth
     side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5cd4e37c-53ec-473e-aa78-ded77677c869"><div class="modal-content"><h4>modules/heat_conduction/test/tests/convective_heat_flux/equilibrium.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
[]

[Variables]
  [./temp]
    initial_condition = 200.0
  [../]
[]

[Kernels]
  [./heat_dt]
    type = TimeDerivative
    variable = temp
  [../]
  [./heat_conduction]
    type = Diffusion
    variable = temp
  [../]
[]

[BCs]
  [./right]
    type = ConvectiveHeatFluxBC
    variable = temp
    boundary = &#x27;right&#x27;
    T_infinity = 100.0
    heat_transfer_coefficient = 1
    heat_transfer_coefficient_dT = 0
  [../]
[]

[Postprocessors]
  [./left_temp]
    type = SideAverageValue
    variable = temp
    boundary = left
    execute_on = &#x27;TIMESTEP_END initial&#x27;
  [../]
  [./right_temp]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./right_flux]
    type = SideFluxAverage
    variable = temp
    boundary = right
    diffusivity = 1
  [../]
[]

[Executioner]
  type = Transient

  num_steps = 10
  dt = 1e1

  nl_abs_tol = 1e-12
[]

[Outputs]
  [./out]
    type = CSV
    interval = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4c2d29d5-abcb-466f-a725-6ec0b8037c87"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_rz_test.i</h4><pre class="moose-pre"><code class="language-text">#
# 2-D RZ Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks containing one element each.  Each
#   element is a unit cube.  They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit, and then held fixed for an additional
#  time unit.  The temperature of the far right boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks, or cylinders in the case of RZ.:
#
#  Flux = (T_left - T_right) * (gapK/(r*ln(r2/r1)))
#
# For gapK = 1 (default value)
#
# The integrated heat flux across the gap at time 2 is then:
#
# 2*pi*h*k*delta_T/(ln(r2/r1))
# 2*pi*1*1*100/(ln(2/1)) = 906.5 watts
#
# For comparison, see results from the flux post processors.
#
# As a second test, use the rectilinear (parallel plate) form of the gap heat transfer.
#
#  Flux = (T_left - T_right) * (gapK/gapL)
#
# For gapK = 1 (default value)
#
# The integrated heat flux across the gap at time 2 is then:
#
# 2*pi*h*k*delta_T/(1)
# 2*pi*1*1*100/(1) = 628.3 watts
#
# For comparison, see results from the flux post processors.
#

[Problem]
  coord_type = RZ
  rz_coord_axis = Y # this is modified through CLI args to test Z-R as opposed to R-Z
[]

[Mesh]
  active = &#x27;file&#x27;
  [file]
    type = FileMeshGenerator
    file = gap_heat_transfer_htonly_rz_test.e
  []
  [rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;90 0 0&#x27;
    input = file
  []
[]
[Functions]

  [./ramp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
  [./thermal_contact2]
    type = GapHeatTransfer
    variable = temp2
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_geometry_type = PLATE
    appended_property_name = 2
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
  [./temp2]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./gap_cond2]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat2]
    type = HeatConduction
    variable = temp2
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = ramp
  [../]

  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]

  [./temp_far_left2]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp2
    function = ramp
  [../]

  [./temp_far_right2]
    type = DirichletBC
    boundary = 4
    variable = temp2
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
  [./conductance2]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond2
    boundary = 2
  [../]
[]

[Materials]

  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1e6
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
#  petsc_options = &#x27;-snes_mf_operator -ksp_monitor -snes_ksp_ew&#x27;

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;




#  petsc_options_iname = &#x27;-snes_type -snes_ls -snes_linesearch_type -ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
#  petsc_options_value = &#x27;ls         basic    basic                    201                hypre    boomeramg      4&#x27;
#  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
#  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  nl_abs_tol = 1e-3
  nl_rel_tol = 1e-8

  l_tol = 1e-6
  l_max_its = 100

  start_time = 0.0
  dt = 1e-1
  dtmin = 1e-1
  end_time = 2.0
[]

[Postprocessors]

  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]

  [./temp_left2]
    type = SideAverageValue
    boundary = 2
    variable = temp2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right2]
    type = SideAverageValue
    boundary = 3
    variable = temp2
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left2]
    type = SideFluxIntegral
    variable = temp2
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right2]
    type = SideFluxIntegral
    variable = temp2
    boundary = 3
    diffusivity = thermal_conductivity
  [../]

[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4f93577d-c3e4-4fa4-9e7f-5861226bb829"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_it_plot_test.i</h4><pre class="moose-pre"><code class="language-text">#
# 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks containing one element each.  Each
#   element is a unit cube.  They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit, and then held fixed for an additional
#  time unit.  The temperature of the far right boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
#  Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
#  gapK(Tavg) = 1.0*Tavg
#
#
# The heat flux across the gap at time = 2 is then:
#
#  Flux(2) = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors
#


[Mesh]
  file = gap_heat_transfer_htonly_test.e
[]

[Functions]

  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]

  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Materials]

  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]

  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  #Preconditioned JFNK (default)
  solve_type = &#x27;PJFNK&#x27;




  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;


  line_search = &#x27;none&#x27;


  nl_abs_tol = 1e-5
  nl_rel_tol = 1e-12

  l_tol = 1e-10
  l_max_its = 100

  start_time = 0.0
  dt = 1e-1
  end_time = 2.0
[]

[Postprocessors]

  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]


[Outputs]
  file_base = out_it_plot
  [./exodus]
    type = Exodus
    execute_on = &#x27;initial timestep_end nonlinear&#x27;
    nonlinear_residual_dt_divisor = 100
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ff0af589-85fe-4648-b4df-10cb0e8f5201"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/thermal_expansion_function/instantaneous.i</h4><pre class="moose-pre"><code class="language-text"># This test checks the thermal expansion calculated via a instantaneous thermal expansion coefficient.
# The coefficient is selected so as to result in a 1e-4 strain in the x-axis, and to cross over
# from positive to negative strain.

[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = &#x27;1 + t&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ComputeInstantaneousThermalExpansionFunctionEigenstrain
    thermal_expansion_function = 4e-4
    stress_free_temperature = 1.5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Postprocessors]
  [./disp_x_max]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./temp_avg]
    type = ElementAverageValue
    variable = temp
  [../]
[]

[Executioner]
  type = Transient

  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="5811fc8e-9ab7-4dd9-8a3e-0acfc244d057"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_radiation/gap_heat_transfer_radiation_test.i</h4><pre class="moose-pre"><code class="language-text">#
# 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a helium-filled gap including radiation.
#
# The mesh consists of two element blocks containing one element each.  Each
#   element is a unit cube.  They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit, and then held fixed for an additional
#  time unit.  The temperature of the far right boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
#  Flux = (T_left - T_right) * h_gap
#
#    where  h_gap = h_gas + h_cont + h_rad
#
# By setting the contact pressure, roughnesses, and jump distances to zero, the gap
#   conductance simplifies to:
#
#    h_gap = gapK/d_gap + sigma*Fe*(T_left^2 + T_right^2)*(T_left + T_right)
#
#      where Fe = 1/(1/eps_left + 1/eps_right - 1)
#            eps = emissivity
#
# For pure helium, BISON computes the gas conductivity as:
#
#  gapK(Tavg) = 2.639e-3*Tavg^0.7085
#
# For the test, the final (t=2) average gas temperature is (200 +100)/2 = 150,
#  giving gapK(150) = 0.09187557
#
# Assuming ems_left = ems_right = 0.5, Fe = 1/3
#
# The heat flux across the gap at that time is then:
#
#  Flux(2) = 100 * ((0.09187557/1.0) + (5.669e-8/3)*(200^2 + 100^2)*(200 + 100))
#          = 37.532557
#
# The flux post processors give 37.53255
#

[Mesh]
  file = gap_heat_transfer_radiation_test.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;200 200&#x27;
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]

  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[ThermalContact]
  [./gap]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    gap_conductivity = 0.09187557
    emissivity_primary = 0.5
    emissivity_secondary = 0.5
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 10000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;

  nl_abs_tol = 1e-6
  nl_rel_tol = 1e-10

  l_tol = 1e-3
  l_max_its = 100

  start_time = 0.0
  dt = 1
  end_time = 1.0
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c6bef6ac-dc0c-4cfc-bb0b-33fea55d757e"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/additional_volume.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test using using automatic differentiation
#
# This test is designed to compute an internal pressure based on
# p = n * R * / (V_cavity / T_cavity + V_add / T_add)
# where
#  p is the pressure
#  n is the amount of material in the volume (moles)
#  R is the universal gas constant
#  T_cavity is the temperature in the cavity
#  T_add is the temperature of the additional volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7. An additional volume of 2 is added.
#
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V_cavity0 + gamma * t + V_add
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = -(0.003322259...) * V0
#   T0 = 240.54443866068704
#   V_cavity0 = 7
#   V_add = 2
#   T_add = 100
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
#  An additional volume of 2 with a temperature of 100.0 is included.
#
# So, n0 = p0 * (V_cavity / T_cavity + V_add / T_add) / R
#        = 100 * (7 / 240.544439 + 2 / 100) / 8.314472
#        = 0.59054
#
# The parameters combined at t = 1 gives p = 249.647.
#
# This test sets the initial temperature to 500, but the CavityPressure
#   is told that that initial temperature is T0.  Thus, the final solution
#   is unchanged.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3d.e
[]

[GlobalParams]
  volumetric_locking_correction = true
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.59054&#x27;
  [../]
  [./additional_volume]
    type = ConstantFunction
    value = 2
  [../]
  [./temperature_of_additional_volume]
    type = ConstantFunction
    value = 100
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 500
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = ADDiffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = ADFunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      initial_temperature = 240.54443866068704
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      additional_volumes = volume1
      temperature_of_additional_volumes = temperature1
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ADComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 1
  [../]
  [./strain1]
    type = ADComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ADComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 2
  [../]
  [./strain2]
    type = ADComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
  [./volume1]
    type = FunctionValuePostprocessor
    function = additional_volume
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./temperature1]
    type = FunctionValuePostprocessor
    function = temperature_of_additional_volume
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3af5cda9-2654-4e13-9d39-8ef3a794ed73"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/creep.i</h4><pre class="moose-pre"><code class="language-text"># This test is provided as a check to ensure ADComputeMultiplePorousInelasticStress

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmax = 0.002
  ymax = 0.002
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  base_name = &#x27;total&#x27;
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
[]

[Materials]
  active=&#x27;elasticity_tensor porous_stress creep&#x27;
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
    base_name = &#x27;total&#x27;
  [../]
  [./porous_stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = creep
    initial_porosity = 0.1
    outputs = all
    base_name = &#x27;total&#x27;
  [../]
  [./regular_stress]
    type = ADComputeMultipleInelasticStress
    inelastic_models = creep
    outputs = all
    base_name = &#x27;total&#x27;
  [../]
  [./porosity]
    type = ADGenericConstantMaterial
    prop_names = porosity
    prop_values = 0.1
    outputs = all
  [../]
  [./creep]
    type = ADPowerLawCreepStressUpdate
    activation_energy = 4e4
    temperature = 1200
    coefficient = 1e-18
    gas_constant = 1.987
    n_exponent = 3
    base_name = &#x27;creep&#x27;
    outputs = all
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = total_hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = total_vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./eff_creep_strain]
    type = ElementAverageValue
    variable = creep_effective_creep_strain
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ee95995b-feeb-4286-ab02-2548466575db"><div class="modal-content"><h4>modules/heat_conduction/test/tests/ad_convective_heat_flux/coupled.i</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 10
[]

[Variables]
  [./temp]
    initial_condition = 200.0
  [../]
[]

[Kernels]
  [./heat_dt]
    type = ADTimeDerivative
    variable = temp
  [../]
  [./heat_conduction]
    type = Diffusion
    variable = temp
  [../]
  [./heat]
    type = ADBodyForce
    variable = temp
    value = 0
  [../]
[]

[BCs]
  [./right]
    type = ADConvectiveHeatFluxBC
    variable = temp
    boundary = &#x27;right&#x27;
    T_infinity = T_inf
    heat_transfer_coefficient = htc
  [../]
[]

[Materials]
  [chf_mat]
    type = ADConvectiveHeatFluxTest
    temperature = temp
    boundary = &#x27;right&#x27;
  []
[]

[Postprocessors]
  [./left_temp]
    type = SideAverageValue
    variable = temp
    boundary = left
    execute_on = &#x27;TIMESTEP_END initial&#x27;
  [../]
  [./right_temp]
    type = SideAverageValue
    variable = temp
    boundary = right
  [../]
  [./right_flux]
    type = SideFluxAverage
    variable = temp
    boundary = right
    diffusivity = 1
  [../]
[]

[Executioner]
  type = Transient

  num_steps = 10
  dt = 1

  nl_abs_tol = 1e-12
[]

[Outputs]
  [./out]
    type = CSV
    interval = 10
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3f95fc25-faae-41b6-9d10-f27faeb4e084"><div class="modal-content"><h4>modules/heat_conduction/test/tests/radiation_transfer_action/radiative_transfer_action.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  kernel_coverage_check = false
[]

[Mesh]
  type = MeshGeneratorMesh

  [./cmg]
    type = CartesianMeshGenerator
    dim = 2
    dx = &#x27;1 1.3 1.9&#x27;
    ix = &#x27;3 3 3&#x27;
    dy = &#x27;2 1.2 0.9&#x27;
    iy = &#x27;3 3 3&#x27;
    subdomain_id = &#x27;0 1 0
                    4 5 2
                    0 3 0&#x27;
  [../]

  [./inner_bottom]
    type = SideSetsBetweenSubdomainsGenerator
    input = cmg
    primary_block = 1
    paired_block = 5
    new_boundary = &#x27;inner_bottom&#x27;
  [../]

  [./inner_left]
    type = SideSetsBetweenSubdomainsGenerator
    input = inner_bottom
    primary_block = 4
    paired_block = 5
    new_boundary = &#x27;inner_left&#x27;
  [../]

  [./inner_right]
    type = SideSetsBetweenSubdomainsGenerator
    input = inner_left
    primary_block = 2
    paired_block = 5
    new_boundary = &#x27;inner_right&#x27;
  [../]

  [./inner_top]
    type = SideSetsBetweenSubdomainsGenerator
    input = inner_right
    primary_block = 3
    paired_block = 5
    new_boundary = &#x27;inner_top&#x27;
  [../]

  [./rename]
    type = RenameBlockGenerator
    old_block_id = &#x27;1 2 3 4&#x27;
    new_block_id = &#x27;0 0 0 0&#x27;
    input = inner_top
  [../]
[]

[Variables]
  [./temperature]
    block = 0
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temperature
    block = 0
    diffusion_coefficient = 5
  [../]
[]

[GrayDiffuseRadiation]
  [./cavity]
    boundary = &#x27;4 5 6 7&#x27;
    emissivity = &#x27;0.9 0.8 0.4 1&#x27;
    n_patches = &#x27;2 2 2 3&#x27;
    partitioners = &#x27;centroid centroid centroid centroid&#x27;
    centroid_partitioner_directions = &#x27;x y y x&#x27;
    final_mesh_generator = rename
    temperature = temperature
    adiabatic_boundary = &#x27;7&#x27;
    fixed_temperature_boundary = &#x27;4&#x27;
    fixed_boundary_temperatures = &#x27;1200&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = temperature
    boundary = left
    value = 600
  [../]

  [./right]
    type = DirichletBC
    variable = temperature
    boundary = right
    value = 300
  [../]
[]

[Postprocessors]
  [./average_T_inner_right]
    type = SideAverageValue
    variable = temperature
    boundary = inner_right
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f7a0d77c-db52-4a9f-be06-804146342167"><div class="modal-content"><h4>modules/heat_conduction/test/tests/radiation_transfer_action/radiative_transfer_action_external_boundary.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  kernel_coverage_check = false
[]

[Mesh]
  [./cmg]
    type = CartesianMeshGenerator
    dim = 2
    dx = &#x27;1 1.3 1.9&#x27;
    ix = &#x27;3 3 3&#x27;
    dy = &#x27;6&#x27;
    iy = &#x27;9&#x27;
    subdomain_id = &#x27;0 1 2&#x27;
  [../]

    [./inner_left]
      type = SideSetsBetweenSubdomainsGenerator
      input = cmg
      primary_block = 0
      paired_block = 1
      new_boundary = &#x27;inner_left&#x27;
    [../]

    [./inner_right]
      type = SideSetsBetweenSubdomainsGenerator
      input = inner_left
      primary_block = 2
      paired_block = 1
      new_boundary = &#x27;inner_right&#x27;
    [../]

    [./inner_top]
      type = ParsedGenerateSideset
      combinatorial_geometry = &#x27;abs(y - 6) &lt; 1e-10&#x27;
      normal = &#x27;0 1 0&#x27;
      included_subdomain_ids = 1
      new_sideset_name = &#x27;inner_top&#x27;
      input = &#x27;inner_right&#x27;
    [../]

    [./inner_bottom]
      type = ParsedGenerateSideset
      combinatorial_geometry = &#x27;abs(y) &lt; 1e-10&#x27;
      normal = &#x27;0 -1 0&#x27;
      included_subdomain_ids = 1
      new_sideset_name = &#x27;inner_bottom&#x27;
      input = &#x27;inner_top&#x27;
    [../]

    [./rename]
      type = RenameBlockGenerator
      old_block_id = &#x27;2&#x27;
      new_block_id = &#x27;0&#x27;
      input = inner_bottom
    [../]
[]

[Variables]
  [./temperature]
    block = 0
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temperature
    block = 0
    diffusion_coefficient = 5
  [../]
[]

[GrayDiffuseRadiation]
  [./cavity]
    boundary = &#x27;4 5 6 7&#x27;
    emissivity = &#x27;0.9 0.8 0.4 1&#x27;
    n_patches = &#x27;2 2 2 3&#x27;
    partitioners = &#x27;centroid centroid centroid centroid&#x27;
    centroid_partitioner_directions = &#x27;x y y x&#x27;
    final_mesh_generator = rename
    temperature = temperature
    adiabatic_boundary = &#x27;7&#x27;
    fixed_temperature_boundary = &#x27;6&#x27;
    fixed_boundary_temperatures = &#x27;800&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = temperature
    boundary = left
    value = 1000
  [../]

  [./right]
    type = DirichletBC
    variable = temperature
    boundary = right
    value = 300
  [../]
[]

[Postprocessors]
  [./average_T_inner_right]
    type = SideAverageValue
    variable = temperature
    boundary = inner_right
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="cab3c71b-4d28-4eb5-ae87-da098dbe7e92"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_thermal_expansion_function/instantaneous.i</h4><pre class="moose-pre"><code class="language-text"># This test checks the thermal expansion calculated via a instantaneous thermal expansion coefficient.
# The coefficient is selected so as to result in a 1e-4 strain in the x-axis, and to cross over
# from positive to negative strain.

[Mesh]
  [./gen]
    type = GeneratedMeshGenerator
    dim = 3
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[AuxVariables]
  [./temp]
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = SMALL
    add_variables = true
    eigenstrain_names = eigenstrain
    generate_output = &#x27;strain_xx strain_yy strain_zz&#x27;
    use_automatic_differentiation = true
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]

  [./bottom]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]

  [./back]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value = 0.0
  [../]
[]

[AuxKernels]
  [./temp]
    type = FunctionAux
    variable = temp
    function = &#x27;1 + t&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeLinearElasticStress
  [../]
  [./thermal_expansion_strain]
    type = ADComputeInstantaneousThermalExpansionFunctionEigenstrain
    thermal_expansion_function = 4e-4
    stress_free_temperature = 1.5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Postprocessors]
  [./disp_x_max]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./temp_avg]
    type = ElementAverageValue
    variable = temp
  [../]
[]

[Executioner]
  type = Transient

  end_time = 1.0
  dt = 0.1
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0ae5197d-6101-47b7-a99d-10de0e25e11b"><div class="modal-content"><h4>modules/functional_expansion_tools/examples/2D_interface_no_material/main.i</h4><pre class="moose-pre"><code class="language-text"># Derived from the example &#x27;2D_interface&#x27; with the following differences:
#
#   1) No materials are used
[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 0.4
  nx = 6
  ymin = 0.0
  ymax = 10.0
  ny = 20
[]

[Variables]
  [./m]
  [../]
[]

[Kernels]
  [./diff_m]
    type = Diffusion
    variable = m
  [../]
  [./time_diff_m]
    type = TimeDerivative
    variable = m
  [../]
  [./source_m]
    type = BodyForce
    variable = m
    value = 100
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    value = 2
    variable = m
  [../]
[]

[BCs]
  [./interface_value]
    type = FXValueBC
    variable = m
    boundary = right
    function = FX_Basis_Value_Main
  [../]
  [./interface_flux]
    type = FXFluxBC
    boundary = right
    variable = m
    function = FX_Basis_Flux_Main
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;4&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
  [./FX_Basis_Flux_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;5&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
[]

[UserObjects]
  [./FX_Flux_UserObject_Main]
    type = FXBoundaryFluxUserObject
    function = FX_Basis_Flux_Main
    variable = m
    boundary = right
    diffusivity = 0.1
  [../]
[]

[Postprocessors]
  [./average_interface_value]
    type = SideAverageValue
    variable = m
    boundary = right
  [../]
  [./total_flux]
    type = SideFluxIntegral
    variable = m
    boundary = right
    diffusivity = 0.1
  [../]
  [./picard_iterations]
    type = NumPicardIterations
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 1.0
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = sub.i
    sub_cycling = true
  [../]
[]

[Transfers]
  [./FluxToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Flux_UserObject_Main
    multi_app_object_name = FX_Basis_Flux_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
  [./FluxToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Flux_Main
    multi_app_object_name = FX_Flux_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="838a0131-16b1-41c8-88bb-23415462c15f"><div class="modal-content"><h4>modules/heat_conduction/test/tests/recover/recover.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = recover_in.e
[]

[Variables]
  [./temp]
    initial_condition = 580.0
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
  [./heat_source]
    type = BodyForce
    variable = temp
    block = pellet_type_1
    value = 1e3
    function = &#x27;t&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 5
    secondary = 10
    emissivity_primary = 0
    emissivity_secondary = 0
    quadrature = true
  [../]
[]

[BCs]
  [./outside]
    type = DirichletBC
    value = 580
    boundary = &#x27;1 2 3&#x27;
    variable = temp
  [../]
  [./edge]
    type = DirichletBC
    value = 700
    boundary = 10
    variable = temp
  [../]
[]

[Materials]
  [./thermal_3]
    type = HeatConductionMaterial
    block = 3
    thermal_conductivity = 5
    specific_heat = 12
  [../]
  [./thermal_1]
    type = HeatConductionMaterial
    block = 1
    thermal_conductivity = 16.0
    specific_heat = 330.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27; lu       superlu_dist&#x27;

  nl_rel_tol = 1e-9
  nl_abs_tol = 1e-11

  start_time = -200
  n_startup_steps = 1
  end_time = 1.02e5
  num_steps = 10

  dtmax = 2e6
  dtmin = 1

  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 2.0e2
    optimal_iterations = 15
    iteration_window = 2
  [../]

  [./Quadrature]
    order = FIFTH
    side_order = SEVENTH
  [../]
[]

[Postprocessors]
  [./ave_temp_interior]
     type = SideAverageValue
     boundary = 9
     variable = temp
     execute_on = &#x27;initial linear&#x27;
  [../]
  [./avg_clad_temp]
    type = SideAverageValue
    boundary = 7
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./flux_from_clad]
    type = SideFluxIntegral
    variable = temp
    boundary = 5
    diffusivity = thermal_conductivity
  [../]
  [./_dt]
    type = TimestepSize
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="4b42a6b6-ec0a-423d-8d98-55340544e26a"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/rz.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (2) with an interior cavity of volume 8.
#   Block 1 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts T in the following way:
#   T =&gt; T0 + beta * t
# with
#   beta = T0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# At t = 1, p = 200.

[Problem]
  coord_type = RZ
[]

[GlobalParams]
  displacements = &#x27;disp_r disp_z&#x27;
[]

[Mesh]
  file = rz.e
[]

[Functions]
  [./temperature]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 2&#x27;
    scale_factor = 240.54443866068704
  [../]
[]

[Variables]
  [./disp_r]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
[]

[BCs]
  [./no_x]
    type = DirichletBC
    variable = disp_r
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 2
    function = temperature
    variable = temp
  [../]
  [./CavityPressure]
    [./1]
      boundary = 2
      initial_pressure = 100
      R = 8.314472
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
    [../]
  [../]
[]

[Materials]
  [./elastic_tensor1]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 1
  [../]
  [./strain1]
    type = ComputeAxisymmetricRZFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elastic_tensor2]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.3
    block = 2
  [../]
  [./strain2]
    type = ComputeAxisymmetricRZFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_abs_tol = 1e-10

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 2
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
[]

[Outputs]
  exodus = true
  [./checkpoint]
    type = Checkpoint
    num_files = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2a77ba20-6ef1-4b9c-b386-430cb6ce2cd3"><div class="modal-content"><h4>modules/functional_expansion_tools/examples/2D_interface/main.i</h4><pre class="moose-pre"><code class="language-text"># Basic example coupling a master and sub app at an interface in a 2D model.
# The master app provides a flux term to the sub app via Functional Expansions, which then performs
# its calculations.  The sub app&#x27;s interface conditions, both value and flux, are transferred back
# to the master app
[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 0.4
  nx = 6
  ymin = 0.0
  ymax = 10.0
  ny = 20
[]

[Variables]
  [./m]
  [../]
[]

[Kernels]
  [./diff_m]
    type = HeatConduction
    variable = m
  [../]
  [./time_diff_m]
    type = HeatConductionTimeDerivative
    variable = m
  [../]
  [./source_m]
    type = BodyForce
    variable = m
    value = 100
  [../]
[]

[Materials]
  [./Impervium]
    type = GenericConstantMaterial
    prop_names =  &#x27;thermal_conductivity specific_heat density&#x27;
    prop_values = &#x27;0.00001              50.0          100.0&#x27; # W/(cm K), J/(g K), g/cm^3
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    value = 2
    variable = m
  [../]
[]

[BCs]
  [./interface_value]
    type = FXValueBC
    variable = m
    boundary = right
    function = FX_Basis_Value_Main
  [../]
  [./interface_flux]
    type = FXFluxBC
    boundary = right
    variable = m
    function = FX_Basis_Flux_Main
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;4&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
  [./FX_Basis_Flux_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;5&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
[]

[UserObjects]
  [./FX_Flux_UserObject_Main]
    type = FXBoundaryFluxUserObject
    function = FX_Basis_Flux_Main
    variable = m
    boundary = right
    diffusivity = thermal_conductivity
  [../]
[]

[Postprocessors]
  [./average_interface_value]
    type = SideAverageValue
    variable = m
    boundary = right
  [../]
  [./total_flux]
    type = SideFluxIntegral
    variable = m
    boundary = right
    diffusivity = thermal_conductivity
  [../]
  [./picard_iterations]
    type = NumPicardIterations
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 1.0
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = sub.i
    sub_cycling = true
  [../]
[]

[Transfers]
  [./FluxToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Flux_UserObject_Main
    multi_app_object_name = FX_Basis_Flux_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
  [./FluxToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Flux_Main
    multi_app_object_name = FX_Flux_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="dd85de5b-43fa-49c5-b9c1-4d57ced24384"><div class="modal-content"><h4>modules/functional_expansion_tools/examples/2D_interface_different_submesh/main.i</h4><pre class="moose-pre"><code class="language-text"># Derived from the example &#x27;2D_interface&#x27; with the following differences:
#
#   1) The number of y divisions in the sub app is not the same as the master app
#   2) The subapp mesh is skewed in y
#   3) The Functional Expansion order for the flux term was increased to 7
[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0.0
  xmax = 0.4
  nx = 6
  ymin = 0.0
  ymax = 10.0
  ny = 20
[]

[Variables]
  [./m]
  [../]
[]

[Kernels]
  [./diff_m]
    type = HeatConduction
    variable = m
  [../]
  [./time_diff_m]
    type = HeatConductionTimeDerivative
    variable = m
  [../]
  [./source_m]
    type = BodyForce
    variable = m
    value = 100
  [../]
[]

[Materials]
  [./Impervium]
    type = GenericConstantMaterial
    prop_names =  &#x27;thermal_conductivity specific_heat density&#x27;
    prop_values = &#x27;0.00001              50.0          100.0&#x27; # W/(cm K), J/(g K), g/cm^3
  [../]
[]

[ICs]
  [./start_m]
    type = ConstantIC
    value = 2
    variable = m
  [../]
[]

[BCs]
  [./interface_value]
    type = FXValueBC
    variable = m
    boundary = right
    function = FX_Basis_Value_Main
  [../]
  [./interface_flux]
    type = FXFluxBC
    boundary = right
    variable = m
    function = FX_Basis_Flux_Main
  [../]
[]

[Functions]
  [./FX_Basis_Value_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;4&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
  [./FX_Basis_Flux_Main]
    type = FunctionSeries
    series_type = Cartesian
    orders = &#x27;7&#x27;
    physical_bounds = &#x27;0.0 10&#x27;
    y = Legendre
  [../]
[]

[UserObjects]
  [./FX_Flux_UserObject_Main]
    type = FXBoundaryFluxUserObject
    function = FX_Basis_Flux_Main
    variable = m
    boundary = right
    diffusivity = thermal_conductivity
  [../]
[]

[Postprocessors]
  [./average_interface_value]
    type = SideAverageValue
    variable = m
    boundary = right
  [../]
  [./total_flux]
    type = SideFluxIntegral
    variable = m
    boundary = right
    diffusivity = thermal_conductivity
  [../]
  [./picard_iterations]
    type = NumPicardIterations
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 1.0
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  picard_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-9
  picard_rel_tol = 1e-8
  picard_abs_tol = 1e-9
[]

[Outputs]
  exodus = true
[]

[MultiApps]
  [./FXTransferApp]
    type = TransientMultiApp
    input_files = sub.i
    sub_cycling = true
  [../]
[]

[Transfers]
  [./FluxToSub]
    type = MultiAppFXTransfer
    direction = to_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Flux_UserObject_Main
    multi_app_object_name = FX_Basis_Flux_Sub
  [../]
  [./ValueToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Value_Main
    multi_app_object_name = FX_Value_UserObject_Sub
  [../]
  [./FluxToMe]
    type = MultiAppFXTransfer
    direction = from_multiapp
    multi_app = FXTransferApp
    this_app_object_name = FX_Basis_Flux_Main
    multi_app_object_name = FX_Flux_UserObject_Sub
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d44a8265-c1d8-4c34-b84e-904e87f47ea8"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/3d.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = - (0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# The parameters combined at t = 1 gives p = 301.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 3d.e
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = ADDiffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = ADFunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e1
    poissons_ratio = 0
    block = 1
  [../]
  [./strain1]
    type = ADComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0
    block = 2
  [../]
  [./strain2]
    type = ADComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="56c17068-366b-4dc7-b837-08af34acf2fd"><div class="modal-content"><h4>modules/phase_field/examples/measure_interface_energy/1Dinterface_energy.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  nx = 100
  xmax = 100
  xmin = 0
  elem_type = EDGE
[]

[AuxVariables]
  [./local_energy]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./local_free_energy]
    type = TotalFreeEnergy
    variable = local_energy
    kappa_names = kappa_c
    interfacial_vars = c
  [../]
[]

[Variables]
  [./c]
    order = FIRST
    family = LAGRANGE
    scaling = 1e1
    [./InitialCondition]
      type = RampIC
      variable = c
      value_left = 0
      value_right = 1
    [../]
  [../]
  [./w]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./c_res]
    type = SplitCHParsed
    variable = c
    f_name = F
    kappa_name = kappa_c
    w = w
  [../]
  [./w_res]
    type = SplitCHWRes
    variable = w
    mob_name = M
  [../]
  [./time]
    type = CoupledTimeDerivative
    variable = w
    v = c
  [../]

[]

[Functions]
  [./Int_energy]
    type = ParsedFunction
    vals = &#x27;total_solute Cleft Cright Fleft Fright volume&#x27;
    value = &#x27;((total_solute-Cleft*volume)/(Cright-Cleft))*Fright+(volume-(total_solute-Cleft*volume)/(Cright-Cleft))*Fleft&#x27;
    vars = &#x27;total_solute Cleft Cright Fleft Fright volume&#x27;
  [../]
  [./Diff]
    type = ParsedFunction
    vals = &#x27;total_free_energy total_no_int&#x27;
    vars = &#x27;total_free_energy total_no_int&#x27;
    value = total_free_energy-total_no_int
  [../]
[]

[Materials]
  [./consts]
    type = GenericConstantMaterial
    prop_names  = &#x27;kappa_c M&#x27;
    prop_values = &#x27;25      150&#x27;
  [../]
  [./Free_energy]
    type = DerivativeParsedMaterial
    f_name = F
    function = &#x27;c^2*(c-1)^2&#x27;
    args = c
    derivative_order = 2
  [../]
[]

[Postprocessors]
  # The total free energy of the simulation cell to observe the energy reduction.
  [./total_free_energy]
    type = ElementIntegralVariablePostprocessor
    variable = local_energy
  [../]

  # for testing we also monitor the total solute amount, which should be conserved,
  # gives Cavg in % for this problem.
  [./total_solute]
    type = ElementIntegralVariablePostprocessor
    variable = c
  [../]
  # Get simulation cell size (1D volume) from postprocessor
  [./volume]
    type = ElementIntegralMaterialProperty
    mat_prop = 1
  [../]
  # Find concentration in each phase using SideAverageValue
  [./Cleft]
    type = SideAverageValue
    boundary = left
    variable = c
  [../]
  [./Cright]
    type = SideAverageValue
    boundary = right
    variable = c
  [../]
  # Find local energy in each phase by checking boundaries
  [./Fleft]
    type = SideAverageValue
    boundary = left
    variable = local_energy
  [../]
  [./Fright]
    type = SideAverageValue
    boundary = right
    variable = local_energy
  [../]
  # Use concentrations and energies to find total free energy without any interface,
  # only applies once equilibrium is reached!!
  # Difference between energy with and without interface
  # gives interface energy per unit area.
  [./total_no_int]
    type = FunctionValuePostprocessor
    function = Int_energy
  [../]
  [./Energy_of_Interface]
    type = FunctionValuePostprocessor
    function = Diff
  [../]
[]

[Preconditioning]
  # This preconditioner makes sure the Jacobian Matrix is fully populated. Our
  # kernels compute all Jacobian matrix entries.
  # This allows us to use the Newton solver below.
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  scheme = &#x27;bdf2&#x27;

  # Automatic differentiation provides a _full_ Jacobian in this example
  # so we can safely use NEWTON for a fast solve
  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 15
  l_tol = 1.0e-6

  nl_max_its = 15
  nl_rel_tol = 1.0e-10
  nl_abs_tol = 1.0e-4

  start_time = 0.0
  # make sure that the result obtained for the interfacial free energy is fully converged
  end_time   = 40

  [./TimeStepper]
    type = SolutionTimeAdaptiveDT
    dt = 0.5
  [../]
[]

[Outputs]
  gnuplot = true
  csv = true
  [./exodus]
    type = Exodus
    show = &#x27;c local_energy&#x27;
    execute_on = &#x27;failed initial nonlinear timestep_end final&#x27;
  [../]
  [./console]
    type = Console
    execute_on = &#x27;FAILED INITIAL NONLINEAR TIMESTEP_END final&#x27;
  [../]
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2d688aaf-e610-4287-9af0-69e9a93bc6c8"><div class="modal-content"><h4>modules/combined/test/tests/phase_field_fracture/crack2d_aniso.i</h4><pre class="moose-pre"><code class="language-text">#This input uses PhaseField-Nonconserved Action to add phase field fracture bulk rate kernels
[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 40
    ny = 20
    ymax = 0.5
  []
  [./noncrack]
    type = BoundingBoxNodeSetGenerator
    new_boundary = noncrack
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 0 0&#x27;
    input = gen
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./All]
        add_variables = true
        strain = SMALL
        additional_generate_output = &#x27;strain_yy stress_yy&#x27;
        planar_formulation = PLANE_STRAIN
      [../]
    [../]
  [../]
  [./PhaseField]
    [./Nonconserved]
      [./c]
        free_energy = F
        kappa = kappa_op
        mobility = L
      [../]
    [../]
  [../]
[]

[Kernels]
  [./solid_x]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_x
    component = 0
    c = c
  [../]
  [./solid_y]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_y
    component = 1
    c = c
  [../]
  [./off_disp]
    type = AllenCahnElasticEnergyOffDiag
    variable = c
    displacements = &#x27;disp_x disp_y&#x27;
    mob_name = L
  [../]
[]

[BCs]
  [./ydisp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = &#x27;t&#x27;
  [../]
  [./yfix]
    type = DirichletBC
    variable = disp_y
    boundary = noncrack
    value = 0
  [../]
  [./xfix]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0
  [../]
[]

[Materials]
  [./pfbulkmat]
    type = GenericConstantMaterial
    prop_names = &#x27;gc_prop l visco&#x27;
    prop_values = &#x27;1e-3 0.05 1e-6&#x27;
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;127.0 70.8 70.8 127.0 70.8 127.0 73.55 73.55 73.55&#x27;
    fill_method = symmetric9
    euler_angle_1 = 30
    euler_angle_2 = 0
    euler_angle_3 = 0
  [../]
  [./define_mobility]
    type = ParsedMaterial
    material_property_names = &#x27;gc_prop visco&#x27;
    f_name = L
    function = &#x27;1.0/(gc_prop * visco)&#x27;
  [../]
  [./define_kappa]
    type = ParsedMaterial
    material_property_names = &#x27;gc_prop l&#x27;
    f_name = kappa_op
    function = &#x27;gc_prop * l&#x27;
  [../]
  [./damage_stress]
    type = ComputeLinearElasticPFFractureStress
    c = c
    E_name = &#x27;elastic_energy&#x27;
    D_name = &#x27;degradation&#x27;
    F_name = &#x27;local_fracture_energy&#x27;
    decomposition_type = stress_spectral
    use_current_history_variable = true
  [../]
  [./degradation]
    type = DerivativeParsedMaterial
    f_name = degradation
    args = &#x27;c&#x27;
    function = &#x27;(1.0-c)^2*(1.0 - eta) + eta&#x27;
    constant_names       = &#x27;eta&#x27;
    constant_expressions = &#x27;1.0e-6&#x27;
    derivative_order = 2
  [../]
  [./local_fracture_energy]
    type = DerivativeParsedMaterial
    f_name = local_fracture_energy
    args = &#x27;c&#x27;
    material_property_names = &#x27;gc_prop l&#x27;
    function = &#x27;c^2 * gc_prop / 2 / l&#x27;
    derivative_order = 2
  [../]
  [./fracture_driving_energy]
    type = DerivativeSumMaterial
    args = c
    sum_materials = &#x27;elastic_energy local_fracture_energy&#x27;
    derivative_order = 2
    f_name = F
  [../]
[]

[Postprocessors]
  [./av_stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./av_strain_yy]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solving_package&#x27;
  petsc_options_value = &#x27;lu superlu_dist&#x27;

  nl_rel_tol = 1e-8
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 10

  dt = 5e-5
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="43326b62-03b0-4c14-b5e7-3a896d54264a"><div class="modal-content"><h4>test/tests/mesh/named_entities/named_entities_test_xda.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = named_entities.xda
  uniform_refine = 1
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 center_block 3&#x27;

    [./InitialCondition]
      type = ConstantIC
      value = 20
      block = &#x27;center_block 3&#x27;
    [../]
  [../]
[]

[AuxVariables]
  [./reporter]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;left_block 3&#x27;
  [../]
[]

[ICs]
  [./reporter_ic]
    type = ConstantIC
    variable = reporter
    value = 10
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
    # Note we are using both names and numbers here
    block = &#x27;left_block 2 right_block&#x27;
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = &#x27;center_block&#x27;
    value = 10
  [../]
[]

[AuxKernels]
  [./hardness]
    type = MaterialRealAux
    variable = reporter
    property = &#x27;hardness&#x27;
    block = &#x27;left_block 3&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left_side&#x27;
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = &#x27;right_side&#x27;
    value = 1
  [../]
[]

[Postprocessors]
  [./elem_average]
    type = ElementAverageValue
    variable = u
    block = &#x27;center_block&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./side_average]
    type = SideAverageValue
    variable = u
    boundary = &#x27;right_side&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Materials]
  [./constant]
    type = GenericConstantMaterial
    prop_names = &#x27;hardness&#x27;
    prop_values = 10
    block = &#x27;1 right_block&#x27;
  [../]

  [./empty]
    type = MTMaterial
    block = &#x27;center_block&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8da837ce-7476-4468-bd73-4d7eb2991f3c"><div class="modal-content"><h4>modules/combined/examples/effective_properties/effective_th_cond.i</h4><pre class="moose-pre"><code class="language-text"># This example calculates the effective thermal conductivity across a microstructure
# with circular second phase precipitates. Two methods are used to calculate the effective thermal conductivity,
# the direct method that applies a temperature to one side and a heat flux to the other,
# and the AEH method.
[Mesh] #Sets mesh size to 10 microns by 10 microns
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 100
    ny = 100
    xmax = 10
    ymax = 10
  []
  [./new_nodeset]
    input = gen
    type = ExtraNodesetGenerator
    coord = &#x27;5 5&#x27;
    new_boundary = 100
  [../]
[]

[Variables] #Adds variables needed for two ways of calculating effective thermal cond.
  [./T] #Temperature used for the direct calculation
    initial_condition = 800
  [../]
  [./Tx_AEH] #Temperature used for the x-component of the AEH solve
    initial_condition = 800
    scaling = 1.0e4 #Scales residual to improve convergence
  [../]
  [./Ty_AEH] #Temperature used for the y-component of the AEH solve
    initial_condition = 800
    scaling = 1.0e4  #Scales residual to improve convergence
  [../]
[]

[AuxVariables] #Creates second constant phase
  [./phase2]
  [../]
[]

[ICs] #Sets the IC for the second constant phase
  [./phase2_IC] #Creates circles with smooth interfaces at random locations
    variable = phase2
    type = MultiSmoothCircleIC
    int_width = 0.3
    numbub = 20
    bubspac = 1.5
    radius = 0.5
    outvalue = 0
    invalue = 1
    block = 0
  [../]
[]

[Kernels]
  [./HtCond] #Kernel for direct calculation of thermal cond
    type = HeatConduction
    variable = T
  [../]
  [./heat_x] #All other kernels are for AEH approach to calculate thermal cond.
    type = HeatConduction
    variable = Tx_AEH
  [../]
  [./heat_rhs_x]
    type = HomogenizedHeatConduction
    variable = Tx_AEH
    component = 0
  [../]
  [./heat_y]
    type = HeatConduction
    variable = Ty_AEH
  [../]
  [./heat_rhs_y]
    type = HomogenizedHeatConduction
    variable = Ty_AEH
    component = 1
  [../]
[]

[BCs]
  [./Periodic]
    [./all]
      auto_direction = &#x27;x y&#x27;
      variable = &#x27;Tx_AEH Ty_AEH&#x27;
    [../]
  [../]
  [./left_T] #Fix temperature on the left side
    type = DirichletBC
    variable = T
    boundary = left
    value = 800
  [../]
  [./right_flux] #Set heat flux on the right side
    type = NeumannBC
    variable = T
    boundary = right
    value = 5e-6
  [../]
  [./fix_x] #Fix Tx_AEH at a single point
    type = DirichletBC
    variable = Tx_AEH
    value = 800
    boundary = 100
  [../]
  [./fix_y] #Fix Ty_AEH at a single point
    type = DirichletBC
    variable = Ty_AEH
    value = 800
    boundary = 100
  [../]
[]

[Materials]
  [./thcond] #The equation defining the thermal conductivity is defined here, using two ifs
    # The k in the bulk is k_b, in the precipitate k_p2, and across the interaface k_int
    type = ParsedMaterial
    block = 0
    constant_names = &#x27;length_scale k_b k_p2 k_int&#x27;
    constant_expressions = &#x27;1e-6 5 1 0.1&#x27;
    function = &#x27;sk_b:= length_scale*k_b; sk_p2:= length_scale*k_p2; sk_int:= k_int*length_scale; if(phase2&gt;0.1,if(phase2&gt;0.95,sk_p2,sk_int),sk_b)&#x27;
    outputs = exodus
    f_name = thermal_conductivity
    args = phase2
  [../]
[]

[Postprocessors]
  [./right_T]
    type = SideAverageValue
    variable = T
    boundary = right
  [../]
  [./k_x_direct] #Effective thermal conductivity from direct method
    # This value is lower than the AEH value because it is impacted by second phase
    # on the right boundary
    type = ThermalConductivity
    variable = T
    flux = 5e-6
    length_scale = 1e-06
    T_hot = 800
    dx = 10
    boundary = right
  [../]
  [./k_x_AEH] #Effective thermal conductivity in x-direction from AEH
    type = HomogenizedThermalConductivity
    variable = Tx_AEH
    temp_x = Tx_AEH
    temp_y = Ty_AEH
    component = 0
    scale_factor = 1e6 #Scale due to length scale of problem
  [../]
  [./k_y_AEH] #Effective thermal conductivity in x-direction from AEH
    type = HomogenizedThermalConductivity
    variable = Ty_AEH
    temp_x = Tx_AEH
    temp_y = Ty_AEH
    component = 1
    scale_factor = 1e6 #Scale due to length scale of problem
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    off_diag_row = &#x27;Tx_AEH Ty_AEH&#x27;
    off_diag_column = &#x27;Ty_AEH Tx_AEH&#x27;
  [../]
[]

[Executioner]
  type = Steady
  l_max_its = 15
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold&#x27;
  petsc_options_value = &#x27;hypre boomeramg 31 0.7&#x27;
  l_tol = 1e-04
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1fab0db6-2baa-4290-9d34-fd2b5b0d882b"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/planar_xz.i</h4><pre class="moose-pre"><code class="language-text"># 1-D Gap Heat Transfer Test without mechanics
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two element blocks in the x-z plane.  Each element block
# is a square. They sit next to one another with a unit between them.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
# across each block. The temperature of the far bottom boundary
# is ramped from 100 to 200 over one time unit.  The temperature of the far top
# boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks:
#
# Flux = (T_left - T_right) * (gapK/gap_width)
#
# The gap conductivity is specified as 1, thus
#
# gapK(Tavg) = 1.0*Tavg
#
# The heat flux across the gap at time = 1 is then:
#
# Flux = 100 * (1.0/1.0) = 100
#
# For comparison, see results from the flux post processors.  These results
# are the same as for the unit 1-D gap heat transfer between two unit cubes.

[Mesh]
  [file]
    type = FileMeshGenerator
    file = simple_2D.e
  []
  [./rotate]
    type = TransformGenerator
    transform = ROTATE
    vector_value = &#x27;0 90 0&#x27;
    input = file
  [../]
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_bottom]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_top]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 100000000.0
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27;201                hypre    boomeramg      4&#x27;

  line_search = &#x27;none&#x27;
  nl_rel_tol = 1e-12
  l_tol = 1e-3
  l_max_its = 100

  dt = 1e-1
  end_time = 1.0
[]

[Postprocessors]
  [./temp_bottom]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_top]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_bottom]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_top]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="152dfc09-429f-4eb0-9c28-5fb6634d2290"><div class="modal-content"><h4>modules/combined/test/tests/phase_field_fracture/crack2d_computeCrackedStress_finitestrain_elastic.i</h4><pre class="moose-pre"><code class="language-text">#This input uses PhaseField-Nonconserved Action to add phase field fracture bulk rate kernels
[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 40
    ny = 20
    ymax = 0.5
  []
  [./noncrack]
    type = BoundingBoxNodeSetGenerator
    new_boundary = noncrack
    bottom_left = &#x27;0.5 0 0&#x27;
    top_right = &#x27;1 0 0&#x27;
    input = gen
  [../]
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[AuxVariables]
  [./strain_yy]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Modules]
  [./TensorMechanics]
    [./Master]
      [./All]
        add_variables = true
        strain = FINITE
        planar_formulation = PLANE_STRAIN
        additional_generate_output = &#x27;stress_yy&#x27;
        strain_base_name = uncracked
      [../]
    [../]
  [../]
  [./PhaseField]
    [./Nonconserved]
      [./c]
        free_energy = E_el
        kappa = kappa_op
        mobility = L
      [../]
    [../]
  [../]
[]

[Kernels]
  [./solid_x]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_x
    component = 0
    c = c
  [../]
  [./solid_y]
    type = PhaseFieldFractureMechanicsOffDiag
    variable = disp_y
    component = 1
    c = c
  [../]
  [./off_disp]
    type = AllenCahnElasticEnergyOffDiag
    variable = c
    displacements = &#x27;disp_x disp_y&#x27;
    mob_name = L
  [../]
[]

[AuxKernels]
  [./strain_yy]
    type = RankTwoAux
    variable = strain_yy
    rank_two_tensor = uncracked_mechanical_strain
    index_i = 1
    index_j = 1
    execute_on = TIMESTEP_END
  [../]
[]

[BCs]
  [./ydisp]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = top
    function = &#x27;t&#x27;
  [../]
  [./yfix]
    type = DirichletBC
    variable = disp_y
    boundary = noncrack
    value = 0
  [../]
  [./xfix]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0
  [../]
[]

[Materials]
  [./pfbulkmat]
    type = GenericConstantMaterial
    prop_names = &#x27;gc_prop l visco&#x27;
    prop_values = &#x27;1e-3 0.05 1e-4&#x27;
  [../]
  [./elasticity_tensor]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;120.0 80.0&#x27;
    fill_method = symmetric_isotropic
    base_name = uncracked
  [../]
  [./elastic]
    type = ComputeFiniteStrainElasticStress
    base_name = uncracked
  [../]
  [./cracked_stress]
    type = ComputeCrackedStress
    c = c
    kdamage = 1e-5
    F_name = E_el
    use_current_history_variable = true
    uncracked_base_name = uncracked
    finite_strain_model = true
  [../]
[]

[Postprocessors]
  [./av_stress_yy]
    type = ElementAverageValue
    variable = stress_yy
  [../]
  [./av_strain_yy]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solving_package&#x27;
  petsc_options_value = &#x27;lu superlu_dist&#x27;

  nl_rel_tol = 1e-8
  l_tol = 1e-4
  l_max_its = 100
  nl_max_its = 10

  dt = 3e-5
  num_steps = 2
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="55850264-9ffc-47ab-a020-767ada23692c"><div class="modal-content"><h4>modules/combined/examples/phase_field-mechanics/kks_mechanics_KHS.i</h4><pre class="moose-pre"><code class="language-text"># KKS phase-field model coupled with elasticity using Khachaturyan&#x27;s scheme as
# described in L.K. Aagesen et al., Computational Materials Science, 140, 10-21 (2017)
# Original run #170403a

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 640
  ny = 1
  nz = 1
  xmin = -10
  xmax = 10
  ymin = 0
  ymax = 0.03125
  zmin = 0
  zmax = 0.03125
  elem_type = HEX8
[]


[Variables]
  # order parameter
  [./eta]
    order = FIRST
    family = LAGRANGE
  [../]

  # solute concentration
  [./c]
    order = FIRST
    family = LAGRANGE
  [../]

  # chemical potential
  [./w]
    order = FIRST
    family = LAGRANGE
  [../]

  # solute phase concentration (matrix)
  [./cm]
    order = FIRST
    family = LAGRANGE
  [../]
  # solute phase concentration (precipitate)
  [./cp]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./eta_ic]
    variable = eta
    type = FunctionIC
    function = ic_func_eta
    block = 0
  [../]
  [./c_ic]
    variable = c
    type = FunctionIC
    function = ic_func_c
    block = 0
  [../]
  [./w_ic]
    variable = w
    type = ConstantIC
    value = 0.00991
    block = 0
  [../]
  [./cm_ic]
    variable = cm
    type = ConstantIC
    value = 0.131
    block = 0
  [../]
  [./cp_ic]
    variable = cp
    type = ConstantIC
    value = 0.236
    block = 0
  [../]
[]

[Functions]
  [./ic_func_eta]
    type = ParsedFunction
    value = &#x27;0.5*(1.0+tanh((x)/delta_eta/sqrt(2.0)))&#x27;
    vars = &#x27;delta_eta&#x27;
    vals = &#x27;0.8034&#x27;
  [../]
  [./ic_func_c]
    type = ParsedFunction
    value = &#x27;0.2389*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))^3*(6*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))^2-15*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))+10)+0.1339*(1-(0.5*(1.0+tanh(x/delta/sqrt(2.0))))^3*(6*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))^2-15*(0.5*(1.0+tanh(x/delta/sqrt(2.0))))+10))&#x27;
    vars = &#x27;delta&#x27;
    vals = &#x27;0.8034&#x27;
  [../]
  [./psi_eq_int]
    type = ParsedFunction
    value = &#x27;volume*psi_alpha&#x27;
    vars = &#x27;volume psi_alpha&#x27;
    vals = &#x27;volume psi_alpha&#x27;
  [../]
  [./gamma]
    type = ParsedFunction
    value = &#x27;(psi_int - psi_eq_int) / dy / dz&#x27;
    vars = &#x27;psi_int psi_eq_int dy       dz&#x27;
    vals = &#x27;psi_int psi_eq_int 0.03125  0.03125&#x27;
  [../]
[]

[AuxVariables]
  [./sigma11]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./sigma22]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./sigma33]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e11]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e12]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e22]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e33]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_el11]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_el12]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_el22]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./f_el]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./eigen_strain00]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./Fglobal]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./psi]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./matl_sigma11]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = sigma11
  [../]
  [./matl_sigma22]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = sigma22
  [../]
  [./matl_sigma33]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = sigma33
  [../]
  [./matl_e11]
    type = RankTwoAux
    rank_two_tensor = total_strain
    index_i = 0
    index_j = 0
    variable = e11
  [../]
  [./f_el]
    type = MaterialRealAux
    variable = f_el
    property = f_el_mat
    execute_on = timestep_end
  [../]
  [./GlobalFreeEnergy]
    variable = Fglobal
    type = KKSGlobalFreeEnergy
    fa_name = fm
    fb_name = fp
    w = 0.0264
    kappa_names = kappa
    interfacial_vars = eta
  [../]
  [./psi_potential]
    variable = psi
    type = ParsedAux
    args = &#x27;Fglobal w c f_el sigma11 e11&#x27;
    function = &#x27;Fglobal - w*c + f_el - sigma11*e11&#x27;
  [../]
[]


[BCs]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value = 0
  [../]
  [./front_y]
    type = DirichletBC
    variable = disp_y
    boundary = front
    value = 0
  [../]
  [./back_y]
    type = DirichletBC
    variable = disp_y
    boundary = back
    value = 0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value = 0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value = 0
  [../]
[]

[Materials]
  # Chemical free energy of the matrix
  [./fm]
    type = DerivativeParsedMaterial
    f_name = fm
    args = &#x27;cm&#x27;
    function = &#x27;6.55*(cm-0.13)^2&#x27;
  [../]

  # Chemical Free energy of the precipitate phase
  [./fp]
    type = DerivativeParsedMaterial
    f_name = fp
    args = &#x27;cp&#x27;
    function = &#x27;6.55*(cp-0.235)^2&#x27;
  [../]

# Elastic energy of the precipitate
  [./elastic_free_energy_p]
    type = ElasticEnergyMaterial
    f_name = f_el_mat
    args = &#x27;eta&#x27;
    outputs = exodus
  [../]


  # h(eta)
  [./h_eta]
    type = SwitchingFunctionMaterial
    h_order = HIGH
    eta = eta
  [../]

  # 1- h(eta), putting in function explicitly
  [./one_minus_h_eta_explicit]
    type = DerivativeParsedMaterial
    f_name = one_minus_h_explicit
    args = eta
    function = 1-eta^3*(6*eta^2-15*eta+10)
    outputs = exodus
  [../]

  # g(eta)
  [./g_eta]
    type = BarrierFunctionMaterial
    g_order = SIMPLE
    eta = eta
  [../]

  # constant properties
  [./constants]
    type = GenericConstantMaterial
    prop_names  = &#x27;M   L   kappa      misfit&#x27;
    prop_values = &#x27;0.7 0.7 0.01704    0.00377&#x27;
  [../]

  #Mechanical properties
  [./Stiffness_matrix]
    type = ComputeElasticityTensor
    base_name = C_matrix
    C_ijkl = &#x27;103.3 74.25 74.25 103.3 74.25 103.3 46.75 46.75 46.75&#x27;
    fill_method = symmetric9
  [../]
  [./Stiffness_ppt]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;100.7 71.45 71.45 100.7 71.45 100.7 50.10 50.10 50.10&#x27;
    base_name = C_ppt
    fill_method = symmetric9
  [../]
  [./C]
    type = CompositeElasticityTensor
    args = eta
    tensors = &#x27;C_matrix               C_ppt&#x27;
    weights = &#x27;one_minus_h_explicit   h&#x27;
  [../]
  [./stress]
    type = ComputeLinearElasticStress
  [../]
  [./strain]
    type = ComputeSmallStrain
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    eigenstrain_names = &#x27;eigenstrain_ppt&#x27;
  [../]
  [./eigen_strain]
    type = ComputeVariableEigenstrain
    eigen_base = &#x27;0.00377 0.00377 0.00377 0 0 0&#x27;
    prefactor = h
    args = eta
    eigenstrain_name = &#x27;eigenstrain_ppt&#x27;
  [../]
[]

[Kernels]
  [./TensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  # enforce c = (1-h(eta))*cm + h(eta)*cp
  [./PhaseConc]
    type = KKSPhaseConcentration
    ca       = cm
    variable = cp
    c        = c
    eta      = eta
  [../]

  # enforce pointwise equality of chemical potentials
  [./ChemPotVacancies]
    type = KKSPhaseChemicalPotential
    variable = cm
    cb       = cp
    fa_name  = fm
    fb_name  = fp
  [../]

  #
  # Cahn-Hilliard Equation
  #
  [./CHBulk]
    type = KKSSplitCHCRes
    variable = c
    ca       = cm
    fa_name  = fm
    w        = w
  [../]

  [./dcdt]
    type = CoupledTimeDerivative
    variable = w
    v = c
  [../]
  [./ckernel]
    type = SplitCHWRes
    mob_name = M
    variable = w
  [../]

  #
  # Allen-Cahn Equation
  #
  [./ACBulkF]
    type = KKSACBulkF
    variable = eta
    fa_name  = fm
    fb_name  = fp
    w        = 0.0264
    args = &#x27;cp cm&#x27;
  [../]
  [./ACBulkC]
    type = KKSACBulkC
    variable = eta
    ca       = cm
    cb       = cp
    fa_name  = fm
  [../]
  [./ACBulk_el] #This adds df_el/deta for strain interpolation
    type = AllenCahn
    variable = eta
    f_name = f_el_mat
  [../]
  [./ACInterface]
    type = ACInterface
    variable = eta
    kappa_name = kappa
  [../]
  [./detadt]
    type = TimeDerivative
    variable = eta
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -sub_pc_type   -sub_pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;asm       ilu            nonzero&#x27;

  l_max_its = 30
  nl_max_its = 10
  l_tol = 1.0e-4
  nl_rel_tol = 1.0e-8
  nl_abs_tol = 1.0e-11
  num_steps = 200

  [./TimeStepper]
    type = SolutionTimeAdaptiveDT
    dt = 0.5
  [../]
[]

[Postprocessors]
  [./f_el_int]
    type = ElementIntegralMaterialProperty
    mat_prop = f_el_mat
  [../]
  [./c_alpha]
    type =  SideAverageValue
    boundary = left
    variable = c
  [../]
  [./c_beta]
    type =  SideAverageValue
    boundary = right
    variable = c
  [../]
  [./e11_alpha]
    type =  SideAverageValue
    boundary = left
    variable = e11
  [../]
  [./e11_beta]
    type =  SideAverageValue
    boundary = right
    variable = e11
  [../]
  [./s11_alpha]
    type =  SideAverageValue
    boundary = left
    variable = sigma11
  [../]
  [./s22_alpha]
    type =  SideAverageValue
    boundary = left
    variable = sigma22
  [../]
  [./s33_alpha]
    type =  SideAverageValue
    boundary = left
    variable = sigma33
  [../]
  [./s11_beta]
    type =  SideAverageValue
    boundary = right
    variable = sigma11
  [../]
  [./s22_beta]
    type =  SideAverageValue
    boundary = right
    variable = sigma22
  [../]
  [./s33_beta]
    type =  SideAverageValue
    boundary = right
    variable = sigma33
  [../]
  [./f_el_alpha]
    type =  SideAverageValue
    boundary = left
    variable = f_el
  [../]
  [./f_el_beta]
    type =  SideAverageValue
    boundary = right
    variable = f_el
  [../]
  [./f_c_alpha]
    type =  SideAverageValue
    boundary = left
    variable = Fglobal
  [../]
  [./f_c_beta]
    type =  SideAverageValue
    boundary = right
    variable = Fglobal
  [../]
  [./chem_pot_alpha]
    type =  SideAverageValue
    boundary = left
    variable = w
  [../]
  [./chem_pot_beta]
    type =  SideAverageValue
    boundary = right
    variable = w
  [../]
  [./psi_alpha]
    type =  SideAverageValue
    boundary = left
    variable = psi
  [../]
  [./psi_beta]
    type =  SideAverageValue
    boundary = right
    variable = psi
  [../]
  [./total_energy]
    type = ElementIntegralVariablePostprocessor
    variable = Fglobal
  [../]
  # Get simulation cell size from postprocessor
  [./volume]
    type = ElementIntegralMaterialProperty
    mat_prop = 1
  [../]
  [./psi_eq_int]
    type = FunctionValuePostprocessor
    function = psi_eq_int
  [../]
  [./psi_int]
    type = ElementIntegralVariablePostprocessor
    variable = psi
  [../]
  [./gamma]
    type = FunctionValuePostprocessor
    function = gamma
  [../]
  [./int_position]
    type = FindValueOnLine
    start_point = &#x27;-10 0 0&#x27;
    end_point = &#x27;10 0 0&#x27;
    v = eta
    target = 0.5
  [../]
[]

#
# Precondition using handcoded off-diagonal terms
#
[Preconditioning]
  [./full]
    type = SMP
    full = true
  [../]
[]


[Outputs]
  [./exodus]
    type = Exodus
    interval = 20
  [../]
  checkpoint = true
  [./csv]
    type = CSV
    execute_on = &#x27;final&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fa8caf5a-b01c-4843-b1f9-cced97a86a60"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/radial_disp_aux/sphere_2d_axisymmetric.i</h4><pre class="moose-pre"><code class="language-text"># The purpose of this set of tests is to check the values computed
# by the RadialDisplacementAux AuxKernel. They should match the
# radial component of the displacment for a cylindrical or spherical
# model.
# This particular model is of a sphere subjected to uniform thermal
# expansion represented using a 2D axisymmetric model.

[Mesh]
  type = FileMesh
  file = circle_sector_2d.e
[]

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  order = SECOND
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[AuxVariables]
  [./temp]
  [../]
  [./rad_disp]
  [../]
[]

[Functions]
  [./temperature_load]
    type = ParsedFunction
    value = t+300.0
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    strain = FINITE
    add_variables = true
    eigenstrain_names = eigenstrain
  [../]
[]

[AuxKernels]
  [./tempfuncaux]
    type = FunctionAux
    variable = temp
    function = temperature_load
    use_displaced_mesh = false
  [../]
  [./raddispaux]
    type = RadialDisplacementSphereAux
    variable = rad_disp
    origin = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./x]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0.0
  [../]
  [./y]
    type = DirichletBC
    variable = disp_y
    boundary = 2
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 2.1e5
    poissons_ratio = 0.3
  [../]
  [./small_stress]
    type = ComputeFiniteStrainElasticStress
  [../]
  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    stress_free_temperature = 300
    thermal_expansion_coeff = 1.3e-5
    temperature = temp
    eigenstrain_name = eigenstrain
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-snes_ksp_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;51&#x27;

  line_search = &#x27;none&#x27;

  l_max_its = 50
  nl_max_its = 50
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10

  start_time = 0.0
  end_time = 1
  dt = 1
  dtmin = 1
[]

[Outputs]
 csv = true
 exodus = true
[]

#[Postprocessors]
#  [./strain_xx]
#    type = SideAverageValue
#    variable =
#    block = 0
#  [../]
#[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8ce69379-7f80-4a09-b002-d1001cd7ebd7"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/gap_heat_transfer_htonly_rspherical.i</h4><pre class="moose-pre"><code class="language-text">#
# 1-D spherical Gap Heat Transfer Test
#
# This test exercises 1-D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of two &quot;blocks&quot; with a mesh biased toward the gap
#   between them.  Each block is unit length.  The gap between them is one
#   unit in length.
#
# The conductivity of both blocks is set very large to achieve a uniform temperature
#  across each block. The temperature of the far left boundary
#  is ramped from 100 to 200 over one time unit, and then held fixed for an additional
#  time unit.  The temperature of the far right boundary is held fixed at 100.
#
# A simple analytical solution is possible for the heat flux between the blocks, or spheres in the case of RSPHERICAL.:
#
#  Flux = (T_left - T_right) * (gapK/(r^2*((1/r1)-(1/r2))))
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 4 * pi * 1 * 1
#
# The integrated heat flux across the gap at time 2 is then:
#
# 4*pi*k*delta_T/((1/r1)-(1/r2))
# 4*pi*1*100/((1/1) - (1/2)) =  2513.3 watts
#
# For comparison, see results from the flux post processors.
#
#

[Problem]
  coord_type = RSPHERICAL
[]

[Mesh]
  file = gap_heat_transfer_htonly_rspherical.e
  construct_side_list_from_node_list = true
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1   2&#x27;
    y = &#x27;100 200 200&#x27;
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
  [../]
[]

[Variables]
  [./temp]
    order = FIRST
    family = LAGRANGE
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_cond]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./heat]
    type = HeatConduction
    variable = temp
  [../]
[]


[BCs]
  [./temp_far_left]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]

  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[AuxKernels]
  [./conductance]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_cond
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1e6
  [../]
  [./density]
    type = Density
    block = &#x27;1 2&#x27;
    density = 1.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;PJFNK&#x27;

  # I don&#x27;t know enough about this test to say why it needs such a
  # loose nl_abs_tol... after timestep 10 the residual basically can&#x27;t
  # be reduced much beyond the initial residual.  The test probably
  # needs to be revisited to determine why.
  nl_abs_tol = 1e-3
  nl_rel_tol = 1e-10
  l_tol = 1e-6
  l_max_its = 100
  line_search = &#x27;none&#x27;
  nl_max_its = 10

  dt = 1e-1
  dtmin = 1e-1
  end_time = 2.0
[]

[Postprocessors]

  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]


[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="1c99bef0-66d1-4b18-b19a-40dcf5b22e44"><div class="modal-content"><h4>test/tests/functions/pps_function/pp_function.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  active = &#x27;u&#x27;
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./function_force]
    function = pp_func
    variable = u
    type = BodyForce
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = out
  exodus = true
[]

[Functions]
  [./pp_func]
    pp = right_value
    type = PostprocessorFunction
  [../]
[]

[Postprocessors]
  [./right_value]
    variable = u
    execute_on = linear
    boundary = 1
    type = SideAverageValue
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="db07b59c-86c4-4ef5-952a-da283c77138e"><div class="modal-content"><h4>test/tests/mesh/named_entities/named_entities_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = named_entities.e
  uniform_refine = 1
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 center_block 3&#x27;

    [./InitialCondition]
      type = ConstantIC
      value = 20
      block = &#x27;center_block 3&#x27;
    [../]
  [../]
[]

[AuxVariables]
  [./reporter]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;left_block 3&#x27;
  [../]
[]

[ICs]
  [./reporter_ic]
    type = ConstantIC
    variable = reporter
    value = 10
  [../]
[]

[Kernels]
  active = &#x27;diff body_force&#x27;

  [./diff]
    type = Diffusion
    variable = u
    # Note we are using both names and numbers here
    block = &#x27;left_block 2 right_block&#x27;
  [../]

  [./body_force]
    type = BodyForce
    variable = u
    block = &#x27;center_block&#x27;
    value = 10
  [../]
[]

[AuxKernels]
  [./hardness]
    type = MaterialRealAux
    variable = reporter
    property = &#x27;hardness&#x27;
    block = &#x27;left_block 3&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left_side&#x27;
    value = 1
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = &#x27;right_side&#x27;
    value = 1
  [../]
[]

[Postprocessors]
  [./elem_average]
    type = ElementAverageValue
    variable = u
    block = &#x27;center_block&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]

  [./side_average]
    type = SideAverageValue
    variable = u
    boundary = &#x27;right_side&#x27;
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[Materials]
  [./constant]
    type = GenericConstantMaterial
    prop_names = &#x27;hardness&#x27;
    prop_values = 10
    block = &#x27;1 right_block&#x27;
  [../]

  [./empty]
    type = MTMaterial
    block = &#x27;center_block&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f8ea6f45-6088-4bce-b660-2b1cefd4e1d3"><div class="modal-content"><h4>modules/combined/test/tests/ad_cavity_pressure/multiple_postprocessors.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test (Volume input as a vector of postprocessors)
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = - (0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# In this test the internal volume is calculated as the sum of two Postprocessors
# internalVolumeInterior and internalVolumeExterior.  This sum equals the value
# reported by the internalVolume postprocessor.
#
# The parameters combined at t = 1 gives p = 301.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 3d.e
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
    use_automatic_differentiation = true
  [../]
  [./heat]
    type = ADDiffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = ADDiffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = ADRankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = ADFunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = ADFunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = ADFunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      volume = &#x27;internalVolumeInterior internalVolumeExterior&#x27;
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
      use_automatic_differentiation = true
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e1
    poissons_ratio = 0
    block = 1
  [../]
  [./strain1]
    type = ADComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ADComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0
    block = 2
  [../]
  [./strain2]
    type = ADComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ADComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./internalVolumeInterior]
    type = InternalVolume
    boundary = &#x27;1 2 3 4 5 6&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./internalVolumeExterior]
    type = InternalVolume
    boundary = &#x27;13 14 15 16 17 18&#x27;
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f2a301d4-eab3-40dd-b023-0c9935ffe31d"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/initial_temperature.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = -(0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# The parameters combined at t = 1 gives p = 301.
#
# This test sets the initial temperature to 500, but the CavityPressure
#   is told that that initial temperature is T0.  Thus, the final solution
#   is unchanged.

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3d.e
[]

[GlobalParams]
  volumetric_locking_correction = true
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 500
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = Diffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = FunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      initial_temperature = 240.54443866068704
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 1
  [../]
  [./strain1]
    type = ComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ComputeElasticityTensor
    C_ijkl = &#x27;0 5&#x27;
    fill_method = symmetric_isotropic
    block = 2
  [../]
  [./strain2]
    type = ComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="296f844d-ae13-4b1a-8076-810a18a080f6"><div class="modal-content"><h4>test/tests/controls/time_periods/user_objects/user_object.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
    initial_condition = 0.01
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Postprocessors]
  [./nodal]
    type = AverageNodalVariableValue
    variable = u
    execute_on = &#x27;TIMESTEP_END&#x27;
  [../]
  [./elemental]
    type = ElementAverageValue
    variable = u
    execute_on = &#x27;TIMESTEP_END&#x27;
  [../]
  [./general]
    type = PointValue
    point = &#x27;0.5 0.5 0&#x27;
    variable = u
    execute_on = &#x27;TIMESTEP_END&#x27;
  [../]
  [./internal_side]
    type = NumInternalSides
  [../]
  [./side]
    type = SideAverageValue
    boundary = right
    variable = u
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 10
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  csv = true
[]

[Controls]
  [./pp_control]
    type = TimePeriod
    enable_objects = &#x27;*/nodal */elemental */general */internal_side */side&#x27;
    start_time = 0.5
    end_time = 1
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="85bcb09f-9ec1-49f8-9a9f-2d8f16515944"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_single.i</h4><pre class="moose-pre"><code class="language-text"># This test provides an example of an individual LPS viscoplasticity model

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmax = 0.002
  ymax = 0.002
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = lps
    initial_porosity = 0.1
    outputs = all
  [../]

  [./lps]
    type = ADViscoplasticityStressUpdate
    coefficient = &#x27;coef&#x27;
    power = 3
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./coef]
    type = ADParsedMaterial
    f_name = coef
    # Example of creep power law
    function = &#x27;1e-18 * exp(-4e4 / 1.987 / 1200)&#x27;
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./eff_creep_strain]
    type = ElementAverageValue
    variable = effective_viscoplasticity
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d8f7956a-f128-40b3-980b-6590daed2cce"><div class="modal-content"><h4>modules/combined/test/tests/cavity_pressure/3d.i</h4><pre class="moose-pre"><code class="language-text">#
# Cavity Pressure Test
#
# This test is designed to compute an internal pressure based on
#   p = n * R * T / V
# where
#   p is the pressure
#   n is the amount of material in the volume (moles)
#   R is the universal gas constant
#   T is the temperature
#   V is the volume
#
# The mesh is composed of one block (1) with an interior cavity of volume 8.
#   Block 2 sits in the cavity and has a volume of 1.  Thus, the total
#   initial volume is 7.
# The test adjusts n, T, and V in the following way:
#   n =&gt; n0 + alpha * t
#   T =&gt; T0 + beta * t
#   V =&gt; V0 + gamma * t
# with
#   alpha = n0
#   beta = T0 / 2
#   gamma = - (0.003322259...) * V0
#   T0 = 240.54443866068704
#   V0 = 7
#   n0 = f(p0)
#   p0 = 100
#   R = 8.314472 J * K^(-1) * mol^(-1)
#
# So, n0 = p0 * V0 / R / T0 = 100 * 7 / 8.314472 / 240.544439
#        = 0.35
#
# The parameters combined at t = 1 gives p = 301.
#

[GlobalParams]
  displacements = &#x27;disp_x disp_y disp_z&#x27;
  volumetric_locking_correction = true
[]

[Mesh]
  file = 3d.e
[]

[Functions]
  [./displ_positive]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 0.0029069767441859684&#x27;
  [../]
  [./displ_negative]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;0 -0.0029069767441859684&#x27;
  [../]
  [./temp1]
    type = PiecewiseLinear
    x = &#x27;0 1&#x27;
    y = &#x27;1 1.5&#x27;
    scale_factor = 240.54443866068704
  [../]
  [./material_input_function]
    type = PiecewiseLinear
    x = &#x27;0    1&#x27;
    y = &#x27;0 0.35&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./temp]
    initial_condition = 240.54443866068704
  [../]
  [./material_input]
  [../]
[]

[AuxVariables]
  [./pressure_residual_x]
  [../]
  [./pressure_residual_y]
  [../]
  [./pressure_residual_z]
  [../]
  [./stress_xx]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_xy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_zx]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./TensorMechanics]
    use_displaced_mesh = true
  [../]
  [./heat]
    type = Diffusion
    variable = temp
    use_displaced_mesh = true
  [../]
  [./material_input_dummy]
    type = Diffusion
    variable = material_input
    use_displaced_mesh = true
  [../]
[]

[AuxKernels]
  [./stress_xx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 0
    variable = stress_xx
  [../]
  [./stress_yy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 1
    variable = stress_yy
  [../]
  [./stress_zz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 2
    variable = stress_zz
  [../]
  [./stress_xy]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 0
    index_j = 1
    variable = stress_xy
  [../]
  [./stress_yz]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 1
    index_j = 2
    variable = stress_yz
  [../]
  [./stress_zx]
    type = RankTwoAux
    rank_two_tensor = stress
    index_i = 2
    index_j = 0
    variable = stress_zx
  [../]
[]

[BCs]
  [./no_x_exterior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;7 8&#x27;
    value = 0.0
  [../]
  [./no_y_exterior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;9 10&#x27;
    value = 0.0
  [../]
  [./no_z_exterior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;11 12&#x27;
    value = 0.0
  [../]
  [./prescribed_left]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 13
    function = displ_positive
  [../]
  [./prescribed_right]
    type = FunctionDirichletBC
    variable = disp_x
    boundary = 14
    function = displ_negative
  [../]
  [./no_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;15 16&#x27;
    value = 0.0
  [../]
  [./no_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;17 18&#x27;
    value = 0.0
  [../]
  [./no_x_interior]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
  [./no_y_interior]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;3 4&#x27;
    value = 0.0
  [../]
  [./no_z_interior]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;5 6&#x27;
    value = 0.0
  [../]
  [./temperatureInterior]
    type = FunctionDirichletBC
    boundary = 100
    function = temp1
    variable = temp
  [../]
  [./MaterialInput]
    type = FunctionDirichletBC
    boundary = &#x27;100 13 14 15 16&#x27;
    function = material_input_function
    variable = material_input
  [../]
  [./CavityPressure]
    [./1]
      boundary = 100
      initial_pressure = 100
      material_input = materialInput
      R = 8.314472
      temperature = aveTempInterior
      volume = internalVolume
      startup_time = 0.5
      output = ppress
      save_in = &#x27;pressure_residual_x pressure_residual_y pressure_residual_z&#x27;
    [../]
  [../]
[]

[Materials]
  [./elast_tensor1]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e1
    poissons_ratio = 0
    block = 1
  [../]
  [./strain1]
    type = ComputeFiniteStrain
    block = 1
  [../]
  [./stress1]
    type = ComputeFiniteStrainElasticStress
    block = 1
  [../]
  [./elast_tensor2]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0
    block = 2
  [../]
  [./strain2]
    type = ComputeFiniteStrain
    block = 2
  [../]
  [./stress2]
    type = ComputeFiniteStrainElasticStress
    block = 2
  [../]
[]

[Executioner]
  type = Transient

  petsc_options_iname = &#x27;-pc_type -sub_pc_type&#x27;
  petsc_options_value = &#x27;asm       lu&#x27;

  nl_rel_tol = 1e-12
  l_tol = 1e-12

  l_max_its = 20

  dt = 0.5
  end_time = 1.0
[]

[Postprocessors]
  [./internalVolume]
    type = InternalVolume
    boundary = 100
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./aveTempInterior]
    type = SideAverageValue
    boundary = 100
    variable = temp
    execute_on = &#x27;initial linear&#x27;
  [../]
  [./materialInput]
    type = SideAverageValue
    boundary = &#x27;7 8 9 10 11 12&#x27;
    variable = material_input
    execute_on = linear
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="49eb1c45-a01f-4395-98df-9fe9dcf6b69c"><div class="modal-content"><h4>modules/combined/test/tests/gap_heat_transfer_htonly/sphere2DRZ.i</h4><pre class="moose-pre"><code class="language-text">#
# 2DRZ Spherical Gap Heat Transfer Test.
#
# This test exercises 2D gap heat transfer for a constant conductivity gap.
#
# The mesh consists of an inner solid sphere of radius = 1 unit, and outer
# hollow sphere with an inner radius of 2. In other words, the gap between
# them is 1 radial unit in length.
#
# The conductivity of both spheres is set very large to achieve a uniform
# temperature in each sphere. The temperature of the center node of the
# inner sphere is ramped from 100 to 200 over one time unit. The
# temperature of the outside of the outer, hollow sphere is held fixed
# at 100.
#
# A simple analytical solution is possible for the integrated heat flux
# between the inner and outer spheres:
#
#  Integrated Flux = (T_left - T_right) * (gapK/(r^2*((1/r1)-(1/r2)))) * Area
#
# For gapK = 1 (default value)
#
# The area is taken as the area of the secondary (inner) surface:
#
# Area = 4 * pi * 1^2 (4*pi*r^2)
#
# The integrated heat flux across the gap at time 1 is then:
#
# 4*pi*k*delta_T/((1/r1)-(1/r2))
# 4*pi*1*100/((1/1) - (1/2)) =  2513.3 watts
#
# For comparison, see results from the integrated flux post processors.
# This simulation makes use of symmetry, so only 1/2 of the spheres is meshed
# As such, the integrated flux from the post processors is 1/2 of the total,
# or 1256.6 watts... i.e. 400*pi.
# The value coming from the post processor is slightly less than this
# but converges as mesh refinement increases.
#
# Simulating contact is challenging. Regression tests that exercise
# contact features can be difficult to solve consistently across multiple
# platforms. While designing these tests, we felt it worth while to note
# some aspects of these tests. The following applies to:
# sphere3D.i, sphere2DRZ.i, cyl2D.i, and cyl3D.i.
# 1. We decided that to perform consistently across multiple platforms we
# would use very small convergence tolerance. In this test we chose an
# nl_rel_tol of 1e-12.
# 2. Due to such a high value for thermal conductivity (used here so that the
# domains come to a uniform temperature) the integrated flux at time = 0
# was relatively large (the value coming from SideIntegralFlux =
#  -_diffusion_coef[_qp]*_grad_u[_qp]*_normals[_qp] where the diffusion coefficient
# here is thermal conductivity).
# Even though _grad_u[_qp] is small, in this case the diffusion coefficient
# is large. The result is a number that isn&#x27;t exactly zero and tends to
# fail exodiff. For this reason the parameter execute_on = initial should not
# be used. That parameter is left to default settings in these regression tests.
#
[GlobalParams]
  order = SECOND
  family = LAGRANGE
[]

[Problem]
  coord_type = RZ
[]

[Mesh]
  file = cyl2D.e
[]

[Functions]
  [./temp]
    type = PiecewiseLinear
    x = &#x27;0   1&#x27;
    y = &#x27;100 200&#x27;
  [../]
[]


[Variables]
  [./temp]
    initial_condition = 100
  [../]
[]

[AuxVariables]
  [./gap_conductance]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]


[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temp
  [../]
[]


[AuxKernels]
  [./gap_cond]
    type = MaterialRealAux
    property = gap_conductance
    variable = gap_conductance
    boundary = 2
  [../]
[]

[Materials]
  [./heat1]
    type = HeatConductionMaterial
    block = &#x27;1 2&#x27;
    specific_heat = 1.0
    thermal_conductivity = 1000000.0
  [../]
[]

[ThermalContact]
  [./thermal_contact]
    type = GapHeatTransfer
    variable = temp
    primary = 3
    secondary = 2
    emissivity_primary = 0
    emissivity_secondary = 0
    gap_conductivity = 1
    quadrature = true
    gap_geometry_type = SPHERE
    sphere_origin = &#x27;0 0 0&#x27;
  [../]
[]

[BCs]
  [./mid]
    type = FunctionDirichletBC
    boundary = 1
    variable = temp
    function = temp
  [../]
  [./temp_far_right]
    type = DirichletBC
    boundary = 4
    variable = temp
    value = 100
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  petsc_options_value = &#x27;lu       superlu_dist&#x27;

  dt = 1
  dtmin = 0.01
  end_time = 1

  nl_rel_tol = 1e-12
  nl_abs_tol = 1e-7

  [./Quadrature]
    order = fifth
    side_order = seventh
  [../]
[]

[Outputs]
  exodus = true
  [./Console]
    type = Console
  [../]
[]

[Postprocessors]
  [./temp_left]
    type = SideAverageValue
    boundary = 2
    variable = temp
  [../]

  [./temp_right]
    type = SideAverageValue
    boundary = 3
    variable = temp
  [../]

  [./flux_left]
    type = SideFluxIntegral
    variable = temp
    boundary = 2
    diffusivity = thermal_conductivity
  [../]

  [./flux_right]
    type = SideFluxIntegral
    variable = temp
    boundary = 3
    diffusivity = thermal_conductivity
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2a222d9d-b9c9-4b56-8f07-f29e80356cda"><div class="modal-content"><h4>modules/heat_conduction/test/tests/radiation_transfer_action/radiative_transfer_no_action.i</h4><pre class="moose-pre"><code class="language-text">[Problem]
  kernel_coverage_check = false
[]

[Mesh]
  type = MeshGeneratorMesh

  [./cmg]
    type = CartesianMeshGenerator
    dim = 2
    dx = &#x27;1 1.3 1.9&#x27;
    ix = &#x27;3 3 3&#x27;
    dy = &#x27;2 1.2 0.9&#x27;
    iy = &#x27;3 3 3&#x27;
    subdomain_id = &#x27;0 1 0
                    4 5 2
                    0 3 0&#x27;
  [../]

  [./inner_bottom]
    type = SideSetsBetweenSubdomainsGenerator
    input = cmg
    primary_block = 1
    paired_block = 5
    new_boundary = &#x27;inner_bottom&#x27;
  [../]

  [./inner_left]
    type = SideSetsBetweenSubdomainsGenerator
    input = inner_bottom
    primary_block = 4
    paired_block = 5
    new_boundary = &#x27;inner_left&#x27;
  [../]

  [./inner_right]
    type = SideSetsBetweenSubdomainsGenerator
    input = inner_left
    primary_block = 2
    paired_block = 5
    new_boundary = &#x27;inner_right&#x27;
  [../]

  [./inner_top]
    type = SideSetsBetweenSubdomainsGenerator
    input = inner_right
    primary_block = 3
    paired_block = 5
    new_boundary = &#x27;inner_top&#x27;
  [../]

  [./rename]
    type = RenameBlockGenerator
    old_block_id = &#x27;1 2 3 4&#x27;
    new_block_id = &#x27;0 0 0 0&#x27;
    input = inner_top
  [../]

  [./split_inner_bottom]
    type = PatchSidesetGenerator
    boundary = 4
    n_patches = 2
    partitioner = centroid
    centroid_partitioner_direction = x
    input = rename
  [../]

  [./split_inner_left]
    type = PatchSidesetGenerator
    boundary = 5
    n_patches = 2
    partitioner = centroid
    centroid_partitioner_direction = y
    input = split_inner_bottom
  [../]

  [./split_inner_right]
    type = PatchSidesetGenerator
    boundary = 6
    n_patches = 2
    partitioner = centroid
    centroid_partitioner_direction = y
    input = split_inner_left
  [../]

  [./split_inner_top]
    type = PatchSidesetGenerator
    boundary = 7
    n_patches = 3
    partitioner = centroid
    centroid_partitioner_direction = x
    input = split_inner_right
  [../]
[]

[Variables]
  [./temperature]
    block = 0
  [../]
[]

[Kernels]
  [./heat_conduction]
    type = HeatConduction
    variable = temperature
    block = 0
    diffusion_coefficient = 5
  [../]
[]

[UserObjects]
  [./gray_lambert]
    type = ViewFactorObjectSurfaceRadiation
    boundary = &#x27;inner_bottom_0 inner_bottom_1
                inner_left_0 inner_left_1
                inner_right_0 inner_right_1
                inner_top_0 inner_top_1 inner_top_2&#x27;
    fixed_temperature_boundary = &#x27;inner_bottom_0 inner_bottom_1&#x27;
    fixed_boundary_temperatures = &#x27;1200          1200&#x27;
    adiabatic_boundary = &#x27;inner_top_0 inner_top_1 inner_top_2&#x27;
    emissivity = &#x27;0.9 0.9
                  0.8 0.8
                  0.4 0.4
                  1 1 1&#x27;
    temperature = temperature
    view_factor_object_name = view_factor
    execute_on = &#x27;LINEAR TIMESTEP_END&#x27;
  [../]

  [./view_factor]
    type = UnobstructedPlanarViewFactor
    boundary = &#x27;inner_bottom_0 inner_bottom_1
                inner_left_0 inner_left_1
                inner_right_0 inner_right_1
                inner_top_0 inner_top_1 inner_top_2&#x27;
    normalize_view_factor = true
    execute_on = &#x27;INITIAL&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = temperature
    boundary = left
    value = 600
  [../]

  [./right]
    type = DirichletBC
    variable = temperature
    boundary = right
    value = 300
  [../]

  [./radiation]
    type = GrayLambertNeumannBC
    variable = temperature
    surface_radiation_object_name = gray_lambert
    boundary = &#x27;inner_left_0 inner_left_1
                inner_right_0 inner_right_1&#x27;
  [../]
[]

[Postprocessors]
  [./average_T_inner_right]
    type = SideAverageValue
    variable = temperature
    boundary = inner_right
  [../]
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b10ba510-e900-4035-9295-df9dc1c800b2"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/ad_viscoplasticity_stress_update/lps_single_split.i</h4><pre class="moose-pre"><code class="language-text"># This test provides an example of combining two LPS viscoplasticity model.
# The answer should be close, but not exactly the same, as lps_single.i

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 1
  xmax = 0.002
  ymax = 0.002
[]

[Modules/TensorMechanics/Master/All]
  strain = FINITE
  add_variables = true
  generate_output = &#x27;strain_xx strain_yy strain_xy hydrostatic_stress vonmises_stress&#x27;
  use_automatic_differentiation = true
[]

[Functions]
  [./pull]
    type = PiecewiseLinear
    x = &#x27;0 0.1&#x27;
    y = &#x27;0 1e-5&#x27;
  [../]
  [./tot_effective_viscoplasticity]
    type = ParsedFunction
    vals = &#x27;lps_1_eff_creep_strain lps_2_eff_creep_strain&#x27;
    vars = &#x27;lps_1_eff_creep_strain lps_2_eff_creep_strain&#x27;
    value = &#x27;lps_1_eff_creep_strain+lps_2_eff_creep_strain&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ADComputeIsotropicElasticityTensor
    youngs_modulus = 1e10
    poissons_ratio = 0.3
  [../]
  [./stress]
    type = ADComputeMultiplePorousInelasticStress
    inelastic_models = &#x27;one two&#x27;
    initial_porosity = 0.1
    outputs = all
  [../]

  [./one]
    type = ADViscoplasticityStressUpdate
    coefficient = &#x27;coef&#x27;
    power = 3
    base_name = &#x27;lps_first&#x27;
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./two]
    type = ADViscoplasticityStressUpdate
    coefficient = &#x27;coef&#x27;
    power = 3
    base_name = &#x27;lps_second&#x27;
    outputs = all
    relative_tolerance = 1e-11
  [../]
  [./coef]
    type = ADParsedMaterial
    f_name = coef
    # Example of creep power law
    function = &#x27;0.5e-18 * exp(-4e4 / 1.987 / 1200)&#x27;
  [../]
[]

[BCs]
  [./no_disp_x]
    type = ADDirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./no_disp_y]
    type = ADDirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./pull_disp_y]
    type = ADFunctionDirichletBC
    variable = disp_y
    boundary = top
    function = pull
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  dt = 0.01
  end_time = 0.12
[]

[Postprocessors]
  [./disp_x]
    type = SideAverageValue
    variable = disp_x
    boundary = right
  [../]
  [./disp_y]
    type = SideAverageValue
    variable = disp_y
    boundary = top
  [../]
  [./avg_hydro]
    type = ElementAverageValue
    variable = hydrostatic_stress
  [../]
  [./avg_vonmises]
    type = ElementAverageValue
    variable = vonmises_stress
  [../]
  [./dt]
    type = TimestepSize
  [../]
  [./num_lin]
    type = NumLinearIterations
    outputs = console
  [../]
  [./num_nonlin]
    type = NumNonlinearIterations
    outputs = console
  [../]
  [./lps_1_eff_creep_strain]
    type = ElementAverageValue
    variable = lps_first_effective_viscoplasticity
    outputs = none
  [../]
  [./lps_2_eff_creep_strain]
    type = ElementAverageValue
    variable = lps_second_effective_viscoplasticity
    outputs = none
  [../]
  [./eff_creep_strain_tot]
    type = FunctionValuePostprocessor
    function = tot_effective_viscoplasticity
  [../]
  [./porosity]
    type = ElementAverageValue
    variable = porosity
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="2775417a-2de0-4d5e-9ab7-a804cb7c0a58" data-section-level="2" data-section-text="Child Objects"><h2 id="child-objects">Child Objects</h2><ul class="moose-list-children browser-default"><li><a href="#0f76fbdb-7eff-4ee5-85c5-c5df3c33e75b" class="modal-trigger">framework/include/postprocessors/AxisymmetricCenterlineAverageValue.h</a></li></ul><div class="modal moose-modal" id="0f76fbdb-7eff-4ee5-85c5-c5df3c33e75b"><div class="modal-content"><h4>framework/include/postprocessors/AxisymmetricCenterlineAverageValue.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;SideAverageValue.h&quot;

// Forward Declarations
class AxisymmetricCenterlineAverageValue;

template &lt;&gt;
InputParameters validParams&lt;AxisymmetricCenterlineAverageValue&gt;();

/**
 * This postprocessor computes a line integral of the specified variable
 * along the centerline of an axisymmetric domain.
 */
class AxisymmetricCenterlineAverageValue : public SideAverageValue
{
public:
  static InputParameters validParams();

  AxisymmetricCenterlineAverageValue(const InputParameters &amp; parameters);

protected:
  virtual Real computeIntegral() override;
  virtual Real volume() override;
  Real _volume;
};

</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#e5d0db47-06b4-4447-8ccd-425382322820" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#9789b99b-2100-48ee-b805-898450114fe6" class="tooltipped" data-position="left" data-tooltip="Example Input Syntax">Example Input Syntax</a></li><li><a href="#c09df2aa-57b3-49d1-a26a-2fdb9d8187a5" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#0d86d01f-15bf-4133-b45a-a4caedbe3573" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li><li><a href="#2775417a-2de0-4d5e-9ab7-a804cb7c0a58" class="tooltipped" data-position="left" data-tooltip="Child Objects">Child Objects</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>