<!DOCTYPE html><head><meta charset="UTF-8"><title>ReflectRayBC.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="7ffad3aa-c5e6-4ce1-a2f8-cdfaed75d77d"><i class="material-icons">menu</i></a><ul class="sidenav" id="7ffad3aa-c5e6-4ce1-a2f8-cdfaed75d77d"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">ray_bcs</span><a href="#" class="breadcrumb">ReflectRayBC</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="ca5ad111-b544-4545-9d15-616a3c0ada20" data-section-level="1" data-section-text="ReflectRayBC"><h1 id="reflectraybc">ReflectRayBC</h1><section class="scrollspy" id="4f19a153-b814-44cd-a233-250711894dbb" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p><code>ReflectRayBC</code> is a <a href="../../syntax/RayBCs/index.html">RayBCs</a> that reflects a <a href="../ray_tracing/Ray.html">Ray</a> on a boundary in a specular (mirror-like) manner. It can properly handle reflections at domain corners/edges that are reflecting on all boundaries at the corner/edge (see <a href="../../syntax/RayBCs/index.html#hitting-multiple-boundaries">Hitting Multiple Boundaries</a> for more information).</p><p>It achieves the reflection by changing the direction of the <a href="../ray_tracing/Ray.html">Ray</a>:</p><pre class="moose-pre"><code class="language-cpp">void
ReflectRayBC::onBoundary(const unsigned int num_applying)
{
  // No need to do anything if the Ray&#x27;s gonna die anyway
  if (!currentRay()-&gt;shouldContinue())
    return;

  // The direction this Ray reflects off this boundary
  const auto &amp; normal = _study.getSideNormal(_current_elem, _current_intersected_side, _tid);
  const auto reflected_direction = reflectedDirection(currentRay()-&gt;direction(), normal);

  // Change it! Note here the usage of num_applying: if we are at a corner with a reflecting
  // boundary condition on both sides, we want to allow both boundary conditions to reflect the Ray.
  // Therefore, we skip the check that another RayBC has changed the Ray&#x27;s trajectory when we are
  // applying multiple of the same ReflectRayBC at different boundaries at the same point to allow
  // this. Note that this double (or triple in 3D) reflection will only be allowed when the same
  // ReflectRayBC object is on both boundaries.
  changeRayDirection(reflected_direction, /* skip_changed_check = */ num_applying &gt; 1);
}
</code></pre><a href="#c92554f2-cb08-47eb-95e5-590443976feb" class="modal-trigger">(modules/ray_tracing/src/ray_bcs/ReflectRayBC.C)</a><div class="modal moose-modal" id="c92554f2-cb08-47eb-95e5-590443976feb"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/modules/ray_tracing/src/ray_bcs/ReflectRayBC.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ReflectRayBC.h&quot;

// Local includes
#include &quot;RayTracingStudy.h&quot;

registerMooseObject(&quot;RayTracingApp&quot;, ReflectRayBC);

InputParameters
ReflectRayBC::validParams()
{
  auto params = GeneralRayBC::validParams();
  params.addClassDescription(&quot;A RayBC that reflects a Ray in a specular manner on a boundary.&quot;);
  return params;
}

ReflectRayBC::ReflectRayBC(const InputParameters &amp; params) : GeneralRayBC(params) {}

void
ReflectRayBC::onBoundary(const unsigned int num_applying)
{
  // No need to do anything if the Ray&#x27;s gonna die anyway
  if (!currentRay()-&gt;shouldContinue())
    return;

  // The direction this Ray reflects off this boundary
  const auto &amp; normal = _study.getSideNormal(_current_elem, _current_intersected_side, _tid);
  const auto reflected_direction = reflectedDirection(currentRay()-&gt;direction(), normal);

  // Change it! Note here the usage of num_applying: if we are at a corner with a reflecting
  // boundary condition on both sides, we want to allow both boundary conditions to reflect the Ray.
  // Therefore, we skip the check that another RayBC has changed the Ray&#x27;s trajectory when we are
  // applying multiple of the same ReflectRayBC at different boundaries at the same point to allow
  // this. Note that this double (or triple in 3D) reflection will only be allowed when the same
  // ReflectRayBC object is on both boundaries.
  changeRayDirection(reflected_direction, /* skip_changed_check = */ num_applying &gt; 1);
}

Point
ReflectRayBC::reflectedDirection(const Point &amp; direction, const Point &amp; normal)
{
  Point reflected_direction = direction;
  reflected_direction -= 2.0 * (reflected_direction * normal) * normal;
  return reflected_direction;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>Per the specularly reflected direction (static and available for other <a href="../../syntax/RayBCs/index.html">RayBCs</a> to use):</p><pre class="moose-pre"><code class="language-cpp">Point
ReflectRayBC::reflectedDirection(const Point &amp; direction, const Point &amp; normal)
{
  Point reflected_direction = direction;
  reflected_direction -= 2.0 * (reflected_direction * normal) * normal;
  return reflected_direction;
}
</code></pre><a href="#66531b0e-7a4c-4a2e-9e55-f5207011a359" class="modal-trigger">(modules/ray_tracing/src/ray_bcs/ReflectRayBC.C)</a><div class="modal moose-modal" id="66531b0e-7a4c-4a2e-9e55-f5207011a359"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/modules/ray_tracing/src/ray_bcs/ReflectRayBC.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ReflectRayBC.h&quot;

// Local includes
#include &quot;RayTracingStudy.h&quot;

registerMooseObject(&quot;RayTracingApp&quot;, ReflectRayBC);

InputParameters
ReflectRayBC::validParams()
{
  auto params = GeneralRayBC::validParams();
  params.addClassDescription(&quot;A RayBC that reflects a Ray in a specular manner on a boundary.&quot;);
  return params;
}

ReflectRayBC::ReflectRayBC(const InputParameters &amp; params) : GeneralRayBC(params) {}

void
ReflectRayBC::onBoundary(const unsigned int num_applying)
{
  // No need to do anything if the Ray&#x27;s gonna die anyway
  if (!currentRay()-&gt;shouldContinue())
    return;

  // The direction this Ray reflects off this boundary
  const auto &amp; normal = _study.getSideNormal(_current_elem, _current_intersected_side, _tid);
  const auto reflected_direction = reflectedDirection(currentRay()-&gt;direction(), normal);

  // Change it! Note here the usage of num_applying: if we are at a corner with a reflecting
  // boundary condition on both sides, we want to allow both boundary conditions to reflect the Ray.
  // Therefore, we skip the check that another RayBC has changed the Ray&#x27;s trajectory when we are
  // applying multiple of the same ReflectRayBC at different boundaries at the same point to allow
  // this. Note that this double (or triple in 3D) reflection will only be allowed when the same
  // ReflectRayBC object is on both boundaries.
  changeRayDirection(reflected_direction, /* skip_changed_check = */ num_applying &gt; 1);
}

Point
ReflectRayBC::reflectedDirection(const Point &amp; direction, const Point &amp; normal)
{
  Point reflected_direction = direction;
  reflected_direction -= 2.0 * (reflected_direction * normal) * normal;
  return reflected_direction;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="1089ca98-0822-4b6e-a0b0-07fd984488ff" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="686638dc-b92a-4d99-9cc0-401e9f1e6b69" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundary IDs from the mesh where this boundary condition applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<BoundaryName></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The list of boundary IDs from the mesh where this boundary condition applies</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="db91c92b-440f-4fa4-ae91-806bbf9bbfea" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">depends_on</span><span class="moose-parameter-header-description">Other RayBCs that this RayBC depends on</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Other RayBCs that this RayBC depends on</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">rays</span><span class="moose-parameter-header-description">The name of the Rays associated with this object (only used if Ray registration is enabled within the study)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the Rays associated with this object (only used if Ray registration is enabled within the study)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">study</span><span class="moose-parameter-header-description">The RayTracingStudy associated with this object. If none provided, this will default to the one study that exists.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>UserObjectName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The RayTracingStudy associated with this object. If none provided, this will default to the one study that exists.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="321ac99b-5597-4e8c-8b1e-630cfcd09f4f" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section class="scrollspy" id="5fbfee90-f398-4004-b4bb-85f58d126add" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#5f4f43f5-471b-4db0-8d7b-91886891d77b" class="modal-trigger">modules/ray_tracing/test/tests/ray_bcs/reflect_ray_bc/reflect_ray_bc.i</a></li><li><a href="#14e4ef32-5ae3-4dd0-a8f5-c5e4cb903650" class="modal-trigger">modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_1d.i</a></li><li><a href="#55f2fe3d-3331-43e4-a8e2-4908eb67318f" class="modal-trigger">modules/ray_tracing/test/tests/userobjects/repeatable_ray_study/max_distance.i</a></li><li><a href="#7ffea7c8-1e7a-41fe-8e77-60c74ef730c0" class="modal-trigger">modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_3d.i</a></li><li><a href="#3540f3ba-3216-4fd6-a6bb-13970e0d2417" class="modal-trigger">modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_2d.i</a></li></ul><div class="modal moose-modal" id="5f4f43f5-471b-4db0-8d7b-91886891d77b"><div class="modal-content"><h4>modules/ray_tracing/test/tests/ray_bcs/reflect_ray_bc/reflect_ray_bc.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
[]

[RayBCs]
  [reflect]
    type = ReflectRayBC
    boundary = &#x27;top right left bottom&#x27;
  []
[]

[UserObjects/lots]
  type = LotsOfRaysRayStudy
  ray_kernel_coverage_check = false
  vertex_to_vertex = true
  centroid_to_vertex = true
  centroid_to_centroid = false
  execute_on = initial
  ray_distance = 10
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  study = lots
  result = total_distance
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="14e4ef32-5ae3-4dd0-a8f5-c5e4cb903650"><div class="modal-content"><h4>modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_1d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 1
    xmax = 6
    nx = 6
  []

  [central_block]
    type = SubdomainBoundingBoxGenerator
    input = gmg
    block_id = 1
    bottom_left = &#x27;2 0 0&#x27;
    top_right = &#x27;4 0 0&#x27;
  []

  [central_boundary]
    type = SideSetsBetweenSubdomainsGenerator
    input = central_block
    master_block = 1
    paired_block = 0
    new_boundary = 7
  []
[]

[RayBCs]
  active = &#x27;kill_internal&#x27;
  # active = &#x27;kill_external reflect_internal&#x27;

  # for testing internal kill
  [kill_internal]
    type = KillRayBC
    boundary = 7
    rays = &#x27;left_in at_left right_in at_right inside_left&#x27;
  []

  # for testing internal reflect
  [kill_external]
    type = KillRayBC
    boundary = &#x27;left right&#x27;
    rays = &#x27;left_in at_left right_in at_right inside_left&#x27;
  []
  [reflect_internal]
    type = ReflectRayBC
    boundary = 7
    rays = &#x27;left_in at_left right_in at_right inside_left&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  2 0 0
                  6 0 0
                  4 0 0
                  3 0 0&#x27;
  directions = &#x27;1 0 0
                1 0 0
                -1 0 0
                -1 0 0
                -1 0 0&#x27;
  names = &#x27;left_in at_left right_in at_right inside_left&#x27;
  ray_distance = 10
  execute_on = initial
  ray_kernel_coverage_check = false
  use_internal_sidesets = true
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  study = study
  result = total_distance
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="55f2fe3d-3331-43e4-a8e2-4908eb67318f"><div class="modal-content"><h4>modules/ray_tracing/test/tests/userobjects/repeatable_ray_study/max_distance.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
[]

# to_right_distance_kill - makes it to the right boundary at (5, 0)
#   and dies due to max distance (doesn&#x27;t call RayBCs)
# to_right_bc_kill - makes it to right boundary at (5, 0); is still
#   0.1 from its max distance so calls &#x27;kill_right&#x27; RayBC which
#   kills it
# to_top_corner - makes it to the top right corner at (5, 5);
#   reflects with direction (-1, -1) and stops once its distance
#   hits 7.0
# reflect_a_lot - reflects a bunch with the RayBC &#x27;reflect_all&#x27;
#   until it gets to a distance of 50 and dies
[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  0 0 0
                  0 0 0
                  0.1 0.2 0&#x27;
  directions = &#x27;1 0 0
                1 0 0
                1 1 0
                1 0.5 0&#x27;
  max_distances = &#x27;5
                   5.1
                   7.0
                   50&#x27;
  names = &#x27;to_right_distance_kill
           to_right_bc_kill
           to_top_corner
           reflect_a_lot&#x27;
[]

[RayKernels/null]
  type = NullRayKernel
  rays = &#x27;to_right_distance_kill
          to_right_bc_kill
          to_top_corner
          reflect_a_lot&#x27;
[]

[RayBCs]
  [kill_right]
    type = KillRayBC
    boundary = right
    rays = &#x27;to_right_bc_kill&#x27;
  []
  [reflect_top_right]
    type = ReflectRayBC
    boundary = &#x27;top right&#x27;
    rays = &#x27;to_top_corner&#x27;
  []
  [reflect_all]
    type = ReflectRayBC
    boundary = &#x27;top right bottom left&#x27;
    rays = &#x27;reflect_a_lot&#x27;
  []
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  result = &#x27;total_distance&#x27;
  study = study
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7ffea7c8-1e7a-41fe-8e77-60c74ef730c0"><div class="modal-content"><h4>modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [cmg]
    type = CartesianMeshGenerator
    dim = 3
    dx = &#x27;2 2 2&#x27;
    dy = &#x27;2 2 2&#x27;
    dz = &#x27;2 2 2&#x27;
    ix = &#x27;2 2 2&#x27;
    iy = &#x27;2 2 2&#x27;
    iz = &#x27;2 2 2&#x27;
    subdomain_id = &#x27;0 0 0
                    0 1 0
                    0 0 0

                    0 2 0
                    3 7 4
                    0 5 0

                    0 0 0
                    0 6 0
                    0 0 0&#x27;
  []

  [interior_back]
    type = SideSetsBetweenSubdomainsGenerator
    input = cmg
    master_block = 7
    paired_block = 1
    new_boundary = &#x27;interior_back&#x27;
  []
  [interior_bottom]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_back
    master_block = 7
    paired_block = 2
    new_boundary = &#x27;interior_bottom&#x27;
  []
  [interior_left]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_bottom
    master_block = 7
    paired_block = 3
    new_boundary = &#x27;interior_left&#x27;
  []
  [interior_right]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_left
    master_block = 7
    paired_block = 4
    new_boundary = &#x27;interior_right&#x27;
  []
  [interior_top]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_right
    master_block = 7
    paired_block = 5
    new_boundary = &#x27;interior_top&#x27;
  []
  [interior_front]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_top
    master_block = 7
    paired_block = 6
    new_boundary = &#x27;interior_front&#x27;
  []
[]

[RayBCs]
  active = &#x27;kill_internal&#x27;
  # active = &#x27;kill_external reflect_internal&#x27;

  # for testing internal kill
  [kill_internal]
    type = KillRayBC
    boundary = &#x27;interior_top interior_right interior_bottom interior_left interior_front interior_back&#x27;
    rays = &#x27;to_bottom_left_corner
            at_bottom_left_corner
            to_top_right_corner
            at_top_right_corner
            centroid_offset
            top_down
            left_to_edge
            inside_to_corner
            inside_offset&#x27;
  []

  # for testing internal reflect
  [kill_external]
    type = KillRayBC
    boundary = &#x27;top right bottom left front back&#x27;
    rays = &#x27;to_bottom_left_corner
            at_bottom_left_corner
            to_top_right_corner
            at_top_right_corner
            centroid_offset
            top_down
            left_to_edge
            inside_to_corner
            inside_offset&#x27;
  []
  [reflect_internal]
    type = ReflectRayBC
    boundary = &#x27;interior_top interior_right interior_bottom interior_left interior_front interior_back&#x27;
    rays = &#x27;to_bottom_left_corner
            at_bottom_left_corner
            to_top_right_corner
            at_top_right_corner
            centroid_offset
            top_down
            left_to_edge
            inside_to_corner
            inside_offset&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  2 2 2
                  6 6 6
                  4 4 4
                  0 2.5 2.5
                  3 3 6
                  2.5 0 0
                  3 3 3
                  2.5 2.5 2.5&#x27;
  directions = &#x27;1 1 1
                1 1 1
                -1 -1 -1
                -1 -1 -1
                1 0.1 0
                0 0 -1
                0 1 1
                1 1 1
                0.5 1.5 1.5&#x27;
  names = &#x27;to_bottom_left_corner
           at_bottom_left_corner
           to_top_right_corner
           at_top_right_corner
           centroid_offset
           top_down
           left_to_edge
           inside_to_corner
           inside_offset&#x27;
  execute_on = initial
  ray_distance = 10
  ray_kernel_coverage_check = false
  use_internal_sidesets = true
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  study = study
  result = total_distance
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3540f3ba-3216-4fd6-a6bb-13970e0d2417"><div class="modal-content"><h4>modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [cmg]
    type = CartesianMeshGenerator
    dim = 2
    dx = &#x27;2 2 2&#x27;
    dy = &#x27;2 2 2&#x27;
    ix = &#x27;2 2 2&#x27;
    iy = &#x27;2 2 2&#x27;
    subdomain_id = &#x27;0 1 0
                    2 5 3
                    0 4 0&#x27;
  []

  [interior_bottom]
    type = SideSetsBetweenSubdomainsGenerator
    input = cmg
    master_block = 5
    paired_block = 1
    new_boundary = &#x27;interior_bottom&#x27;
  []
  [interior_left]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_bottom
    master_block = 5
    paired_block = 2
    new_boundary = &#x27;interior_left&#x27;
  []
  [interior_right]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_left
    master_block = 5
    paired_block = 3
    new_boundary = &#x27;interior_right&#x27;
  []
  [interior_top]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_right
    master_block = 5
    paired_block = 4
    new_boundary = &#x27;interior_top&#x27;
  []
[]

[RayBCs]
  active = &#x27;kill_internal&#x27;
  # active = &#x27;kill_external reflect_internal&#x27;

  # for testing internal kill
  [kill_internal]
    type = KillRayBC
    boundary = &#x27;interior_top interior_right interior_bottom interior_left&#x27;
    rays = &#x27;to_bottom_left_corner
            at_top_left_corner
            to_top_right_corner
            to_left_offset
            to_top_center_node
            inside_to_top&#x27;
  []

  # for testing internal reflect
  [kill_external]
    type = KillRayBC
    boundary = &#x27;top right bottom left&#x27;
    rays = &#x27;to_bottom_left_corner
            at_top_left_corner
            to_top_right_corner
            to_left_offset
            to_top_center_node
            inside_to_top&#x27;
  []
  [reflect_internal]
    type = ReflectRayBC
    boundary = &#x27;interior_top interior_right interior_bottom interior_left&#x27;
    rays = &#x27;to_bottom_left_corner
            at_top_left_corner
            to_top_right_corner
            to_left_offset
            to_top_center_node
            inside_to_top&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  2 4 0
                  6 6 0
                  0 2.5 0
                  3 6 0
                  2.5 2.5 0&#x27;
  directions = &#x27;1 1 0
                1 -1 0
                -1 -1 0
                1 0.1 0
                0 -1 0
                0.5 1.5 0&#x27;
  names = &#x27;to_bottom_left_corner
           at_top_left_corner
           to_top_right_corner
           to_left_offset
           to_top_center_node
           inside_to_top&#x27;
  ray_distance = 10
  execute_on = initial
  ray_kernel_coverage_check = false
  use_internal_sidesets = true
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  study = study
  result = total_distance
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#4f19a153-b814-44cd-a233-250711894dbb" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#1089ca98-0822-4b6e-a0b0-07fd984488ff" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#5fbfee90-f398-4004-b4bb-85f58d126add" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>