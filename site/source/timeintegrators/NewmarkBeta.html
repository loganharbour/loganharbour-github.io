<!DOCTYPE html><head><meta charset="UTF-8"><title>NewmarkBeta.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="5156d96f-7d57-422a-bbce-debb64fb9db3"><i class="material-icons">menu</i></a><ul class="sidenav" id="5156d96f-7d57-422a-bbce-debb64fb9db3"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">timeintegrators</span><a href="#" class="breadcrumb">NewmarkBeta</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="9cdba4cb-46df-4bb3-82e3-6dcb7c2876b5" data-section-level="1" data-section-text="NewmarkBeta"><h1 id="newmarkbeta">NewmarkBeta</h1><p>Computes the first and second time derivative of variable using Newmark-Beta method.</p><section class="scrollspy" id="5b62c621-8a11-4b35-ae40-a69809006d76" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p>Newmark time integration (<a href="#newmark1959amethod">Newmark, 1959</a>) is one of the commonly used time integration methods in structural dynamics problems. In this method, the second (<span tex="\ddot{u}" bookmark="moose-equation-0d3a8565-bf39-45bd-93e0-973cb6641b2f" recursive="True" class="moose-katex-inline-equation" id="moose-equation-0d3a8565-bf39-45bd-93e0-973cb6641b2f"><script>var element = document.getElementById("moose-equation-0d3a8565-bf39-45bd-93e0-973cb6641b2f");katex.render("\\ddot{u}", element, {displayMode:false,throwOnError:false});</script></span>) and first (<span tex="\dot{u}" bookmark="moose-equation-edc66d7c-a2b8-4c2f-be9d-a1f02600fb9b" recursive="True" class="moose-katex-inline-equation" id="moose-equation-edc66d7c-a2b8-4c2f-be9d-a1f02600fb9b"><script>var element = document.getElementById("moose-equation-edc66d7c-a2b8-4c2f-be9d-a1f02600fb9b");katex.render("\\dot{u}", element, {displayMode:false,throwOnError:false});</script></span>) time derivatives of a variable <span tex="u" bookmark="moose-equation-e024896e-0fa2-4c25-ab9a-028f1e5ec5b8" recursive="True" class="moose-katex-inline-equation" id="moose-equation-e024896e-0fa2-4c25-ab9a-028f1e5ec5b8"><script>var element = document.getElementById("moose-equation-e024896e-0fa2-4c25-ab9a-028f1e5ec5b8");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> at <span tex="t+\Delta t" bookmark="moose-equation-a362fe86-7597-490b-be63-0d6c4587847b" recursive="True" class="moose-katex-inline-equation" id="moose-equation-a362fe86-7597-490b-be63-0d6c4587847b"><script>var element = document.getElementById("moose-equation-a362fe86-7597-490b-be63-0d6c4587847b");katex.render("t+\\Delta t", element, {displayMode:false,throwOnError:false});</script></span> are written in terms of the <span tex="u" bookmark="moose-equation-b0eb5db2-1752-4141-b4d8-39f1157a387d" recursive="True" class="moose-katex-inline-equation" id="moose-equation-b0eb5db2-1752-4141-b4d8-39f1157a387d"><script>var element = document.getElementById("moose-equation-b0eb5db2-1752-4141-b4d8-39f1157a387d");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span>, <span tex="\dot{u}" bookmark="moose-equation-e3ab02ea-0ef4-4cf1-ac12-acb7d21b0648" recursive="True" class="moose-katex-inline-equation" id="moose-equation-e3ab02ea-0ef4-4cf1-ac12-acb7d21b0648"><script>var element = document.getElementById("moose-equation-e3ab02ea-0ef4-4cf1-ac12-acb7d21b0648");katex.render("\\dot{u}", element, {displayMode:false,throwOnError:false});</script></span> and <span tex="\ddot{u}" bookmark="moose-equation-1abd34f0-b6f3-4c97-b563-e361d0325e81" recursive="True" class="moose-katex-inline-equation" id="moose-equation-1abd34f0-b6f3-4c97-b563-e361d0325e81"><script>var element = document.getElementById("moose-equation-1abd34f0-b6f3-4c97-b563-e361d0325e81");katex.render("\\ddot{u}", element, {displayMode:false,throwOnError:false});</script></span> at time <span tex="t" bookmark="moose-equation-6b99de8b-6dc7-42d1-bfec-b20a20a8f57b" recursive="True" class="moose-katex-inline-equation" id="moose-equation-6b99de8b-6dc7-42d1-bfec-b20a20a8f57b"><script>var element = document.getElementById("moose-equation-6b99de8b-6dc7-42d1-bfec-b20a20a8f57b");katex.render("t", element, {displayMode:false,throwOnError:false});</script></span>, and <span tex="u" bookmark="moose-equation-d4d2413a-cbb9-40fc-9fe2-1e85dbb64884" recursive="True" class="moose-katex-inline-equation" id="moose-equation-d4d2413a-cbb9-40fc-9fe2-1e85dbb64884"><script>var element = document.getElementById("moose-equation-d4d2413a-cbb9-40fc-9fe2-1e85dbb64884");katex.render("u", element, {displayMode:false,throwOnError:false});</script></span> at <span tex="t+\Delta t" bookmark="moose-equation-d58880d3-c2cb-4dd8-bd67-d9828f743dd7" recursive="True" class="moose-katex-inline-equation" id="moose-equation-d58880d3-c2cb-4dd8-bd67-d9828f743dd7"><script>var element = document.getElementById("moose-equation-d58880d3-c2cb-4dd8-bd67-d9828f743dd7");katex.render("t+\\Delta t", element, {displayMode:false,throwOnError:false});</script></span> as shown below:</p><p><span class="moose-katex-block-equation"><span tex="\begin{aligned} \mathbf{\ddot{u}}(t+\Delta t) &=& \frac{\mathbf{u}(t+\Delta t)-\mathbf{u}(t)}{\beta \Delta t^2}- \frac{\mathbf{\dot{u}}(t)}{\beta \Delta t}+\frac{\beta -0.5}{\beta}\mathbf{\ddot{u}}(t) \\ \mathbf{\dot{u}}(t+ \Delta t) &=& \mathbf{\dot{u}}(t)+ (1-\gamma)\Delta t \mathbf{\ddot{u}}(t) + \gamma \Delta t \mathbf{\ddot{u}}(t+\Delta t) \end{aligned}" bookmark="moose-equation-7318b5b5-5cea-4c3b-8d39-47acaebfac37" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-7318b5b5-5cea-4c3b-8d39-47acaebfac37"></span><script>var element = document.getElementById("moose-equation-7318b5b5-5cea-4c3b-8d39-47acaebfac37");katex.render("\\begin{aligned} \\mathbf{\\ddot{u}}(t+\\Delta t) &=& \\frac{\\mathbf{u}(t+\\Delta t)-\\mathbf{u}(t)}{\\beta \\Delta t^2}- \\frac{\\mathbf{\\dot{u}}(t)}{\\beta \\Delta t}+\\frac{\\beta -0.5}{\\beta}\\mathbf{\\ddot{u}}(t) \\\\ \\mathbf{\\dot{u}}(t+ \\Delta t) &=& \\mathbf{\\dot{u}}(t)+ (1-\\gamma)\\Delta t \\mathbf{\\ddot{u}}(t) + \\gamma \\Delta t \\mathbf{\\ddot{u}}(t+\\Delta t) \\end{aligned}", element, {displayMode:true,throwOnError:false});</script></span></p><p>In the above equations, <span tex="\beta" bookmark="moose-equation-e92783f9-3943-418a-8994-f460ccb1fccf" recursive="True" class="moose-katex-inline-equation" id="moose-equation-e92783f9-3943-418a-8994-f460ccb1fccf"><script>var element = document.getElementById("moose-equation-e92783f9-3943-418a-8994-f460ccb1fccf");katex.render("\\beta", element, {displayMode:false,throwOnError:false});</script></span> and <span tex="\gamma" bookmark="moose-equation-a3050979-97f1-4b19-bdc2-78acc4b0ccac" recursive="True" class="moose-katex-inline-equation" id="moose-equation-a3050979-97f1-4b19-bdc2-78acc4b0ccac"><script>var element = document.getElementById("moose-equation-a3050979-97f1-4b19-bdc2-78acc4b0ccac");katex.render("\\gamma", element, {displayMode:false,throwOnError:false});</script></span> are Newmark time integration parameters.</p><ul class="browser-default"><li><p>For <span tex="\beta = \frac{1}{4}" bookmark="moose-equation-fd5cb6d5-c99c-4dc3-b367-b8f5181e18dc" recursive="True" class="moose-katex-inline-equation" id="moose-equation-fd5cb6d5-c99c-4dc3-b367-b8f5181e18dc"><script>var element = document.getElementById("moose-equation-fd5cb6d5-c99c-4dc3-b367-b8f5181e18dc");katex.render("\\beta = \\frac{1}{4}", element, {displayMode:false,throwOnError:false});</script></span> and <span tex="\gamma = \frac{1}{2}" bookmark="moose-equation-f5ee10b5-4537-470b-b0b5-796b51ec2508" recursive="True" class="moose-katex-inline-equation" id="moose-equation-f5ee10b5-4537-470b-b0b5-796b51ec2508"><script>var element = document.getElementById("moose-equation-f5ee10b5-4537-470b-b0b5-796b51ec2508");katex.render("\\gamma = \\frac{1}{2}", element, {displayMode:false,throwOnError:false});</script></span>, the Newmark time integration method is implicit, unconditionally stable and second order accurate in time. This is the constant average acceleration method with no numerical damping. </p></li><li><p><span tex="\beta = \frac{1}{6}" bookmark="moose-equation-ff38ece7-059f-4900-8d68-f1f0b7eed87e" recursive="True" class="moose-katex-inline-equation" id="moose-equation-ff38ece7-059f-4900-8d68-f1f0b7eed87e"><script>var element = document.getElementById("moose-equation-ff38ece7-059f-4900-8d68-f1f0b7eed87e");katex.render("\\beta = \\frac{1}{6}", element, {displayMode:false,throwOnError:false});</script></span> and <span tex="\gamma = \frac{1}{2}" bookmark="moose-equation-53f03d9f-3705-4374-ace9-332829bb73b4" recursive="True" class="moose-katex-inline-equation" id="moose-equation-53f03d9f-3705-4374-ace9-332829bb73b4"><script>var element = document.getElementById("moose-equation-53f03d9f-3705-4374-ace9-332829bb73b4");katex.render("\\gamma = \\frac{1}{2}", element, {displayMode:false,throwOnError:false});</script></span> results in the linear acceleration method where the acceleration is linearly varying between <span tex="t" bookmark="moose-equation-a6f67224-8d12-4f7a-8549-d592acb6186f" recursive="True" class="moose-katex-inline-equation" id="moose-equation-a6f67224-8d12-4f7a-8549-d592acb6186f"><script>var element = document.getElementById("moose-equation-a6f67224-8d12-4f7a-8549-d592acb6186f");katex.render("t", element, {displayMode:false,throwOnError:false});</script></span> and <span tex="t+\Delta t" bookmark="moose-equation-d98fe61b-9f3b-4921-a16d-a6bf89794db9" recursive="True" class="moose-katex-inline-equation" id="moose-equation-d98fe61b-9f3b-4921-a16d-a6bf89794db9"><script>var element = document.getElementById("moose-equation-d98fe61b-9f3b-4921-a16d-a6bf89794db9");katex.render("t+\\Delta t", element, {displayMode:false,throwOnError:false});</script></span>. This method is also implicit, unconditionally stable and second order accurate in time. However, there is a small numerical damping when the linear acceleration method is used. </p></li><li><p>For <span tex="\gamma = \frac{1}{2}" bookmark="moose-equation-8fa36a7d-7f66-4eba-a11b-2bb7db378bb1" recursive="True" class="moose-katex-inline-equation" id="moose-equation-8fa36a7d-7f66-4eba-a11b-2bb7db378bb1"><script>var element = document.getElementById("moose-equation-8fa36a7d-7f66-4eba-a11b-2bb7db378bb1");katex.render("\\gamma = \\frac{1}{2}", element, {displayMode:false,throwOnError:false});</script></span>, the method is second order accurate and it is unconditionally stable for <span tex="\frac{1}{2} \le \gamma \le 2 \beta" bookmark="moose-equation-ed095349-a63a-443a-8180-0aa080bb13f5" recursive="True" class="moose-katex-inline-equation" id="moose-equation-ed095349-a63a-443a-8180-0aa080bb13f5"><script>var element = document.getElementById("moose-equation-ed095349-a63a-443a-8180-0aa080bb13f5");katex.render("\\frac{1}{2} \\le \\gamma \\le 2 \\beta", element, {displayMode:false,throwOnError:false});</script></span>.</p></li></ul><p>When using the constant average acceleration method that has no numerical damping, high frequency noise can sometimes be observed in the velocity and acceleration time histories for a problem with prescribed displacement  (<a href="#bathe2012insight">Bathe and Noh, 2012</a>). Using other parameters for <span tex="\beta" bookmark="moose-equation-9dc03a78-4a14-4785-9a41-26661940387d" recursive="True" class="moose-katex-inline-equation" id="moose-equation-9dc03a78-4a14-4785-9a41-26661940387d"><script>var element = document.getElementById("moose-equation-9dc03a78-4a14-4785-9a41-26661940387d");katex.render("\\beta", element, {displayMode:false,throwOnError:false});</script></span> and <span tex="\gamma" bookmark="moose-equation-1dea1c8c-a0ba-49d7-b241-7a65da1585ae" recursive="True" class="moose-katex-inline-equation" id="moose-equation-1dea1c8c-a0ba-49d7-b241-7a65da1585ae"><script>var element = document.getElementById("moose-equation-1dea1c8c-a0ba-49d7-b241-7a65da1585ae");katex.render("\\gamma", element, {displayMode:false,throwOnError:false});</script></span> results in non-zero numerical damping that damps out part of the high frequency noise but not all of it. Hilber-Hughes-Taylor (HHT) time integration is a variation of the Newmark method that damps out high frequency noise especially in structural dynamics problems. More details about this Newmark and HHT time integration schemes can be found in these <a href="http://people.duke.edu/~hpgavin/cee541/NumericalIntegration.pdf">lecture notes</a>. HHT time integration requires modification to the equation of motion and is currently implemented only for structural dynamics problems in tensor mechanics module.</p></section><section class="scrollspy" id="8c63ae89-2687-4be5-a4fb-e5e4dd41ed16" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="b555f13c-855b-4ee8-a188-576571cd0bc9" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">beta</span><span class="moose-parameter-header-default">0.25</span><span class="moose-parameter-header-description">beta value</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0.25</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>beta value</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">gamma</span><span class="moose-parameter-header-default">0.5</span><span class="moose-parameter-header-description">gamma value</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0.5</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>gamma value</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="cb8ef49e-0bd7-4de8-8978-b18d425f7320" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section class="scrollspy" id="de2d1822-da15-4ca6-929a-0237a665542a" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#a52a01a0-611b-4845-931b-ce4e215fede6" class="modal-trigger">test/tests/time_integrators/newmark-beta/newmark_beta_prescribed_parameters.i</a></li><li><a href="#67d5999d-866e-4e92-9d37-4257ff34bcfe" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/3D/3d_consistent_implicit.i</a></li><li><a href="#e1059303-5421-4f48-aaef-1cca25ce3f03" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/3D/3d_nodalmass_implicit.i</a></li><li><a href="#a658fb12-7b1d-4c48-a1ae-003e5d9138be" class="modal-trigger">modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_hht_ti.i</a></li><li><a href="#e0c9e54f-76a0-436e-b7e8-139826fc89ae" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free.i</a></li><li><a href="#0a0f3df1-c79d-457a-b11b-d9833f517894" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free_orientation_inclined_hht.i</a></li><li><a href="#792185db-ebdb-4fd3-8475-221348c95a24" class="modal-trigger">modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_rayleigh_hht_ti.i</a></li><li><a href="#371eeb63-8d78-4f4d-a154-c767752431c0" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/2D/2d_nodalmass_implicit.i</a></li><li><a href="#eebc932e-1044-4938-8e0a-afdd5b934682" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/1D/1d_consistent_implicit.i</a></li><li><a href="#f8b80bae-0bfa-4808-82f0-18dd33840016" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/consistent/2D/2d_consistent_implicit.i</a></li><li><a href="#b8674fb5-90b1-4407-8263-936a4380055a" class="modal-trigger">modules/tensor_mechanics/test/tests/central_difference/lumped/1D/1d_nodalmass_implicit.i</a></li><li><a href="#ebad8725-0f60-44cc-88fb-e38add2f688c" class="modal-trigger">test/tests/variables/time_derivatives_neighbor/test.i</a></li><li><a href="#0c187590-6afc-4cb0-88fe-511fd565efbd" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment.i</a></li><li><a href="#2e840e5d-40fe-46bc-b73f-b217b887392c" class="modal-trigger">test/tests/kernels/vector_dot_dot/vector_test.i</a></li><li><a href="#3ea5709c-d77a-434c-8a1d-132193df2746" class="modal-trigger">modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free_orientation_inclined.i</a></li></ul><div class="modal moose-modal" id="a52a01a0-611b-4845-931b-ce4e215fede6"><div class="modal-content"><h4>test/tests/time_integrators/newmark-beta/newmark_beta_prescribed_parameters.i</h4><pre class="moose-pre"><code class="language-text">###########################################################
# This is a simple test with a time-dependent problem
# demonstrating the use of the TimeIntegrator system.
#
# Testing that the first and second time derivatives
# are calculated correctly using the Newmark-Beta method
#
# @Requirement F1.30
###########################################################

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 1
  ny = 1
[]

[Variables]
  [u]
  []
[]

[Functions]
  [forcing_fn]
    type = PiecewiseLinear
    x = &#x27;0.0 0.1 0.2    0.3  0.4    0.5  0.6&#x27;
    y = &#x27;0.0 0.0 0.0025 0.01 0.0175 0.02 0.02&#x27;
  []
[]

[Kernels]
  [ie]
    type = TimeDerivative
    variable = u
  []

  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  [left]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    function = forcing_fn
  []
  [right]
    type = FunctionDirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    function = forcing_fn
  []
[]

[Executioner]
  type = Transient
  start_time = 0.0
  num_steps = 6
  dt = 0.1
  [TimeIntegrator]
    type = NewmarkBeta
    beta = 0.4225
    gamma = 0.8
  []
[]

[Postprocessors]
  [udot]
    type = ElementAverageTimeDerivative
    variable = u
  []
  [udotdot]
    type = ElementAverageSecondTimeDerivative
    variable = u
  []
  [u]
    type = ElementAverageValue
    variable = u
  []
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="67d5999d-866e-4e92-9d37-4257ff34bcfe"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/3D/3d_consistent_implicit.i</h4><pre class="moose-pre"><code class="language-text"># One element test for the Newmark-Beta time integrator.

[Mesh]
  type = GeneratedMesh # Can generate simple lines, rectangles and rectangular prisms
  dim = 3 # Dimension of the mesh
  nx = 1 # Number of elements in the x direction
  ny = 1 # Number of elements in the y direction
  nz = 2 # Number of elements in the z direction
  xmin = 0.0
  xmax = 1
  ymin = 0.0
  ymax = 1
  zmin = 0.0
  zmax = 2
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
  [./accel_z]
    type = TestNewmarkTI
    variable = accel_z
    displacement = disp_z
    first = false
  [../]
  [./vel_z]
    type = TestNewmarkTI
    variable = vel_z
    displacement = disp_z
  [../]
[]

[BCs]
  [./x_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_x
    beta = 0.25
    velocity = vel_x
    acceleration = accel_x
    function = dispx
  [../]
  [./y_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_y
    beta = 0.25
    velocity = vel_y
    acceleration = accel_y
    function = dispy
  [../]
  [./z_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_z
    beta = 0.25
    velocity = vel_z
    acceleration = accel_z
    function = dispz
  [../]
  [./Periodic]
    [./x_dir]
      variable = &#x27;disp_x disp_y disp_z&#x27;
      primary = &#x27;left&#x27;
      secondary = &#x27;right&#x27;
      translation = &#x27;1.0 0.0 0.0&#x27;
    [../]
    [./y_dir]
      variable = &#x27;disp_x disp_y disp_z&#x27;
      primary = &#x27;bottom&#x27;
      secondary = &#x27;top&#x27;
      translation = &#x27;0.0 1.0 0.0&#x27;
    [../]
  [../]
[]

[Functions]
  [./dispx]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
  [./dispy]
    type = ParsedFunction
    value = 0.1*t*t*sin(10*t)
  [../]
  [./dispz]
    type = ParsedFunction
    value = 0.1*t*t*sin(20*t)
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 1e4
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_abs_tol = 1e-08
  nl_rel_tol = 1e-08
  timestep_tolerance = 1e-6
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./accel_6x]
    type = NodalVariableValue
    nodeid = 6
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e1059303-5421-4f48-aaef-1cca25ce3f03"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/3D/3d_nodalmass_implicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for the Newmark-Beta time integrator

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 1
    ny = 1
    nz = 2
    xmin = 0.0
    xmax = 1
    ymin = 0.0
    ymax = 1
    zmin = 0.0
    zmax = 2
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;1 1 2&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
  [./accel_z]
    type = TestNewmarkTI
    variable = accel_z
    displacement = disp_z
    first = false
  [../]
  [./vel_z]
    type = TestNewmarkTI
    variable = vel_z
    displacement = disp_z
  [../]
[]

[BCs]
  [./x_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_x
    beta = 0.25
    velocity = vel_x
    acceleration = accel_x
    function = dispx
  [../]
  [./y_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_y
    beta = 0.25
    velocity = vel_y
    acceleration = accel_y
    function = dispy
  [../]
  [./z_bot]
    type = PresetDisplacement
    boundary = &#x27;back&#x27;
    variable = disp_z
    beta = 0.25
    velocity = vel_z
    acceleration = accel_z
    function = dispz
  [../]
[]

[Functions]
  [./dispx]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
  [./dispy]
    type = ParsedFunction
    value = 0.1*t*t*sin(10*t)
  [../]
  [./dispz]
    type = ParsedFunction
    value = 0.1*t*t*sin(20*t)
  [../]
[]

[NodalKernels]
  [./nodal_mass_x]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_x&#x27;
  [../]
  [./nodal_mass_y]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_y&#x27;
  [../]
  [./nodal_mass_z]
    type = NodalTranslationalInertia
    boundary = &#x27;all&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_z&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_abs_tol = 1e-08
  nl_rel_tol = 1e-08
  timestep_tolerance = 1e-6
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./accel_10x]
    type = NodalVariableValue
    nodeid = 10
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a658fb12-7b1d-4c48-a1ae-003e5d9138be"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/dynamics/wave_1D/wave_rayleigh_hht_ti.i</h4><pre class="moose-pre"><code class="language-text"># Wave propogation in 1D using HHT time integration in the presence of Rayleigh damping
#
# The test is for an 1D bar element of length 4m  fixed on one end
# with a sinusoidal pulse dirichlet boundary condition applied to the other end.
# alpha, beta and gamma are HHT  time integration parameters
# eta and zeta are mass dependent and stiffness dependent Rayleigh damping
# coefficients, respectively.
# The equation of motion in terms of matrices is:
#
# M*accel + (eta*M+zeta*K)*((1+alpha)*vel-alpha*vel_old)
# +(1+alpha)*K*disp-alpha*K*disp_old = 0
#
# Here M is the mass matrix, K is the stiffness matrix
#
# The displacement at the first, second, third and fourth node at t = 0.1 are
# -7.787499960311491942e-02, 1.955566679096475483e-02 and -4.634888180231294501e-03, respectively.

[Mesh]
  type = GeneratedMesh
  dim = 3
  nx = 1
  ny = 4
  nz = 1
  xmin = 0.0
  xmax = 0.1
  ymin = 0.0
  ymax = 4.0
  zmin = 0.0
  zmax = 0.1
[]


[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_z]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    alpha = -0.3
    zeta = 0.1
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
    eta=0.1
    alpha = -0.3
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
    eta=0.1
    alpha = -0.3
  [../]
  [./inertia_z]
    type = InertialForce
    variable = disp_z
    eta = 0.1
    alpha = -0.3
  [../]

[]

[AuxKernels]
  [./accel_x] # These auxkernels are only to check output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
[]


[BCs]
  [./top_y]
    type = DirichletBC
    variable = disp_y
    boundary = top
    value=0.0
  [../]
  [./top_x]
   type = DirichletBC
    variable = disp_x
    boundary = top
    value=0.0
  [../]
  [./top_z]
    type = DirichletBC
    variable = disp_z
    boundary = top
    value=0.0
  [../]
  [./right_x]
    type = DirichletBC
    variable = disp_x
    boundary = right
    value=0.0
  [../]
  [./right_z]
    type = DirichletBC
    variable = disp_z
    boundary = right
    value=0.0
  [../]
  [./left_x]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value=0.0
  [../]
  [./left_z]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value=0.0
  [../]
  [./front_x]
    type = DirichletBC
    variable = disp_x
    boundary = front
    value=0.0
  [../]
  [./front_z]
    type = DirichletBC
    variable = disp_z
    boundary = front
    value=0.0
  [../]
  [./back_x]
    type = DirichletBC
    variable = disp_x
    boundary = back
    value=0.0
  [../]
  [./back_z]
    type = DirichletBC
    variable = disp_z
    boundary = back
    value=0.0
  [../]
  [./bottom_x]
    type = DirichletBC
    variable = disp_x
    boundary = bottom
    value=0.0
  [../]
  [./bottom_z]
    type = DirichletBC
    variable = disp_z
    boundary = bottom
    value=0.0
  [../]
  [./bottom_y]
    type = FunctionDirichletBC
    variable = disp_y
    boundary = bottom
    function = displacement_bc
  [../]
[]

[Materials]
  [./Elasticity_tensor]
    type = ComputeElasticityTensor
    block = 0
    fill_method = symmetric_isotropic
    C_ijkl = &#x27;1 0&#x27;
  [../]

  [./strain]
    type = ComputeSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  [../]

  [./stress]
    type = ComputeLinearElasticStress
    block = 0
  [../]

  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1&#x27;
  [../]

[]

[Executioner]
  type = Transient
  start_time = 0
  end_time = 6.0
  l_tol = 1e-12
  nl_rel_tol = 1e-12
  dt = 0.1

  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.422
    gamma = 0.8
  [../]
[]


[Functions]
  [./displacement_bc]
    type = PiecewiseLinear
    data_file = &#x27;sine_wave.csv&#x27;
    format = columns
  [../]

[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./disp_1]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_y
  [../]
  [./disp_2]
    type = NodalVariableValue
    nodeid = 3
    variable = disp_y
  [../]
  [./disp_3]
    type = NodalVariableValue
    nodeid = 10
    variable = disp_y
  [../]
  [./disp_4]
    type = NodalVariableValue
    nodeid = 14
    variable = disp_y
  [../]
[]

[Outputs]
  file_base = &#x27;wave_rayleigh_hht_out&#x27;
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e0c9e54f-76a0-436e-b7e8-139826fc89ae"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free.i</h4><pre class="moose-pre"><code class="language-text"># Test to verify the fundamental natural frequency of a one element ADComputeShellStress
# BCs: Clamped on one end, free on others.
# Initial perturbation applied to edge of the beam. After that, the shell vibrates freely.
#
# Results have been compared for various thicknesses with the following approximate Results
# (Moose results were obtained with 8 elements along the length)
# Thickness = 0.1. Reference freq: 10.785 Hz, Moose freq: 10.612 Hz
# Thickness = 0.05. Reference freq: 5.393 Hz, Moose freq: 5.335 Hz
# Thickness = 0.025. Reference freq: 2.696 Hz, Moose freq: 2.660 Hz
#
# Reference values have been obtained from Robert Blevins, &quot;Formulas for Dynamics, Acoustics and Vibration&quot;,
# Table 5.3 case 11. Formula looks like: f = lambda^2/(2*pi*a^2) * sqrt(E*h^2/(12*(1-nu*nu))), where lambda
# changes as a function of shell dimensions.

# This test uses one single element for speed reasons.

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1 # 1
  ny = 1# 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.5
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./rot_x]
  [../]
  [./rot_y]
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  # aux variables for dynamics
  [./vel_x]
  [../]
  [./vel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_x]
  [../]
  [./accel_y]
  [../]
  [./accel_z]
  [../]
  [./rot_vel_x]
  [../]
  [./rot_vel_y]
  [../]
  [./rot_accel_x]
  [../]
  [./rot_accel_y]
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    variable = stress_yy
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    variable = stress_yz
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 2
  [../]

# Kernels for dynamics
[./accel_x]
  type = NewmarkAccelAux
  variable = accel_x
  displacement = disp_x
  velocity = vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_x]
  type = NewmarkVelAux
  variable = vel_x
  acceleration = accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_y]
  type = NewmarkAccelAux
  variable = accel_y
  displacement = disp_y
  velocity = vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_y]
  type = NewmarkVelAux
  variable = vel_y
  acceleration = accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_z]
  type = NewmarkAccelAux
  variable = accel_z
  displacement = disp_z
  velocity = vel_z
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_z]
  type = NewmarkVelAux
  variable = vel_z
  acceleration = accel_z
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_x]
  type = NewmarkAccelAux
  variable = rot_accel_x
  displacement = rot_x
  velocity = rot_vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_x]
  type = NewmarkVelAux
  variable = rot_vel_x
  acceleration = rot_accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_y]
  type = NewmarkAccelAux
  variable = rot_accel_y
  displacement = rot_y
  velocity = rot_vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_y]
  type = NewmarkVelAux
  variable = rot_vel_y
  acceleration = rot_accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_function]
    type = PiecewiseLinear
    x = &#x27;0.0 0.01 0.15 10.0&#x27;
    y = &#x27;0.0 0.01 0.0 0.0&#x27;
  [../]
[]
[NodalKernels]
  [./force_z2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;top&#x27;
    function = force_function
  [../]
[]
[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
  [../]

  [./inertial_force_x]
    type = ADInertialForceShell
    # use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 0
    variable = disp_x
    thickness = 0.1
  [../]

  [./inertial_force_y]
    type = ADInertialForceShell
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 1
    variable = disp_y
    thickness = 0.1

  [../]

  [./inertial_force_z]
    type = ADInertialForceShell
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 2
    variable = disp_z
    thickness = 0.1

  [../]

  [./inertial_force_rot_x]
    type = ADInertialForceShell
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 3
    variable = rot_x
    thickness = 0.1
  [../]

  [./inertial_force_rot_y]
    type = ADInertialForceShell
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 4
    variable = rot_y
    thickness = 0.1
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 2100000
    poissons_ratio = 0.3
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeIncrementalShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 0.1
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_z_tip]
    type = PointValue
    point = &#x27;1.0 1.0 0.0&#x27;
    variable = disp_z
  [../]
  [./rot_x_tip]
    type = PointValue
    point = &#x27;0.0 1.0 0.0&#x27;
    variable = rot_x
  [../]
  [./stress_yy_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yy
  [../]
  [./stress_yy_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yy
  [../]
  [./stress_yy_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yy
  [../]
  [./stress_yy_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yy
  [../]
  [./stress_yz_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yz
  [../]
  [./stress_yz_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yz
  [../]
  [./stress_yz_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yz
  [../]
  [./stress_yz_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yz
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-10
  l_max_its = 20
  dt = 0.005
  dtmin = 0.005
  timestep_tolerance = 2e-13
  end_time = 0.5

  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Outputs]
  perf_graph = true
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0a0f3df1-c79d-457a-b11b-d9833f517894"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free_orientation_inclined_hht.i</h4><pre class="moose-pre"><code class="language-text"># Test to verify the fundamental natural frequency of a one element ADComputeShellStress
# BCs: Clamped on one end, free on others.
# Initial perturbation applied to edge of the beam. After that, the shell vibrates freely.
#
# Results have been compared for various thicknesses with the following approximate Results
# (Moose results were obtained with 8 elements along the length)
# Thickness = 0.1. Reference freq: 10.785 Hz, Moose freq: 10.612 Hz
# Thickness = 0.05. Reference freq: 5.393 Hz, Moose freq: 5.335 Hz
# Thickness = 0.025. Reference freq: 2.696 Hz, Moose freq: 2.660 Hz
#
# Reference values have been obtained from Robert Blevins, &quot;Formulas for Dynamics, Acoustics and Vibration&quot;,
# Table 5.3 case 11. Formula looks like: f = lambda^2/(2*pi*a^2) * sqrt(E*h^2/(12*(1-nu*nu))), where lambda
# changes as a function of shell dimensions.

# This test uses one single element for speed reasons.

# Here, the shell, instead of being on the XY plane, is oriented at a 45 deg. angle
# with respect to the Y axis.

[Mesh]
  type = FileMesh
  file = shell_inclined.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./rot_x]
  [../]
  [./rot_y]
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  # aux variables for dynamics
  [./vel_x]
  [../]
  [./vel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_x]
  [../]
  [./accel_y]
  [../]
  [./accel_z]
  [../]
  [./rot_vel_x]
  [../]
  [./rot_vel_y]
  [../]
  [./rot_accel_x]
  [../]
  [./rot_accel_y]
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    variable = stress_yy
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    variable = stress_yz
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 2
  [../]

# Kernels for dynamics
[./accel_x]
  type = NewmarkAccelAux
  variable = accel_x
  displacement = disp_x
  velocity = vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_x]
  type = NewmarkVelAux
  variable = vel_x
  acceleration = accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_y]
  type = NewmarkAccelAux
  variable = accel_y
  displacement = disp_y
  velocity = vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_y]
  type = NewmarkVelAux
  variable = vel_y
  acceleration = accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_z]
  type = NewmarkAccelAux
  variable = accel_z
  displacement = disp_z
  velocity = vel_z
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_z]
  type = NewmarkVelAux
  variable = vel_z
  acceleration = accel_z
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_x]
  type = NewmarkAccelAux
  variable = rot_accel_x
  displacement = rot_x
  velocity = rot_vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_x]
  type = NewmarkVelAux
  variable = rot_vel_x
  acceleration = rot_accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_y]
  type = NewmarkAccelAux
  variable = rot_accel_y
  displacement = rot_y
  velocity = rot_vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_y]
  type = NewmarkVelAux
  variable = rot_vel_y
  acceleration = rot_accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_function]
    type = PiecewiseLinear
    x = &#x27;0.0 0.01 0.15 10.0&#x27;
    y = &#x27;0.0 0.01 0.0 0.0&#x27;
  [../]
[]
[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;2&#x27;
    function = force_function
  [../]
[]
[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
  [../]

  [./inertial_force_x]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 0
    variable = disp_x
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]

  [./inertial_force_y]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 1
    variable = disp_y
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]

  [./inertial_force_z]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 2
    variable = disp_z
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]

  [./inertial_force_rot_x]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 3
    variable = rot_x
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]

  [./inertial_force_rot_y]
    type = ADInertialForceShell
    use_displaced_mesh = true
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 4
    variable = rot_y
    thickness = 0.1
    eta = 0.0
    alpha = 0.0
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 2100000
    poissons_ratio = 0.3
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeIncrementalShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 0.1
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_z_tip]
    type = PointValue
    point = &#x27;0.0 1.06 1.06&#x27;
    variable = disp_z
  [../]
  [./rot_x_tip]
    type = PointValue
    point = &#x27;0.0 1.06 1.06&#x27;
    variable = rot_x
  [../]
  [./stress_yy_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yy
  [../]
  [./stress_yy_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yy
  [../]
  [./stress_yy_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yy
  [../]
  [./stress_yy_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yy
  [../]
  [./stress_yz_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yz
  [../]
  [./stress_yz_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yz
  [../]
  [./stress_yz_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yz
  [../]
  [./stress_yz_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yz
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-10
  l_max_its = 20
  dt = 0.005
  dtmin = 0.005
  timestep_tolerance = 2e-13
  end_time = 0.5

  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]

[]

[Outputs]
  perf_graph = true
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="792185db-ebdb-4fd3-8475-221348c95a24"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/beam/dynamic/dyn_euler_small_rayleigh_hht_ti.i</h4><pre class="moose-pre"><code class="language-text"># Test for damped small strain euler beam vibration in y direction

# An impulse load is applied at the end of a cantilever beam of length 4m.
# The properties of the cantilever beam are as follows:
# Young&#x27;s modulus (E) = 1e4
# Shear modulus (G) = 4e7
# Shear coefficient (k) = 1.0
# Cross-section area (A) = 0.01
# Iy = 1e-4 = Iz
# Length (L)= 4 m
# density (rho) = 1.0
# mass proportional rayleigh damping(eta) = 0.1
# stiffness proportional rayleigh damping(eta) = 0.1
# HHT time integration parameter (alpha) = -0.3
# Corresponding Newmark beta time integration parameters beta = 0.4225 and gamma = 0.8

# For this beam, the dimensionless parameter alpha = kAGL^2/EI = 6.4e6
# Therefore, the behaves like a Euler-Bernoulli beam.

# The displacement time history from this analysis matches with that obtained from Abaqus.

# Values from the first few time steps are as follows:
# time  disp_y                vel_y                accel_y
# 0.0   0.0                   0.0                  0.0
# 0.2   0.019898364318588     0.18838688112273     1.1774180070171
# 0.4   0.045577003505278     0.087329917525455   -0.92596052423724
# 0.6   0.063767907208218     0.084330765885995    0.21274543331268
# 0.8   0.073602908614573     0.020029576220975   -0.45506879373455
# 1.0   0.06841704414745     -0.071840076837194   -0.46041813317992

[Mesh]
  type = GeneratedMesh
  nx = 10
  dim = 1
  xmin = 0.0
  xmax = 4.0
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./accel_x] # These auxkernels are only to check output
    type = TestNewmarkTI
    displacement = disp_x
    variable = accel_x
    first = false
  [../]
  [./accel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = accel_y
    first = false
  [../]
  [./accel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = accel_z
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    displacement = disp_x
    variable = vel_x
  [../]
  [./vel_y]
    type = TestNewmarkTI
    displacement = disp_y
    variable = vel_y
  [../]
  [./vel_z]
    type = TestNewmarkTI
    displacement = disp_z
    variable = vel_z
  [../]
  [./rot_accel_x]
    type = TestNewmarkTI
    displacement = rot_x
    variable = rot_accel_x
    first = false
  [../]
  [./rot_accel_y]
    type = TestNewmarkTI
    displacement = rot_y
    variable = rot_accel_y
    first = false
  [../]
  [./rot_accel_z]
    type = TestNewmarkTI
    displacement = rot_z
    variable = rot_accel_z
    first = false
  [../]
  [./rot_vel_x]
    type = TestNewmarkTI
    displacement = rot_x
    variable = rot_vel_x
  [../]
  [./rot_vel_y]
    type = TestNewmarkTI
    displacement = rot_y
    variable = rot_vel_y
  [../]
  [./rot_vel_z]
    type = TestNewmarkTI
    displacement = rot_z
    variable = rot_vel_z
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = left
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = left
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = left
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = left
    value = 0.0
  [../]
  [./fixr3]
    type = DirichletBC
    variable = rot_z
    boundary = left
    value = 0.0
  [../]
[]

[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_y
    boundary = right
    function = force
  [../]
[]

[Functions]
  [./force]
    type = PiecewiseLinear
    x = &#x27;0.0 0.2 0.4 10.0&#x27;
    y = &#x27;0.0 0.01  0.0  0.0&#x27;
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  line_search = &#x27;none&#x27;
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-10
  nl_abs_tol = 1e-10
  start_time = 0.0
  dt = 0.2
  end_time = 5.0
  timestep_tolerance = 1e-6

  # Time integrator
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.4225
    gamma = 0.8
  [../]
[]

[Kernels]
  [./solid_disp_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 0
    variable = disp_x
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_disp_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 1
    variable = disp_y
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_disp_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 2
    variable = disp_z
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_x]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 3
    variable = rot_x
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_y]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 4
    variable = rot_y
    zeta = 0.1
    alpha = -0.3
  [../]
  [./solid_rot_z]
    type = StressDivergenceBeam
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    component = 5
    variable = rot_z
    zeta = 0.1
    alpha = -0.3
  [../]
  [./inertial_force_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 0
    variable = disp_x
    alpha = -0.3
  [../]
  [./inertial_force_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 1
    variable = disp_y
    alpha = -0.3
  [../]
  [./inertial_force_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 2
    variable = disp_z
    alpha = -0.3
  [../]
  [./inertial_force_rot_x]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 3
    variable = rot_x
    alpha = -0.3
  [../]
  [./inertial_force_rot_y]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 4
    variable = rot_y
    alpha = -0.3
  [../]
  [./inertial_force_rot_z]
    type = InertialForceBeam
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    eta = 0.1
    area = 0.01
    Iy = 1e-4
    Iz = 1e-4
    Ay = 0.0
    Az = 0.0
    component = 5
    variable = rot_z
    alpha = -0.3
  [../]
[]

[Materials]
  [./elasticity]
    type = ComputeElasticityBeam
    youngs_modulus = 1.0e4
    poissons_ratio = -0.999875
    shear_coefficient = 1.0
    block = 0
  [../]
  [./strain]
    type = ComputeIncrementalBeamStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y rot_z&#x27;
    area = 0.01
    Ay = 0.0
    Az = 0.0
    Iy = 1.0e-4
    Iz = 1.0e-4
    y_orientation = &#x27;0.0 1.0 0.0&#x27;
  [../]
  [./stress]
    type = ComputeBeamResultants
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_x
  [../]
  [./disp_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = disp_y
  [../]
  [./vel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = vel_y
  [../]
  [./accel_y]
    type = PointValue
    point = &#x27;4.0 0.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  file_base = &#x27;dyn_euler_small_rayleigh_hht_out&#x27;
  exodus = true
  csv = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="371eeb63-8d78-4f4d-a154-c767752431c0"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/2D/2d_nodalmass_implicit.i</h4><pre class="moose-pre"><code class="language-text"># One element test to test the central difference time integrator.

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = 0
    xmax = 1
    ymin = 0
    ymax = 2
    nx = 1
    ny = 2
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;1 2 0&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
  [./accel_y]
  [../]
  [./vel_y]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
[]

[BCs]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./x_bot]
    type = PresetDisplacement
    boundary = bottom
    variable = disp_x
    beta = 0.25
    velocity = vel_x
    acceleration = accel_x
    function = disp
  [../]
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
[]

[NodalKernels]
  [./nodal_mass_x]
    type = NodalTranslationalInertia
    variable = &#x27;disp_x&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    boundary = &#x27;all&#x27;
  [../]
  [./nodal_mass_y]
    type = NodalTranslationalInertia
    variable = &#x27;disp_y&#x27;
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    boundary = &#x27;all&#x27;
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_abs_tol = 1e-11
  nl_rel_tol = 1e-11
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./accel_2x]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="eebc932e-1044-4938-8e0a-afdd5b934682"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/1D/1d_consistent_implicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for Newmark Beta integration for a 1D element
# Consistent mass matrix

[Mesh]
  type = GeneratedMesh
  xmin = 0
  xmax = 10
  nx = 5
  dim = 1
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
[]

[NodalKernels]
  [./force_x]
    type = UserForcingFunctionNodalKernel
    variable = disp_x
    boundary = right
    function = force_x
  [../]
[]

[Functions]
  [./force_x]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # force
    scale_factor = 1e3
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 2500
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-8
  dtmin = 1e-4
  timestep_tolerance = 1e-6
  start_time = -0.005
  end_time = 0.1
  dt = 0.005
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./disp_x]
    type = NodalVariableValue
    nodeid = 1
    variable = disp_x
  [../]
  [./vel_x]
    type = NodalVariableValue
    nodeid = 1
    variable = vel_x
  [../]
  [./accel_x]
    type = NodalVariableValue
    nodeid = 1
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
  perf_graph = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f8b80bae-0bfa-4808-82f0-18dd33840016"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/consistent/2D/2d_consistent_implicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for the central difference time integrator for a 2D mesh

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 2
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 2.0
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
[]

[AuxVariables]
  [./vel_x]
  [../]
  [./accel_x]
  [../]
  [./vel_y]
  [../]
  [./accel_y]
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./inertia_x]
    type = InertialForce
    variable = disp_x
  [../]
  [./inertia_y]
    type = InertialForce
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
  [./accel_y]
    type = TestNewmarkTI
    variable = accel_y
    displacement = disp_y
    first = false
  [../]
  [./vel_y]
    type = TestNewmarkTI
    variable = vel_y
    displacement = disp_y
  [../]
[]

[BCs]
  [./y_bot]
    type = DirichletBC
    variable = disp_y
    boundary = bottom
    value = 0.0
  [../]
  [./x_bot]
    type = PresetDisplacement
    boundary = bottom
    variable = disp_x
    beta = 0.25
    velocity = vel_x
    acceleration = accel_x
    function = disp
  [../]
[]

[Functions]
  [./disp]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27;  # displacement
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = density
    prop_values = 1e4
  [../]
[]

[Preconditioning]
  [./andy]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_abs_tol = 1e-11
  nl_rel_tol = 1e-11
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 1e-6
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./_dt]
    type = TimestepSize
  [../]
  [./accel_2x]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_x
  [../]
  [./accel_2y]
    type = PointValue
    point = &#x27;1.0 2.0 0.0&#x27;
    variable = accel_y
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b8674fb5-90b1-4407-8263-936a4380055a"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/central_difference/lumped/1D/1d_nodalmass_implicit.i</h4><pre class="moose-pre"><code class="language-text"># Test for central difference integration for 1D elements

[Mesh]
  [./generated_mesh]
    type = GeneratedMeshGenerator
    xmin = 0
    xmax = 10
    nx = 5
    dim = 1
  [../]
  [./all_nodes]
    type = BoundingBoxNodeSetGenerator
    new_boundary = &#x27;all&#x27;
    input = &#x27;generated_mesh&#x27;
    top_right = &#x27;10 0 0&#x27;
    bottom_left = &#x27;0 0 0&#x27;
  [../]
[]

[Variables]
  [./disp_x]
  [../]
[]

[AuxVariables]
  [./accel_x]
  [../]
  [./vel_x]
  [../]
[]

[AuxKernels]
  [./accel_x]
    type = TestNewmarkTI
    variable = accel_x
    displacement = disp_x
    first = false
  [../]
  [./vel_x]
    type = TestNewmarkTI
    variable = vel_x
    displacement = disp_x
  [../]
[]

[Kernels]
  [./DynamicTensorMechanics]
    displacements = &#x27;disp_x&#x27;
  [../]
[]

[NodalKernels]
  [./force_x]
    type = UserForcingFunctionNodalKernel
    variable = disp_x
    boundary = right
    function = force_x
  [../]
  [./nodal_masses]
    type = NodalTranslationalInertia
    nodal_mass_file = &#x27;nodal_mass_file.csv&#x27;
    variable = &#x27;disp_x&#x27;
    boundary = &#x27;all&#x27;
  [../]
[]

[Functions]
  [./force_x]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0 2.0 3.0 4.0&#x27; # time
    y = &#x27;0.0 1.0 0.0 -1.0 0.0&#x27; # force
    scale_factor = 1e3
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = left
    value = 0.0
  [../]
[]

[Materials]
  [./elasticity_tensor_block]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 1e6
    poissons_ratio = 0.25
    block = 0
  [../]
  [./strain_block]
    type = ComputeIncrementalSmallStrain
    block = 0
    displacements = &#x27;disp_x&#x27;
  [../]
  [./stress_block]
    type = ComputeFiniteStrainElasticStress
    block = 0
  [../]
[]

[Executioner]
  type = Transient
  start_time = -0.01
  end_time = 0.1
  dt = 0.005
  timestep_tolerance = 2e-10
  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]
[]

[Postprocessors]
  [./accel_x]
    type = PointValue
    point = &#x27;10.0 0.0 0.0&#x27;
    variable = accel_x
  [../]
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ebad8725-0f60-44cc-88fb-e38add2f688c"><div class="modal-content"><h4>test/tests/variables/time_derivatives_neighbor/test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 1
  xmin = 0
  xmax = 4
  nx = 2
[]

[Functions]
  [a_fn]
    type = ParsedFunction
    value = &#x27;t*(t+x)&#x27;
  []
[]

[AuxVariables]
  [a]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[AuxKernels]
  [a_ak]
    type = FunctionAux
    variable = a
    function = a_fn
  []
[]

[Materials]
  [cm]
    type = CoupledValuesMaterial
    variable = a
  []
[]

[Variables]
  [u]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[Kernels]
  [td]
    type = TimeDerivative
    variable = u
  []
[]

[DGKernels]
  [dgk]
    type = MatDGKernel
    variable = u
    mat_prop = a_value
  []
[]

[Executioner]
  type = Transient
  dt = 1
  num_steps = 3

  [TimeIntegrator]
    type = NewmarkBeta
  []
  [Quadrature]
    type = GAUSS
    order = FIRST
  []
[]

[Outputs]
  [./out]
    type = Exodus
    output_material_properties = true
    show_material_properties = &#x27;a_value a_dot a_dot_dot a_dot_du a_dot_dot_du&#x27;
    execute_on = &#x27;TIMESTEP_END&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0c187590-6afc-4cb0-88fe-511fd565efbd"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment.i</h4><pre class="moose-pre"><code class="language-text"># Test that models bending of a cantilever beam using shell elements

# A cantilever beam of length 10 m (in Y direction) and cross-section
# 1 m x 0.1 m is modeled using 4 shell elements placed along the length
# (Figure 6a from Dvorkin and Bathe, 1984). All displacements and
# X rotations are fixed on the bottom boundary. E = 2100000 and v = 0.0.
# A load of 0.5 N (in the Z direction) is applied at each node on the top
# boundary resulting in a total load of 1 N.

# The analytical solution for displacement at tip using small strain/rotations # is PL^3/3EI + PL/AG = 1.90485714 m
# The FEM solution using 4 shell elements is 1.875095 m with a relative error
# of 1.5%.

# Similarly, the analytical solution for slope at tip is PL^2/2EI = 0.285714286
# The FEM solution is 0.2857143 and the relative error is 5e-6%.

# The stress_yy for the four elements at z = -0.57735 * (t/2) (first qp below mid-surface of shell) are:
# 3031.089 Pa, 2165.064 Pa, 1299.038 Pa and 433.0127 Pa.
# Note the above values are the average stresses in each element.

# Analytically, stress_yy decreases linearly from y = 0 to y = 10 m.
# The maximum value of stress_yy at y = 0 is Mz/I = PL * 0.57735*(t/2)/I = 3464.1 Pa
# Therefore, the analytical value of stress at z = -0.57735 * (t/2) at the mid-point
# of the four elements are:
# 3031.0875 Pa, 2165.0625 Pa, 1299.0375 Pa ,433.0125 Pa

# The relative error in stress_yy is in the order of 5e-5%.

# The stress_yz at z = -0.57735 * (t/2) at all four elements from the simulation is 10 Pa.
# The analytical solution for the shear stress is: V/2/I *((t^2)/4 - z^2), where the shear force (V)
# is 1 N at any y along the length of the beam. Therefore, the analytical shear stress at
# z = -0.57735 * (t/2) is 10 Pa at any location along the length of the beam.

[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 1
  ny = 4
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 10.0
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_z]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./rot_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  # aux variables for dynamics
  [./vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./vel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./accel_z]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_vel_y]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_x]
  order = FIRST
  family = LAGRANGE
  [../]
  [./rot_accel_y]
  order = FIRST
  family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    variable = stress_yy
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    variable = stress_yz
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 2
  [../]

# Kernels for dynamics
[./accel_x]
  type = NewmarkAccelAux
  variable = accel_x
  displacement = disp_x
  velocity = vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_x]
  type = NewmarkVelAux
  variable = vel_x
  acceleration = accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_y]
  type = NewmarkAccelAux
  variable = accel_y
  displacement = disp_y
  velocity = vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_y]
  type = NewmarkVelAux
  variable = vel_y
  acceleration = accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_z]
  type = NewmarkAccelAux
  variable = accel_z
  displacement = disp_z
  velocity = vel_z
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_z]
  type = NewmarkVelAux
  variable = vel_z
  acceleration = accel_z
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_x]
  type = NewmarkAccelAux
  variable = rot_accel_x
  displacement = rot_x
  velocity = rot_vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_x]
  type = NewmarkVelAux
  variable = rot_vel_x
  acceleration = rot_accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_y]
  type = NewmarkAccelAux
  variable = rot_accel_y
  displacement = rot_y
  velocity = rot_vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_y]
  type = NewmarkVelAux
  variable = rot_vel_y
  acceleration = rot_accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]

[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;bottom&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_function]
    type = PiecewiseLinear
    x = &#x27;0.0 1.0&#x27;
    y = &#x27;0.0 0.5&#x27;
  [../]
[]
[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;top&#x27;
    function = force_function
  [../]
[]
[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
  [../]

  [./inertial_force_x]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 0
    variable = disp_x
    thickness = 0.1
  [../]

  [./inertial_force_y]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 1
    variable = disp_y
    thickness = 0.1
  [../]

  [./inertial_force_z]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 2
    variable = disp_z
    thickness = 0.1
  [../]

  [./inertial_force_rot_x]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 3
    variable = rot_x
    thickness = 0.1
  [../]

  [./inertial_force_rot_y]
    type = ADInertialForceShell
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 4
    variable = rot_y
    thickness = 0.1
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 2100000
    poissons_ratio = 0.0
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeIncrementalShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 0.1
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_z_tip]
    type = PointValue
    point = &#x27;1.0 10.0 0.0&#x27;
    variable = disp_z
  [../]
  [./rot_x_tip]
    type = PointValue
    point = &#x27;0.0 10.0 0.0&#x27;
    variable = rot_x
  [../]
  [./stress_yy_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yy
  [../]
  [./stress_yy_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yy
  [../]
  [./stress_yy_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yy
  [../]
  [./stress_yy_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yy
  [../]
  [./stress_yz_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yz
  [../]
  [./stress_yz_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yz
  [../]
  [./stress_yz_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yz
  [../]
  [./stress_yz_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yz
  [../]
[]
[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  nl_max_its = 2
  nl_rel_tol = 1e-10
  nl_abs_tol = 5e-4

  dt = 0.0005
  dtmin = 0.0005
  end_time = 1

#  [./TimeIntegrator]
#    type = NewmarkBeta
#    beta = 0.25
#    gamma = 0.5
#  [../]

[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2e840e5d-40fe-46bc-b73f-b217b887392c"><div class="modal-content"><h4>test/tests/kernels/vector_dot_dot/vector_test.i</h4><pre class="moose-pre"><code class="language-text"># Tests calculation of first and second time derivative
# of a coupled vector variable in a material
# a_vec(x,y,z,t) = [t*(t*x + y), t*y, 0]
# a_vec_dot(x,y,z,t) = [2*t*x + y, y, 0]
# a_vec_dot_dot(x,y,z,t) = [2*x, 0, 0]
#
# IMPORTANT NOTE:
# Currently, this test produces a_vec_dot and a_vec_dot_dot that contains oscillations over time.
# This is a known by-product of Newmark Beta time integration (see the Newmark Beta documentation),
# but as of Summer 2019, there is no alternative time integrator in MOOSE that can dampen these
# oscillations. This test is used as coverage for the function call coupledVectorDotDot.

[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 4
  ymin = 0
  ymax = 4
  nx = 8
  ny = 8
[]

[Functions]
  [a_fn]
    type = ParsedVectorFunction
    value_x = &#x27;t * (t * x + y)&#x27;
    value_y = &#x27;t * y&#x27;
    value_z = 0
  []
[]

[AuxVariables]
  [a]
    family = LAGRANGE_VEC
    order = FIRST
  []
[]

[AuxKernels]
  [a_ak]
    type = VectorFunctionAux
    variable = a
    function = a_fn
  []
[]

[Materials]
  [cm]
    type = VectorCoupledValuesMaterial
    variable = a
  []
[]

[Variables]
  [u]   # u is zero
    family = LAGRANGE_VEC
    order = FIRST
  []
[]

[Kernels]
  [td]
    type = VectorTimeDerivative
    variable = u
  []
[]

[Executioner]
  type = Transient
  dt = 1
  num_steps = 3

  [TimeIntegrator]
    type = NewmarkBeta
  []
[]

[Outputs]
  [./out]
    type = Exodus
    output_material_properties = true
    show_material_properties = &#x27;a_value a_dot a_dot_dot a_dot_du a_dot_dot_du&#x27;
    execute_on = &#x27;TIMESTEP_END&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3ea5709c-d77a-434c-8a1d-132193df2746"><div class="modal-content"><h4>modules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment_free_orientation_inclined.i</h4><pre class="moose-pre"><code class="language-text"># Test to verify the fundamental natural frequency of a one element ADComputeShellStress
# BCs: Clamped on one end, free on others.
# Initial perturbation applied to edge of the beam. After that, the shell vibrates freely.
#
# Results have been compared for various thicknesses with the following approximate Results
# (Moose results were obtained with 8 elements along the length)
# Thickness = 0.1. Reference freq: 10.785 Hz, Moose freq: 10.612 Hz
# Thickness = 0.05. Reference freq: 5.393 Hz, Moose freq: 5.335 Hz
# Thickness = 0.025. Reference freq: 2.696 Hz, Moose freq: 2.660 Hz
#
# Reference values have been obtained from Robert Blevins, &quot;Formulas for Dynamics, Acoustics and Vibration&quot;,
# Table 5.3 case 11. Formula looks like: f = lambda^2/(2*pi*a^2) * sqrt(E*h^2/(12*(1-nu*nu))), where lambda
# changes as a function of shell dimensions.

# This test uses one single element for speed reasons.

# Here, the shell, instead of being on the XY plane, is oriented at a 45 deg. angle
# with respect to the Y axis.

[Mesh]
  type = FileMesh
  file = shell_inclined.e
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
  [./rot_x]
  [../]
  [./rot_y]
  [../]
[]

[AuxVariables]
  [./stress_yy]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./stress_yz]
    order = CONSTANT
    family = MONOMIAL
  [../]

  # aux variables for dynamics
  [./vel_x]
  [../]
  [./vel_y]
  [../]
  [./vel_z]
  [../]
  [./accel_x]
  [../]
  [./accel_y]
  [../]
  [./accel_z]
  [../]
  [./rot_vel_x]
  [../]
  [./rot_vel_y]
  [../]
  [./rot_accel_x]
  [../]
  [./rot_accel_y]
  [../]
[]

[AuxKernels]
  [./stress_yy]
    type = RankTwoAux
    variable = stress_yy
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 1
  [../]
  [./stress_yz]
    type = RankTwoAux
    variable = stress_yz
    rank_two_tensor = global_stress_t_points_0
    index_i = 1
    index_j = 2
  [../]

# Kernels for dynamics
[./accel_x]
  type = NewmarkAccelAux
  variable = accel_x
  displacement = disp_x
  velocity = vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_x]
  type = NewmarkVelAux
  variable = vel_x
  acceleration = accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_y]
  type = NewmarkAccelAux
  variable = accel_y
  displacement = disp_y
  velocity = vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_y]
  type = NewmarkVelAux
  variable = vel_y
  acceleration = accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[./accel_z]
  type = NewmarkAccelAux
  variable = accel_z
  displacement = disp_z
  velocity = vel_z
  beta = 0.25
  execute_on = timestep_end
[../]
[./vel_z]
  type = NewmarkVelAux
  variable = vel_z
  acceleration = accel_z
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_x]
  type = NewmarkAccelAux
  variable = rot_accel_x
  displacement = rot_x
  velocity = rot_vel_x
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_x]
  type = NewmarkVelAux
  variable = rot_vel_x
  acceleration = rot_accel_x
  gamma = 0.5
  execute_on = timestep_end
[../]
[./rot_accel_y]
  type = NewmarkAccelAux
  variable = rot_accel_y
  displacement = rot_y
  velocity = rot_vel_y
  beta = 0.25
  execute_on = timestep_end
[../]
[./rot_vel_y]
  type = NewmarkVelAux
  variable = rot_vel_y
  acceleration = rot_accel_y
  gamma = 0.5
  execute_on = timestep_end
[../]
[]

[BCs]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixz1]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixr1]
    type = DirichletBC
    variable = rot_x
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixr2]
    type = DirichletBC
    variable = rot_y
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;0&#x27;
    value = 0.0
  [../]
[]

[Functions]
  [./force_function]
    type = PiecewiseLinear
    x = &#x27;0.0 0.01 0.15 10.0&#x27;
    y = &#x27;0.0 0.01 0.0 0.0&#x27;
  [../]
[]
[NodalKernels]
  [./force_y2]
    type = UserForcingFunctionNodalKernel
    variable = disp_z
    boundary = &#x27;2&#x27;
    function = force_function
  [../]
[]
[Kernels]
  [./solid_disp_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 0
    variable = disp_x
    through_thickness_order = SECOND
  [../]
  [./solid_disp_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 1
    variable = disp_y
    through_thickness_order = SECOND
  [../]
  [./solid_disp_z]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 2
    variable = disp_z
    through_thickness_order = SECOND
  [../]
  [./solid_rot_x]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 3
    variable = rot_x
    through_thickness_order = SECOND
  [../]
  [./solid_rot_y]
    type = ADStressDivergenceShell
    block = &#x27;0&#x27;
    component = 4
    variable = rot_y
    through_thickness_order = SECOND
  [../]

  [./inertial_force_x]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 0
    variable = disp_x
    thickness = 0.1
  [../]

  [./inertial_force_y]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 1
    variable = disp_y
    thickness = 0.1

  [../]

  [./inertial_force_z]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 2
    variable = disp_z
    thickness = 0.1

  [../]

  [./inertial_force_rot_x]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 3
    variable = rot_x
    thickness = 0.1
  [../]

  [./inertial_force_rot_y]
    type = ADInertialForceShell
    use_displaced_mesh = true
    eta = 0.0
    block = 0
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    velocities = &#x27;vel_x vel_y vel_z&#x27;
    accelerations = &#x27;accel_x accel_y accel_z&#x27;
    rotational_velocities = &#x27;rot_vel_x rot_vel_y&#x27;
    rotational_accelerations = &#x27;rot_accel_x rot_accel_y&#x27;
    component = 4
    variable = rot_y
    thickness = 0.1
  [../]
[]

[Materials]
  [./elasticity]
    type = ADComputeIsotropicElasticityTensorShell
    youngs_modulus = 2100000
    poissons_ratio = 0.3
    block = 0
    through_thickness_order = SECOND
  [../]
  [./strain]
    type = ADComputeIncrementalShellStrain
    block = &#x27;0&#x27;
    displacements = &#x27;disp_x disp_y disp_z&#x27;
    rotations = &#x27;rot_x rot_y&#x27;
    thickness = 0.1
    through_thickness_order = SECOND
  [../]
  [./stress]
    type = ADComputeShellStress
    block = 0
    through_thickness_order = SECOND
  [../]
  [./density]
    type = GenericConstantMaterial
    block = 0
    prop_names = &#x27;density&#x27;
    prop_values = &#x27;1.0&#x27;
  [../]
[]

[Postprocessors]
  [./disp_z_tip]
    type = PointValue
    point = &#x27;0.0 1.06 1.06&#x27;
    variable = disp_z
  [../]
  [./rot_x_tip]
    type = PointValue
    point = &#x27;0.0 1.06 1.06&#x27;
    variable = rot_x
  [../]
  [./stress_yy_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yy
  [../]
  [./stress_yy_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yy
  [../]
  [./stress_yy_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yy
  [../]
  [./stress_yy_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yy
  [../]
  [./stress_yz_el_0]
    type = ElementalVariableValue
    elementid = 0
    variable = stress_yz
  [../]
  [./stress_yz_el_1]
    type = ElementalVariableValue
    elementid = 1
    variable = stress_yz
  [../]
  [./stress_yz_el_2]
    type = ElementalVariableValue
    elementid = 2
    variable = stress_yz
  [../]
  [./stress_yz_el_3]
    type = ElementalVariableValue
    elementid = 3
    variable = stress_yz
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient
  solve_type = PJFNK
  l_tol = 1e-11
  nl_max_its = 15
  nl_rel_tol = 1e-11
  nl_abs_tol = 1e-10
  l_max_its = 20
  dt = 0.005
  dtmin = 0.005
  timestep_tolerance = 2e-13
  end_time = 0.5

  [./TimeIntegrator]
    type = NewmarkBeta
    beta = 0.25
    gamma = 0.5
  [../]

[]

[Outputs]
  perf_graph = true
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="79888f07-2c58-434f-8b6c-b9248b5f81ed" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="bathe2012insight">K.&nbsp;J. Bathe and G.&nbsp;Noh.
Insight into an implicit time integration scheme for structural dynamics.
<em>Computers and Structures</em>, 98-99:1&ndash;6, 2012.<a href="#750a17a7-f802-4c5c-bf17-342ec676c722" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="750a17a7-f802-4c5c-bf17-342ec676c722"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{bathe2012insight,
    author = "Bathe, K. J. and Noh, G.",
    title = "Insight into an implicit time integration scheme for structural dynamics",
    journal = "Computers and Structures",
    volume = "98-99",
    pages = "1-6",
    year = "2012"
}
</code></pre></div></div></li><li id="newmark1959amethod">N.&nbsp;M. Newmark.
A method of computation for structural dynamics.
<em>Journal of Engineering Mechanics</em>, 85(EM3):6794, 1959.<a href="#88a39706-349d-45a0-befb-872212b72be9" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="88a39706-349d-45a0-befb-872212b72be9"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{newmark1959amethod,
    author = "Newmark, N. M.",
    title = "A method of computation for structural dynamics",
    journal = "Journal of Engineering Mechanics",
    publisher = "ASCE",
    volume = "85",
    number = "EM3",
    pages = "67--94",
    year = "1959"
}
</code></pre></div></div></li></ol></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#5b62c621-8a11-4b35-ae40-a69809006d76" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#8c63ae89-2687-4be5-a4fb-e5e4dd41ed16" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#de2d1822-da15-4ca6-929a-0237a665542a" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li><li><a href="#79888f07-2c58-434f-8b6c-b9248b5f81ed" class="tooltipped" data-position="left" data-tooltip="References">References</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>