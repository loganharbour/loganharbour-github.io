<!DOCTYPE html><head><meta charset="UTF-8"><title>SolutionUserObject.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="b8eea6c5-402a-4db7-a048-ba2fffc3dafa"><i class="material-icons">menu</i></a><ul class="sidenav" id="b8eea6c5-402a-4db7-a048-ba2fffc3dafa"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">userobject</span><a href="#" class="breadcrumb">SolutionUserObject</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="89648a0c-0447-4680-b17d-5de784e629e1" data-section-level="1" data-section-text="SolutionUserObject"><h1 id="solutionuserobject">SolutionUserObject</h1><p>Reads a variable from a mesh in one simulation to another</p><section class="scrollspy" id="6b4dcc81-0a9d-4e25-8510-224f38a50575" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p>A solution user object reads a variable from a mesh in one simulation to another.  In order to use a <code>SolutionUserObject</code> three additional parameters are required, an <a href="../../syntax/AuxVariables/index.html">AuxVariable</a> , a <a href="../../syntax/Functions/index.html">Function</a> and an <a href="../../syntax/AuxKernels/index.html">AuxKernel</a>.  The <code>AuxVariable</code> represents the variable to be read by the solution user object.  The <code>SolutionUserObject</code> is set up to read the old output file.  A <code>SolutionFunction</code> is required to interpolate in time and space the data from the <code>SolutionUserObject</code>.  Finally, the <code>Function</code> is required that will query the function and write the value into the <code>AuxVariable</code>.</p></section><section class="scrollspy" id="eabe60d0-2f28-4b72-ba1c-e3326c0c7e0c" data-section-level="2" data-section-text="Example Input Syntax"><h2 id="example-input-syntax">Example Input Syntax</h2><pre class="moose-pre"><code class="language-text">[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
  [../]
[]
</code></pre><a href="#8a0e361e-58d9-4695-bbab-03234dbffcff" class="modal-trigger">(test/tests/auxkernels/solution_aux/solution_aux_exodus_interp.i)</a><div class="modal moose-modal" id="8a0e361e-58d9-4695-bbab-03234dbffcff"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/test/tests/auxkernels/solution_aux/solution_aux_exodus_interp.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = cubesource.e
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    variable = nn
    solution = soln
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="934a27b0-ba3b-4f2e-8031-38a44b1b5d86" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="fa3c68cb-0f73-4aaf-9be5-697e4dde7e16" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">mesh</span><span class="moose-parameter-header-description">The name of the mesh file (must be xda or exodusII file).</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MeshFileName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the mesh file (must be xda or exodusII file).</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="fa5ee08d-56b2-4f42-9f5b-ec26cd260dec" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">es</span><span class="moose-parameter-header-default"><not supplied></span><span class="moose-parameter-header-description">The name of the file holding the equation system info in xda format (xda only).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span><not supplied></p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FileName</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the file holding the equation system info in xda format (xda only).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">execute_on</span><span class="moose-parameter-header-default">TIMESTEP_END</span><span class="moose-parameter-header-description">The list of flag(s) indicating when this object should be executed, the available options include NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, FINAL, CUSTOM.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>TIMESTEP_END</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>ExecFlagEnum</p><p class="moose-parameter-description-options"><span>Options:</span>NONE INITIAL LINEAR NONLINEAR TIMESTEP_END TIMESTEP_BEGIN FINAL CUSTOM</p><p class="moose-parameter-description"><span>Description:</span>The list of flag(s) indicating when this object should be executed, the available options include NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, FINAL, CUSTOM.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">rotation0_angle</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Anticlockwise rotation angle (in degrees) to use for rotation about rotation0_vector.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Anticlockwise rotation angle (in degrees) to use for rotation about rotation0_vector.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">rotation0_vector</span><span class="moose-parameter-header-default">0 0 1</span><span class="moose-parameter-header-description">Vector about which to rotate points of the simulation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0 0 1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>libMesh::VectorValue<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Vector about which to rotate points of the simulation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">rotation1_angle</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Anticlockwise rotation angle (in degrees) to use for rotation about rotation1_vector.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Anticlockwise rotation angle (in degrees) to use for rotation about rotation1_vector.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">rotation1_vector</span><span class="moose-parameter-header-default">0 0 1</span><span class="moose-parameter-header-description">Vector about which to rotate points of the simulation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0 0 1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>libMesh::VectorValue<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Vector about which to rotate points of the simulation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">scale</span><span class="moose-parameter-header-default">1 1 1 </span><span class="moose-parameter-header-description">Scale factor for points in the simulation</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1 1 1 </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Scale factor for points in the simulation</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">scale_multiplier</span><span class="moose-parameter-header-default">1 1 1 </span><span class="moose-parameter-header-description">Scale multiplying factor for points in the simulation</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1 1 1 </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Scale multiplying factor for points in the simulation</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">system</span><span class="moose-parameter-header-default">nl0</span><span class="moose-parameter-header-description">The name of the system to pull values out of (xda only).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nl0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the system to pull values out of (xda only).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">system_variables</span><span class="moose-parameter-header-description">The name of the nodal and elemental variables from the file you want to use for values</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The name of the nodal and elemental variables from the file you want to use for values</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">timestep</span><span class="moose-parameter-header-description">Index of the single timestep used or "LATEST" for the last timestep (exodusII only).  If not supplied, time interpolation will occur.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Index of the single timestep used or "LATEST" for the last timestep (exodusII only).  If not supplied, time interpolation will occur.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">transformation_order</span><span class="moose-parameter-header-default">translation scale</span><span class="moose-parameter-header-description">The order to perform the operations in.  Define R0 to be the rotation matrix encoded by rotation0_vector and rotation0_angle.  Similarly for R1.  Denote the scale by s, the scale_multiplier by m, and the translation by t.  Then, given a point x in the simulation, if transformation_order = 'rotation0 scale_multiplier translation scale rotation1' then form p = R1*(R0*x*m - t)/s.  Then the values provided by the SolutionUserObject at point x in the simulation are the variable values at point p in the mesh.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>translation scale</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>rotation0 translation scale rotation1 scale_multiplier</p><p class="moose-parameter-description"><span>Description:</span>The order to perform the operations in.  Define R0 to be the rotation matrix encoded by rotation0_vector and rotation0_angle.  Similarly for R1.  Denote the scale by s, the scale_multiplier by m, and the translation by t.  Then, given a point x in the simulation, if transformation_order = 'rotation0 scale_multiplier translation scale rotation1' then form p = R1*(R0*x*m - t)/s.  Then the values provided by the SolutionUserObject at point x in the simulation are the variable values at point p in the mesh.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">translation</span><span class="moose-parameter-header-default">0 0 0 </span><span class="moose-parameter-header-description">Translation factors for x,y,z coordinates of the simulation</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0 0 0 </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Translation factors for x,y,z coordinates of the simulation</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="a2bb72d9-136a-42cf-b898-15b093140037" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">allow_duplicate_execution_on_initial</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_preaux</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the GeneralUserObject to be executed in PREAUX</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Forces the GeneralUserObject to be executed in PREAUX</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_preic</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the GeneralUserObject to be executed in PREIC during initial setup</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Forces the GeneralUserObject to be executed in PREIC during initial setup</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section class="scrollspy" id="9014699a-dcc8-437f-b9b1-dd630e284f0a" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#31a47d15-90a6-493d-81bf-f80b2792e397" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_elemental_only.i</a></li><li><a href="#c58eb31d-093a-4716-aafa-ef8efe24ab8e" class="modal-trigger">test/tests/functions/solution_function/solution_function_scale_transl.i</a></li><li><a href="#a0110efa-b549-4bb3-9dfe-1af8974b5faf" class="modal-trigger">test/tests/functions/solution_function/solution_function_exodus_test.i</a></li><li><a href="#80508586-914a-48d6-ad36-a0ed19ece2fd" class="modal-trigger">modules/combined/test/tests/axisymmetric_2d3d_solution_function/3dy.i</a></li><li><a href="#2d1d2575-afe2-4b57-b97a-262fdfac38f4" class="modal-trigger">test/tests/userobjects/solution_user_object/discontinuous_value_solution_uo_p2.i</a></li><li><a href="#48986531-8707-48a4-b41b-a10d7189ded7" class="modal-trigger">test/tests/auxkernels/solution_aux/aux_nonlinear_solution_adapt_xda.i</a></li><li><a href="#e4b5b5a5-bc89-4ff8-8478-c5ca8b44299b" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus.i</a></li><li><a href="#50ae4e50-8c5f-4ae2-8200-14373d9dbda6" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_file_extension.i</a></li><li><a href="#f1c3d146-daa8-452c-a385-c8b929e502e5" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_elem_map.i</a></li><li><a href="#0734ac63-3383-4f14-b16a-bb5e6c85e1d1" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_multi_err.i</a></li><li><a href="#abde6f67-2f1e-4f3f-8db3-c2cc654f06cc" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_interp_restart2.i</a></li><li><a href="#bcbdd9b7-2f3f-40de-a2b3-c3f43eb4185b" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_interp_restart1.i</a></li><li><a href="#fdc7dc4b-5858-437d-8774-31cd40c99d09" class="modal-trigger">test/tests/functions/solution_function/solution_function_grad_p2.i</a></li><li><a href="#7b6fc226-2f82-4299-afd3-65a8ddf466b6" class="modal-trigger">test/tests/auxkernels/solution_aux/output_error.i</a></li><li><a href="#b7c08876-ca32-42b6-be48-7d8576d9fd85" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_direct.i</a></li><li><a href="#a2aa4ed2-6156-4dec-9c16-e74e4f1bd789" class="modal-trigger">modules/porous_flow/examples/restart/gas_injection_new_mesh.i</a></li><li><a href="#82dac2f8-3e19-4cc1-ac07-41c50769ca0e" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_direct.i</a></li><li><a href="#213b893e-ca01-4da2-8732-d38b5ab47b75" class="modal-trigger">examples/ex14_pps/ex14_compare_solutions_2.i</a></li><li><a href="#42528a56-1710-4027-b14b-02e8a2766dad" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_interp.i</a></li><li><a href="#79b30a65-dbc3-432f-b5a6-4e014816b88f" class="modal-trigger">test/tests/functions/solution_function/solution_function_rot3.i</a></li><li><a href="#8fe7c211-02eb-4136-a321-d97ede43d233" class="modal-trigger">test/tests/functions/solution_function/solution_function_scale_mult.i</a></li><li><a href="#977ad099-8275-4ed3-be53-19096be581a4" class="modal-trigger">test/tests/functions/solution_function/solution_function_rot2.i</a></li><li><a href="#aa9e2740-6227-4599-a35a-3df743d56c55" class="modal-trigger">test/tests/auxkernels/solution_aux/thread_xda.i</a></li><li><a href="#20df8e7b-51c7-4927-b486-6d0e022a1505" class="modal-trigger">test/tests/auxkernels/solution_aux/aux_nonlinear_solution_xda.i</a></li><li><a href="#e498bfe2-ad49-45d4-a5f0-cef4732349be" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_elemental.i</a></li><li><a href="#8cc43600-4c50-4430-bc6a-93b32596c343" class="modal-trigger">test/tests/auxkernels/solution_scalar_aux/solution_scalar_aux.i</a></li><li><a href="#af9e022a-033b-45ab-b1be-34489e9d7822" class="modal-trigger">test/tests/functions/solution_function/solution_function_exodus_interp_test.i</a></li><li><a href="#472640f6-93f0-4c2c-93ca-b44d68c7ef47" class="modal-trigger">test/tests/auxkernels/solution_aux/aux_nonlinear_solution_xdr.i</a></li><li><a href="#ac3a1800-34f5-4da3-96d0-b2a6d2e0d3e3" class="modal-trigger">test/tests/functions/solution_function/solution_function_test.i</a></li><li><a href="#087f86a4-c633-4fcf-9876-26204f96ee95" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_exodus_interp_direct.i</a></li><li><a href="#c622b973-a4f6-4809-8654-4e36ca74a6dc" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_scale.i</a></li><li><a href="#a2520ae4-04c6-42b1-ae63-e6d2ee391a95" class="modal-trigger">test/tests/functions/solution_function/solution_function_rot1.i</a></li><li><a href="#a1b5f39a-478d-4064-ad8d-d9e6e9b06ac5" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux_multi_var.i</a></li><li><a href="#64a5b3ba-75af-4dea-b31a-32f1053c9e15" class="modal-trigger">test/tests/auxkernels/solution_aux/solution_aux.i</a></li><li><a href="#eb1ea84d-6833-4914-88d3-fc47bb2aae74" class="modal-trigger">test/tests/functions/solution_function/solution_function_rot4.i</a></li></ul><div class="modal moose-modal" id="31a47d15-90a6-493d-81bf-f80b2792e397"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_elemental_only.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cubesource.e
  # The SolutionUserObject uses the copy_nodal_solution() capability
  # of the Exodus reader, and therefore won&#x27;t work if the initial mesh
  # has been renumbered (it will be reunumbered if you are running with
  # DistributedMesh in parallel).  Hence, we restrict this test to run with
  # ReplicatedMesh only.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./en]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./en]
    type = SolutionAux
    solution = soln
    variable = en
    scale_factor = 2.0
    from_variable = source_element
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = &#x27;source_element&#x27;
    timestep = 2
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c58eb31d-093a-4716-aafa-ef8efe24ab8e"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_scale_transl.i</h4><pre class="moose-pre"><code class="language-text"># checking scale and translation, with ordering scale first, then translation second
[Mesh]
  type = GeneratedMesh
  dim = 3
  xmin = -1
  xmax = 1
  nx = 3
  ymin = -1
  ymax = 1
  ny = 3
  zmin = -1
  zmax = 1
  nz = 3
[]

[UserObjects]
  [./solution_uo]
    type = SolutionUserObject
    mesh = cube_with_u_equals_x.e
    timestep = 1
    system_variables = u
    scale = &#x27;0.5 1 1&#x27;
    translation = &#x27;2 0 0&#x27;
    transformation_order = &#x27;scale translation&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./u_init]
    type = FunctionIC
    variable = u
    function = solution_fcn
  [../]
[]

[Functions]
  [./solution_fcn]
    type = SolutionFunction
    from_variable = u
    solution = solution_uo
  [../]
[]

[Kernels]
  [./diff]
    type = TimeDerivative
    variable = u
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 1
  end_time = 1
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = solution_function_scale_transl
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a0110efa-b549-4bb3-9dfe-1af8974b5faf"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_exodus_test.i</h4><pre class="moose-pre"><code class="language-text"># [Executioner]
# type = Steady
# petsc_options = &#x27;-snes&#x27;
# l_max_its = 800
# nl_rel_tol = 1e-10
# []

[Mesh]
  type = FileMesh
  file = cubesource.e
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  # [./ne]
  # order = FIRST
  # family = LAGRANGE
  # [../]
  # [./ee]
  # order = CONSTANT
  # family = MONOMIAL
  # [../]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
  [./en]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Functions]
  # [./sourcee]
  # type = SolutionFunction
  # file_type = exodusII
  # mesh = cubesource.e
  # variable = source_element
  # [../]
  [./sourcen]
    type = SolutionFunction
    scale_factor = 2.0
    solution = cube_soln
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  # [./ne]
  # type = FunctionAux
  # variable = ne
  # function = sourcee
  # [../]
  # [./ee]
  # type = FunctionAux
  # variable = ee
  # function = sourcee
  # [../]
  [./nn]
    type = FunctionAux
    variable = nn
    function = sourcen
  [../]
  [./en]
    type = FunctionAux
    variable = en
    function = sourcen
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[UserObjects]
  [./cube_soln]
    type = SolutionUserObject
    timestep = 2
    system_variables = source_nodal
    mesh = cubesource.e
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="80508586-914a-48d6-ad36-a0ed19ece2fd"><div class="modal-content"><h4>modules/combined/test/tests/axisymmetric_2d3d_solution_function/3dy.i</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  order = FIRST
  family = LAGRANGE
  disp_x = disp_x
  disp_y = disp_y
  disp_z = disp_z
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  file = 3dy.e
[]

[Variables]
  [./disp_x]
  [../]
  [./disp_y]
  [../]
  [./disp_z]
  [../]
[]

[AuxVariables]
  [./temp]
  [../]
  [./hoop_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = 2d_out.e
    system_variables = &#x27;disp_x disp_y temp&#x27;
  [../]
[]

[Functions]
  [./soln_func_temp]
    type = Axisymmetric2D3DSolutionFunction
    solution = soln
    from_variables = &#x27;temp&#x27;
  [../]
  [./soln_func_disp_x]
    type = Axisymmetric2D3DSolutionFunction
    solution = soln
    from_variables = &#x27;disp_x disp_y&#x27;
    component = 0
  [../]
  [./soln_func_disp_y]
    type = Axisymmetric2D3DSolutionFunction
    solution = soln
    from_variables = &#x27;disp_x disp_y&#x27;
    component = 1
  [../]
  [./soln_func_disp_z]
    type = Axisymmetric2D3DSolutionFunction
    solution = soln
    from_variables = &#x27;disp_x disp_y&#x27;
    component = 2
  [../]
[]

[Modules/TensorMechanics/Master]
  [./all]
    volumetric_locking_correction = true
    add_variables  = true
    incremental = true
    strain = FINITE
    eigenstrain_names = thermal_expansion
    generate_output = &#x27;stress_xx stress_yy stress_zz vonmises_stress hydrostatic_stress&#x27;
  [../]
[]

[AuxKernels]
  [./t_soln_aux]
    type = FunctionAux
    variable = temp
    block = &#x27;1 2&#x27;
    function = soln_func_temp
  [../]
  [./hoop_stress]
    type = RankTwoScalarAux
    rank_two_tensor = stress
    variable = hoop_stress
    scalar_type = HoopStress
    execute_on = timestep_end
  [../]
[]

[BCs]
  [./x_soln_bc]
    type = FunctionDirichletBC
    variable = disp_x
    preset = false
    boundary = &#x27;1 2&#x27;
    function = soln_func_disp_x
  [../]
  [./y_soln_bc]
    type = FunctionDirichletBC
    variable = disp_y
    preset = false
    boundary = &#x27;1 2&#x27;
    function = soln_func_disp_y
  [../]
  [./z_soln_bc]
    type = FunctionDirichletBC
    variable = disp_z
    preset = false
    boundary = &#x27;1 2&#x27;
    function = soln_func_disp_z
  [../]
[]

[Materials]
  [./elasticity_tensor]
    type = ComputeIsotropicElasticityTensor
    block = &#x27;1 2&#x27;
    youngs_modulus = 193.05e9
    poissons_ratio = 0.3
  [../]

  [./stress]
    type = ComputeFiniteStrainElasticStress
    block = &#x27;1 2&#x27;
  [../]

  [./thermal_expansion]
    type = ComputeThermalExpansionEigenstrain
    block = &#x27;1 2&#x27;
    thermal_expansion_coeff = 13e-6
    stress_free_temperature = 295.00
    temperature = temp
    eigenstrain_name = thermal_expansion
  [../]

  [./density]
    type = Density
    block = &#x27;1&#x27;
    density = 8000.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;

  petsc_options = &#x27;-ksp_snes_ew&#x27;
  petsc_options_iname = &#x27;-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter&#x27;
  petsc_options_value = &#x27; 201                hypre    boomeramg      4&#x27;
  line_search = &#x27;none&#x27;
  l_max_its = 25
  nl_max_its = 20
  nl_rel_tol = 1e-10
  l_tol = 1e-2

  start_time = 0.0
  dt = 1
  end_time = 1
  dtmin = 1
[]

[Outputs]
  file_base = 3dy_out
  exodus = true
  [./console]
    type = Console
    max_rows = 25
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="2d1d2575-afe2-4b57-b97a-262fdfac38f4"><div class="modal-content"><h4>test/tests/userobjects/solution_user_object/discontinuous_value_solution_uo_p2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = 0
  xmax = 1
  ymin = 0
  ymax = 1
  nx = 2
  ny = 2
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./one]
    type = DirichletBC
    variable = u
    boundary = &#x27;right top bottom&#x27;
    value = 1
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = discontinuous_value_solution_uo_p1.e
    system_variables = &#x27;discontinuous_variable continuous_variable&#x27;
  [../]
[]

[Postprocessors]

  [./discontinuous_value_left]
    type = TestDiscontinuousValuePP
    variable = discontinuous_variable
    point = &#x27;0.25 0.25 0.0&#x27;
    solution = soln
  [../]
  [./discontinuous_value_face]
    type = TestDiscontinuousValuePP
    variable = discontinuous_variable
    point = &#x27;0.5 0.25 0.0&#x27;
    solution = soln
  [../]
  [./discontinuous_value_right]
    type = TestDiscontinuousValuePP
    variable = discontinuous_variable
    point = &#x27;0.75 0.25 0.0&#x27;
    solution = soln
  [../]

  [./continuous_gradient_left]
    type = TestDiscontinuousValuePP
    variable = continuous_variable
    evaluate_gradient = true
    gradient_component = x
    point = &#x27;0.25 0.25 0.0&#x27;
    solution = soln
  [../]
  [./continuous_gradient_value_face]
    type = TestDiscontinuousValuePP
    variable = continuous_variable
    evaluate_gradient = true
    gradient_component = x
    point = &#x27;0.5 0.25 0.0&#x27;
    solution = soln
  [../]
  [./continuous_gradient_right]
    type = TestDiscontinuousValuePP
    variable = continuous_variable
    evaluate_gradient = true
    gradient_component = x
    point = &#x27;0.75 0.25 0.0&#x27;
    solution = soln
  [../]

[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  file_base = discontinuous_value_solution_uo_p2
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="48986531-8707-48a4-b41b-a10d7189ded7"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/aux_nonlinear_solution_adapt_xda.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  type = FileMesh
  file = aux_nonlinear_solution_adapt_out_0004_mesh.xda
  parallel_type = replicated
[]

[Adaptivity]
  marker = error_frac
  steps = 2
  [./Indicators]
    [./jump_indicator]
      type = GradientJumpIndicator
      variable = u
    [../]
  [../]
  [./Markers]
    [./error_frac]
      type = ErrorFractionMarker
      indicator = jump_indicator
      refine = 0.7
    [../]
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
  [../]
[]

[Functions]
  [./u_xda_func]
    type = SolutionFunction
    solution = xda_u
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./aux_xda_kernel]
    type = SolutionAux
    variable = u_aux
    solution = xda_u_aux
    execute_on = initial
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 2
  [../]
[]

[UserObjects]
  [./xda_u_aux]
    type = SolutionUserObject
    system = aux0
    mesh = aux_nonlinear_solution_adapt_out_0004_mesh.xda
    es = aux_nonlinear_solution_adapt_out_0004.xda
    system_variables = u_aux
    execute_on = initial
  [../]
  [./xda_u]
    type = SolutionUserObject
    system = nl0
    mesh = aux_nonlinear_solution_adapt_out_0004_mesh.xda
    es = aux_nonlinear_solution_adapt_out_0004.xda
    system_variables = u
    execute_on = initial
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
[]

[ICs]
  [./u_func_ic]
    function = u_xda_func
    variable = u
    type = FunctionIC
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e4b5b5a5-bc89-4ff8-8478-c5ca8b44299b"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cubesource.e
  # The SolutionUserObject uses the copy_nodal_solution() capability
  # of the Exodus reader, and therefore won&#x27;t work if the initial mesh
  # has been renumbered (it will be reunumbered if you are running with
  # DistributedMesh in parallel).  Hence, we restrict this test to run with
  # ReplicatedMesh only.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
  [./en]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    solution = soln
    variable = nn
    scale_factor = 2.0
  [../]
  [./en]
    type = SolutionAux
    solution = soln
    variable = en
    scale_factor = 2.0
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
    timestep = 2
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]

[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="50ae4e50-8c5f-4ae2-8200-14373d9dbda6"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_file_extension.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cubesource.e
  # The SolutionUserObject uses the copy_nodal_solution() capability
  # of the Exodus reader, and therefore won&#x27;t work if the initial mesh
  # has been renumbered (it will be reunumbered if you are running with
  # DistributedMesh in parallel).  Hence, we restrict this test to run with
  # ReplicatedMesh only.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
  [./en]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    solution = soln
    variable = nn
    scale_factor = 2.0
  [../]
  [./en]
    type = SolutionAux
    solution = soln
    variable = en
    scale_factor = 2.0
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e-s003
    system_variables = source_nodal
    timestep = 2
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]

[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="f1c3d146-daa8-452c-a385-c8b929e502e5"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_elem_map.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = elem_map.e
  # The SolutionUserObject uses the copy_nodal_solution() capability
  # of the Exodus reader, and therefore won&#x27;t work if the initial mesh
  # has been renumbered (it will be reunumbered if you are running with
  # DistributedMesh in parallel).  Hence, we restrict this test to run with
  # ReplicatedMesh only.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./matid]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./matid]
    type = SolutionAux
    solution = soln
    variable = matid
    scale_factor = 1.0
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = elem_map.e
    system_variables = MatID
    timestep = LATEST
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1&#x27;
    value = 1.0
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="0734ac63-3383-4f14-b16a-bb5e6c85e1d1"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_multi_err.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cubesource.e
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
  [./en]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    solution = soln
    variable = nn
    scale_factor = 2.0
    #from_variable = source_nodal
    #add_factor = -10teg
  [../]
  [./en]
    type = SolutionAux
    solution = soln
    variable = en
    scale_factor = 2.0
    #from_variable = source_nodal
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource_added.e
    system_variables = &#x27;source_nodal nodal_10&#x27;
    timestep = 2
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]

[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="abde6f67-2f1e-4f3f-8db3-c2cc654f06cc"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_interp_restart2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  type = FileMesh
  file = cubesource.e
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    variable = nn
    solution = soln
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 5
  start_time = 2.5
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]

[Problem]
  restart_file_base = solution_aux_exodus_interp_restart1_out_cp/0005
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bcbdd9b7-2f3f-40de-a2b3-c3f43eb4185b"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_interp_restart1.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  type = FileMesh
  file = cubesource.e
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    variable = nn
    solution = soln
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = NEWTON
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 5
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="fdc7dc4b-5858-437d-8774-31cd40c99d09"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_grad_p2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./test_variable_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./test_variable_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./test_variable_x_aux]
    type = FunctionGradAux
    variable = test_variable_x
    dimension_index = x
    function = solution_function
  [../]
  [./test_variable_y_aux]
    type = FunctionGradAux
    variable = test_variable_y
    dimension_index = y
    function = solution_function
  [../]
[]

[UserObjects]
  [./ex_soln]
    type = SolutionUserObject
    system_variables = test_variable
    mesh = solution_function_grad_p1.e
  [../]
[]

[Functions]
  [./solution_function]
    type = SolutionFunction
    solution = ex_soln
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-10
[]

[Outputs]
  file_base = solution_function_grad_p2
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7b6fc226-2f82-4299-afd3-65a8ddf466b6"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/output_error.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmin = 1
  xmax = 4
  ymin = 1
  ymax = 3
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./initial_cond_aux]
    type = SolutionAux
    solution = xda_soln
    execute_on = initial
    variable = u_aux
    direct = false
  [../]
[]

[UserObjects]
  [./xda_soln]
    type = SolutionUserObject
    mesh = build_out_0001_mesh.xda
    es = build_out_0001.xda
    system_variables = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
  xda = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b7c08876-ca32-42b6-be48-7d8576d9fd85"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_direct.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = build_out_0001_mesh.xda
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./initial_cond_aux]
    type = SolutionAux
    solution = soln
    variable = u_aux
    execute_on = initial
    direct = true
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = build_out_0001_mesh.xda
    es = build_out_0001.xda
    system_variables = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a2aa4ed2-6156-4dec-9c16-e74e4f1bd789"><div class="modal-content"><h4>modules/porous_flow/examples/restart/gas_injection_new_mesh.i</h4><pre class="moose-pre"><code class="language-text"># Using the results from the equilibrium run to provide the initial condition for
# porepressure, we now inject a gas phase into the brine-saturated reservoir. In this
# example, the mesh is not identical to the mesh used in gravityeq.i. Rather, it is
# generated so that it is more refined near the injection boundary and at the top of
# the model, as that is where the gas plume will be present.
#
# To use the hydrostatic pressure calculated using the gravity equilibrium run as the initial
# condition for the pressure, a SolutionUserObject is used, along with a SolutionFunction to
# interpolate the pressure from the gravity equilibrium run to the initial condition for liqiud
# porepressure in this example.
#
# Even though the gravity equilibrium is established using a 2D mesh, in this example,
# we use a mesh shifted 0.1 m to the right and rotate it about the Y axis to make a 2D radial
# model.
#
# Methane injection takes place over the surface of the hole created by rotating the mesh,
# and hence the injection area is 2 pi r h. We can calculate this using an AreaPostprocessor,
# and then use this in a ParsedFunction to calculate the injection rate so that 10 kg/s of
# methane is injected.
#
# Note: as this example uses the results from a previous simulation, gravityeq.i MUST be
# run before running this input file.

[Mesh]
  type = GeneratedMesh
  dim = 2
  ny = 25
  nx = 50
  ymax = 100
  xmin = 0.1
  xmax = 5000
  bias_x = 1.05
  bias_y = 0.95
[]

[Problem]
  coord_type = RZ
  rz_coord_axis = Y
[]

[GlobalParams]
  PorousFlowDictator = dictator
  gravity = &#x27;0 -9.81 0&#x27;
  temperature_unit = Celsius
[]

[Variables]
  [./pp_liq]
  [../]
  [./sat_gas]
    initial_condition = 0
  [../]
[]

[ICs]
  [./ppliq_ic]
    type = FunctionIC
    variable = pp_liq
    function = ppliq_ic
  [../]
[]

[AuxVariables]
  [./temperature]
    initial_condition = 50
  [../]
  [./xnacl]
    initial_condition = 0.1
  [../]
  [./brine_density]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./methane_density]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./massfrac_ph0_sp0]
    initial_condition = 1
  [../]
  [./massfrac_ph1_sp0]
    initial_condition = 0
  [../]
  [./pp_gas]
    family = MONOMIAL
    order = CONSTANT
  [../]
  [./sat_liq]
    family = MONOMIAL
    order = CONSTANT
  [../]
[]

[Kernels]
  [./mass0]
    type = PorousFlowMassTimeDerivative
    variable = pp_liq
  [../]
  [./flux0]
    type = PorousFlowAdvectiveFlux
    variable = pp_liq
  [../]
  [./mass1]
    type = PorousFlowMassTimeDerivative
    variable = sat_gas
    fluid_component = 1
  [../]
  [./flux1]
    type = PorousFlowAdvectiveFlux
    variable = sat_gas
    fluid_component = 1
  [../]
[]

[AuxKernels]
  [./brine_density]
    type = PorousFlowPropertyAux
    property = density
    variable = brine_density
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./methane_density]
    type = PorousFlowPropertyAux
    property = density
    variable = methane_density
    phase = 1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./pp_gas]
    type = PorousFlowPropertyAux
    property = pressure
    phase = 1
    variable = pp_gas
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./sat_liq]
    type = PorousFlowPropertyAux
    property = saturation
    variable = sat_liq
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
[]

[BCs]
  [./gas_injection]
    type = PorousFlowSink
    boundary = left
    variable = sat_gas
    flux_function = injection_rate
    fluid_phase = 1
  [../]
  [./brine_out]
    type = PorousFlowPiecewiseLinearSink
    boundary = right
    variable = pp_liq
    multipliers = &#x27;0 1e9&#x27;
    pt_vals = &#x27;0 1e9&#x27;
    fluid_phase = 0
    flux_function = 1e-6
    use_mobility = true
    use_relperm = true
    mass_fraction_component = 0
  [../]
[]

[Functions]
  [./injection_rate]
    type = ParsedFunction
    vals = injection_area
    vars = area
    value = &#x27;-1/area&#x27;
  [../]
  [./ppliq_ic]
    type = SolutionFunction
    solution = soln
  [../]
[]

[UserObjects]
  [./dictator]
    type = PorousFlowDictator
    porous_flow_vars = &#x27;pp_liq sat_gas&#x27;
    number_fluid_phases = 2
    number_fluid_components = 2
  [../]
  [./pc]
    type = PorousFlowCapillaryPressureVG
    alpha = 1e-5
    m = 0.5
    sat_lr = 0.2
    pc_max = 1e7
  [../]
  [./soln]
    type = SolutionUserObject
    mesh = gravityeq_out.e
    system_variables = porepressure
  [../]
[]

[Modules]
  [./FluidProperties]
    [./brine]
      type = BrineFluidProperties
    [../]
    [./methane]
      type = MethaneFluidProperties
    [../]
    [./methane_tab]
      type = TabulatedFluidProperties
      fp = methane
      save_file = false
    [../]
  [../]
[]

[Materials]
  [./temperature]
    type = PorousFlowTemperature
    temperature = temperature
  [../]
  [./ps]
    type = PorousFlow2PhasePS
    phase0_porepressure = pp_liq
    phase1_saturation = sat_gas
    capillary_pressure = pc
  [../]
  [./massfrac]
    type = PorousFlowMassFraction
    mass_fraction_vars = &#x27;massfrac_ph0_sp0 massfrac_ph1_sp0&#x27;
  [../]
  [./brine]
    type = PorousFlowBrine
    compute_enthalpy = false
    compute_internal_energy = false
    xnacl = xnacl
    phase = 0
  [../]
  [./methane]
    type = PorousFlowSingleComponentFluid
    compute_enthalpy = false
    compute_internal_energy = false
    fp = methane_tab
    phase = 1
  [../]
  [./porosity]
    type = PorousFlowPorosityConst
    porosity = 0.1
  [../]
  [./permeability]
    type = PorousFlowPermeabilityConst
    permeability = &#x27;1e-13 0 0 0 5e-14 0  0 0 1e-13&#x27;
  [../]
  [./relperm_liq]
    type = PorousFlowRelativePermeabilityCorey
    n = 2
    phase = 0
    s_res = 0.2
    sum_s_res = 0.3
  [../]
  [./relperm_gas]
    type = PorousFlowRelativePermeabilityCorey
    n = 2
    phase = 1
    s_res = 0.1
    sum_s_res = 0.3
  [../]
[]

[Preconditioning]
  [./smp]
    type = SMP
    full = true
    petsc_options_iname = &#x27;-pc_type -sub_pc_type -sub_pc_factor_shift_type&#x27;
    petsc_options_value = &#x27; asm      lu           NONZERO&#x27;
  [../]
[]

[Executioner]
  type = Transient
  solve_type = Newton
  end_time = 1e8
  nl_abs_tol = 1e-12
  nl_rel_tol = 1e-06
  nl_max_its = 20
  dtmax = 1e6
  [./TimeStepper]
    type = IterationAdaptiveDT
    dt = 1e1
    growth_factor = 1.5
  [../]
[]

[Postprocessors]
  [./mass_ph0]
    type = PorousFlowFluidMass
    fluid_component = 0
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./mass_ph1]
    type = PorousFlowFluidMass
    fluid_component = 1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./injection_area]
    type = AreaPostprocessor
    boundary = left
    execute_on = initial
  [../]
[]

[Outputs]
  execute_on = &#x27;initial timestep_end&#x27;
  exodus = true
  perf_graph = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="82dac2f8-3e19-4cc1-ac07-41c50769ca0e"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_direct.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = cubesource.e
  # The SolutionUserObject uses the copy_nodal_solution() capability
  # of the Exodus reader, and therefore won&#x27;t work if the initial mesh
  # has been renumbered (it will be reunumbered if you are running with
  # DistributedMesh in parallel).  Hence, we restrict this test to run with
  # ReplicatedMesh only.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    solution = soln
    variable = nn
    scale_factor = 2.0
    direct = true
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
    timestep = 2
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="213b893e-ca01-4da2-8732-d38b5ab47b75"><div class="modal-content"><h4>examples/ex14_pps/ex14_compare_solutions_2.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 11
  ny = 11
  xmin = 0.0
  xmax = 1.0
  ymin = 0.0
  ymax = 1.0
[]

[Variables]
  [./forced]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = forced
  [../]

  [./forcing]
    type = BodyForce
    variable = forced
    function = &#x27;x*x+y*y&#x27; # Any object expecting a function name can also receive a ParsedFunction string
  [../]
[]

[BCs]
  [./all]
    type = DirichletBC
    variable = forced
    boundary = &#x27;bottom right top left&#x27;
    value = 0
  [../]
[]

[UserObjects]
  [./fine_solution]
    # Read in the fine grid solution
    type = SolutionUserObject
    system_variables = forced
    mesh = ex14_compare_solutions_1_out_0000_mesh.xda
    es = ex14_compare_solutions_1_out_0000.xda
  [../]
[]

[Functions]
  [./fine_function]
    # Create a Function out of the fine grid solution
    # Note: This references the SolutionUserObject above
    type = SolutionFunction
    solution = fine_solution
  [../]
[]

[Executioner]
  type = Steady

  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;

  [./Quadrature]
    # The integration of the error happens on the coarse mesh
    # To reduce integration error of the finer solution we can
    # raise the integration order.
    # Note: This will slow down the calculation a bit
    order = SIXTH
  [../]
[]

[Postprocessors]
  [./error]
    # Compute the error between the computed solution and the fine-grid solution
    type = ElementL2Error
    variable = forced
    function = fine_function
  [../]
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="42528a56-1710-4027-b14b-02e8a2766dad"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_interp.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = cubesource.e
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    variable = nn
    solution = soln
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="79b30a65-dbc3-432f-b5a6-4e014816b88f"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_rot3.i</h4><pre class="moose-pre"><code class="language-text"># checking rotation of points by 90 deg about z axis, then 45 deg about x axis in a SolutionUserObject
[Mesh]
  # this is chosen so when i rotate through 45deg i get a length of &quot;1&quot; along the x or y or z direction
  type = GeneratedMesh
  dim = 3
  xmin = -0.70710678
  xmax = 0.70710678
  nx = 3
  ymin = -0.70710678
  ymax = 0.70710678
  ny = 3
  zmin = -0.70710678
  zmax = 0.70710678
  nz = 3
[]

[UserObjects]
  [./solution_uo]
    type = SolutionUserObject
    mesh = cube_with_u_equals_x.e
    timestep = 1
    system_variables = u
    # the following takes:
    # (0.7, 0.7, +/-0.7) -&gt; (-0.7, 0.7, +/-0.7)
    # (-0.7, 0.7, +/-0.7) -&gt; (-0.7, -0.7, +/-0.7)
    # (0.7, -0.7, +/-0.7) -&gt; (0.7, 0.7, +/-0.7)
    # (-0.7, -0.7, +/-0.7) -&gt; (0.7, -0.7, +/-0.7)
    rotation0_vector = &#x27;0 0 1&#x27;
    rotation0_angle = 90
    # then the following takes:
    # (+/-0.7, 0.7, 0.7) -&gt; (+/-0.7, 0, 1)
    # (+/-0.7, 0.7, -0.7) -&gt; (+/-0.7, 1, 0)
    # (+/-0.7, -0.7, 0.7) -&gt; (+/-0.7, -1, 0)
    # (+/-0.7, -0.7, -0.7) -&gt; (+/-0.7, 0, -1)
    rotation1_vector = &#x27;1 0 0&#x27;
    rotation1_angle = 45
    # so, in total: a point y = +/-0.7 takes values from x = -/+0.7, so solution_function_rot3 should have u = -y
    transformation_order = &#x27;rotation0 rotation1&#x27;
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./u_init]
    type = FunctionIC
    variable = u
    function = solution_fcn
  [../]
[]

[Functions]
  [./solution_fcn]
    type = SolutionFunction
    from_variable = u
    solution = solution_uo
  [../]
[]

[Kernels]
  [./diff]
    type = TimeDerivative
    variable = u
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 1
  end_time = 1
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = solution_function_rot3
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8fe7c211-02eb-4136-a321-d97ede43d233"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_scale_mult.i</h4><pre class="moose-pre"><code class="language-text"># checking scale_multiplier
[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  nx = 3
  ymin = -1
  ymax = 1
  ny = 3
[]

[UserObjects]
  [./solution_uo]
    type = SolutionUserObject
    mesh = square_with_u_equals_x.e
    timestep = 1
    system_variables = u
    scale_multiplier = &#x27;2 2 0&#x27;
    transformation_order = scale_multiplier
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./u_init]
    type = FunctionIC
    variable = u
    function = solution_fcn
  [../]
[]

[Functions]
  [./solution_fcn]
    type = SolutionFunction
    from_variable = u
    solution = solution_uo
  [../]
[]

[Kernels]
  [./diff]
    type = TimeDerivative
    variable = u
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 1
  end_time = 1
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = solution_function_scale_mult
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="977ad099-8275-4ed3-be53-19096be581a4"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_rot2.i</h4><pre class="moose-pre"><code class="language-text"># checking rotation of points by 45 deg about y axis in a SolutionUserObject
[Mesh]
  # this is chosen so when i rotate through 45deg i get a length of &quot;1&quot; along the x or y or z direction
  type = GeneratedMesh
  dim = 3
  xmin = -0.70710678
  xmax = 0.70710678
  nx = 3
  ymin = -0.70710678
  ymax = 0.70710678
  ny = 3
  zmin = -0.70710678
  zmax = 0.70710678
  nz = 3
[]

[UserObjects]
  [./solution_uo]
    type = SolutionUserObject
    mesh = cube_with_u_equals_x.e
    timestep = 1
    system_variables = u
    rotation0_vector = &#x27;0 1 0&#x27;
    rotation0_angle = 45
    transformation_order = rotation0
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./u_init]
    type = FunctionIC
    variable = u
    function = solution_fcn
  [../]
[]

[Functions]
  [./solution_fcn]
    type = SolutionFunction
    from_variable = u
    solution = solution_uo
  [../]
[]

[Kernels]
  [./diff]
    type = TimeDerivative
    variable = u
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 1
  end_time = 1
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = solution_function_rot2
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="aa9e2740-6227-4599-a35a-3df743d56c55"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/thread_xda.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # This test uses SolutionUserObject which doesn&#x27;t work with ParallelMesh.
  type = GeneratedMesh
  parallel_type = REPLICATED
  dim = 2
  nx = 2
  ny = 2
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./u_xda_func]
    type = SolutionFunction
    solution = xda_u
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 2
  [../]
[]

[UserObjects]
  [./xda_u]
    type = SolutionUserObject
    system = nl0
    mesh = aux_nonlinear_solution_out_0001_mesh.xda
    es = aux_nonlinear_solution_out_0001.xda
    system_variables = u
    execute_on = initial
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  nl_rel_tol = 1e-10
[]

[Postprocessors]
  [./unorm]
    type = ElementL2Norm
    variable = u
  [../]
  [./uerror]
    type = ElementL2Error
    variable = u
    function = u_xda_func
  [../]
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="20df8e7b-51c7-4927-b486-6d0e022a1505"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/aux_nonlinear_solution_xda.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  type = GeneratedMesh
  parallel_type = replicated
  dim = 2
  nx = 2
  ny = 2
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
  [../]
[]

[Functions]
  [./u_xda_func]
    type = SolutionFunction
    solution = xda_u
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./aux_xda_kernel]
    type = SolutionAux
    variable = u_aux
    solution = xda_u_aux
    execute_on = initial
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 2
  [../]
[]

[UserObjects]
  [./xda_u_aux]
    type = SolutionUserObject
    system = aux0
    mesh = aux_nonlinear_solution_out_0001_mesh.xda
    es = aux_nonlinear_solution_out_0001.xda
    system_variables = u_aux
    execute_on = initial
  [../]
  [./xda_u]
    type = SolutionUserObject
    system = nl0
    mesh = aux_nonlinear_solution_out_0001_mesh.xda
    es = aux_nonlinear_solution_out_0001.xda
    system_variables = u
    execute_on = initial
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
[]

[ICs]
  [./u_func_ic]
    function = u_xda_func
    variable = u
    type = FunctionIC
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e498bfe2-ad49-45d4-a5f0-cef4732349be"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_elemental.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cubesource.e
  # The SolutionUserObject uses the copy_nodal_solution() capability
  # of the Exodus reader, and therefore won&#x27;t work if the initial mesh
  # has been renumbered (it will be reunumbered if you are running with
  # DistributedMesh in parallel).  Hence, we restrict this test to run with
  # ReplicatedMesh only.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
  [./en]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    solution = soln
    variable = nn
    scale_factor = 2.0
    from_variable = source_nodal
  [../]
  [./en]
    type = SolutionAux
    solution = soln
    variable = en
    scale_factor = 2.0
    from_variable = source_element
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = &#x27;source_nodal source_element&#x27;
    timestep = 2
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="8cc43600-4c50-4430-bc6a-93b32596c343"><div class="modal-content"><h4>test/tests/auxkernels/solution_scalar_aux/solution_scalar_aux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  type = GeneratedMesh
  dim = 1
  nx = 1
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./a]
    family = SCALAR
    order = FIRST
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxScalarKernels]
  [./a_sk]
    type = SolutionScalarAux
    variable = a
    solution = solution_uo
    from_variable = a
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[UserObjects]
  [./solution_uo]
    type = SolutionUserObject
    mesh = build_out.e
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 2
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 3
  [../]
[]

[Executioner]
  type = Transient
  solve_type = &#x27;NEWTON&#x27;
  nl_rel_tol = 1e-10
  dt = 1
  num_steps = 3
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="af9e022a-033b-45ab-b1be-34489e9d7822"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_exodus_interp_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cubesource.e
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
#  [./ne]
#    order = FIRST
#    family = LAGRANGE
#  [../]
  [./en]
    order = CONSTANT
    family = MONOMIAL
  [../]
#  [./ee]
#    order = CONSTANT
#    family = MONOMIAL
#  [../]
[]

[Functions]
  [./sourcen]
    type = SolutionFunction
    solution = cube_soln
  [../]
#  [./sourcee]
#    type = SolutionFunction
#    file_type = exodusII
#    mesh = cubesource.e
#    variable = source_element
#  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
     type = FunctionAux
     variable = nn
     function = sourcen
  [../]
#  [./ne]
#     type = FunctionAux
#     variable = ne
#     function = sourcee
#  [../]
  [./en]
     type = FunctionAux
     variable = en
     function = sourcen
  [../]
#  [./ee]
#     type = FunctionAux
#     variable = ee
#     function = sourcee
#  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[UserObjects]
  [./cube_soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
  [../]
[]

#[Executioner]
#  type = Steady
#  petsc_options = &#x27;-snes&#x27;
#  l_max_its = 800
#  nl_rel_tol = 1e-10
#[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="472640f6-93f0-4c2c-93ca-b44d68c7ef47"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/aux_nonlinear_solution_xdr.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  type = GeneratedMesh
  parallel_type = replicated
  dim = 2
  nx = 2
  ny = 2
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
  [../]
[]

[Functions]
  [./u_xdr_func]
    type = SolutionFunction
    solution = xdr_u
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./aux_xdr_kernel]
    type = SolutionAux
    variable = u_aux
    solution = xdr_u_aux
    execute_on = initial
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 2
  [../]
[]

[UserObjects]
  [./xdr_u_aux]
    type = SolutionUserObject
    system = aux0
    mesh = aux_nonlinear_solution_xdr_0001_mesh.xdr
    es = aux_nonlinear_solution_xdr_0001.xdr
    execute_on = initial
  [../]
  [./xdr_u]
    type = SolutionUserObject
    system = nl0
    mesh = aux_nonlinear_solution_xdr_0001_mesh.xdr
    es = aux_nonlinear_solution_xdr_0001.xdr
    execute_on = initial
  [../]
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
[]

[ICs]
  [./u_func_ic]
    function = u_xdr_func
    variable = u
    type = FunctionIC
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ac3a1800-34f5-4da3-96d0-b2a6d2e0d3e3"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_test.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = initial_cond_func
    [../]
  [../]
[]

[AuxVariables]
  [./u_aux]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = FunctionIC
      function = initial_cond_func
    [../]
  [../]
[]

[Functions]
  [./initial_cond_func]
    type = SolutionFunction
    solution = ex_soln
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[UserObjects]
  [./ex_soln]
    type = SolutionUserObject
    system_variables = u
    mesh = build_out_0001_mesh.xda
    es = build_out_0001.xda
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10
[]

[Outputs]
  file_base = out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="087f86a4-c633-4fcf-9876-26204f96ee95"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_exodus_interp_direct.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = cubesource.e
  # The SolutionUserObject uses the copy_nodal_solution() capability
  # of the Exodus reader, and therefore won&#x27;t work if the initial mesh
  # has been renumbered (it will be reunumbered if you are running with
  # DistributedMesh in parallel).  Hence, we restrict this test to run with
  # ReplicatedMesh only.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    variable = nn
    solution = soln
    direct = true
    from_variable = source_nodal
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource.e
    system_variables = source_nodal
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;
  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="c622b973-a4f6-4809-8654-4e36ca74a6dc"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_scale.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  xmin = 1
  xmax = 4
  ymin = 1
  ymax = 3
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./initial_cond_aux]
    type = SolutionAux
    solution = xda_soln
    execute_on = initial
    variable = u_aux
  [../]
[]

[UserObjects]
  [./xda_soln]
    type = SolutionUserObject
    mesh = build_out_0001_mesh.xda
    es = build_out_0001.xda
    system_variables = u
    scale = &#x27;3 2 1&#x27;
    translation = &#x27;1 1 0&#x27;
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
  xda = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a2520ae4-04c6-42b1-ae63-e6d2ee391a95"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_rot1.i</h4><pre class="moose-pre"><code class="language-text"># checking rotation of points by 45 deg about z axis in a SolutionUserObject
[Mesh]
  # this is chosen so when i rotate through 45deg i get a length of &quot;1&quot; along the x or y or z direction
  type = GeneratedMesh
  dim = 3
  xmin = -0.70710678
  xmax = 0.70710678
  nx = 3
  ymin = -0.70710678
  ymax = 0.70710678
  ny = 3
  zmin = -0.70710678
  zmax = 0.70710678
  nz = 3
[]

[UserObjects]
  [./solution_uo]
    type = SolutionUserObject
    mesh = cube_with_u_equals_x.e
    timestep = LATEST
    system_variables = u
    rotation0_vector = &#x27;0 0 1&#x27;
    rotation0_angle = 45
    transformation_order = rotation0
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./u_init]
    type = FunctionIC
    variable = u
    function = solution_fcn
  [../]
[]

[Functions]
  [./solution_fcn]
    type = SolutionFunction
    from_variable = u
    solution = solution_uo
  [../]
[]

[Kernels]
  [./diff]
    type = TimeDerivative
    variable = u
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 1
  end_time = 1
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = solution_function_rot1
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="a1b5f39a-478d-4064-ad8d-d9e6e9b06ac5"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux_multi_var.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = cubesource.e
  # The SolutionUserObject uses the copy_nodal_solution() capability
  # of the Exodus reader, and therefore won&#x27;t work if the initial mesh
  # has been renumbered (it will be reunumbered if you are running with
  # DistributedMesh in parallel).  Hence, we restrict this test to run with
  # ReplicatedMesh only.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
    initial_condition = 0.0
  [../]
[]

[AuxVariables]
  [./nn]
    order = FIRST
    family = LAGRANGE
  [../]
  [./en]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./nn]
    type = SolutionAux
    solution = soln
    variable = nn
    scale_factor = 2.0
    from_variable = nodal_10
    add_factor = -20
  [../]
  [./en]
    type = SolutionAux
    solution = soln
    variable = en
    scale_factor = 2.0
    from_variable = source_nodal
  [../]
[]

[UserObjects]
  [./soln]
    type = SolutionUserObject
    mesh = cubesource_added.e
    timestep = 2
  [../]
[]

[BCs]
  [./stuff]
    type = DirichletBC
    variable = u
    boundary = &#x27;1 2&#x27;
    value = 0.0
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 50
  end_time = 5
  dt = 0.5
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="64a5b3ba-75af-4dea-b31a-32f1053c9e15"><div class="modal-content"><h4>test/tests/auxkernels/solution_aux/solution_aux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
  # This test uses SolutionUserObject which doesn&#x27;t work with DistributedMesh.
  parallel_type = replicated
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./u_aux]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[AuxKernels]
  [./initial_cond_aux]
    type = SolutionAux
    solution = xda_soln
    execute_on = initial
    variable = u_aux
  [../]
[]

[UserObjects]
  [./xda_soln]
    type = SolutionUserObject
    mesh = build_out_0001_mesh.xda
    es = build_out_0001.xda
    system_variables = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;

  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
  [./xda]
    type = XDA
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="eb1ea84d-6833-4914-88d3-fc47bb2aae74"><div class="modal-content"><h4>test/tests/functions/solution_function/solution_function_rot4.i</h4><pre class="moose-pre"><code class="language-text"># checking rotation of points by 45 deg about z axis in a SolutionUserObject for a 2D situation
[Mesh]
  # this is chosen so when i rotate through 45deg i get a length of &quot;1&quot; along the x or y direction
  type = GeneratedMesh
  dim = 2
  xmin = -0.70710678
  xmax = 0.70710678
  nx = 3
  ymin = -0.70710678
  ymax = 0.70710678
  ny = 3
[]

[UserObjects]
  [./solution_uo]
    type = SolutionUserObject
    mesh = square_with_u_equals_x.e
    timestep = 1
    system_variables = u
    rotation0_vector = &#x27;0 0 1&#x27;
    rotation0_angle = 45
    transformation_order = rotation0
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[ICs]
  [./u_init]
    type = FunctionIC
    variable = u
    function = solution_fcn
  [../]
[]

[Functions]
  [./solution_fcn]
    type = SolutionFunction
    from_variable = u
    solution = solution_uo
  [../]
[]

[Kernels]
  [./diff]
    type = TimeDerivative
    variable = u
  [../]
[]

[Executioner]
  type = Transient

  solve_type = &#x27;NEWTON&#x27;

  l_max_its = 800
  nl_rel_tol = 1e-10
  num_steps = 1
  end_time = 1
  dt = 1
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  file_base = solution_function_rot4
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#6b4dcc81-0a9d-4e25-8510-224f38a50575" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#eabe60d0-2f28-4b72-ba1c-e3326c0c7e0c" class="tooltipped" data-position="left" data-tooltip="Example Input Syntax">Example Input Syntax</a></li><li><a href="#934a27b0-ba3b-4f2e-8031-38a44b1b5d86" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#9014699a-dcc8-437f-b9b1-dd630e284f0a" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>