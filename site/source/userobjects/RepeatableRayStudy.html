<!DOCTYPE html><head><meta charset="UTF-8"><title>RepeatableRayStudy.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="d6160c69-177f-43be-83f8-0d71b6dc4418"><i class="material-icons">menu</i></a><ul class="sidenav" id="d6160c69-177f-43be-83f8-0d71b6dc4418"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">userobjects</span><a href="#" class="breadcrumb">RepeatableRayStudy</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="f0ae110b-f266-4537-9337-1e98c90cac18" data-section-level="1" data-section-text="RepeatableRayStudy"><h1 id="repeatableraystudy">RepeatableRayStudy</h1><section class="scrollspy" id="055f7b5f-fbca-4eb6-872f-69a5af53443e" data-section-level="2" data-section-text="Description"><h2 id="description">Description</h2><p>The <code>RepeatableRayStudy</code> is a specialized <a href="RayTracingStudy.html">RayTracingStudy</a> that generates rays from a set of user-input start points and end points/directions.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p><p>The <code>RepeatableRayStudy</code> is meant to be the primary <a href="RayTracingStudy.html">RayTracingStudy</a> to be used for the majority of use cases and is not meant to be derived from! It is &quot;repeatable&quot; because it works with adaptivity and multiple executions (transients, on residual/Jacobian evaluations, etc). It does not require the user to have any knowledge of how to generate rays or determine on which processor and element element rays need to start depending on their starting point.</p></p></div></div></div></section><section class="scrollspy" id="d78a3a31-6a38-4e68-9b2c-7ba2fe38a79a" data-section-level="2" data-section-text="Defining the Rays"><h2 id="defining-the-rays">Defining the Rays</h2><p>The following parameters must be set:</p><ul class="browser-default"><li><p><code>names</code>: A list of unique names to identify the rays being generated. </p></li><li><p><code>start_points</code>: A list of points that the rays should start from.</p></li></ul><p>When using <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a> with the <code>RepeatableRayStudy</code>, you must specify which rays the <a href="../../syntax/RayKernels/index.html">RayKernels</a>/<a href="../../syntax/RayBCs/index.html">RayBCs</a> are applied to via their own <code>names</code> parameter. The names supplied to the <a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a> are the same as the names specified in your <code>RepeatableRayStudy</code>.</p><p>After setting these parameters, you must decide if you want to define the remainder of the trajectory by end points or by directions.</p><section id="6bb89ee8-26d5-41a8-b807-41fbe47fce3c" data-section-level="3" data-section-text="Defining By End Points"><h3 id="defining-by-end-points">Defining By End Points</h3><p>To define the remainder of the trajectory by end points, provide the points at which you want the rays to end in the <code>end_points</code> parameter. When the <a href="../ray_tracing/Ray.html">Ray</a> end points are set, internally the tracer will set the max distance of each <a href="../ray_tracing/Ray.html">Ray</a> individually such that they all end at the straight-line distance between the provided start point and the provided end point.</p><p><a href="../../syntax/RayKernels/index.html">RayKernels</a> and <a href="../../syntax/RayBCs/index.html">RayBCs</a> can still kill the rays earlier along their trajectory, but they are guaranteed to end once they hit either their end point or possibly sooner if the study&#x27;s global maximum ray distance (the <code>ray_distance</code> parameter) is less than the distance from the start to end point.</p><p>Rays that are killed due to reaching their max distance (which is the case when they reach their end point) are killed before the execution of <a href="../../syntax/RayBCs/index.html">RayBCs</a>. For example, if a <a href="../ray_tracing/Ray.html">Ray</a> reaches its end point and said end point is on a boundary with <a href="../../syntax/RayBCs/index.html">RayBCs</a>, the <a href="../../syntax/RayBCs/index.html">RayBCs</a> will not be executed on the <a href="../ray_tracing/Ray.html">Ray</a>.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p><p>Rays that have had their trajectory set via end points are not allowed to have their trajectories modified mid-trace via <a href="../../syntax/RayKernels/index.html">RayKernels</a> or <a href="../../syntax/RayBCs/index.html">RayBCs</a>. For example, these rays cannot be reflected on boundaries via the <a href="../ray_bcs/ReflectRayBC.html">ReflectRayBC</a>. You must instead define rays by the <code>directions</code> parameter if you want them to be able to have their trajectories changed mid-trace.</p></p></div></div></div></section><section id="57d0fc3a-a4f6-46f0-9992-c620dcf085cc" data-section-level="3" data-section-text="Defining By Directions"><h3 id="defining-by-directions">Defining By Directions</h3><p>To define the remainder of the trajectory by directions, provide the directions at which you want the rays to travel in the <code>directions</code> parameter. These directions do not need to be normalized.</p><p>When the <a href="../ray_tracing/Ray.html">Ray</a> trajectory is defined by a direction, the user is responsible for killing the <a href="../ray_tracing/Ray.html">Ray</a>. If the <a href="../ray_tracing/Ray.html">Ray</a> hits an external boundary and has not been killed or had its trajectory changed, it will error.</p><p>Common ways of ending a <a href="../ray_tracing/Ray.html">Ray</a> when its trajectory is defined by a direction:</p><ul class="browser-default"><li><p>Killing the <a href="../ray_tracing/Ray.html">Ray</a> on a boundary via <a href="../../syntax/RayBCs/index.html">RayBCs</a> (see <a href="../ray_bcs/KillRayBC.html">KillRayBC</a>). </p></li><li><p>Setting the maximum distance each <a href="../ray_tracing/Ray.html">Ray</a> can travel via the <code>max_distances</code> parameter. </p></li><li><p>Setting the maximum distance all <a href="../ray_tracing/Ray.html">Ray</a>s can travel via the <code>ray_distance</code> parameter. </p></li><li><p>Killing the <a href="../ray_tracing/Ray.html">Ray</a> within an element via <a href="../../syntax/RayKernels/index.html">RayKernels</a> (see <a href="../../syntax/RayKernels/index.html#ending-the-ray">Ending the Ray</a>).</p></li></ul></section></section><section class="scrollspy" id="19b7cf80-1513-46ac-9253-c3e0bfec77b7" data-section-level="2" data-section-text="Setting Ray Data"><h2 id="setting-ray-data">Setting Ray Data</h2><p>For more advanced use, one can also register <a href="../ray_tracing/Ray.html">Ray</a> data/auxiliary data and initialize it as desired. It is important that this is not necessary when using <a href="../../syntax/RayKernels/index.html">RayKernels</a> that contribute to residuals or integrate along lones, as the <a href="../ray_tracing/Ray.html">Ray</a> data mangement in those cases is handled under the hood.</p></section><section class="scrollspy" id="359ba2af-5727-4765-97de-f244ee6b7b5d" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="4ad2d539-f6ef-4d16-a9ae-58b338969a1c" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">names</span><span class="moose-parameter-header-description">Unique names for the Rays</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Unique names for the Rays</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="90c589ac-ac2e-4145-9f6f-170ff2e28093" data-section-level="3" data-section-text="Optional Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">allow_addition_during_execution</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to allow the addition of objects to the buffer during execution</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to allow the addition of objects to the buffer during execution</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">always_cache_traces</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to cache the Ray traces on every execution, primarily for use in output. Warning: this can get expensive very quick with a large number of rays!</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to cache the Ray traces on every execution, primarily for use in output. Warning: this can get expensive very quick with a large number of rays!</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">aux_data_on_cache_traces</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to also cache the Ray's aux data when caching its traces</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to also cache the Ray's aux data when caching its traces</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">buffer_growth_multiplier</span><span class="moose-parameter-header-default">2</span><span class="moose-parameter-header-description">How much to grow a SendBuffer by if the buffer completely fills and dumps.  Will max at send_buffer_size</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>2</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>How much to grow a SendBuffer by if the buffer completely fills and dumps.  Will max at send_buffer_size</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">buffer_shrink_multiplier</span><span class="moose-parameter-header-default">0.5</span><span class="moose-parameter-header-description">Multiplier (between 0 and 1) to apply to the current buffer size if it is force dumped.  Will stop at min_buffer_size.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0.5</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Multiplier (between 0 and 1) to apply to the current buffer size if it is force dumped.  Will stop at min_buffer_size.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">chunk_size</span><span class="moose-parameter-header-default">100</span><span class="moose-parameter-header-description">The number of objects to process at one time during execution</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>100</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The number of objects to process at one time during execution</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">clicks_per_communication</span><span class="moose-parameter-header-default">10</span><span class="moose-parameter-header-description">Iterations to wait before communicating</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>10</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Iterations to wait before communicating</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">clicks_per_receive</span><span class="moose-parameter-header-default">1</span><span class="moose-parameter-header-description">Iterations to wait before checking for new objects</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Iterations to wait before checking for new objects</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">clicks_per_root_communication</span><span class="moose-parameter-header-default">10</span><span class="moose-parameter-header-description">Iterations to wait before communicating with root</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>10</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Iterations to wait before communicating with root</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">data_on_cache_traces</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to also cache the Ray's data when caching its traces</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to also cache the Ray's data when caching its traces</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">execute_on</span><span class="moose-parameter-header-default">TIMESTEP_END</span><span class="moose-parameter-header-description">The list of flag(s) indicating when this object should be executed, the available options include NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, FINAL, CUSTOM.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>TIMESTEP_END</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>ExecFlagEnum</p><p class="moose-parameter-description-options"><span>Options:</span>NONE INITIAL LINEAR NONLINEAR TIMESTEP_END TIMESTEP_BEGIN FINAL CUSTOM PRE_KERNELS</p><p class="moose-parameter-description"><span>Description:</span>The list of flag(s) indicating when this object should be executed, the available options include NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, FINAL, CUSTOM.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">method</span><span class="moose-parameter-header-default">smart</span><span class="moose-parameter-header-description">The algorithm to use</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>smart</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>smart harm bs</p><p class="moose-parameter-description"><span>Description:</span>The algorithm to use</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">min_buffer_size</span><span class="moose-parameter-header-description">The initial size of the SendBuffer and the floor for shrinking it.  This defaults to send_buffer_size if not set (i.e. the buffer won't change size)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The initial size of the SendBuffer and the floor for shrinking it.  This defaults to send_buffer_size if not set (i.e. the buffer won't change size)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">planar_face_check</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether or not to check and warn if any element's faces are not planar</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to check and warn if any element's faces are not planar</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ray_distance</span><span class="moose-parameter-header-default">1.79769e+308</span><span class="moose-parameter-header-description">The maximum distance a Ray can travel</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1.79769e+308</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The maximum distance a Ray can travel</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ray_kernel_coverage_check</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether or not to perform coverage checks on RayKernels</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to perform coverage checks on RayKernels</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">segments_on_cache_traces</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether or not to cache individual segments when trace caching is enabled. If false, we will instead cache a segment for each part of the trace where the direction is the same. This minimizes the number of segments requied to represent the Ray's path, but removes the ability to show Ray field data on each segment through an element.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to cache individual segments when trace caching is enabled. If false, we will instead cache a segment for each part of the trace where the direction is the same. This minimizes the number of segments requied to represent the Ray's path, but removes the ability to show Ray field data on each segment through an element.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">send_buffer_size</span><span class="moose-parameter-header-default">100</span><span class="moose-parameter-header-description">The size of the send buffer</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>100</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The size of the send buffer</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">tolerate_failure</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to tolerate a ray tracing failure</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to tolerate a ray tracing failure</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_internal_sidesets</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not to use internal sidesets for RayBCs in ray tracing</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to use internal sidesets for RayBCs in ray tracing</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">verify_rays</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether or not to verify if Rays have valid information in optmized modes before being traced. All Rays are verified outside of optimized modes regardless of this parameter.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to verify if Rays have valid information in optmized modes before being traced. All Rays are verified outside of optimized modes regardless of this parameter.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">warn_subdomain_hmax</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Whether or not to warn if the approximated hmax (constant on subdomain) varies significantly for an element</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not to warn if the approximated hmax (constant on subdomain) varies significantly for an element</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">work_buffer_type</span><span class="moose-parameter-header-default">circular</span><span class="moose-parameter-header-description">The work buffer type to use</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>circular</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>lifo circular</p><p class="moose-parameter-description"><span>Description:</span>The work buffer type to use</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="78fd0fc2-f2b5-4cd6-b2e1-b70820fb1caf" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">allow_duplicate_execution_on_initial</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_preaux</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the GeneralUserObject to be executed in PREAUX</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Forces the GeneralUserObject to be executed in PREAUX</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_preic</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the GeneralUserObject to be executed in PREIC during initial setup</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Forces the GeneralUserObject to be executed in PREIC during initial setup</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="1200ba23-6c44-491f-b77e-a0fc3bd8d242" data-section-level="3" data-section-text="Trajectory Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">directions</span><span class="moose-parameter-header-description">The directions to spawn Rays in (they do not need to be normalized to 1). Use either this parameter or the end_points parameter, but not both!</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<libMesh::Point></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The directions to spawn Rays in (they do not need to be normalized to 1). Use either this parameter or the end_points parameter, but not both!</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">end_points</span><span class="moose-parameter-header-description">The points where Rays should end. Use either this parameter or the directions parameter, but not both!</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<libMesh::Point></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The points where Rays should end. Use either this parameter or the directions parameter, but not both!</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">max_distances</span><span class="moose-parameter-header-description">The maximum distances that each Ray can travel before it is killed internally after RayKernel execution. This can ONLY be used when the 'directions' parameter is used. When this not set, the Rays must be killed by RayKernels, RayBCs, or the global  max distance parameter, 'ray_max_distance' (applies to all Rays)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The maximum distances that each Ray can travel before it is killed internally after RayKernel execution. This can ONLY be used when the 'directions' parameter is used. When this not set, the Rays must be killed by RayKernels, RayBCs, or the global  max distance parameter, 'ray_max_distance' (applies to all Rays)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">start_points</span><span class="moose-parameter-header-description">The points to start Rays from</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<libMesh::Point></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The points to start Rays from</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Trajectory Parameters</h3></summary></details></section><section id="935d9f91-f109-487d-99e0-d793eb48c2f4" data-section-level="3" data-section-text="Data Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">initial_ray_aux_data</span><span class="moose-parameter-header-description">The initial Ray aux data to set. This must be paired with 'ray_aux_data_names' to know what aux data names to assign the data to</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The initial Ray aux data to set. This must be paired with 'ray_aux_data_names' to know what aux data names to assign the data to</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">initial_ray_data</span><span class="moose-parameter-header-description">The initial Ray data to set. This must be paired with 'ray_data_names' to know what data names to assign the data to</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<double></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The initial Ray data to set. This must be paired with 'ray_data_names' to know what data names to assign the data to</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ray_aux_data_names</span><span class="moose-parameter-header-description">The Ray aux data names to register. If 'initial_ray_aux_data' is set, these aux data names will be associated with said initial values. Otherwise, they will be set to zero.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The Ray aux data names to register. If 'initial_ray_aux_data' is set, these aux data names will be associated with said initial values. Otherwise, they will be set to zero.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ray_data_names</span><span class="moose-parameter-header-description">The Ray data names to register. If 'initial_ray_data' is set, these data names will be associated with said initial values. Otherwise, they will be set to zero.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description-options"><span>Options:</span></p><p class="moose-parameter-description"><span>Description:</span>The Ray data names to register. If 'initial_ray_data' is set, these data names will be associated with said initial values. Otherwise, they will be set to zero.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Data Parameters</h3></summary></details></section></section><section class="scrollspy" id="181026e5-f0ac-40f5-ae03-272b33c20e6e" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a href="#37b3fdd4-a0ca-48df-88a9-f21f13edd144" class="modal-trigger">modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_1d.i</a></li><li><a href="#b1774d04-7bb8-4c4f-9cbd-57e94d068d33" class="modal-trigger">modules/ray_tracing/test/tests/userobjects/repeatable_ray_study/max_distance.i</a></li><li><a href="#9d8c55b8-4d1c-4395-90e4-c026821a3a45" class="modal-trigger">modules/ray_tracing/test/tests/ray_kernels/variable_integral_ray_kernel/variable_integral_ray_kernel.i</a></li><li><a href="#099c29e4-9a0d-4a54-b342-34fbafcbb8e4" class="modal-trigger">modules/ray_tracing/test/tests/ray_kernels/line_source_ray_kernel/simple_diffusion_line_source.i</a></li><li><a href="#9061a740-2f7c-42fa-8da0-d26ab9f85b25" class="modal-trigger">modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_3d.i</a></li><li><a href="#bcdac2eb-dd79-4474-92df-835ec3559c10" class="modal-trigger">modules/ray_tracing/test/tests/coord_type/rspherical_line_integral.i</a></li><li><a href="#b2fa88e6-e5f5-4a75-a715-67697eeb7da5" class="modal-trigger">modules/ray_tracing/test/tests/ray_kernels/material_integral_ray_kernel/material_integral_ray_kernel.i</a></li><li><a href="#df243ba3-d22b-4a64-af7e-dd9557509c6c" class="modal-trigger">modules/ray_tracing/test/tests/outputs/ray_tracing_mesh_output/ray_mesh_output_data.i</a></li><li><a href="#d903554f-4bef-4baa-9cd8-4998af53a4f7" class="modal-trigger">modules/ray_tracing/test/tests/ray_kernels/variable_integral_ray_kernel/simple_diffusion_line_integral.i</a></li><li><a href="#83c37c6b-dac4-42e9-a8d7-980efff86220" class="modal-trigger">modules/ray_tracing/test/tests/coord_type/rz_line_integral.i</a></li><li><a href="#af62eca6-0432-4e52-a507-b2b0a8eebbab" class="modal-trigger">modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_2d.i</a></li><li><a href="#3599f717-fc32-41b1-858e-c69d71ef6db6" class="modal-trigger">modules/ray_tracing/test/tests/outputs/ray_tracing_mesh_output/ray_mesh_output.i</a></li><li><a href="#ab3e976e-5dd8-4d83-942a-cd7a4c3d549c" class="modal-trigger">modules/ray_tracing/test/tests/postprocessors/ray_data_value/ray_data_value.i</a></li><li><a href="#82107122-353b-4fc4-bc01-40153e48aaf5" class="modal-trigger">modules/ray_tracing/test/tests/ray_kernels/function_integral_ray_kernel/function_integral_ray_kernel.i</a></li><li><a href="#e2f9527e-5d95-42d6-a46c-99bb1cdac8ec" class="modal-trigger">modules/ray_tracing/test/tests/ray_kernels/line_source_ray_kernel/line_source_ray_kernel.i</a></li><li><a href="#12faf04d-a005-4bcd-8131-89cbd0252609" class="modal-trigger">modules/ray_tracing/test/tests/outputs/ray_tracing_mesh_output/ray_mesh_output_3d.i</a></li><li><a href="#7f9bb69b-e8fd-4c35-84d9-c5a49b4face7" class="modal-trigger">modules/ray_tracing/test/tests/ray_kernels/coupled_line_source_ray_kernel/coupled_line_source_ray_kernel.i</a></li></ul><div class="modal moose-modal" id="37b3fdd4-a0ca-48df-88a9-f21f13edd144"><div class="modal-content"><h4>modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_1d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 1
    xmax = 6
    nx = 6
  []

  [central_block]
    type = SubdomainBoundingBoxGenerator
    input = gmg
    block_id = 1
    bottom_left = &#x27;2 0 0&#x27;
    top_right = &#x27;4 0 0&#x27;
  []

  [central_boundary]
    type = SideSetsBetweenSubdomainsGenerator
    input = central_block
    master_block = 1
    paired_block = 0
    new_boundary = 7
  []
[]

[RayBCs]
  active = &#x27;kill_internal&#x27;
  # active = &#x27;kill_external reflect_internal&#x27;

  # for testing internal kill
  [kill_internal]
    type = KillRayBC
    boundary = 7
    rays = &#x27;left_in at_left right_in at_right inside_left&#x27;
  []

  # for testing internal reflect
  [kill_external]
    type = KillRayBC
    boundary = &#x27;left right&#x27;
    rays = &#x27;left_in at_left right_in at_right inside_left&#x27;
  []
  [reflect_internal]
    type = ReflectRayBC
    boundary = 7
    rays = &#x27;left_in at_left right_in at_right inside_left&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  2 0 0
                  6 0 0
                  4 0 0
                  3 0 0&#x27;
  directions = &#x27;1 0 0
                1 0 0
                -1 0 0
                -1 0 0
                -1 0 0&#x27;
  names = &#x27;left_in at_left right_in at_right inside_left&#x27;
  ray_distance = 10
  execute_on = initial
  ray_kernel_coverage_check = false
  use_internal_sidesets = true
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  study = study
  result = total_distance
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b1774d04-7bb8-4c4f-9cbd-57e94d068d33"><div class="modal-content"><h4>modules/ray_tracing/test/tests/userobjects/repeatable_ray_study/max_distance.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
[]

# to_right_distance_kill - makes it to the right boundary at (5, 0)
#   and dies due to max distance (doesn&#x27;t call RayBCs)
# to_right_bc_kill - makes it to right boundary at (5, 0); is still
#   0.1 from its max distance so calls &#x27;kill_right&#x27; RayBC which
#   kills it
# to_top_corner - makes it to the top right corner at (5, 5);
#   reflects with direction (-1, -1) and stops once its distance
#   hits 7.0
# reflect_a_lot - reflects a bunch with the RayBC &#x27;reflect_all&#x27;
#   until it gets to a distance of 50 and dies
[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  0 0 0
                  0 0 0
                  0.1 0.2 0&#x27;
  directions = &#x27;1 0 0
                1 0 0
                1 1 0
                1 0.5 0&#x27;
  max_distances = &#x27;5
                   5.1
                   7.0
                   50&#x27;
  names = &#x27;to_right_distance_kill
           to_right_bc_kill
           to_top_corner
           reflect_a_lot&#x27;
[]

[RayKernels/null]
  type = NullRayKernel
  rays = &#x27;to_right_distance_kill
          to_right_bc_kill
          to_top_corner
          reflect_a_lot&#x27;
[]

[RayBCs]
  [kill_right]
    type = KillRayBC
    boundary = right
    rays = &#x27;to_right_bc_kill&#x27;
  []
  [reflect_top_right]
    type = ReflectRayBC
    boundary = &#x27;top right&#x27;
    rays = &#x27;to_top_corner&#x27;
  []
  [reflect_all]
    type = ReflectRayBC
    boundary = &#x27;top right bottom left&#x27;
    rays = &#x27;reflect_a_lot&#x27;
  []
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  result = &#x27;total_distance&#x27;
  study = study
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9d8c55b8-4d1c-4395-90e4-c026821a3a45"><div class="modal-content"><h4>modules/ray_tracing/test/tests/ray_kernels/variable_integral_ray_kernel/variable_integral_ray_kernel.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
[]

[Variables/u]
  [InitialCondition]
    type = FunctionIC
    variable = u
    function = &#x27;(x &lt; 2) * (x + 2 * y) + (x &gt;= 2) * (2 * x + 2 * y - 2)&#x27;
  []
[]

[AuxVariables/aux]
  order = CONSTANT
  family = MONOMIAL
  [InitialCondition]
    type = FunctionIC
    variable = u_ag
    function = &#x27;x + y + cos(x)&#x27;
  []
[]


[UserObjects]
  [study]
    type = RepeatableRayStudy
    names = &#x27;diag
             top_across
             bottom_across
             partial&#x27;
    start_points = &#x27;0 0 0
                    0 5 0
                    0 0 0
                    0.5 0.5 0&#x27;
    end_points = &#x27;5 5 0
                  5 5 0
                  5 0 0
                  4.5 0.5 0&#x27;
  []
[]

[RayKernels]
  [variable_integral]
    type = VariableIntegralRayKernel
    study = study
    variable = u
    rays = &#x27;diag top_across bottom_across partial&#x27;
  []
  [aux_variable_integral]
    type = VariableIntegralRayKernel
    study = study
    variable = aux
    rays = &#x27;diag top_across bottom_across partial&#x27;
  []
[]

[Postprocessors]
  [diag_value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = diag
  []
  [top_across_value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = top_across
  []
  [bottom_across_value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = bottom_across
  []
  [partial_value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = partial
  []

  [aux_diag_value]
    type = RayIntegralValue
    ray_kernel = aux_variable_integral
    ray = diag
  []
  [aux_top_across_value]
    type = RayIntegralValue
    ray_kernel = aux_variable_integral
    ray = top_across
  []
  [aux_bottom_across_value]
    type = RayIntegralValue
    ray_kernel = aux_variable_integral
    ray = bottom_across
  []
  [aux_partial_value]
    type = RayIntegralValue
    ray_kernel = aux_variable_integral
    ray = partial
  []
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="099c29e4-9a0d-4a54-b342-34fbafcbb8e4"><div class="modal-content"><h4>modules/ray_tracing/test/tests/ray_kernels/line_source_ray_kernel/simple_diffusion_line_source.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 10
    ny = 10
    xmax = 5
    ymax = 5
  []
[]

[Variables/u]
[]

[Kernels/diff]
  type = Diffusion
  variable = u
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]

[UserObjects/study]
  type = RepeatableRayStudy
  names = &#x27;line_source_ray&#x27;
  start_points = &#x27;1 1 0&#x27;
  end_points = &#x27;5 2 0&#x27;
  execute_on = PRE_KERNELS # must be set for line sources!
[]

[RayKernels/line_source]
  type = LineSourceRayKernel
  variable = u
  value = 5
  rays = &#x27;line_source_ray&#x27;
[]

# This isn&#x27;t used in the test but can be enabled
# for pretty pictures as is used in an example!
[Adaptivity]
  steps = 0 # 5
  marker = marker
  initial_marker = marker
  max_h_level = 5
  [Indicators/indicator]
    type = GradientJumpIndicator
    variable = u
  []
  [Markers/marker]
    type = ErrorFractionMarker
    indicator = indicator
    coarsen = 0.1
    refine = 0.5
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="9061a740-2f7c-42fa-8da0-d26ab9f85b25"><div class="modal-content"><h4>modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [cmg]
    type = CartesianMeshGenerator
    dim = 3
    dx = &#x27;2 2 2&#x27;
    dy = &#x27;2 2 2&#x27;
    dz = &#x27;2 2 2&#x27;
    ix = &#x27;2 2 2&#x27;
    iy = &#x27;2 2 2&#x27;
    iz = &#x27;2 2 2&#x27;
    subdomain_id = &#x27;0 0 0
                    0 1 0
                    0 0 0

                    0 2 0
                    3 7 4
                    0 5 0

                    0 0 0
                    0 6 0
                    0 0 0&#x27;
  []

  [interior_back]
    type = SideSetsBetweenSubdomainsGenerator
    input = cmg
    master_block = 7
    paired_block = 1
    new_boundary = &#x27;interior_back&#x27;
  []
  [interior_bottom]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_back
    master_block = 7
    paired_block = 2
    new_boundary = &#x27;interior_bottom&#x27;
  []
  [interior_left]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_bottom
    master_block = 7
    paired_block = 3
    new_boundary = &#x27;interior_left&#x27;
  []
  [interior_right]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_left
    master_block = 7
    paired_block = 4
    new_boundary = &#x27;interior_right&#x27;
  []
  [interior_top]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_right
    master_block = 7
    paired_block = 5
    new_boundary = &#x27;interior_top&#x27;
  []
  [interior_front]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_top
    master_block = 7
    paired_block = 6
    new_boundary = &#x27;interior_front&#x27;
  []
[]

[RayBCs]
  active = &#x27;kill_internal&#x27;
  # active = &#x27;kill_external reflect_internal&#x27;

  # for testing internal kill
  [kill_internal]
    type = KillRayBC
    boundary = &#x27;interior_top interior_right interior_bottom interior_left interior_front interior_back&#x27;
    rays = &#x27;to_bottom_left_corner
            at_bottom_left_corner
            to_top_right_corner
            at_top_right_corner
            centroid_offset
            top_down
            left_to_edge
            inside_to_corner
            inside_offset&#x27;
  []

  # for testing internal reflect
  [kill_external]
    type = KillRayBC
    boundary = &#x27;top right bottom left front back&#x27;
    rays = &#x27;to_bottom_left_corner
            at_bottom_left_corner
            to_top_right_corner
            at_top_right_corner
            centroid_offset
            top_down
            left_to_edge
            inside_to_corner
            inside_offset&#x27;
  []
  [reflect_internal]
    type = ReflectRayBC
    boundary = &#x27;interior_top interior_right interior_bottom interior_left interior_front interior_back&#x27;
    rays = &#x27;to_bottom_left_corner
            at_bottom_left_corner
            to_top_right_corner
            at_top_right_corner
            centroid_offset
            top_down
            left_to_edge
            inside_to_corner
            inside_offset&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  2 2 2
                  6 6 6
                  4 4 4
                  0 2.5 2.5
                  3 3 6
                  2.5 0 0
                  3 3 3
                  2.5 2.5 2.5&#x27;
  directions = &#x27;1 1 1
                1 1 1
                -1 -1 -1
                -1 -1 -1
                1 0.1 0
                0 0 -1
                0 1 1
                1 1 1
                0.5 1.5 1.5&#x27;
  names = &#x27;to_bottom_left_corner
           at_bottom_left_corner
           to_top_right_corner
           at_top_right_corner
           centroid_offset
           top_down
           left_to_edge
           inside_to_corner
           inside_offset&#x27;
  execute_on = initial
  ray_distance = 10
  ray_kernel_coverage_check = false
  use_internal_sidesets = true
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  study = study
  result = total_distance
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="bcdac2eb-dd79-4474-92df-835ec3559c10"><div class="modal-content"><h4>modules/ray_tracing/test/tests/coord_type/rspherical_line_integral.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 1
    nx = 5
  []
[]

[Variables/u]
[]

[BCs]
  [fixed]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Kernels]
  [diffusion]
    type = Diffusion
    variable = u
  []
  [source]
    type = BodyForce
    variable = u
    value = 10
  []
[]

[UserObjects]
  [study]
    type = RepeatableRayStudy
    names = &#x27;ray0&#x27;
    start_points = &#x27;0 0 0&#x27;
    end_points = &#x27;1 0 0&#x27;
  []
[]

[RayKernels]
  [variable_integral]
    type = VariableIntegralRayKernel
    study = study
    variable = u
    rays = &#x27;ray0&#x27;
  []
[]

[Postprocessors]
  [value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = ray0
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Problem]
  coord_type = RSPHERICAL
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="b2fa88e6-e5f5-4a75-a715-67697eeb7da5"><div class="modal-content"><h4>modules/ray_tracing/test/tests/ray_kernels/material_integral_ray_kernel/material_integral_ray_kernel.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
  [modify_subdomain]
    type = ParsedSubdomainMeshGenerator
    input = gmg
    block_id = 1
    combinatorial_geometry = &#x27;x &gt; 2&#x27;
  []
[]

[Materials]
  [generic_mat_block0]
    type = GenericFunctionMaterial
    block = 0
    prop_names = &#x27;mat&#x27;
    prop_values = &#x27;parsed_block0&#x27;
  []
  [generic_mat_block1]
    type = GenericFunctionMaterial
    block = 1
    prop_names = &#x27;mat&#x27;
    prop_values = &#x27;parsed_block1&#x27;
  []
[]

[Functions]
  [parsed_block0]
    type = ParsedFunction
    value = &#x27;x + 2 * y&#x27;
  []
  [parsed_block1] # continuous at the interface
    type = ParsedFunction
    value = &#x27;2 * x + 2 * y - 2&#x27;
  []
[]

[UserObjects]
  [study]
    type = RepeatableRayStudy
    names = &#x27;diag
             top_across
             bottom_across
             partial&#x27;
    start_points = &#x27;0 0 0
                    0 5 0
                    0 0 0
                    0.5 0.5 0&#x27;
    end_points = &#x27;5 5 0
                  5 5 0
                  5 0 0
                  4.5 0.5 0&#x27;
  []
[]

[RayKernels]
  [material_integral]
    type = MaterialIntegralRayKernel
    study = study
    mat_prop = mat
    rays = &#x27;diag top_across bottom_across partial&#x27;
  []
[]

[Postprocessors]
  [diag_value]
    type = RayIntegralValue
    ray_kernel = material_integral
    ray = diag
  []
  [top_across_value]
    type = RayIntegralValue
    ray_kernel = material_integral
    ray = top_across
  []
  [bottom_across_value]
    type = RayIntegralValue
    ray_kernel = material_integral
    ray = bottom_across
  []
  [partial_value]
    type = RayIntegralValue
    ray_kernel = material_integral
    ray = partial
  []
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="df243ba3-d22b-4a64-af7e-dd9557509c6c"><div class="modal-content"><h4>modules/ray_tracing/test/tests/outputs/ray_tracing_mesh_output/ray_mesh_output_data.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
[]

[Variables/u]
  [InitialCondition]
    type = FunctionIC
    variable = u
    function = &#x27;(x &lt; 2) * (x + 2 * y) + (x &gt;= 2) * (2 * x + 2 * y - 2)&#x27;
  []
[]

[UserObjects]
  [study]
    type = RepeatableRayStudy
    names = &#x27;diag
             top_across
             bottom_across
             partial&#x27;
    start_points = &#x27;0 0 0
                    0 5 0
                    0 0 0
                    0.5 0.5 0&#x27;
    end_points = &#x27;5 5 0
                  5 5 0
                  5 0 0
                  4.5 0.5 0&#x27;
    always_cache_traces = true
    data_on_cache_traces = true
  []
[]

[RayKernels]
  [variable_integral]
    type = VariableIntegralRayKernel
    study = study
    variable = u
    rays = &#x27;diag top_across bottom_across partial&#x27;
  []
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = true
  [rays]
    type = RayTracingExodus
    study = study
    output_data = true
    execute_on = final
  []
  [rays_nodal]
    type = RayTracingExodus
    study = study
    output_data_nodal = true
    execute_on = final
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="d903554f-4bef-4baa-9cd8-4998af53a4f7"><div class="modal-content"><h4>modules/ray_tracing/test/tests/ray_kernels/variable_integral_ray_kernel/simple_diffusion_line_integral.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
[]

[Variables/u]
[]

[Kernels/diff]
  type = Diffusion
  variable = u
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = false
  csv = true
[]

[UserObjects/study]
  type = RepeatableRayStudy
  names = &#x27;diag
           right_up&#x27;
  start_points = &#x27;0 0 0
                  5 0 0&#x27;
  end_points = &#x27;5 5 0
                5 5 0&#x27;
  execute_on = TIMESTEP_END
[]

[RayKernels/u_integral]
  type = VariableIntegralRayKernel
  variable = u
  rays = &#x27;diag right_up&#x27;
[]

[Postprocessors]
  [diag_line_integral]
    type = RayIntegralValue
    ray_kernel = u_integral
    ray = diag
  []
  [right_up_line_integral]
    type = RayIntegralValue
    ray_kernel = u_integral
    ray = right_up
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="83c37c6b-dac4-42e9-a8d7-980efff86220"><div class="modal-content"><h4>modules/ray_tracing/test/tests/coord_type/rz_line_integral.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 2
    xmin = 0
    xmax = 2
    ymin = 0
    ymax = 1
  []
[]

[Variables/u]
[]

[BCs]
  [fixed]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Kernels]
  [diffusion]
    type = Diffusion
    variable = u
  []
  [source]
    type = BodyForce
    variable = u
    value = 10
  []
[]

[UserObjects]
  [study]
    type = RepeatableRayStudy
    names = &#x27;ray0 ray1&#x27;
    start_points = &#x27;0 0.5 0
                    0 0.1 0&#x27;
    end_points = &#x27;2.0 0.5 0
                  2.0 0.9 0&#x27;
  []
[]

[RayKernels]
  [variable_integral]
    type = VariableIntegralRayKernel
    study = study
    variable = u
    rays = &#x27;ray0 ray1&#x27;
  []
[]

[Postprocessors]
  [ray0_value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = ray0
  []
  [ray1_value]
    type = RayIntegralValue
    ray_kernel = variable_integral
    ray = ray1
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Problem]
  coord_type = RZ
[]

[Outputs]
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="af62eca6-0432-4e52-a507-b2b0a8eebbab"><div class="modal-content"><h4>modules/ray_tracing/test/tests/trace_ray/internal_sidesets/internal_sidesets_2d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [cmg]
    type = CartesianMeshGenerator
    dim = 2
    dx = &#x27;2 2 2&#x27;
    dy = &#x27;2 2 2&#x27;
    ix = &#x27;2 2 2&#x27;
    iy = &#x27;2 2 2&#x27;
    subdomain_id = &#x27;0 1 0
                    2 5 3
                    0 4 0&#x27;
  []

  [interior_bottom]
    type = SideSetsBetweenSubdomainsGenerator
    input = cmg
    master_block = 5
    paired_block = 1
    new_boundary = &#x27;interior_bottom&#x27;
  []
  [interior_left]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_bottom
    master_block = 5
    paired_block = 2
    new_boundary = &#x27;interior_left&#x27;
  []
  [interior_right]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_left
    master_block = 5
    paired_block = 3
    new_boundary = &#x27;interior_right&#x27;
  []
  [interior_top]
    type = SideSetsBetweenSubdomainsGenerator
    input = interior_right
    master_block = 5
    paired_block = 4
    new_boundary = &#x27;interior_top&#x27;
  []
[]

[RayBCs]
  active = &#x27;kill_internal&#x27;
  # active = &#x27;kill_external reflect_internal&#x27;

  # for testing internal kill
  [kill_internal]
    type = KillRayBC
    boundary = &#x27;interior_top interior_right interior_bottom interior_left&#x27;
    rays = &#x27;to_bottom_left_corner
            at_top_left_corner
            to_top_right_corner
            to_left_offset
            to_top_center_node
            inside_to_top&#x27;
  []

  # for testing internal reflect
  [kill_external]
    type = KillRayBC
    boundary = &#x27;top right bottom left&#x27;
    rays = &#x27;to_bottom_left_corner
            at_top_left_corner
            to_top_right_corner
            to_left_offset
            to_top_center_node
            inside_to_top&#x27;
  []
  [reflect_internal]
    type = ReflectRayBC
    boundary = &#x27;interior_top interior_right interior_bottom interior_left&#x27;
    rays = &#x27;to_bottom_left_corner
            at_top_left_corner
            to_top_right_corner
            to_left_offset
            to_top_center_node
            inside_to_top&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  2 4 0
                  6 6 0
                  0 2.5 0
                  3 6 0
                  2.5 2.5 0&#x27;
  directions = &#x27;1 1 0
                1 -1 0
                -1 -1 0
                1 0.1 0
                0 -1 0
                0.5 1.5 0&#x27;
  names = &#x27;to_bottom_left_corner
           at_top_left_corner
           to_top_right_corner
           to_left_offset
           to_top_center_node
           inside_to_top&#x27;
  ray_distance = 10
  execute_on = initial
  ray_kernel_coverage_check = false
  use_internal_sidesets = true
[]

[Postprocessors/total_distance]
  type = RayTracingStudyResult
  study = study
  result = total_distance
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="3599f717-fc32-41b1-858e-c69d71ef6db6"><div class="modal-content"><h4>modules/ray_tracing/test/tests/outputs/ray_tracing_mesh_output/ray_mesh_output.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
    elem_type = QUAD4
  []

  [middle_block]
    type = SubdomainBoundingBoxGenerator
    input = gmg
    block_id = 1
    bottom_left = &#x27;2 0 0&#x27;
    top_right = &#x27;3 5 0&#x27;
  []

  [middle_block_sideset]
    type = SideSetsBetweenSubdomainsGenerator
    input = middle_block
    master_block = 1
    paired_block = 0
    new_boundary = 7
  []
[]

[RayBCs]
  [kill_top_right]
    type = &#x27;KillRayBC&#x27;
    boundary = &#x27;top right&#x27;
    rays = &#x27;to_top_right
            centroid_left_to_right
            along_top&#x27;
  []
  [kill_bottom_left]
    type = &#x27;KillRayBC&#x27;
    boundary = &#x27;left bottom&#x27;
    rays = &#x27;reflect_right_and_top
            reflect_right_at_node
            reflect_internal&#x27;
  []
  [reflect]
    type = &#x27;ReflectRayBC&#x27;
    boundary = &#x27;top right&#x27;
    rays = &#x27;reflect_right_and_top
            reflect_right_at_node&#x27;
  []
  [reflect_internal]
    type = &#x27;ReflectRayBC&#x27;
    boundary = 7
    rays = &#x27;reflect_internal&#x27;
  []
  [kill_internal]
    type = &#x27;KillRayBC&#x27;
    boundary = 7
    rays = &#x27;kill_internal&#x27;
  []
  [nothing_internal]
    type = &#x27;NullRayBC&#x27;
    boundary = 7
    rays = &#x27;to_top_right
            centroid_left_to_right
            along_top
            reflect_right_and_top
            reflect_right_at_node&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  ray_kernel_coverage_check = false
  start_points = &#x27;0 0 0
                  0.5 2.6 0
                  0 5 0
                  0 0.23 0
                  3 0 0
                  0 2.25 0
                  4.8 0.2 0&#x27;
  directions = &#x27;1 1 0
                1 0 0
                1 0 0
                1 0.6 0
                1 0.5 0
                1 0.58 0
                -1 0.2 0&#x27;
  names = &#x27;to_top_right
           centroid_left_to_right
           along_top
           reflect_right_and_top
           reflect_right_at_node
           reflect_internal
           kill_internal&#x27;
  execute_on = initial
  always_cache_traces = true
  use_internal_sidesets = true
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  [rays]
    type = RayTracingExodus
    study = study
    execute_on = final
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="ab3e976e-5dd8-4d83-942a-cd7a4c3d549c"><div class="modal-content"><h4>modules/ray_tracing/test/tests/postprocessors/ray_data_value/ray_data_value.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
[]

[RayKernels/null]
  type = NullRayKernel
  rays = &#x27;ray0 ray1&#x27;
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0.5 0.5 0
                  2.5 2.5 0&#x27;
  end_points = &#x27;5 4.9 0
                0.1 0 0&#x27;
  names = &#x27;ray0 ray1&#x27;
  ray_data_names = &#x27;data0 data1&#x27;
  initial_ray_data = &#x27;1 2&#x27;
  ray_aux_data_names = &#x27;aux_data0 aux_data1&#x27;
  initial_ray_aux_data = &#x27;3 4&#x27;
[]

[Postprocessors]
  [ray0_data0]
    type = RayDataValue
    study = study
    ray_name = ray0
    data_name = data0
  []
  [ray0_data1]
    type = RayDataValue
    study = study
    ray_name = ray0
    data_name = data1
  []
  [ray0_aux_data0]
    type = RayDataValue
    study = study
    ray_name = ray0
    data_name = aux_data0
    aux = true
  []
  [ray0_aux_data1]
    type = RayDataValue
    study = study
    ray_name = ray0
    data_name = aux_data1
    aux = true
  []

  # For ray1, we&#x27;re betting on the fact that the IDs are assigned
  # in sequential order, therefore its ID should be 1. In reality,
  # you should rely on the name but this is just for testing purposes.
  [ray1_data0]
    type = RayDataValue
    study = study
    ray_id = 1
    data_name = data0
  []
  [ray1_data1]
    type = RayDataValue
    study = study
    ray_id = 1
    data_name = data1
  []
  [ray1_aux_data0]
    type = RayDataValue
    study = study
    ray_id = 1
    data_name = aux_data0
    aux = true
  []
  [ray1_aux_data1]
    type = RayDataValue
    study = study
    ray_id = 1
    data_name = aux_data1
    aux = true
  []
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="82107122-353b-4fc4-bc01-40153e48aaf5"><div class="modal-content"><h4>modules/ray_tracing/test/tests/ray_kernels/function_integral_ray_kernel/function_integral_ray_kernel.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 5
    ny = 5
    xmax = 5
    ymax = 5
  []
[]

[Functions/parsed_function]
  type = ParsedFunction
  value = &#x27;x + sin(y)&#x27;
[]

[UserObjects/study]
  type = RepeatableRayStudy
  names = &#x27;diag
           top_across
           bottom_across
           partial&#x27;
  start_points = &#x27;0 0 0
                  0 5 0
                  0 0 0
                  0.5 0.5 0&#x27;
  end_points = &#x27;5 5 0
                5 5 0
                5 0 0
                4.5 0.5 0&#x27;
[]

[RayKernels/function_integral]
  type = FunctionIntegralRayKernel
  function = parsed_function
  rays = &#x27;diag top_across bottom_across partial&#x27;
[]

[Postprocessors]
  [diag_value]
    type = RayIntegralValue
    ray_kernel = function_integral
    ray = diag
  []
  [top_across_value]
    type = RayIntegralValue
    ray_kernel = function_integral
    ray = top_across
  []
  [bottom_across_value]
    type = RayIntegralValue
    ray_kernel = function_integral
    ray = bottom_across
  []
  [partial_value]
    type = RayIntegralValue
    ray_kernel = function_integral
    ray = partial
  []
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  exodus = false
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="e2f9527e-5d95-42d6-a46c-99bb1cdac8ec"><div class="modal-content"><h4>modules/ray_tracing/test/tests/ray_kernels/line_source_ray_kernel/line_source_ray_kernel.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 5
  xmax = 5
  ymax = 5
[]

[Variables/u]
  order = FIRST
  family = LAGRANGE
[]

[BCs/zero]
  type = DirichletBC
  variable = u
  value = 0
  boundary = &#x27;top right bottom left&#x27;
[]

[Kernels/diffusion]
  type = Diffusion
  variable = u
[]

[Postprocessors/postprocessor]
  type = FunctionValuePostprocessor
  function = 3
  execute_on = initial
[]

[RayKernels]
  [constant_source]
    type = LineSourceRayKernel
    variable = u
    value = 5
    rays = constant_source
  []
  [pp_source]
    type = LineSourceRayKernel
    variable = u
    postprocessor = postprocessor
    rays = pp_source
  []
  [function_source]
    type = LineSourceRayKernel
    variable = u
    function = &#x27;x + 2 * y&#x27;
    rays = function_source
  []
  [mixed_source]
    type = LineSourceRayKernel
    variable = u
    value = 5
    postprocessor = postprocessor
    function = &#x27;x + 2 * y&#x27;
    rays = mixed_source
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 2 0
                  0.5 0.5 0
                  1 1 0
                  5 5 0&#x27;
  end_points = &#x27;3 5 0
                4.5 1.5 0
                2 2 0
                4 1 0&#x27;
  names = &#x27;constant_source
           pp_source
           function_source
           mixed_source&#x27;
  execute_on = PRE_KERNELS
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="12faf04d-a005-4bcd-8131-89cbd0252609"><div class="modal-content"><h4>modules/ray_tracing/test/tests/outputs/ray_tracing_mesh_output/ray_mesh_output_3d.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 5
    ny = 5
    nz = 5
    xmax = 5
    ymax = 5
    zmax = 5
    elem_type = HEX8
  []

  [middle_block]
    type = SubdomainBoundingBoxGenerator
    input = gmg
    block_id = 1
    bottom_left = &#x27;2 0 0&#x27;
    top_right = &#x27;3 5 5&#x27;
  []

  [middle_block_sideset]
    type = SideSetsBetweenSubdomainsGenerator
    input = middle_block
    master_block = 1
    paired_block = 0
    new_boundary = 7
  []
[]

[RayBCs]
  [kill]
    type = &#x27;KillRayBC&#x27;
    boundary = &#x27;top right front left&#x27;
    rays = &#x27;to_top_right
            along_edge
            within&#x27;
  []
  [kill_left]
    type = &#x27;KillRayBC&#x27;
    boundary = &#x27;left&#x27;
    rays = &#x27;reflect_three_times
            reflect_at_nodes
            reflect_internal&#x27;
  []
  [reflect]
    type = &#x27;ReflectRayBC&#x27;
    boundary = &#x27;back right top&#x27;
    rays = &#x27;reflect_three_times
            reflect_at_nodes&#x27;
  []
  [reflect_internal]
    type = &#x27;ReflectRayBC&#x27;
    boundary = 7
    rays = &#x27;reflect_internal&#x27;
  []
  [kill_internal]
    type = &#x27;KillRayBC&#x27;
    boundary = 7
    rays = &#x27;kill_internal&#x27;
  []
  [nothing_internal]
    type = &#x27;NullRayBC&#x27;
    boundary = 7
    rays = &#x27;to_top_right
            reflect_three_times
            reflect_at_nodes&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  ray_kernel_coverage_check = false
  start_points = &#x27;0 0 0
                  0 5 0
                  0.6 0.6 0
                  0 1.2 0.8
                  3 0 1
                  0 1.3 2.5
                  5 0 2&#x27;
  directions = &#x27;1 1 1
                0 0 1
                0 0 1
                1 0.6 -0.4
                2 2 1
                0.8 0.5 0.4
                -1 1 1&#x27;
  names = &#x27;to_top_right
           along_edge
           within
           reflect_three_times
           reflect_at_nodes
           reflect_internal
           kill_internal&#x27;
  execute_on = initial
  always_cache_traces = true
  use_internal_sidesets = true
[]

[Executioner]
  type = Steady
[]

[Problem]
  solve = false
[]

[Outputs]
  exodus = false
  [rays]
    type = RayTracingExodus
    study = study
    execute_on = final
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="modal moose-modal" id="7f9bb69b-e8fd-4c35-84d9-c5a49b4face7"><div class="modal-content"><h4>modules/ray_tracing/test/tests/ray_kernels/coupled_line_source_ray_kernel/coupled_line_source_ray_kernel.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 5
  xmax = 5
  ymax = 5
[]

[Variables]
  [u]
    order = FIRST
    family = LAGRANGE
  []
  [v]
    order = FIRST
    family = LAGRANGE
  []
[]

[BCs]
  [u_left]
    type = DirichletBC
    variable = u
    value = 0
    boundary = &#x27;left&#x27;
  []
  [u_right]
    type = DirichletBC
    variable = u
    value = 1
    boundary = &#x27;right&#x27;
  []
  [v_left]
    type = DirichletBC
    variable = v
    value = 0
    boundary = &#x27;left&#x27;
  []
  [v_right]
    type = DirichletBC
    variable = v
    value = 1
    boundary = &#x27;right&#x27;
  []
[]

[Kernels]
  [diffusion_u]
    type = Diffusion
    variable = u
  []
  [diffusion_v]
    type = Diffusion
    variable = v
  []
[]

[RayKernels]
  active = &#x27;source&#x27;

  [source]
    type = CoupledLineSourceRayKernelTest
    variable = u
    coupled = v
    rays = &#x27;ray1 ray2&#x27;
  []
  [source_ad]
    type = ADCoupledLineSourceRayKernelTest
    variable = u
    coupled = v
    rays = &#x27;ray1 ray2&#x27;
  []
[]

[UserObjects/study]
  type = RepeatableRayStudy
  start_points = &#x27;0 0 0
                  0 4.9 0&#x27;
  end_points = &#x27;5 0 0
                4.9 3.9 0&#x27;
  names = &#x27;ray1 ray2&#x27;
  execute_on = PRE_KERNELS
[]

[Executioner]
  type = Steady
  solve_type = NEWTON
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#055f7b5f-fbca-4eb6-872f-69a5af53443e" class="tooltipped" data-position="left" data-tooltip="Description">Description</a></li><li><a href="#d78a3a31-6a38-4e68-9b2c-7ba2fe38a79a" class="tooltipped" data-position="left" data-tooltip="Defining the Rays">Defining the Rays</a></li><li><a href="#19b7cf80-1513-46ac-9253-c3e0bfec77b7" class="tooltipped" data-position="left" data-tooltip="Setting Ray Data">Setting Ray Data</a></li><li><a href="#359ba2af-5727-4765-97de-f244ee6b7b5d" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#181026e5-f0ac-40f5-ae03-272b33c20e6e" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>