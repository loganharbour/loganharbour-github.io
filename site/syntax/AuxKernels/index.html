<!DOCTYPE html><head><meta charset="UTF-8"><title>index.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="15976057-1d3c-4bdc-a9b2-d3b1c3952513"><i class="material-icons">menu</i></a><ul class="sidenav" id="15976057-1d3c-4bdc-a9b2-d3b1c3952513"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">AuxKernels</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="2430dcd7-d346-4d4d-b798-6409a3f9fae5" data-section-level="1" data-section-text="AuxKernels System"><h1 id="auxkernels-system">AuxKernels System</h1><p>The AuxKernel system mimics the <a href="../Kernels/index.html">Kernels System</a> but compute values that can be defined explicitly with a known function. There are two main use cases for AuxKerenel system: computing a quantity that varies with space and time for postprocessing purposes or for decoupling systems of equations. Examples for both of these use cases shall be discussed further in the following sections.</p><p>Creating a custom AuxKernel object is done by creating a new C++ object that inherits from <code>AuxKernel</code> or <code>VectorAuxKernel</code> and overriding the <code>computeValue</code> method, which returns a scalar (<code>Real</code>) or vector (<code>RealVectorValue</code>) for the two types respectively. A third type (<code>AuxScalarKernel</code>) also exists, but the syntax for these objects is different and detailed in the <a href="../AuxScalarKernels/index.html" class="moose-error">../AuxScalarKernels/index.html</a>.</p><p>AuxKernel objects, like Kernel objects, must operate on a variable. Thus, there is a required parameter (&quot;variable&quot;) that indicates the variable that the AuxKernel object is computing. These variables are defined in the <a href="../AuxVariables/index.html">AuxVariables</a> block of the input file, for example the following input file snippet creates an auxiliary variable suitable for use with an VectorAuxKernel.</p><pre class="moose-pre"><code class="language-text">[AuxVariables]
  [vec]
    family = LAGRANGE_VEC
    order = FIRST
  []
[]
</code></pre><a href="#501907c1-34ee-436e-b347-489562a341c3" class="modal-trigger">(test/tests/auxkernels/vector_function_aux/vector_function_aux.i)</a><div class="modal moose-modal" id="501907c1-34ee-436e-b347-489562a341c3"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/test/tests/auxkernels/vector_function_aux/vector_function_aux.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
[]

[AuxVariables]
  [vec]
    family = LAGRANGE_VEC
    order = FIRST
  []
[]

[Variables]
  [u][]
[]

[Functions]
  [function]
    type = ParsedVectorFunction
    value_x = t*x
    value_y = t*y
  []
[]

[AuxKernels]
  [vec]
    type = VectorFunctionAux
    variable = vec
    function = function
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
[]

[Problem]
  type = FEProblem
  #solve = false
  kernel_coverage_check = false
[]

[Executioner]
  type = Transient
  start_time = 0.0
  num_steps = 5
  dt = 1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><section class="scrollspy" id="94fad6e9-2abb-4965-8eee-add549cfa13f" data-section-level="2" data-section-text="Nodal vs Elemental AuxKernel Objects"><h2 id="nodal-vs-elemental-auxkernel-objects">Nodal vs Elemental AuxKernel Objects</h2><p>There are two flavors of AuxKernel objects: nodal and elemental. The distinction is based on the type of variable that is being operated on by the object. If the variable family is <code>LAGRANGE</code> or <code>LAGRANGE_VEC</code> then the AuxKernel will behave as nodal. If the variable family is <code>MONOMIAL</code> then the AuxKernel will behave as an elemental.</p><p>The difference is based on how the <code>computeValue</code> method of the object is called when the kernel is executed. In the nodal case the <code>computeValue</code> method will be executed on each <strong>node</strong> within the finite element mesh and the value returned from the method will directly assign the value of the shape function at that node.</p><p>In the elemental case the <code>computeValue</code> method will be executed on each quadrature point of an <strong>element</strong> of the finite element mesh. The values computed at the quadrature points are used to perform the correct finite element interpolation automatically and set the values for the degrees of freedom. Typically, in the elemental case the order of the monomial finite element is set to constant so there is a single DOF per element, but higher monomials are also supported.</p><p>As is evident by the functionality detailed, the distinction between the two arises from the nature of the finite element shape functions. For Lagrange shape functions the DOF values correspond with the nodes, while for monomial shape functions the DOF values are not associated with nodes.</p><p>The same AuxKernel object can be designed work both as elemental or nodal, for example the <code>computeValue</code> method for the <a href="../../source/auxkernels/FunctionAux.html" class="moose-error">../../source/auxkernels/FunctionAux.html</a> object properly handles using the correct spatial location based on if the object is nodal or elemental with the <code>isNodal</code> method.</p><pre class="moose-pre"><code class="language-cpp">Real
FunctionAux::computeValue()
{
  if (isNodal())
    return _func.value(_t, *_current_node);
  else
    return _func.value(_t, _q_point[_qp]);
}
</code></pre><a href="#aaec8c6a-0c96-4dba-ba44-eb5d7a4b8c1e" class="modal-trigger">(framework/src/auxkernels/FunctionAux.C)</a><div class="modal moose-modal" id="aaec8c6a-0c96-4dba-ba44-eb5d7a4b8c1e"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/framework/src/auxkernels/FunctionAux.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;FunctionAux.h&quot;
#include &quot;Function.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FunctionAux);

defineLegacyParams(FunctionAux);

InputParameters
FunctionAux::validParams()
{
  InputParameters params = AuxKernel::validParams();
  params.addClassDescription(&quot;Auxiliary Kernel that creates and updates a field variable by &quot;
                             &quot;sampling a function through space and time.&quot;);
  params.addRequiredParam&lt;FunctionName&gt;(&quot;function&quot;, &quot;The function to use as the value&quot;);
  return params;
}

FunctionAux::FunctionAux(const InputParameters &amp; parameters)
  : AuxKernel(parameters), _func(getFunction(&quot;function&quot;))
{
}

Real
FunctionAux::computeValue()
{
  if (isNodal())
    return _func.value(_t, *_current_node);
  else
    return _func.value(_t, _q_point[_qp]);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>Nodal AuxKernel objects abuse the notion of quadrature points, the <code>_qp</code> member variable is set to zero, but still must be used to access coupled variable values and material properties. This is done to allow the syntax to be consistent regardless of the AuxKernel flavor: nodal or elemental.</p></section><section class="scrollspy" id="39e8de90-eb06-4a0d-9af5-4068170bfb03" data-section-level="2" data-section-text="Execute Flags"><h2 id="execute-flags">Execute Flags</h2><p>AuxKernel objects inherit from the <a href="../../source/interfaces/SetupInterface.html">SetupInterface (execute_on)</a> so they include the &quot;execute_on&quot; variable. By default this parameter is set to <code>EXEC_LINEAR</code> and <code>EXEC_TIMESTEP_END</code>. The <code>EXEC_LINEAR</code> flag is set because it is possible to couple values compute by an AuxKernel object to other objects such as Kernel or Material objects that are used in the residual calculation. In order to ensure that the values from the auxiliary variable are correct during the iterative solve they are computed for each iteration.</p><p>However, if the auxiliary variable be computed is not being coupled to objects computing the residual evaluating the AuxKernel on each linear iteration is not necessary and can slow down the execution of a simulation. In this case, the <code>EXEC_LINEAR</code> flag should be removed. Likely the <code>EXEC_INITIAL</code> flag should be added to perform the auxiliary variable calculation during the initial setup phase as well.</p></section><section class="scrollspy" id="4a5520f3-75cf-4874-9f77-698dca320dd2" data-section-level="2" data-section-text="Example A : Post processing with AuxKernel"><h2 id="example-a-post-processing-with-auxkernel">Example A: Post processing with AuxKernel</h2><p>The following example is extracted from step 4 of the Darcy Flow and Thermomechanics Tutorial. Consider Darcy&#x27;s Law for flow in porous media neglecting changes in time and gravity:</p><p><span class="moose-katex-block-equation"><span tex="-\nabla\cdot\frac{\mathbf{K}}{\mu}\nabla p = 0," label="darcy" number="1" bookmark="moose-equation-a9198f2b-2f44-4b3a-a45a-e81cbc3058a6" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-a9198f2b-2f44-4b3a-a45a-e81cbc3058a6"></span><span class="moose-katex-equation-number">(1)</span><script>var element = document.getElementById("moose-equation-a9198f2b-2f44-4b3a-a45a-e81cbc3058a6");katex.render(" -\\nabla\\cdot\\frac{\\mathbf{K}}{\\mu}\\nabla p = 0,", element, {displayMode:true,throwOnError:false});</script></span> where <span tex="\mathbf{K}" bookmark="moose-equation-ec916f1d-be82-43f7-b5f1-d3462ec60011" recursive="True" class="moose-katex-inline-equation" id="moose-equation-ec916f1d-be82-43f7-b5f1-d3462ec60011"><script>var element = document.getElementById("moose-equation-ec916f1d-be82-43f7-b5f1-d3462ec60011");katex.render("\\mathbf{K}", element, {displayMode:false,throwOnError:false});</script></span> is the permeability tensor, <span tex="\mu" bookmark="moose-equation-e4168f7e-bbe3-499f-8120-ca81a8a3ff83" recursive="True" class="moose-katex-inline-equation" id="moose-equation-e4168f7e-bbe3-499f-8120-ca81a8a3ff83"><script>var element = document.getElementById("moose-equation-e4168f7e-bbe3-499f-8120-ca81a8a3ff83");katex.render("\\mu", element, {displayMode:false,throwOnError:false});</script></span> is the fluid viscosity, and <span tex="p" bookmark="moose-equation-73ed5798-96a5-4fc6-bfd7-3d967456747f" recursive="True" class="moose-katex-inline-equation" id="moose-equation-73ed5798-96a5-4fc6-bfd7-3d967456747f"><script>var element = document.getElementById("moose-equation-73ed5798-96a5-4fc6-bfd7-3d967456747f");katex.render("p", element, {displayMode:false,throwOnError:false});</script></span> is the pressure and the velocity (<span tex="\vec{u}" bookmark="moose-equation-01045ac8-8dfa-4d6b-a368-9c0cd73b0106" recursive="True" class="moose-katex-inline-equation" id="moose-equation-01045ac8-8dfa-4d6b-a368-9c0cd73b0106"><script>var element = document.getElementById("moose-equation-01045ac8-8dfa-4d6b-a368-9c0cd73b0106");katex.render("\\vec{u}", element, {displayMode:false,throwOnError:false});</script></span>) may be computed as:</p><p><span class="moose-katex-block-equation"><span tex="\vec{u} = \frac{\mathbf{K}}{\mu}\nabla p." label="darcy_vel" number="2" bookmark="moose-equation-72402afb-02d0-4d18-b995-f226c10ff097" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-72402afb-02d0-4d18-b995-f226c10ff097"></span><span class="moose-katex-equation-number">(2)</span><script>var element = document.getElementById("moose-equation-72402afb-02d0-4d18-b995-f226c10ff097");katex.render(" \\vec{u} = \\frac{\\mathbf{K}}{\\mu}\\nabla p.", element, {displayMode:true,throwOnError:false});</script></span></p><p>The left-hand side of <a href="#moose-equation-a9198f2b-2f44-4b3a-a45a-e81cbc3058a6">Eq. (1)</a> would be solved with a nonlinear variable and an appropriate <a href="../Kernels/index.html">Kernel object</a>. The AuxKernel system can be used computing the velocity following <a href="#moose-equation-72402afb-02d0-4d18-b995-f226c10ff097">Eq. (2)</a>. In the tutorial the exact calculation is performed using the DarcyVelocity object, the header and source files for this object are listed below.</p><pre class="moose-pre"><code class="language-cpp">
#pragma once

#include &quot;AuxKernel.h&quot;

/**
 * Auxiliary kernel responsible for computing the Darcy velocity given
 * several fluid properties and the pressure gradient.
 */
class DarcyVelocity : public VectorAuxKernel
{
public:
  static InputParameters validParams();

  DarcyVelocity(const InputParameters &amp; parameters);

protected:
  /**
   * AuxKernels MUST override computeValue.  computeValue() is called on
   * every quadrature point.  For Nodal Auxiliary variables those quadrature
   * points coincide with the nodes.
   */
  virtual RealVectorValue computeValue() override;

  /// The gradient of a coupled variable
  const VariableGradient &amp; _pressure_gradient;

  /// Holds the permeability and viscosity from the material system
  const ADMaterialProperty&lt;Real&gt; &amp; _permeability;
  const ADMaterialProperty&lt;Real&gt; &amp; _viscosity;
};
</code></pre><a href="#4c4daefa-6042-4372-8465-3846a682451f" class="modal-trigger">(tutorials/darcy_thermo_mech/step04_velocity_aux/include/auxkernels/DarcyVelocity.h)</a><div class="modal moose-modal" id="4c4daefa-6042-4372-8465-3846a682451f"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/tutorials/darcy_thermo_mech/step04_velocity_aux/include/auxkernels/DarcyVelocity.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;AuxKernel.h&quot;

/**
 * Auxiliary kernel responsible for computing the Darcy velocity given
 * several fluid properties and the pressure gradient.
 */
class DarcyVelocity : public VectorAuxKernel
{
public:
  static InputParameters validParams();

  DarcyVelocity(const InputParameters &amp; parameters);

protected:
  /**
   * AuxKernels MUST override computeValue.  computeValue() is called on
   * every quadrature point.  For Nodal Auxiliary variables those quadrature
   * points coincide with the nodes.
   */
  virtual RealVectorValue computeValue() override;

  /// The gradient of a coupled variable
  const VariableGradient &amp; _pressure_gradient;

  /// Holds the permeability and viscosity from the material system
  const ADMaterialProperty&lt;Real&gt; &amp; _permeability;
  const ADMaterialProperty&lt;Real&gt; &amp; _viscosity;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><pre class="moose-pre"><code class="language-cpp">
#include &quot;DarcyVelocity.h&quot;

#include &quot;metaphysicl/raw_type.h&quot;

registerMooseObject(&quot;DarcyThermoMechApp&quot;, DarcyVelocity);

InputParameters
DarcyVelocity::validParams()
{
  InputParameters params = VectorAuxKernel::validParams();

  // Add a &quot;coupling paramater&quot; to get a variable from the input file.
  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The pressure field.&quot;);

  return params;
}

DarcyVelocity::DarcyVelocity(const InputParameters &amp; parameters)
  : VectorAuxKernel(parameters),

    // Get the gradient of the variable
    _pressure_gradient(coupledGradient(&quot;pressure&quot;)),

    // Set reference to the permeability MaterialProperty.
    // Only AuxKernels operating on Elemental Auxiliary Variables can do this
    _permeability(getADMaterialProperty&lt;Real&gt;(&quot;permeability&quot;)),

    // Set reference to the viscosity MaterialProperty.
    // Only AuxKernels operating on Elemental Auxiliary Variables can do this
    _viscosity(getADMaterialProperty&lt;Real&gt;(&quot;viscosity&quot;))
{
}

RealVectorValue
DarcyVelocity::computeValue()
{
  // Access the gradient of the pressure at this quadrature point, then pull out the &quot;component&quot; of
  // it requested (x, y or z). Note, that getting a particular component of a gradient is done using
  // the parenthesis operator.
  return -MetaPhysicL::raw_value(_permeability[_qp] / _viscosity[_qp]) * _pressure_gradient[_qp];
}
</code></pre><a href="#a3a566b9-567e-4d09-92a0-dd61495733cf" class="modal-trigger">(tutorials/darcy_thermo_mech/step04_velocity_aux/src/auxkernels/DarcyVelocity.C)</a><div class="modal moose-modal" id="a3a566b9-567e-4d09-92a0-dd61495733cf"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/tutorials/darcy_thermo_mech/step04_velocity_aux/src/auxkernels/DarcyVelocity.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;DarcyVelocity.h&quot;

#include &quot;metaphysicl/raw_type.h&quot;

registerMooseObject(&quot;DarcyThermoMechApp&quot;, DarcyVelocity);

InputParameters
DarcyVelocity::validParams()
{
  InputParameters params = VectorAuxKernel::validParams();

  // Add a &quot;coupling paramater&quot; to get a variable from the input file.
  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The pressure field.&quot;);

  return params;
}

DarcyVelocity::DarcyVelocity(const InputParameters &amp; parameters)
  : VectorAuxKernel(parameters),

    // Get the gradient of the variable
    _pressure_gradient(coupledGradient(&quot;pressure&quot;)),

    // Set reference to the permeability MaterialProperty.
    // Only AuxKernels operating on Elemental Auxiliary Variables can do this
    _permeability(getADMaterialProperty&lt;Real&gt;(&quot;permeability&quot;)),

    // Set reference to the viscosity MaterialProperty.
    // Only AuxKernels operating on Elemental Auxiliary Variables can do this
    _viscosity(getADMaterialProperty&lt;Real&gt;(&quot;viscosity&quot;))
{
}

RealVectorValue
DarcyVelocity::computeValue()
{
  // Access the gradient of the pressure at this quadrature point, then pull out the &quot;component&quot; of
  // it requested (x, y or z). Note, that getting a particular component of a gradient is done using
  // the parenthesis operator.
  return -MetaPhysicL::raw_value(_permeability[_qp] / _viscosity[_qp]) * _pressure_gradient[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="488b336a-8654-4fee-b1a5-bc7724c9579f" data-section-level="2" data-section-text="Example B : Decoupling Equations"><h2 id="example-b-decoupling-equations">Example B: Decoupling Equations</h2><p>Auxiliary variables may be used interchangeably with nonlinear variables with respect to coupling allowing complicated systems of equations to be decoupled for solving individually. This is very useful for testing and validation.</p><p>Consider the heat equation with an advective term that is coupled to the pressure computed in <a href="#moose-equation-a9198f2b-2f44-4b3a-a45a-e81cbc3058a6">Eq. (1)</a> as in step 6 of the Darcy Flow and Thermomechanics Tutorial:</p><p><span class="moose-katex-block-equation"><span tex="C\left( \frac{\partial T}{\partial t} + \epsilon \vec{u}\cdot\nabla T \right) - \nabla \cdot k \nabla T = 0," label="heat" number="3" bookmark="moose-equation-744f610a-583d-4b0e-85a2-a5d61564b8de" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-744f610a-583d-4b0e-85a2-a5d61564b8de"></span><span class="moose-katex-equation-number">(3)</span><script>var element = document.getElementById("moose-equation-744f610a-583d-4b0e-85a2-a5d61564b8de");katex.render(" C\\left( \\frac{\\partial T}{\\partial t} + \\epsilon \\vec{u}\\cdot\\nabla T \\right) - \\nabla \\cdot k \\nabla T = 0,", element, {displayMode:true,throwOnError:false});</script></span> where <span tex="T" bookmark="moose-equation-b1121c63-afb8-4072-84f1-f7cd9775737b" recursive="True" class="moose-katex-inline-equation" id="moose-equation-b1121c63-afb8-4072-84f1-f7cd9775737b"><script>var element = document.getElementById("moose-equation-b1121c63-afb8-4072-84f1-f7cd9775737b");katex.render("T", element, {displayMode:false,throwOnError:false});</script></span> is temperature, <span tex="C" bookmark="moose-equation-cc521ec1-57a2-4db2-91c0-3ce43c92d178" recursive="True" class="moose-katex-inline-equation" id="moose-equation-cc521ec1-57a2-4db2-91c0-3ce43c92d178"><script>var element = document.getElementById("moose-equation-cc521ec1-57a2-4db2-91c0-3ce43c92d178");katex.render("C", element, {displayMode:false,throwOnError:false});</script></span> is the heat capacity, <span tex="k" bookmark="moose-equation-6ac80f35-3569-4664-b726-9aca03efc566" recursive="True" class="moose-katex-inline-equation" id="moose-equation-6ac80f35-3569-4664-b726-9aca03efc566"><script>var element = document.getElementById("moose-equation-6ac80f35-3569-4664-b726-9aca03efc566");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span> is the thermal conductivity, and <span tex="\epsilon" bookmark="moose-equation-2f8423f0-0249-495b-8797-47fe744fc4dc" recursive="True" class="moose-katex-inline-equation" id="moose-equation-2f8423f0-0249-495b-8797-47fe744fc4dc"><script>var element = document.getElementById("moose-equation-2f8423f0-0249-495b-8797-47fe744fc4dc");katex.render("\\epsilon", element, {displayMode:false,throwOnError:false});</script></span> is the porosity. The advective term (<span tex="\epsilon\vec{u}\cdot\nabla T" bookmark="moose-equation-0e34ad59-5827-406a-bf08-3eed4d2d30c2" recursive="True" class="moose-katex-inline-equation" id="moose-equation-0e34ad59-5827-406a-bf08-3eed4d2d30c2"><script>var element = document.getElementById("moose-equation-0e34ad59-5827-406a-bf08-3eed4d2d30c2");katex.render("\\epsilon\\vec{u}\\cdot\\nabla T", element, {displayMode:false,throwOnError:false});</script></span>) is computed in a kernel object (<a href="#791cf17d-43b0-4ab5-a0b1-05e71512aa67" class="modal-trigger">DarcyAdvection.C</a>) and requires the pressure variable be provided as a variable:</p><div class="modal moose-modal" id="791cf17d-43b0-4ab5-a0b1-05e71512aa67"><div class="modal-content"><h4>/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/kernels/DarcyAdvection.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;DarcyAdvection.h&quot;

registerMooseObject(&quot;DarcyThermoMechApp&quot;, DarcyAdvection);

InputParameters
DarcyAdvection::validParams()
{
  InputParameters params = ADKernelValue::validParams();
  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The variable representing the pressure.&quot;);
  return params;
}

DarcyAdvection::DarcyAdvection(const InputParameters &amp; parameters)
  : ADKernelValue(parameters),
    // Couple to the gradient of the pressure
    _pressure_grad(adCoupledGradient(&quot;pressure&quot;)),
    // Grab necessary material properties
    _permeability(getADMaterialProperty&lt;Real&gt;(&quot;permeability&quot;)),
    _porosity(getADMaterialProperty&lt;Real&gt;(&quot;porosity&quot;)),
    _viscosity(getADMaterialProperty&lt;Real&gt;(&quot;viscosity&quot;)),
    _density(getADMaterialProperty&lt;Real&gt;(&quot;density&quot;)),
    _specific_heat(getADMaterialProperty&lt;Real&gt;(&quot;specific_heat&quot;))
{
}

ADReal
DarcyAdvection::precomputeQpResidual()
{
  // See also: E. Majchrzak and L. Turchan, &quot;The Finite Difference
  // Method For Transient Convection Diffusion&quot;, Scientific Research
  // of the Institute of Mathematics and Computer Science, vol. 1,
  // no. 11, 2012, pp. 63-72.
  // http://srimcs.im.pcz.pl/2012_1/art_07.pdf

  // http://en.wikipedia.org/wiki/Superficial_velocity
  ADRealVectorValue superficial_velocity =
      _porosity[_qp] * -(_permeability[_qp] / _viscosity[_qp]) * _pressure_grad[_qp];

  return _density[_qp] * _specific_heat[_qp] * superficial_velocity * _grad_u[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><pre class="moose-pre"><code class="language-cpp">  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The variable representing the pressure.&quot;);
</code></pre><a href="#2ab23c4e-317c-4c3b-861e-4bff5636b525" class="modal-trigger">(tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/kernels/DarcyAdvection.C)</a><div class="modal moose-modal" id="2ab23c4e-317c-4c3b-861e-4bff5636b525"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/kernels/DarcyAdvection.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;DarcyAdvection.h&quot;

registerMooseObject(&quot;DarcyThermoMechApp&quot;, DarcyAdvection);

InputParameters
DarcyAdvection::validParams()
{
  InputParameters params = ADKernelValue::validParams();
  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The variable representing the pressure.&quot;);
  return params;
}

DarcyAdvection::DarcyAdvection(const InputParameters &amp; parameters)
  : ADKernelValue(parameters),
    // Couple to the gradient of the pressure
    _pressure_grad(adCoupledGradient(&quot;pressure&quot;)),
    // Grab necessary material properties
    _permeability(getADMaterialProperty&lt;Real&gt;(&quot;permeability&quot;)),
    _porosity(getADMaterialProperty&lt;Real&gt;(&quot;porosity&quot;)),
    _viscosity(getADMaterialProperty&lt;Real&gt;(&quot;viscosity&quot;)),
    _density(getADMaterialProperty&lt;Real&gt;(&quot;density&quot;)),
    _specific_heat(getADMaterialProperty&lt;Real&gt;(&quot;specific_heat&quot;))
{
}

ADReal
DarcyAdvection::precomputeQpResidual()
{
  // See also: E. Majchrzak and L. Turchan, &quot;The Finite Difference
  // Method For Transient Convection Diffusion&quot;, Scientific Research
  // of the Institute of Mathematics and Computer Science, vol. 1,
  // no. 11, 2012, pp. 63-72.
  // http://srimcs.im.pcz.pl/2012_1/art_07.pdf

  // http://en.wikipedia.org/wiki/Superficial_velocity
  ADRealVectorValue superficial_velocity =
      _porosity[_qp] * -(_permeability[_qp] / _viscosity[_qp]) * _pressure_grad[_qp];

  return _density[_qp] * _specific_heat[_qp] * superficial_velocity * _grad_u[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>For testing purposes is it not desirable to include the solve for the pressure variable when examining the correctness of the heat equation solve, so an auxiliary variable that is assigned an arbitrary function of space and time is used instead. The following input file snippet demonstrates the decoupling of the pressure variable by computing it using an AuxVariable the FunctionAux object.</p><pre class="moose-pre"><code class="language-text">[AuxVariables]
  [pressure]
  []
[]

[AuxKernels]
  [pressure]
    type = FunctionAux
    variable = pressure
    function = &#x27;t*x*x*y&#x27;
    execute_on = timestep_end
  []
[]
</code></pre><a href="#aac6c42e-ead8-4692-8dfc-3c211dce2a74" class="modal-trigger">(tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/problems/step6c_decoupled.i)</a><div class="modal moose-modal" id="aac6c42e-ead8-4692-8dfc-3c211dce2a74"><div class="modal-content"><h4>/Users/harblh/projects/moc/private_moose/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/problems/step6c_decoupled.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 200
  ny = 10
  xmax = 0.304 # Length of test chamber
  ymax = 0.0257 # Test chamber radius
[]

[Variables]
  [temperature]
    initial_condition = 300 # Start at room temperature
  []
[]

[AuxVariables]
  [pressure]
  []
[]

[AuxKernels]
  [pressure]
    type = FunctionAux
    variable = pressure
    function = &#x27;t*x*x*y&#x27;
    execute_on = timestep_end
  []
[]

[Kernels]
  [heat_conduction]
    type = ADHeatConduction
    variable = temperature
  []
  [heat_conduction_time_derivative]
    type = ADHeatConductionTimeDerivative
    variable = temperature
  []
  [heat_convection]
    type = DarcyAdvection
    variable = temperature
    pressure = pressure
  []
[]

[BCs]
  [inlet_temperature]
    type = DirichletBC
    variable = temperature
    boundary = left
    value = 350
  []
  [outlet_temperature]
    type = HeatConductionOutflow
    variable = temperature
    boundary = right
  []
[]

[Materials]
  [column]
    type = PackedColumn
    radius = 1
    temperature = 293.15 # 20C
  []
[]

[Problem]
  type = FEProblem
  coord_type = RZ
  rz_coord_axis = X
[]

[Executioner]
  type = Transient
  num_steps = 300
  dt = 0.1
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section><section class="scrollspy" id="472e9d57-f906-4b9d-9513-3a1ef78774be" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRankTwoTensorAux.html">ADMaterialRankTwoTensorAux</a>Access a component of a RankTwoTensor for automatic material property output</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealAux.html">ADMaterialRealAux</a>Outputs element volume-averaged material properties</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealVectorValueAux.html">ADMaterialRealVectorValueAux</a></li><li class="collection-item"><a href="../../source/auxkernels/VectorMaterialRealVectorValueAux.html">ADVectorMaterialRealVectorValueAux</a>Converts a vector-quantity material property into a vector auxiliary variable</li><li class="collection-item"><a href="../../source/auxkernels/ArrayVariableComponent.html">ArrayVariableComponent</a>Copy a component of an array variable.</li><li class="collection-item"><a href="../../source/auxkernels/ConstantAux.html">ConstantAux</a>Creates a constant field in the domain.</li><li class="collection-item"><a href="../../source/auxkernels/ConstantBoundsAux.html">ConstantBoundsAux</a>Provides constant bound of a variable for the PETSc&#x27;s variational inequalities solver</li><li class="collection-item"><a href="../../source/auxkernels/DebugResidualAux.html">DebugResidualAux</a></li><li class="collection-item"><a href="../../source/auxkernels/DiffusionFluxAux.html">DiffusionFluxAux</a>Compute components of flux vector for diffusion problems <span tex="(\vv{J} = -D \nabla C)" bookmark="moose-equation-cdb783d7-5b08-415b-b7f0-3f83a4310bbd" recursive="True" class="moose-katex-inline-equation" id="moose-equation-cdb783d7-5b08-415b-b7f0-3f83a4310bbd"><script>var element = document.getElementById("moose-equation-cdb783d7-5b08-415b-b7f0-3f83a4310bbd");katex.render("(\\vv{J} = -D \\nabla C)", element, {displayMode:false,throwOnError:false});</script></span>.</li><li class="collection-item"><a href="../../source/auxkernels/ElemExtraIDAux.html">ElemExtraIDAux</a>Puts element extra IDs into an aux variable.</li><li class="collection-item"><a href="../../source/auxkernels/ElementH1ErrorFunctionAux.html">ElementH1ErrorFunctionAux</a>Computes the H1 or W^{1,p} error between an exact function and a coupled variable.</li><li class="collection-item"><a href="../../source/auxkernels/ElementIntegerAux.html">ElementIntegerAux</a>Creates a field showing the element integer.</li><li class="collection-item"><a href="../../source/auxkernels/ElementL2ErrorFunctionAux.html">ElementL2ErrorFunctionAux</a>A class for computing the element-wise L^2 (Euclidean) error between a function and a coupled variable.</li><li class="collection-item"><a href="../../source/auxkernels/ElementLengthAux.html">ElementLengthAux</a>Compute the element size using Elem::hmin() or Elem::hmax() from libMesh.</li><li class="collection-item"><a href="../../source/auxkernels/ElementLpNormAux.html">ElementLpNormAux</a>Compute an elemental field variable (single value per element) equal to the Lp-norm of a coupled Variable.</li><li class="collection-item"><a href="../../source/auxkernels/ElementQualityAux.html">ElementQualityAux</a>Generates a field containing the quality metric for each element.  Useful for visualizing mesh quality.</li><li class="collection-item"><a href="../../source/auxkernels/FunctionAux.html">FunctionAux</a>Auxiliary Kernel that creates and updates a field variable by sampling a function through space and time.</li><li class="collection-item"><a href="../../source/auxkernels/GapValueAux.html">GapValueAux</a></li><li class="collection-item"><a href="../../source/auxkernels/GhostingAux.html">GhostingAux</a>Colors the elements ghosted to the chosen PID.</li><li class="collection-item"><a href="../../source/auxkernels/HardwareIDAux.html">HardwareIDAux</a>Creates a field showing the assignment of partitions to physical nodes in the cluster.</li><li class="collection-item"><a href="../../source/auxkernels/InterfaceValueUserObjectAux.html">InterfaceValueUserObjectAux</a>Get stored value from the specified InterfaceQpUserObjectBase.</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRankFourTensorAux.html">MaterialRankFourTensorAux</a>Access a component of a RankFourTensor for automatic material property output</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRankTwoTensorAux.html">MaterialRankTwoTensorAux</a>Access a component of a RankTwoTensor for automatic material property output</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealAux.html">MaterialRealAux</a>Outputs element volume-averaged material properties</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealDenseMatrixAux.html">MaterialRealDenseMatrixAux</a></li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealTensorValueAux.html">MaterialRealTensorValueAux</a></li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealVectorValueAux.html">MaterialRealVectorValueAux</a></li><li class="collection-item"><a href="../../source/auxkernels/MaterialStdVectorAux.html">MaterialStdVectorAux</a>Extracts a component of a material type std::vector&lt;Real&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="../../source/auxkernels/MaterialStdVectorRealGradientAux.html">MaterialStdVectorRealGradientAux</a>Extracts a component of a material&#x27;s std::vector&lt;RealGradient&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="../../source/auxkernels/NearestNodeDistanceAux.html">NearestNodeDistanceAux</a>Stores the distance between a block and boundary or between two boundaries.</li><li class="collection-item"><a href="../../source/auxkernels/NearestNodeValueAux.html">NearestNodeValueAux</a>Retrieves a field value from the closest node on the paired boundary and stores it on this boundary or block.</li><li class="collection-item"><a href="../../source/auxkernels/NormalizationAux.html">NormalizationAux</a></li><li class="collection-item"><a href="../../source/auxkernels/ParsedAux.html">ParsedAux</a>Parsed function AuxKernel.</li><li class="collection-item"><a href="../../source/auxkernels/PenetrationAux.html">PenetrationAux</a>Auxiliary Kernel for computing several geometry related quantities between two contacting bodies.</li><li class="collection-item"><a href="../../source/auxkernels/ProcessorIDAux.html">ProcessorIDAux</a>Creates a field showing the processors and partitioning.</li><li class="collection-item"><a href="../../source/auxkernels/QuotientAux.html">QuotientAux</a>Divides two coupled variables.</li><li class="collection-item"><a href="../../source/auxkernels/SelfAux.html">SelfAux</a></li><li class="collection-item"><a href="../../source/auxkernels/SolutionAux.html">SolutionAux</a>Creates fields by using information from a SolutionUserObject.</li><li class="collection-item"><a href="../../source/auxkernels/SpatialUserObjectAux.html">SpatialUserObjectAux</a></li><li class="collection-item"><a href="../../source/auxkernels/TagMatrixAux.html">TagMatrixAux</a>Couple the diag of a tag matrix, and return its nodal value</li><li class="collection-item"><a href="../../source/auxkernels/TagVectorAux.html">TagVectorAux</a>Couple a tag vector, and return its nodal value</li><li class="collection-item"><a href="../../source/auxkernels/VariableGradientComponent.html">VariableGradientComponent</a>Creates a field with consisting of one component of a coupled variable.</li><li class="collection-item"><a href="../../source/auxkernels/VariableOldValueBoundsAux.html">VariableOldValueBoundsAux</a>Provides the upper and lower bound of the phase field fracture variable to PETSc&#x27;s SNES variational inequalities solver.</li><li class="collection-item"><a href="../../source/auxkernels/VariableTimeIntegrationAux.html">VariableTimeIntegrationAux</a></li><li class="collection-item"><a href="../../source/auxkernels/VectorFunctionAux.html">VectorFunctionAux</a>Auxiliary Kernel that creates and updates a vector field variable by sampling a Function object, via the vectorValue method, through space and time.</li><li class="collection-item"><a href="../../source/auxkernels/VectorMagnitudeAux.html">VectorMagnitudeAux</a>Creates a field representing the magnitude of three coupled variables using an Euclidean norm.</li><li class="collection-item"><a href="../../source/auxkernels/VectorMaterialRealVectorValueAux.html">VectorMaterialRealVectorValueAux</a>Converts a vector-quantity material property into a vector auxiliary variable</li><li class="collection-item"><a href="../../source/auxkernels/VectorPostprocessorVisualizationAux.html">VectorPostprocessorVisualizationAux</a>Read values from a VectorPostprocessor that is producing vectors that are &#x27;number of processors&#x27; * in length.  Puts the value for each processor into an elemental auxiliary field.</li><li class="collection-item"><a href="../../source/auxkernels/VectorVariableComponentAux.html">VectorVariableComponentAux</a>Creates a field consisting of one component of a coupled vector variable.</li></ul></section><section class="scrollspy" id="4f478912-8670-4cfa-8aaa-797753a6bec5" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddKernelAction.html">AddKernelAction</a></li></ul></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#94fad6e9-2abb-4965-8eee-add549cfa13f" class="tooltipped" data-position="left" data-tooltip="Nodal vs Elemental AuxKernel Objects">Nodal vs Elemental AuxKernel Objects</a></li><li><a href="#39e8de90-eb06-4a0d-9af5-4068170bfb03" class="tooltipped" data-position="left" data-tooltip="Execute Flags">Execute Flags</a></li><li><a href="#4a5520f3-75cf-4874-9f77-698dca320dd2" class="tooltipped" data-position="left" data-tooltip="Example A : Post processing with AuxKernel">Example A : Post processing with AuxKernel</a></li><li><a href="#488b336a-8654-4fee-b1a5-bc7724c9579f" class="tooltipped" data-position="left" data-tooltip="Example B : Decoupling Equations">Example B : Decoupling Equations</a></li><li><a href="#472e9d57-f906-4b9d-9513-3a1ef78774be" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#4f478912-8670-4cfa-8aaa-797753a6bec5" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>