<!DOCTYPE html><head><meta charset="UTF-8"><title>index.md|MOOSE Ray Tracing Module</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="/modules/ray_tracing" class="left moose-logo hide-on-med-and-down">MOOSE Ray Tracing Module</a><a href="https://github.com/idaholab/moose" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"></ul><a href="#" class="sidenav-trigger" data-target="505bbc21-d309-4f44-b2f1-277a03d2bf01"><i class="material-icons">menu</i></a><ul class="sidenav" id="505bbc21-d309-4f44-b2f1-277a03d2bf01"></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/modules/ray_tracing" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">MeshGenerators</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="fa440027-a7a3-4f44-bdca-c3085165028e" data-section-level="1" data-section-text="MeshGenerators System"><h1 id="meshgenerators-system">MeshGenerators System</h1><p>This is the base class of all the <code>MeshGenerators</code> systems.</p><p>There are two types of MeshGenerators:</p><ul class="browser-default"><li><p>Those who create a mesh (such as <code>AnnularMeshGenerator</code>, <code>FileMeshGenerator</code>,...). They are usually similar to the <code>Mesh</code> objects. </p></li><li><p>Those who modify an existing mesh (such as <code>MeshExtruderGenerator</code>, <code>StitchedMeshGenerator</code>,...). They are usually similar to <code>MeshModifier</code> objects.</p></li></ul><p>The point of these objects is to create complex meshes using only one input file. Indeed, you can use several MeshGenerator blocks in your input file. Those represent the different steps necessary to create your complex mesh.</p><p>Objects that create a mesh (such as <code>FileMeshGenerator</code>, <code>GeneratedMeshGenerator</code>, etc.) should build their libMesh mesh base objects through <code>MooseMesh</code> APIs. This will guarantee that non-local elements will be handled properly when <code>prepare_for_use</code> is called. This is because during <code>Action</code> execution during simulation setup, MOOSE objects such as periodic boundary conditions or a displaced problem will signal the <code>MooseMesh</code> if they need to delay remote/non-local element removal or if they need certain remote/non-local elements preserved using the <a href="../../source/relationshipmanagers/RelationshipManager.html"><code>RelationshipManager</code></a> system. This information needs to be communicated to any <code>MeshGenerators</code> that are building new meshes in order for the simulation to run correctly.</p><p>There are two <code>MooseMesh</code> APIs that should be used by <code>MeshGenerators</code>. <code>MooseMesh::buildMeshBaseObject</code> should be called to construct the mesh that will be returned by the derived class implementation of <code>MeshGenerator::generate</code>. This is a <code>std::unique_ptr</code>. If you want to guarantee that the derived class type of the <code>std::unique_ptr&lt;MeshBase&gt;</code> returned by <code>_mesh-&gt;buildMeshBaseObject()</code> is a certain type, then <code>_mesh-&gt;buildMeshBaseObject()</code> should be preceded by a call to <code>_mesh-&gt;setParallelType(Moose::ParallelType::REPLICATED)</code> or <code>_mesh-&gt;setParallelType(Moose::ParallelType::DISTRIBUTED)</code>.</p><p>The second API, <code>MooseMesh::buildTypedMesh</code>, should be used for constructing auxiliary meshes whose data may be used in the <code>MeshBase</code> object that is returned by <code>DerivedMeshGenerator::generate</code>. An example is stitching meshes. <code>MooseMesh::buildTypedMesh</code> takes a single template argument that is the type of derived <code>MeshBase</code> object that you want to build. So if you want a <code>ReplicatedMesh</code>, you would create a <code>ReplicatedMesh</code> instance by calling <code>_mesh-&gt;buildTypedMesh&lt;ReplicatedMesh&gt;(dim)</code> where <code>dim</code> is the desired dimensio of the mesh. If <code>dim</code> is not provided, then <code>buildTypedMesh</code> will use the value of <code>dim</code> from the <code>MooseMesh</code> <code>InputParameters</code> object. Note the difference in return type between <code>MooseMesh::buildMeshBaseObject</code> and <code>MooseMesh::buildTypedMesh</code>. The former will return <code>std::unique_ptr&lt;MeshBase</code> and the latter will return <code>T</code> where <code>T</code> is the value of the template argument provided to the <code>MooseMesh::buildTypedMesh</code> method.</p><section class="scrollspy" id="2478adc5-9213-4804-98bb-4c938dd68488" data-section-level="2" data-section-text="Input File Example"><h2 id="input-file-example">Input File Example</h2><p>For instance, take a look at the following input file:</p><pre class="moose-pre"><code class="language-text">
[MeshGenerators]
  [./gmg]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 3
    ny = 3
    nz = 3
  []

  [./tmg]
    type = TiledMeshGenerator
    input = gmg
    x_width = 1
    y_width = 1
    z_width = 1

    left_boundary = left
    right_boundary = right
    top_boundary = top
    bottom_boundary = bottom
    front_boundary = front
    back_boundary = back

    x_tiles = 2
    y_tiles = 1
    z_tiles = 5
  []
[]

[Mesh]
  type = MeshGeneratorMesh
[]

[Outputs]
  exodus = true
[]
</code></pre><p>Structurally, notice that one can have several <code>MeshGenerator</code> blocks, but only one <code>Mesh</code> block of type <code>MeshGeneratorMesh</code>.</p><p>Let&#x27;s analyze the different steps. First, we use a <code>GeneratedMeshGenerator</code> to create a 3D mesh labeled <code>gmg</code> (here it&#x27;s simply a regular cube). After that, we use this mesh as an input (via <code>input = gmg</code>) to create a larger mesh using a <code>TiledMeshGenerator</code>. </p></section><section class="scrollspy" id="aa1fa1cc-d4fb-4b6e-a932-599fc66b47a0" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/meshgenerators/AllSideSetsByNormalsGenerator.html">AllSideSetsByNormalsGenerator</a>Adds sidesets to the entire mesh based on unique normals.</li><li class="collection-item"><a href="../../source/meshgenerators/AnnularMeshGenerator.html">AnnularMeshGenerator</a>For rmin&gt;0: creates an annular mesh of QUAD4 elements.  For rmin=0: creates a disc mesh of QUAD4 and TRI3 elements.  Boundary sidesets are created at rmax and rmin, and given these names.  If dmin!<u>0 and dmax!</u>360, a sector of an annulus or disc is created.  In this case boundary sidesets are also created a dmin and dmax, and given these names</li><li class="collection-item"><a href="../../source/meshgenerators/BlockDeletionGenerator.html">BlockDeletionGenerator</a>Mesh generator which removes elements with the specified subdomain ID</li><li class="collection-item"><a href="../../source/meshgenerators/BoundingBoxNodeSetGenerator.html">BoundingBoxNodeSetGenerator</a>Assigns all of the nodes either inside or outside of a bounding box to a new nodeset.</li><li class="collection-item"><a href="../../source/meshgenerators/BreakBoundaryOnSubdomainGenerator.html">BreakBoundaryOnSubdomainGenerator</a>Break boundaries based on the subdomains to which their sides are attached. Naming convention for the new boundaries will be the old boundary name plus &quot;_to_&quot; plus the subdomain name</li><li class="collection-item"><a href="../../source/meshgenerators/BreakMeshByBlockGenerator.html">BreakMeshByBlockGenerator</a>Break boundaries based on the subdomains to which their sides are attached. Naming convention for the new boundaries will be the old boundary name plus &quot;_to_&quot; plus the subdomain name. At the momentthis only works on REPLICATED mesh</li><li class="collection-item"><a href="../../source/meshgenerators/CartesianMeshGenerator.html">CartesianMeshGenerator</a>This CartesianMeshGenerator creates a non-uniform Cartesian mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/CombinerGenerator.html">CombinerGenerator</a>Combine multiple meshes (or copies of one mesh) together into one (disjoint) mesh.  Can optionally translate those meshes before combining them.</li><li class="collection-item"><a href="../../source/meshgenerators/ConcentricCircleMeshGenerator.html">ConcentricCircleMeshGenerator</a>This ConcentricCircleMeshGenerator source code is to generate concentric circle meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/DistributedRectilinearMeshGenerator.html">DistributedRectilinearMeshGenerator</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ElementGenerator.html">ElementGenerator</a>Generates individual elements given a list of nodal positions.</li><li class="collection-item"><a href="../../source/meshgenerators/ElementSubdomainIDGenerator.html">ElementSubdomainIDGenerator</a>Allows the user to assign each element the subdomain ID of their choice</li><li class="collection-item"><a href="../../source/meshgenerators/ExtraNodesetGenerator.html">ExtraNodesetGenerator</a>Creates a new node set and a new boundary made with the nodes the user provides.</li><li class="collection-item"><a href="../../source/meshgenerators/FancyExtruderGenerator.html">FancyExtruderGenerator</a>Extrudes a 2D mesh into 3D, can have variable a variable height for each elevation, variable number of layers within each elevation and remap subdomain_ids within each elevation</li><li class="collection-item"><a href="../../source/meshgenerators/FileMeshGenerator.html">FileMeshGenerator</a>Read a mesh from a file.</li><li class="collection-item"><a href="../../source/meshgenerators/GeneratedMeshGenerator.html">GeneratedMeshGenerator</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ImageMeshGenerator.html">ImageMeshGenerator</a>Generated mesh with the aspect ratio of a given image stack.</li><li class="collection-item"><a href="../../source/meshgenerators/ImageSubdomainGenerator.html">ImageSubdomainGenerator</a>Samples an image at the coordinates of each element centroid, using the resulting pixel color value as each element&#x27;s subdomain ID</li><li class="collection-item"><a href="../../source/meshgenerators/LowerDBlockFromSidesetGenerator.html">LowerDBlockFromSidesetGenerator</a>Adds lower dimensional elements on the specified sidesets.</li><li class="collection-item"><a href="../../source/meshgenerators/MeshCollectionGenerator.html">MeshCollectionGenerator</a>Collects multiple meshes into a single (unconnected) mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/MeshExtruderGenerator.html">MeshExtruderGenerator</a>Takes a 1D or 2D mesh and extrudes the entire structure along the specified axis increasing the dimensionality of the mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/MeshSideSetGenerator.html">MeshSideSetGenerator</a>Add lower dimensional elements along the faces contained in a side set to set up mixed dimensional problems</li><li class="collection-item"><a href="../../source/meshgenerators/OrientedSubdomainBoundingBoxGenerator.html">OrientedSubdomainBoundingBoxGenerator</a>Defines a subdomain inside or outside of a bounding box with arbitrary orientation.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedGenerateSideset.html">ParsedGenerateSideset</a>A MeshModifier that adds element sides to a sideset if the centroid satisfies the <code>combinatorial_geometry</code> expression. Optionally, element sides are also added if they are included in <code>included_subdomain_ids</code> and if they feature the designated normal.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedSubdomainMeshGenerator.html">ParsedSubdomainMeshGenerator</a>Uses a parsed expression (<code>combinatorial_geometry</code>) to determine if an element (via its centroid) is inside the region defined by the expression and assigns a new block ID.</li><li class="collection-item"><a href="../../source/meshgenerators/PatchMeshGenerator.html">PatchMeshGenerator</a>Creates 2D or 3D patch meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/PatternedMeshGenerator.html">PatternedMeshGenerator</a>Creates a 2D mesh from a specified set of unique &#x27;tiles&#x27; meshes and a two-dimensional pattern.</li><li class="collection-item"><a href="../../source/meshgenerators/PlaneDeletionGenerator.html">PlaneDeletionGenerator</a>Removes elements lying &#x27;above&#x27; the plane (in the direction of the normal).</li><li class="collection-item"><a href="../../source/meshgenerators/RenameBlockGenerator.html">RenameBlockGenerator</a>RenameBlockGenerator re-numbers or re-names an <code>old_block_id</code> or <code>old_block_name</code> with a <code>new_block_id</code> or <code>new_block_name</code>.  If using RenameBlockGenerator to merge blocks (by giving them the same name, for instance) it is advisable to specify all your blocks in <code>old_blocks</code> to avoid inconsistencies</li><li class="collection-item"><a href="../../source/meshgenerators/RenameBoundaryGenerator.html">RenameBoundaryGenerator</a>RenameBoundaryGenerator re-numbers or re-names an <code>old_boundary_id</code> or <code>old_boundary_name</code> with a <code>new_boundary_id</code> or <code>new_boundary_name</code>.  If using RenameBoundaryGenerator to merge boundaries (by giving them the same name, for instance) it is advisable to specify all your boundaries in <code>old_boundaries</code> to avoid inconsistencies</li><li class="collection-item"><a href="../../source/meshgenerators/RinglebMeshGenerator.html">RinglebMeshGenerator</a>Creates a mesh for the Ringleb problem.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsAroundSubdomainGenerator.html">SideSetsAroundSubdomainGenerator</a>Adds element faces that are on the exterior of the given block to the sidesets specified</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsBetweenSubdomainsGenerator.html">SideSetsBetweenSubdomainsGenerator</a>MeshGenerator that creates a sideset composed of the nodes located between two or more subdomains.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromBoundingBoxGenerator.html">SideSetsFromBoundingBoxGenerator</a>Defines new sidesets using currently-defined sideset IDs inside or outside of a bounding box.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromNormalsGenerator.html">SideSetsFromNormalsGenerator</a>Adds a new named sideset to the mesh for all faces matching the specified normal.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromPointsGenerator.html">SideSetsFromPointsGenerator</a>Adds a new sideset starting at the specified point containing all connected element faces with the same normal.</li><li class="collection-item"><a href="../../source/meshgenerators/SmoothMeshGenerator.html">SmoothMeshGenerator</a>Utilizes a simple Laplacian based smoother to attempt to improve mesh quality.  Will not move boundary nodes or nodes along block/subdomain boundaries</li><li class="collection-item"><a href="../../source/meshgenerators/SpiralAnnularMeshGenerator.html">SpiralAnnularMeshGenerator</a>Creates an annular mesh based on TRI3 or TRI6 elements on several rings.</li><li class="collection-item"><a href="../../source/meshgenerators/StackGenerator.html">StackGenerator</a>Use the supplied meshes and stitch them on top of each other</li><li class="collection-item"><a href="../../source/meshgenerators/StitchedMeshGenerator.html">StitchedMeshGenerator</a>Allows multiple mesh files to be stiched together to form a single mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/SubdomainBoundingBoxGenerator.html">SubdomainBoundingBoxGenerator</a>Changes the subdomain ID of elements either (XOR) inside or outside the specified box to the specified ID.</li><li class="collection-item"><a href="../../source/meshgenerators/SubdomainIDGenerator.html">SubdomainIDGenerator</a>Sets all the elements of the input mesh to a unique subdomain ID.</li><li class="collection-item"><a href="../../source/meshgenerators/TiledMeshGenerator.html">TiledMeshGenerator</a>Use the supplied mesh and create a tiled grid by repeating this mesh in the x, y, and z directions.</li><li class="collection-item"><a href="../../source/meshgenerators/TransformGenerator.html">TransformGenerator</a>Applies a linear transform to the entire mesh.</li></ul></section><section class="scrollspy" id="8a89842b-5fa9-4f1a-a2d1-e1aaa24fefe9" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddMeshGeneratorAction.html">AddMeshGeneratorAction</a>Action for adding mesh generator objects</li></ul></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#2478adc5-9213-4804-98bb-4c938dd68488" class="tooltipped" data-position="left" data-tooltip="Input File Example">Input File Example</a></li><li><a href="#aa1fa1cc-d4fb-4b6e-a932-599fc66b47a0" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#8a89842b-5fa9-4f1a-a2d1-e1aaa24fefe9" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>